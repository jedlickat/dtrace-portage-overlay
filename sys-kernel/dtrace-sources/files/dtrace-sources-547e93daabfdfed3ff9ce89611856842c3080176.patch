diff --git a/Documentation/dwarf2ctf b/Documentation/dwarf2ctf
new file mode 100644
index 000000000000..b53787b775b8
--- /dev/null
+++ b/Documentation/dwarf2ctf
@@ -0,0 +1,1054 @@
+dwarf2ctf, a type encoder for the Linux kernel
+=========
+
+Many kernel-level debugging and tracing systems need access to the kernel's type
+information.  Since C doesn't support any form of introspection, the data must
+be extracted in some other way: here, we extract it from the DWARF debugging
+information generated by the compiler.  Unfortunately, this information is very
+voluminous (just the type information alone adds up to a couple of hundred
+megabytes in a 'make allyesconfig' kernel): even if users are happy to spend the
+disk space, the time and memory required to read much of this information in is
+likely to be prohibitive.
+
+This problem is not new -- back in 2004, Sun had the same problem when
+attempting to give DTrace a view of the type information in the Solaris kernel.
+Their solution was the Compact ANSI-C Type Format (CTF), a highly compacted
+representation of C types suitable for debuggers and tracers.  They combined
+this with a highly efficient tool for converting DWARF2 types to CTF, and hacks
+in the Solaris kernel causing the kernel itself to emit CTF data for its own
+types.
+
+Unfortunately while this tool may be highly efficient it is not adequate for the
+Linux kernel.  It treats every ELF object as an independent entity with an
+independent set of types -- perfectly all right for the Solaris kernel with a
+few hundred modules maximum, but very much not for Linux, where distro kernels
+often compile in thousands of modules.  Ideally, we would like to treat all
+kernel modules, built-in or not, the same way, sharing and deduplicating all
+globally-visible types across the entire set of visible modules and recording
+each precisely once.
+
+We also want to collect descriptions of global variables and emit descriptions
+of their name->type mapping as well, since the kernel has no easily accessible
+ELF section we can extract this information from at runtime (kernel modules must
+be accessible at runtime for modern Linux systems to work, but the kernel itself
+could have come from over the network or off a USB key or from a non-mounted
+partition or an EFI boot partition or who knows where, and could have any name
+even if it is accessible: so tracing tools should not rely on being able to look
+inside the kernel image).
+
+We do all this with dwarf2ctf, a CTF generation tool that reads in DWARF from a
+set of object files (usually, every object file in the kernel and all modules)
+and fills a directory with compressed files containing CTF representations of
+the types in those object files: the kernel build system regenerates these as
+necessary and links them directly into kernel modules.
+
+Caveats: It is somewhat specific to the form of DWARF output emitted by GCC, and
+doesn't yet support DWARF-4 type signatures or compressed DWARF at all.
+
+We'll look at each part of this system in turn, from the top down, starting with
+using the kernel type information  dwarf2ctf produces in other programs.
+
+
+Using dwarf2ctf output
+----------------------
+
+Using this data is fairly simple.  Once you've read the CTF sections from the
+kernel modules and inflated them (or ignored them if they are empty or, as just
+mentioned, one byte long), you simply need to look at the ctf_parent_name() for
+each module, and if it is set to "ctf", call ctf_import() to set the parent of
+this module to the CTF data you have read from the .ctf.shared_ctf section in
+the ctf.ko kernel module.  The core kernel's types are stored in the
+.ctf.vmlinux section in the same kernel module, and all built-in kernel modules
+have their types in .ctf.$module_name.  Non-built-in kernel modules just have a
+.ctf section containing their types, which again might need their parent set to
+"shared_ctf".  (Out-of-tree kernel modules will have no such parent.)
+
+Once you've set up the parenthood relationships you can call ctf_close() on the
+shared type repository and forget about it entirely: it will be refcounted and
+destroyed when all its children are closed.
+
+
+You should end up with a family of CTF files, one per kernel module built-in or
+not and one for the core kernel, freely usable for whatever purpose you need.
+
+
+Invocation and build-system connections
+----------
+
+dwarf2ctf's command-line syntax emphasises simplicity over compactness.  Linux
+has nearly-infinitely-long command lines these days, so we can take advantage of
+this.
+
+Two syntaxes are supported.  The first shares types across multiple modules and
+the core kernel; the second is used for out-of-tree module building, and avoids
+either sharing anything at all across modules or depending on the set of shared
+types defined for the core kernel.
+
+
+dwarf2ctf outputdir objects.builtin modules.builtin dedup.blacklist \
+	  vmlinux.o module.o ...
+dwarf2ctf outputdir -e module.o ...
+
+where:
+
+ - 'outputdir' is the possibly-relative path to a directory in which the
+   generated CTF files get placed.
+ - 'objects.builtin' is the name of the file containing the object files that
+   correspond to always-built-in kernel code (that cannot be built as modules).
+ - 'modules.builtin' is the name of the file containing the names of
+   kernel modules presently built in to the kernel.
+ - 'dedup.blacklist' is a blacklist of modules that should never participate
+   in deduplication: see 'Duplicate type detection' below.
+ - the .o filenames are the names of object files comprising the kernel and/or
+   modules: you can feed in whole modules at once (before linking with .mod.o).
+   This list is often very, very long (I have seen command-lines in excess of
+   60Kb).
+
+dwarf2ctf's output consists of a series of gzip-compressed .ctf.new files in the
+outputdir, which the makefile compares with and if necessary moves over the top
+of .ctf files with the same basename, so as to avoid relinking things if
+dwarf2ctf has written out content identical to what it wrote last time it ran.
+These fall into several classes, partitioned according to the contents of
+objects.builtin and modules.builtin:
+
+ - shared_ctf.builtin.ctf: The shared type repository.  Types shared by more
+   than one of the files below go here.
+   libdtrace-ctf).  See 'Using dwarf2ctf output' below regarding use of this
+   data.
+ - vmlinux.builtin.ctf: Types in the core kernel, that cannot be built in to
+   modules, go here.
+ - *.builtin.ctf: One of these is generated for the types in each module that
+   is presently built in to the kernel.
+ - *.mod.ctf: One of these is generated for each .ko.
+
+All the files in the first three classes are linked into the ctf.ko module under
+various names, an empty module containing nothing but CTF data.
+
+
+A lengthy section of Makefile.modpost, and a short section of the toplevel
+Makefile, is dedicated to creating these files, and to linking them into the
+kernel modules.  The dependency graph related to dwarf2ctf output is quite
+complex: modules and objects (ld -r'ed *.o files) are processed by dwarf2ctf to
+produce a number of files in the .ctf directory, and the final modules depend on
+the relevant ctf files.  The .mod.ctf's go into the .ko's with the same stem
+name, but ctf.ko receives content from all the CTF files corresponding to
+built-in modules, and until dwarf2ctf runs and creates those files we cannot
+tell what those CTF files will be, though we do have a wildcard that matches
+them all.
+[
+GNU Make's 'secondary expansion' feature comes to the rescue here: we can
+compute a list of expected CTF filenames at runtime, given the names of the
+modules we are linking in.  For the builtin modules, we cheat and touch a stamp
+file after moving any .ctf.new files back over a .ctf file, then depend on that
+to see if ctf.ko needs to be relinked.
+
+The actual incorporation of the CTF data into the kernel modules happens before
+module signing (if signing is active), by calling objcopy --add-section on the
+module in question.  This too has some knotty corners.
+
+First of all, the module linkage process normally links a module using all the
+prerequisites of the module's target -- but we have designated all the CTF files
+as prerequisites of the module's target, and we don't want to link them directly
+in using ld(1), since they aren't object files.  So we have to filter them out in
+the link line.
+
+Secondly, those modules which have no CTF files should acquire empty CTF
+sections to indicate their lack of unique types -- but objcopy in binutils 2.20
+and below silently exits if asked to --add-section an empty file.  So we use dd
+to generate a file with a one-byte null in it instead, and teach the users of
+CTF sections to treat a one-byte-long 'CTF' section as if it were empty.
+
+
+Overview of dwarf2ctf operation
+--------
+
+There are four phases to dwarf2ctf operation: initialization, duplicate type
+detection, CTF construction, and writeout.  Some of these phases can repeat.
+All but the last phase consists purely of sucking data from object files into
+GHashTables in memory. (The last two phases could potentially be combined,
+shrinking the size of one hash and saving memory, but the hash that is shrunk is
+by no means the largest one, so the extra complexity is probably not worth it.)
+
+dwarf2ctf uses several other libraries to do this:
+
+ - elfutils, used for DWARF parsing.  We could potentially write our own
+   DWARF parser, but elfutils works and is tested.
+
+ - glib, used for the GHashTable.  The rest of the kernel uses roll-your-own
+   hash tables, but dwarf2ctf makes heavy demands of its hashtables: they must
+   be expanding hashes capable of efficiently storing hundreds of thousands of
+   items, with amortized log(N) lookup time, and they must support deletion
+   (though it need not be particularly efficient deletion).  This rules out
+   simple fixed-size bucket hashes like the ones used in other parts of the
+   kernel build system: GHashTable is already implemented, and works.
+
+ - zlib, used to compress the CTF information.  
+
+ - libdtrace-ctf, which both reads and writes the CTF data.  This is a port of
+   the Solaris CTF library, GPLed and with additional support for the storage
+   of name->type mappings (meant to represent variables) akin to its existing
+   ELF symbol->type mappings.
+
+dwarf2ctf has a good few important data structures, described at the top of
+scripts/dwarf2ctf/dwarf2ctf.c.
+
+dwarf2ctf has its own trace facility, implemented via the dw_ctf_trace() macro
+and enabled by compiling with -DDEBUG and setting DWARF2CTF_TRACE in the
+environment.  (The first step is required because some very numerous data
+structures are greatly expanded when debugging is turned on, which would waste
+memory if it were done all the time).  This produces a huge volume of trace
+output, several gigabytes when run over an allyesconfig kernel.
+
+
+Unless you're interested in how dwarf2ctf works internally, you can stop reading
+here.  If you are interested, now is a good time to read the comments above
+main() in scripts/dwarf2ctf/dwarf2ctf.c, which briefly describe dwarf2ctf's data
+structures and functions.
+
+
+Flow of Control
+---------------
+
+The /* C comments */ point to other sections of this document,
+
+Functions named in the /* Utilities */ section of dwarf2ctf.c are not mentioned
+here for simplicity's sake.
+
+[C]: Callback
+[R]: recursive
+[1]: Numbers: Mutually-recursive loop
+|: Several functions which all call the same functions
+->: Call from array of callbacks (filter_ctf_*() omitted as uninteresting)
+
+main()
+ /* See 'Initialization' */
+ init_assembly_tab()
+ init_builtin()
+ init_dedup_blacklist()
+ init_member_blacklist()
+ run()
+   init_tu_to_modules()
+   init_ctf_table()
+
+   /* Duplicate detection */
+
+   scan_duplicates()
+     process_file()                       /* Toplevel DWARF walkers */
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates()
+[ 1]       mark_shared()
+[R]          type_id()                    /* Type IDs */
+[C1]           mark_shared()
+[R]        mark_seen_contained()
+[C]    detect_duplicates_done()
+
+     process_file()
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates_alias_fixup()
+[R]        type_id()
+[C]          is_named_struct_union_enum()
+[R]        type_id()
+[C]          detect_duplicates_alias_fixup_internal()
+               mark_shared() (see above)
+[C]    detect_duplicates_done()
+
+   /* CTF construction */
+
+   process_file()
+[R]  process_tu_func()
+[C]    assembly_filter_tab[]
+[C]    construct_ctf()
+[ 2]     construct_ctf_id()
+[R3]       die_to_ctf()
+             assembly_tab[]
+[C]           -> assemble_ctf_base()
+              -> assemble_ctf_pointer()
+               | assemble_ctf_array()
+               | assemble_ctf_array_dimension()
+               | assemble_ctf_typedef()
+               | assemble_ctf_cvr_qual()
+               | assemble_ctf_variable()
+                   lookup_ctf_type()
+[ 2]                 construct_ctf_id()
+              -> assemble_ctf_enumeration()
+              -> assemble_ctf_enumerator()
+              -> assemble_ctf_struct_union()
+              -> assemble_ctf_su_member()
+[ 3]               die_to_ctf()
+[ 2]               construct_ctf_id()
+
+   write_types()
+
+Initialization
+--------------
+
+ init_assembly_tab()
+ init_builtin()
+ init_dedup_blacklist()
+ run()
+   init_tu_to_modules()
+   init_ctf_table()
+
+This happens at the top of main() and run(), and in various functions named
+init_*().  Of these, init_assembly_tab() and init_builtin() serve only to turn
+various static arrays and files mentioned on the command line into more useful
+internal representations (e.g. the assembly filter array of structures is turned
+into a pair of arrays indexed by DWARF tag), and the blacklisting functions are
+described in the section on duplicate type detection below.
+
+init_ctf_table(), called both at initialization time and later during CTF
+assembly when new CTF files are found to be needed, creates a new CTF file in
+memory and either marks it as a child of the shared type repository, or (if it
+*is* the shared type repository, or deduplication is off and there is only one
+CTF file being processed and no shared type repository at all) creates a few
+types in it which CTF has representations of but DWARF does not: a void type,
+and a generic catchall pointer-to-function-returning-int.
+
+That leaves init_tu_to_modules().  This walks over all the top-level
+compile_unit DIEs in the DWARF debugging information in every object file
+mentioned in the list of modules and built-in modules, constructing a mapping
+from translation unit name back to the name of the kernel module it comes from,
+even if that module is built in to the kernel.  This is normally the same as the
+filename (sans extension), but for built-in kernel modules, the name comes from
+the modules.builtin file's entry for the translation unit instead, so that the
+output can land in a .builtin.ctf file rather than being jammed into
+vmlinux.builtin.ctf with the core kernel's types.
+
+This means that dwarf2ctf can operate in terms of the kernel module a type is
+contained within rather than having to think about the mapping between object
+file name, translation unit name and module name all the time.
+
+
+Toplevel DWARF walkers
+----------------------
+
+     process_file()
+[C]    (per-TU initialization callback)
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      (per-DIE callback)
+[C]    (per-TU cleanup callback)
+
+All routines in dwarf2ctf other than initialization and writeout are DWARF
+walkers: i.e., they walk over all DWARF DIEs in all object files specified on
+the command line and do something with every DIE.  This job is done by
+process_file() and its helper process_tu_func(), which not only digs out the
+corresponding (built-in or non-built-in) module name corresponding to each
+object file, but also detects and skips translation units it has handled before
+(in case they are incrementally linked into multiple object files) and allows
+callbacks to be invoked at the start and end of each translation unit.
+
+Even though dwarf2ctf only cares about top-level types, in some situations DWARF
+can emit top-level types with references to a non-top-level type: if all
+occurrences of the top-level type are an opaque structure, and the only
+non-opaque definition is inside a function, references in the same translation
+unit as the non-opaque definition will point to the definition inside the
+function (and references outside the translation unit will not point at any
+definition).  Thus, if we want to catch all nuances of globally-visible types,
+we have to scan types inside functions and lexical blocks inside functions too.
+
+To avoid generating a vast number of unnecessary type definitions, the 'assembly
+table' which describes how to construct a CTF type given a DWARF DIE also
+contains a description of a set of filters which are passed the current DIE and
+its parent: if they return false, the DIE is skipped and never passed to the
+callback function.  We also avoid calling the callback for any DWARF DIE whose
+tag doesn't appear in the assembly table at all: there's no point doing
+duplicate detection or anything else for a DWARF DIE we won't be generating CTF
+from.  There are currently two filters defined: filter_ctf_file_scope(), which
+is called for every DWARF DIE whose tag is one we never expect to see a
+reference to if it is inside a function (except if they relate to a structure or
+union, as above), and filter_ctf_uninteresting(), which is called for variables
+to see if they are worthy of recording (top-level named variables with external
+linkage not part of the internal workings of macros only).
+
+
+Type IDs
+--------
+
+[R]  type_id()
+[C]    (optional per-type callback)       
+
+The only thing dwarf2ctf does which the Sun tool does not is the detection of
+duplicate and shared types, both within individual kernel modules and across
+modules.  Our ultimate goal is that a type that appears in the source code once
+appears in the CTF output once as well.  This goal has mostly been attained,
+except for out-of-tree modules, where cross-module type sharing must be disabled
+to avoid requiring rebuilds of the module whenever the core kernel is rebuilt.
+
+The core of this is the concept of a *type ID* and the function type_id() which
+computes it.  A type ID is an identifier for a type which precisely represents
+that type and only that type.  Doing this for types in different headers or at
+different scopes with the same name without needing to encode knowledge of C
+scoping rules into dwarf2ctf is an interesting proposition: we can use the line
+number and filename info provided by DWARF in most user-specified types to help.
+
+A type ID is a recursively-constructed string of the following form (fixed
+elements represented by {}, optional elements by []):
+
+//[filename]//[line number]//{type string}
+
+Types are *based* upon other types iff they have a DW_AT_type attribute pointing
+to some other type.  All types based upon other types have a type ID that is the
+type ID of the type upon which they are based, with additional information
+specific to this type appended to it.  The filename and line number is only
+added for those types which are not based upon other types and which have a
+filename and line number in the DWARF (lots don't, e.g. base types): the
+filename is canonicalized with realpath(), though since this is quite slow and
+type_id() is called a lot, the mapping from DWARF filename to realpath() result
+is cached.  Types that have no filename or line number start with '////'.
+
+We use // to separate the filename and line number elements because this is the
+shortest string other than NUL that cannot appear in a canonicalized POSIX
+pathname (ignoring Pyramid, Cygwin and other strange systems that actually
+return // in the result of realpath(): Linux doesn't use it and that's all that
+matters.  Should it start to use it, we can switch delimiter to ///.)
+
+Function pointers are not represented (or, rather, are all mapped to the same
+type ID, the generic catchall function-pointer type mentioned above); array
+dimensions are represented by [index-type dimension], or [] for flexible array
+members.  Structure members are not represented, since they are not types, but
+the types of their members *are* represented, as are nested structures (the line
+number and filename serving, as ever, to disambiguate them from other structures
+with the same name declared nested inside different structures).
+
+The following are some examples of valid type IDs (assuming the kernel source
+tree is, implausibly, located at /k/, just off the root directory: comments on
+individual types done /* like C */; the last example is broken across lines for
+formatting's sake):
+
+//fp//*  # a pointer to a function, any function
+////long int
+////char []
+////unsigned int typedef __kernel_uid_t typedef __kernel_uid32_t
+//fp//* typedef __signalfn_t * typedef __sighandler_t
+////struct nsproxy                       /* an opaque type */
+////struct nsproxy * #                   /* pointer to it */
+////long unsigned int typedef u64 volatile
+////long unsigned int volatile const * const
+////long unsigned int typedef sector_t [////long unsigned int  511]
+/k/include/linux/types.h//222//struct list_head
+/k/include/linux/types.h//222//struct list_head *
+/k/include/linux/types.h//222//struct list_head [////long unsigned int 5]
+/k/include/linux/types.h//217//struct    /* no struct tag */
+/k/include/linux/types.h//217//struct typedef atomic64_t
+/k/include/linux/mm_types.h//34//struct page * typedef pgtable_t
+/k/fs/eventpoll.c//122//struct nested_calls
+/k/include/linux/sysctl.h//1016//struct ctl_table typedef ctl_table
+    [////long unsigned int 4] var inotify_table  /* A global variable */
+
+This scheme means that cv-quals and other modifiers applied to other types are
+always merged: if there are a dozen typedefs for a single type 'foo' with the
+same name declared in the same place, they all end up with the same type ID and
+are only emitted into the CTF once.
+
+The type_id() function can also accept a callback, which is called as the
+recursion unwinds, from base type up to derived type: so it might be called for
+"////unsigned int", then for "////unsigned int typedef __kernel_uid_t", and so
+on up to the DIE that was originally passed in.  Because type_id() returns a
+dynamically-allocated string, calls to type_id() made purely for the sake of
+invoking a callback are normally of the peculiar form "free(type_id(...))".
+
+type_id() is a very hot spot, so syscall results are cached in it (such as
+realpath(), as mentioned above), and when string appending is done, it is done
+all at once where possible, via str_appendn(), which calls realloc() only once
+no matter the number of strings being appended.
+
+Lots of core data structures in dwarf2ctf consist of hashes mapping type IDs to
+something else (predominantly CTF file/ID pairs and module names).  It would
+be possible to map from hashes of type IDs, saving some memory, but this would
+impair debugging so is not yet implemented.  (If it is implemented, it should
+probably be implemented only when DEBUG is not defined.)
+
+
+Duplicate detection
+-------------------
+
+   scan_duplicates()
+     process_file()                       /* Toplevel DWARF walkers */
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates()
+[ 1]       mark_shared()
+[R]          type_id()                    /* Type IDs */
+[C1]           mark_shared()
+[ 4]       type_id()
+[ 4]         detect_duplicates_typeid()
+[ 4]           detect_duplicates()
+[R]        mark_seen_contained()
+           member_blacklisted()
+[C]    detect_duplicates_done()
+
+     process_file()
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates_alias_fixup()
+[R]        type_id()
+[C]          is_named_struct_union_enum()
+[R]        type_id()
+[C]          detect_duplicates_alias_fixup_internal()
+               mark_shared() (see above)
+[C]    detect_duplicates_done()
+
+The job of the duplicate detection pass is to fill out the id_to_module hash,
+which maps type IDs to the module they appear in, with the two special cases
+that types that appear only in the core kernel are said to appear in the module
+'vmlinux', and types that appear in more than one module (or in a module and in
+the core kernel) are said to appear in the module 'shared_ctf', the shared type
+repository.  This is quite a tricky multi-pass process, because we must ensure
+that the shared type repository is self-contained: all types in the repository
+must not reference any types outside the repository.
+
+Detecting duplicates itself is easy: we consider two types duplicates if they
+have the same type ID: if they both reside in the same module, the resulting
+type resides in that module too.  However, detecting shared types is harder.
+We consider that a type belongs in the shared module if any of these conditions
+is true:
+
+ - the type appears multiple times in different modules
+ - a type for which this type is a base type is shared
+ - the type is referenced by a structure or union member, and the structure
+   or union is shared
+ - the type is a non-opaque type with an opaque variant ('struct foo'), or
+   vice versa, and either of these variants is shared: these two types will
+   get different type IDs, so explicit checking is necessary
+
+Note that we do *not* consider a type to belong in the shared module merely if
+*it* has a base type which is shared: indeed, this is the common case for
+unshared types (even unshared structures tend to have fields of shared types
+like int).
+
+It should be fairly easy to see that sharedness is a contagious property:
+e.g. if you mark a structure as shared, and one of its members is an
+otherwise-unshared opaque pointer to a structure, you have to mark that as
+shared: this causes the non-opaque definition of the structure, and all *its*
+members, to be shared, and so on.  So since dwarf2ctf does not track the members
+of structures itself (not until the CTF generation phase, anyway), this means
+walking over the DWARF DIEs multiple times, checking for sharedness over and
+over until we are done.
+
+We partition the problem into two parts, both of which are carried out by
+process_file() callback functions: detect_duplicates() and
+detect_duplicates_alias_fixup().
+
+
+detect_duplicates() is called first, once for every DIE in the kernel (via
+process_file()).  This identifies types that are duplicated but not shared, and
+identifies shared types without consideration of opaque struct/union aliasing.
+It also flags types that have been seen only once as 'seen': this is checked
+much later on by the CTF construction phase, since construction of CTF for
+any type which has not been inspected by the deduplicator is a sign of a bug in
+the deduplicator.
+
+This has several subtleties.
+
+If we are running for an out-of-tree module, we must still identify types as
+duplicated within the module, but must never mark them as shared: out-of-tree
+modules cannot contribute to the shared type repository nor even use types in
+it, since they are rebuilt independently from the kernel proper and thus cannot
+depend on a type currently in the repository remaining there (e.g. perhaps it
+has only two users, both in modules, and the kernel is rebuilt to not build one
+of those modules anymore: this should not require rebuilding of any out-of-tree
+modules).
+
+If we mark a structure or union type as seen, we must mark aggregate types that
+appear directly within that type's DIE as seen as well.  This is done by the
+recursive function mark_seen_contained().  You might wonder what the point of it
+is: such types surely cannot appear anywhere else, and any duplication will
+precisely match the duplication of the containing type.  The answer is that they
+can still be referenced as the type of structure members of their containing
+structure, e.g. in
+
+struct foo {
+	struct bar {
+	} *baz;
+	struct bar wombat[16];
+};
+
+Here, a reference to 'struct bar' appears in 'struct foo', and CTF is
+constructed for it, even though it is not a top-level DIE.  In GCC 4.8+, a
+reference to the 16-element array-of-struct-bar can also appear in 'struct foo':
+in fact almost anything can appear in there if used nowhere else in the
+translation unit, even base types.  So we look for the appearance of anything
+which we can assemble into CTF (anything in the assembly_tab) other than
+members, since members cannot be used as the type of anything else, and mark
+them all as seen in this module.  (Nearly everything in a structure or union is
+a member, so this ends up skipping almost but not quite everything.)
+
+
+If we find that a type has appeared more than once in different kernel modules
+(or in a module and in the core kernel), we must mark it as shared.  This is
+done via mark_shared(), which is both a function that can be directly called
+(e.g. from detect_duplicates()) and a type_id() callback.  If it is called
+directly, it immediately reinvokes itself as a type_id() callback, which calls
+it for the base type of the type in question and then for all qualifiers up the
+type ID stack, marking them all as shared if they weren't already.
+
+If a structure or union is marked as shared, the types of its members are also
+marked as shared via a recursive call (even if they have already been so marked:
+just because this structure is of a type we've already seen, in a location we've
+already seen, doesn't mean that someone might not have legitimately used
+#defines to add extra members to the end of it, and we need to mark them as
+shared too).  We track structures that have been seen in this translation unit
+and avoid recursing into them, to avoid an infinite loop in cases like this:
+
+struct one;
+struct two {
+	struct one *foo;
+};
+
+struct one {
+	struct two *foo;
+}
+
+The types being pointers does not help here -- the marking of 'struct one *' as
+shared will automatically mark 'struct one' as shared too, because otherwise we
+might have a structure in the shared type repository whose members' types 
+could not be found there.
+
+
+The second pass is the 'alias fixup' pass, implemented by
+detect_duplicates_alias_fixup().  This pass serves to detect unshared opaque
+types whose non-opaque equivalents are shared, and vice versa.  It is executed
+repeatedly until no types have been marked as shared for an entire iteration,
+but is considerably faster per iteration than the first pass, which often
+consumes more than half of dwarf2ctf's total runtime.  We work in one direction
+only, looking for non-opaque structures, unions or enums which have structure
+tags.  (Structures without tags cannot have opaque variants, and structures
+which are opaque will have non-opaque cousins somewhere, or can be emitted to
+the CTF as an opaque structure harmlessly since they truly have no members and
+are probably manipulated only via casts.)
+
+We identify structures, unions or enums with tags via the type_id() callback
+is_named_struct_union_enum(), but cannot determine if something is an opaque
+structure at this stage.  Instead, we do that after the callback, checking to
+see if the first four characters of the type ID are "////": this relies on the
+fact that GCC never gives opaque structures line numbers in DWARF.  We do the
+actual checking and marking of each non-opaque structure using
+detect_duplicates_alias_fixup_internal(), which is yet another type_id()
+callback.
+
+This function directly synthesises the name which this structure's opaque cousin
+would have, if it existed, by stripping off the line number and filename and
+replacing them with '////', and sees if either of these types have been marked
+as shared while the other has not.  If the opaque type is shared, the non-opaque
+variant can be marked shared using the same recursive mark_shared() function as
+before (thus marking the types of all its members and types it depends upon as
+shared too).  If it is the opaque type that needs marking shared, this will not
+work, since mark_shared() takes a DWARF DIE, and we don't have one for the
+opaque type, just a faked-up type ID.  However, since an opaque type doesn't
+have any members that need recursively tracing, we don't need access to its
+DWARF DIE to figure them out, and can just mark it as shared directly, via an
+insert into the id_to_module hash.
+
+Since this function is a type_id() callback, it is called not just for
+structures but for types based on them (e.g. in type_id form, "struct foo const
+* [43] volatile *"); at every level of this declarator stack, a shared opaque
+base type will contaminate its non-opaque cousins with sharedness, and vice
+versa.  This handles situations in which, say, the opaque version of "struct foo
+const * [43]" was used by more than one module and was marked as shared: the
+marking process will have marked the opaque versions of "struct foo const *
+[43]", "struct foo const *", "struct foo const" and "struct foo" as shared, but
+will not have touched any non-opaque versions of these types which may exist
+until this routine runs.  It also handles typedefs to structures with no need
+for any extra code.
+
+This whole alias fixup process needs to be repeated, because whenever a
+non-opaque type is marked as shared and its member's types traced and marked
+shared, *those* may themselves be structure types with corresponding opaque or
+non-opaque variants, and when they are opaque types the non-opaque variant that
+alias fixup works from may already have passed under the DWARF walker's gaze: so
+another pass over the kernel's DWARF is necessary to be sure we catch it.
+mark_shared() thus sets a flag that scan_duplicates() recognizes and uses to
+trigger another run through the alias fixup pass.
+
+
+There are a very few modules that this algorithm doesn't work for.  One example
+is snd-ens1371, which reads, in toto
+
+#define CHIP1371
+#include "ens1370.c"
+
+and ens1370.c (itself a distinct kernel module) then defines a 'struct ensoniq'
+whose members vary depending on whether CHIP1371 is defined.  Obviously, it is
+impossible to share any such types between kernel modules even though their
+names are the same and they are defined in the same place in the same source
+file in both cases.  But this sort of trickery is very rare, so we simply
+implement a 'deduplication blacklist' of modules which will not introduce new
+types into the shared CTF repository, and who do not participate in alias fixup
+detection either.  Detecting these cases in order to blacklist them is harder:
+no automated system has yet been implemented, although instances where #defines
+of this nature introduce new types that are then used by later members will
+cause assertion failures inside dwarf2ctf which might be a clue.  So it is
+possible that some examples have been missed.  (The blacklist only applies to
+cases where structure members change within a single kernel build, so cases
+where structures have members whose presence depends on CONFIG_* values are
+quite all right, as are cases where #defines are introduced by one translation
+that #includes another that then goes on to define whole new structures: it is
+only cases where modules #define something that changes the definition of
+individual possibly-shared types that will need blacklisting.)
+
+
+There are a few even worse cases where a single structure is defined with
+different members in different translation units within a single module.  In
+this case we can do nothing at all, since our output representation describes
+only a single type per module: we implement a 'member blacklist' which bans
+emission of affected members entirely, leaving a description of a structure with
+an undescribed hole in it.
+
+
+CTF construction
+----------------
+
+   process_file()
+[R]  process_tu_func()
+[C]    assembly_filter_tab[]
+[C]    construct_ctf()
+[ 2]     construct_ctf_id()
+[R3]       die_to_ctf()
+             assembly_tab[]
+[C]           -> assemble_ctf_base()
+              -> assemble_ctf_pointer()
+               | assemble_ctf_array()
+               | assemble_ctf_array_dimension()
+               | assemble_ctf_typedef()
+               | assemble_ctf_cvr_qual()
+               | assemble_ctf_variable()
+                   lookup_ctf_type()
+[ 2]                 construct_ctf_id()
+              -> assemble_ctf_enumeration()
+              -> assemble_ctf_enumerator()
+              -> assemble_ctf_struct_union()
+              -> assemble_ctf_su_member()
+                   member_blacklisted()
+[ 3]               die_to_ctf()
+[ 2]               construct_ctf_id()
+[C]    cleanup_sou_member_count()
+
+The next stage after the detection of duplicate and cross-module shared types is
+to generate CTF.  We generate all CTF at once before emitting it: this is
+potentially somewhat wasteful of memory, but in practice has not proved to be a
+problem: substantially less memory is used than is used by other parts of the
+kernel build, unless -DDEBUG is enabled.  Its job is to look through the
+kernel's type DWARF (via process_file(), as usual) and create CTF for every
+file-or-global-scope type and every externally-visible variable in the CTF file
+in which the duplicate detection pass has said that type should appear.
+(Variables are treated exactly like types: it just so happens that they are
+never shared because no type or variable can depend upon them, so they always go
+directly into the appropriate module and never into the shared type repository.)
+
+At this stage, the 'CTF files' are not actually files but rather ctf_file_t
+structures maintained by libdtrace-ctf and tracked in the per_module hash, along
+with other information which varies by module name.  We track every single
+individual type in the CTF file in the id_to_type hash, which maps type IDs to
+pairs of (CTF file ID, ctf type ID): this lets us use the type IDs described
+above when considering cross-references within CTF files (e.g. from one CTF type
+to a type it depends upon).
+
+The most important functions in this phase are:
+
+ - construct_ctf_id(), the top-level process_file() callback which is given a
+   DWARF DIE, looks in module_to_ctf_file for the CTF file where this type
+   should land (creating it if necessary), makes sure a type with this type ID
+   has not already been created there, calls die_to_ctf() to create the CTF,
+   notes where it was created in id_to_type, and handles errors.
+
+ - die_to_ctf(), a recursive function which calls the assembly function for the
+   DIE it is given and all its immediate children, with special-case handling
+   for tagged structures and unions.  If you want to create a type but not note
+   where it was created for future lookups by lookup_ctf_type(), this is what to
+   call.  (This is only done currently for unnamed structures/unions.)
+
+ - lookup_ctf_type(), which is called by CTF assembly functions for those
+   types that depend upon other types: it calls construct_ctf_id() again
+   to construct the type, and double-checks that all such types appear
+   either in the module we are constructing types for, or in the shared CTF
+   module.  CTF represents all function pointers the same way, and has a
+   special type ID for 'void', so we special-case both of these cases.
+
+These functions are mostly straightforward (though highly recursive, with all
+three plus CTF construction functions participating in loop 2 above,
+die_to_ctf() calling itself directly, and even one situation, the
+already-mentioned unnamed structures/unions, in which die_to_ctf() is directly
+called back by a CTF construction function, in loop 3 above.)
+
+
+There are a few subtleties, though.  Firstly, error handling.  We consider that
+errors that will lead to unusable CTF are fatal: mostly, these are errors where
+a bug in the deduplicator has failed to trace types correctly and has left at
+least one type in the shared module depending on a type in a non-shared module,
+or has failed to mark a type as shared at all.  In all these cases, you'll
+eventually get an error from lookup_ctf_type() of the general form
+
+blah.c:413:foo_t: Internal error: lookup of flob found in different file.
+
+The first two parts of this error are the translation unit and line number the
+type being assembled (usually a structure or union) was found in: foo_t is the
+name of the type being assembled.  The type of the structure being looked up
+appears nowhere, because we don't know it, but the name of the member is given
+("flob" above, or "(unnamed)" if we don't know it).  If you want more
+information, you can pass -DDEBUG to the compilation of dwarf2ctf.c in
+scripts/dwarf2ctf/Makefile, and rerun dwarf2ctf, and you'll get the module and
+filename in which both the originating and the target types appear.  In order to
+actually track down the bug you'll probably have to run dwarf2ctf with
+DWARF2CTF_TRACE set in the environment, and look at the place where the target
+type was deduplicated, and try to figure out why the deduplicator didn't trace
+the reference to the type in foo_t correctly.
+
+There is another kind of error, though: a failure to assemble a single type,
+perhaps because DWARF was emitted that we don't know how to understand (this is
+particularly likely in structure assembly, where we are highly dependent on the
+form of the DWARF that GCC happens to emit for DW_AT_member_location).  We pass
+an 'enum skip_type' around, which has three possible values, one of which is
+SKIP_ABORT.  Before each type is assembled, we call ctf_snapshot() to take a
+snapshot of the variable-plus-type set in the CTF file we're working over.  If a
+SKIP_ABORT propagates up to construct_ctf_id(), we call ctf_rollback(), which
+throws away every type constructed since the last ctf_snapshot() -- i.e., the
+specific erroneous type we've just been working on.  (We might have emitted some
+parts of it and then failed, so we should try to clean up).
+
+A SKIP_ABORT is not fatal unless DEBUG is defined: its only effect is to omit
+one single type from the resulting CTF, which is probably still usable.
+
+libdtrace-ctf causes additional problems here.  It can only see the types we
+added once the notably expensive function ctf_update() is called.  This takes
+the in-memory structures and serializes them (all of them, every time).  This
+only affects libctf when structure and union members are added: libctf needs to
+know the sizes and alignments of the types of those members, which might quite
+possibly just have been added, e.g. if this structure contains a pointer to its
+own structure tag.  So, when we insert a member in assemble_ctf_su_member(), we
+note a bad type-ID error and do a ctf_update() on the file we're working over
+and try again: even then that can fail if the type was added to the shared
+repository, so we do a ctf_update() on *that* and try again, and only if that
+fails do we declare a SKIP_ABORT error.  (We check the shared repository last
+because it is very large, so takes longer to serialize than other CTF files do).
+
+The need to keep the number of calls to ctf_update() down means we must avoid
+all access to the CTF types we are assembling if we can possibly get at the same
+data another way.  Hence the member_counts hash, a member of the per_module
+state, which tracks the number of members in structures with a given C-style
+name and their CTF IDs.  This structure allows us to handle the (valid) C idiom
+of redeclaring the same structure with a different number of members, merging
+the definitions across translation units and discarding them (iff the structure
+was unshared) when we transition into a new module, without ever having to
+consult the CTF to see how many members we put into it.  (We have to use the
+C-style name here, because by definition the type IDs of such redeclared
+structures will be different, since a type ID contains a line number and
+translation unit name.)
+
+
+There's more error-handling complexity inside die_to_ctf(), where errors from
+libdtrace-ctf are actually reported (there may be multiple of them for a single
+type, e.g. if we are assembling a structure and several members somehow refer to
+a type we do not know about).
+
+die_to_ctf() itself has the sort of parameter list that can make people swear
+off C for life.  It is largely explained in the description of ctf_assembly_fun.
+Most parts of it are hardly used in the function itself, just passed down to CTF
+assembly functions.
+
+Finally, we must note the override flag.  Both die_to_ctf() and
+construct_ctf_id() return a CTF ID.  This is thrown away by the DWARF walking
+code (the function construct_ctf() exists just for that purpose), but when
+called by lookup_ctf_type(), this CTF ID is taken to be the single ID of the CTF
+type that's just been assembled.  Normally this is the same as the CTF ID
+returned by the CTF assembly function for the top-level DWARF DIE, but there are
+a few structures for which we want to return the result of some other CTF
+assembly function.
+
+The only currently-existing example is array dimensions, which DWARF represents
+as a typed array DIE whose child is a dimension, but which CTF represents as an
+array-with-dimensions that you can't change afterwards.  We can't assemble an
+'array' at the top level because we don't know how big it is, but we have to
+track the type recorded there somehow.  We handle this by having
+assemble_ctf_array(), the assembly function for the top-level DW_TAG_array_type
+DIE, simply look up the type of the array's members and return its ID as if it
+had just constructed it, after which assemble_ctf_array_dimension(), the
+assembly function for DW_TAG_subrange_type, actually constructs the array,
+wrapping it around the CTF 'ID' 'assembled' by the parent and setting the
+override flag to make sure that this is what is really recorded.
+
+
+CTF construction functions
+--------------------------
+
+Each CTF construction function takes a single DWARF DIE and turns it into CTF,
+somehow.  They are laid out in the assembly table described in 'toplevel DWARF
+walkers' above.  They all start the same way, with a series of CTF_DW_ENFORCE or
+CTF_DW_ENFORCE_NOT assertions.  These guard against corrupted DWARF missing some
+of the attributes we need, or DWARF containing attributes which indicate that we
+can't handle the content (e.g. DW_AT_signature or DW_AT_specification on
+structures, which would both indicate this is DWARF 4, which we can't handle
+yet.)
+
+We'll go through these functions one by one, pointing out anything that
+maintainers should be aware of.
+
+
+assemble_ctf_base() assembles all integral base types (DW_TAG_base_type) and
+transforms them into the corresponding CTF type.  The functions we need to call
+for this in the CTF API all have the same type signature but have different
+names; CTF also distinguishes between the various differently-sized
+floating-point types, so we must figure out from the type size which type a
+given DWARF base type is referring to.  We map from DWARF encoding to a triple
+of (CTF addition function, CTF integral type, type size) where the latter is
+optional and depends on the size of the DWARF type we are encoding and the size
+of various floating_point types on the current system.  (This does mean that
+cross-compilation using dwarf2ctf is likely to fail fairly often: we need
+machinery to determine the sizeof() types on the target system before that can
+function.)
+
+This sizeof()-based search procedure is why we do not currently support
+DW_AT_bit_size for base types: we could easily support it for sizes modulo 8,
+but GCC happens to emit DW_AT_byte_size in this case.  In C DW_AT_bit_size is
+likely to be emitted only for bitfields in structures anyway, not for base
+types.
+
+
+assemble_ctf_pointer() and assemble_ctf_typedef() are trivial: look up the
+associated type with lookup_ctf_type() and assemble the appropriate thing.
+assemble_ctf_cvr_qual() is almost as trivial, but has to figure out which of
+const, volatile or restrict it was called for and call the corresponding CTF API
+function.  assemble_ctf_enumeration() and assemble_ctf_enumerator() are quite
+simple too.
+
+
+assemble_ctf_variable() has a couple of extra complexities: we unconditionally
+set the skip parameter to SKIP_SKIP, suppressing recursion into containing DIEs,
+since we already know we won't care about any of them.  Also, while the
+deduplication pass unifies opaque and non-opaque structures into the same type,
+it never makes sure that variables declared in the same header by translation
+units which have opaque versus non-opaque structures in scope are deduplicated.
+e.g. you could well end up with these two type IDs, depending on whether
+<linux/pid_namespace.h> was included before <linux/pid.h> in a given translation
+unit:
+
+////struct pid_namespace var init_pid_ns
+/path/to/kernel/include/linux/pid_namespace.h//19//struct pid_namespace var init_pid_ns
+
+These variables both refer to the same type, but deduplicating them would
+require an additional deduplication pass.  Since variables are always terminal
+and nothing can refer to them, nothing will ever look up any of those type IDs
+(since the only thing that looks up type IDs is code that is searching for type
+that other types depend on).  So we don't care about this duplication and
+running an additional deduplication pass to eliminate it would slow down
+dwarf2ctf to no good end.  It's better just to ignore duplicate errors from
+ctf_add_variable().
+
+
+assemble_ctf_array() and assemble_ctf_array_dimension() we talked about
+above. One last subtlety remains, which is that figuring out the actual
+dimensionality of an array is complicated enough that it has been hived off into
+a private_subrange_dimension() function, called both from here and from
+type_id().  Arrays with neither a DW_AT_upper_bound nor a DW_AT_count, and
+arrays without an indexing type, are best considered flexible arrays; arrays
+whose upper bound or count is not unsigned or signed integral data are also
+flexible (perhaps they're using a full-blown location list, but we can't encode
+that in CTF so we treat it as flexible); and if an upper bound is used, we want
+to add one to its value before treating it as a count of elements.
+
+
+This leaves structure/union assembly, both of which are assembled by the same
+pair of functions, assemble_ctf_struct_union for the type itself and
+assemble_ctf_su_member() for the individual members.  As with
+assemble_ctf_cvr_qual(), we have to look at the tag to figure out which CTF
+function to use to do the assembly, but we have an extra constraint: it is
+perfectly idiomatic C to declare a structure repeatedly with a different number
+of members every time.  This is perfectly permissible as long as the leading
+portions of all declarations match.  We do not verify this (we hope that the
+compiler will diagnose it, which it will unless the conflicting declarations
+cross modules), though perhaps we should: we simply look up the structure in the
+CTF and the DWARF and skip assembly of the structure members via SKIP_SKIP if
+the already-assembled structure has at least as many members as the current one.
+
+assemble_ctf_su_member() is by far the most complex of the assembly functions.
+It has to handle members that already exist, members that need assembly, members
+that correspond to unnamed structure members, numerous different ways of
+representing structure offsets and members with no offset at all.
+
+The offset computation is quite laborious and by no means complete: a complete
+implementation would require an interpreter for DWARF location lists, which is
+total overkill given that in DWARF2 GCC emits a totally stereotyped location
+list, and in DWARF3+ we don't need location list parsing at all.  CTF wants an
+offset in bits.
+
+We have five cases:
+ - for DW_AT_data_bit_offset, we just use the offset unchanged.
+
+ - for DW_AT_data_member_location with an integral form (data2, data4, data8,
+   udata, or sdata) we just look it up and multiply it by eight, adding the
+   parent's DW_AT_bit_offset to handle structures nested inside other
+   structures.
+
+ - for DW_AT_data_member_location with a block form, we make sure that the list
+   is of one particular simple form (DW_OP_plus_uconst and a constant value in
+   bytes), and abort assembly otherwise.  The only case I know of where this
+   test will trip is C++ virtual bases: if people are using C++ code with
+   virtual bases inside the kernel they deserve sympathy, but probably not
+   support in the code.  CTF can't represent C++ types in any case.
+
+ - for expression location lists, or anything else that we don't understand, we
+   simply die (we could simply skip the type, but this seems serious enough that
+   dying is warranted).
+
+ - with none of these present, we have no offset: the member is at the same
+   location as the start of the structure.
+
+But where is the 'start of the structure'?  That depends on whether this is an
+unnamed struct/union member (usually a union).  If it is, we want to fold all
+its members directly into the parent structure, with their offsets increased by
+the offset of the unnamed member as a whole.  This is done by directly calling
+die_to_ctf() with the first child of the anonymous member's type and with all
+other parameters set as if the parent DIE was the current structure, thus
+fooling die_to_ctf() into believing that these members are members of the
+current structure, not of the anonymous one.  The offset-increasing magic is
+done via the parent_bias parameter to die_to_ctf() and all the CTF construction
+functions: it is ignored by all of them except for assemble_ctf_su_member()
+itself, which adds the parent bias onto the normally-computed offset, and is
+otherwise passed down unchanged to all children.  This means that even this
+terribly contrived case works:
+
+struct horror {
+	int spacer;
+	union {
+		struct {
+			int spacer;
+			struct {
+				int foo;
+				int bar;
+			} b;
+		} a;
+	};
+};
+
+In this situation, horror.a.b.bar may have:
+
+ - a nonzero parent_bias due to the offset of the anonymous union in 'struct
+   horror'
+ - a nonzero offset due to the offset of 'bar' in its containing structure
+ - if DW_AT_data_member_location with integral form is used, a nonzero
+   DW_AT_bit_offset of 'b' in 'a'
+
+If this is not an anonymous union, we are dealing with only one member: we look
+up its type and add it reasonably conventionally via ctf_add_member_offset().
+Even here there are subtleties: we use construct_ctf_id() directly rather than
+via lookup_ctf_type() so we can get a better error message on failure, and we
+ignore any duplicate-member errors because this is probably a sign that this
+structure has already been encountered and we are working through another
+instance of it with more members.
+
+
+Writeout
+--------
+
+   write_types()
+
+This couldn't really be simpler, as the trivial call graph shows.  We create an
+output directory with the requested name, then work over the entire
+module_to_ctf_file hash, writing out every CTF file into a new suitably-named
+file via zlib's compressed file I/O functions.
diff --git a/Documentation/process/changes.rst b/Documentation/process/changes.rst
index 560beaef5a7c..859bbaf22cb8 100644
--- a/Documentation/process/changes.rst
+++ b/Documentation/process/changes.rst
@@ -54,9 +54,14 @@ iptables               1.4.2            iptables -V
 openssl & libcrypto    1.0.0            openssl version
 bc                     1.06.95          bc --version
 Sphinx\ [#f1]_	       1.3		sphinx-build --version
+elfutils\ [#f2]_       0.156		eu-readelf --version
+pkg-config\ [#f2]_     0.16		pkg-config --version
+glib\ [#f2]_           2.x		pkg-config --exists glib-2.0 && echo present
+libdtrace-ctf\ [#f2]_  0.7
 ====================== ===============  ========================================
 
 .. [#f1] Sphinx is needed only to build the Kernel documentation
+.. [#f2] This is needed at build-time when CTF or DTrace are enabled
 
 Kernel compilation
 ******************
@@ -450,6 +455,26 @@ NFS-Utils
 
 - <http://nfs.sourceforge.net/>
 
+elfutils
+--------
+
+- <https://fedorahosted.org/elfutils/>
+
+pkg-config
+----------
+
+- <http://www.freedesktop.org/wiki/Software/pkg-config>
+
+glib 2.x
+--------
+
+- <http://www.gtk.org/>
+
+libdtrace-ctf
+-------------
+
+- <https://oss.oracle.com/git/?p=libdtrace-ctf.git>
+
 Kernel documentation
 ********************
 
diff --git a/Makefile b/Makefile
index 68d70485b088..52fb1bcf3ba7 100644
--- a/Makefile
+++ b/Makefile
@@ -564,6 +564,7 @@ net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
 virt-y		:= virt/
+dtrace-y	:= dtrace/
 endif # KBUILD_EXTMOD
 
 ifeq ($(dot-config),1)
@@ -955,14 +956,17 @@ core-y		+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m) $(virt-y)))
+		     $(net-y) $(net-m) $(libs-y) $(libs-m) $(virt-y) \
+		     $(dtrace-y) $(dtrace-m)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
-		     $(init-) $(core-) $(drivers-) $(net-) $(libs-) $(virt-))))
+		     $(init-) $(core-) $(drivers-) $(net-) $(libs-) $(virt-) \
+		     $(dtrace-))))
 
 init-y		:= $(patsubst %/, %/built-in.o, $(init-y))
 core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
 drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
+dtrace-y	:= $(patsubst %/, %/built-in.o, $(dtrace-y))
 net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
 libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
 libs-y2		:= $(filter-out %.a, $(patsubst %/, %/built-in.o, $(libs-y)))
@@ -970,7 +974,7 @@ virt-y		:= $(patsubst %/, %/built-in.o, $(virt-y))
 
 # Externally visible symbols (used by link-vmlinux.sh)
 export KBUILD_VMLINUX_INIT := $(head-y) $(init-y)
-export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y2) $(drivers-y) $(net-y) $(virt-y)
+export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y2) $(drivers-y) $(net-y) $(virt-y) $(dtrace-y)
 export KBUILD_VMLINUX_LIBS := $(libs-y1)
 export KBUILD_LDS          := arch/$(SRCARCH)/kernel/vmlinux.lds
 export LDFLAGS_vmlinux
@@ -1006,7 +1010,7 @@ cmd_link-vmlinux =                                                 \
 	$(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) ;    \
 	$(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)
 
-vmlinux: scripts/link-vmlinux.sh vmlinux_prereq $(vmlinux-deps) FORCE
+vmlinux: scripts/link-vmlinux.sh vmlinux_prereq $(vmlinux-deps) modules_thick.builtin FORCE
 	+$(call if_changed,link-vmlinux)
 
 # Build samples along the rest of the kernel
@@ -1212,17 +1216,49 @@ all: modules
 # using awk while concatenating to the final file.
 
 PHONY += modules
-modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
+modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules_thick.builtin objects.builtin
 	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
 	@$(kecho) '  Building modules, stage 2.';
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
 
-modules.builtin: $(vmlinux-dirs:%=%/modules.builtin)
-	$(Q)$(AWK) '!x[$$0]++' $^ > $(objtree)/modules.builtin
+ifneq (CONFIG_CTF@CONFIG_KALLMODSYMS,'@')
 
-%/modules.builtin: include/config/auto.conf
-	$(Q)$(MAKE) $(modbuiltin)=$*
+# We need to force everything to be built, since we need the .o files below.
+KBUILD_BUILTIN := 1
 
+# Set a default CTF filename.
+CTF_FILENAME := vmlinux.ctfa
+
+# This contains all the object files that are built directly into the
+# kernel (including built-in modules), for consumption by dwarf2ctf in
+# Makefile.modpost.
+# This is made doubly annoying by the presence of '.o' files which are actually
+# thin ar archives, and the need to support file(1) versions too old to
+# recognize them as archives at all.  (So we assume that everything that is not
+# an ELF object is an archive.)
+ifeq ($(SRCARCH),x86)
+objects.builtin: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),bzImage) FORCE
+else
+objects.builtin: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) FORCE
+endif
+	@echo $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN) | \
+		tr " " "\n" | grep "\.o$$" | xargs -r file | \
+		grep ELF | cut -d: -f1 > objects.builtin
+	@for archive in $$(echo $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN) |\
+		tr " " "\n" | xargs -r file | grep -v ELF | cut -d: -f1); do \
+		$(AR) t "$$archive" >> objects.builtin; \
+	done
+
+CTF_DEBUGDIR := .
+
+ctf: $(CTF_FILENAME)
+PHONY += ctf
+$(CTF_FILENAME):
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost CTF_FILENAME=$(CTF_FILENAME) CTF_DEBUGDIR=$(CTF_DEBUGDIR) $(CTF_FILENAME) ctf-builtins="$(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)"
+else
+PHONY += objects.builtin
+objects.builtin:
+endif
 
 # Target to prepare building external modules
 PHONY += modules_prepare
@@ -1244,6 +1280,9 @@ _modinst_:
 	fi
 	@cp -f $(objtree)/modules.order $(MODLIB)/
 	@cp -f $(objtree)/modules.builtin $(MODLIB)/
+	@if [ -f $(objtree)/$(CTF_FILENAME) ] ; then \
+		cp -f $(objtree)/$(CTF_FILENAME) $(MODLIB)/kernel ; \
+	fi
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
 
 # This depmod is only for convenience to give the initial
@@ -1275,6 +1314,30 @@ modules modules_install:
 
 endif # CONFIG_MODULES
 
+# modules.builtin has a 'thick' form usable by tools that do not understand
+# thin archives, which transforms thin archives to their constituent elements,
+# while retaining the name of the archive (-> module) they are part of before a
+# comma.  The redundant kernel/ on the start of every line is also removed, and
+# the object file name corrected (the tools that use this file work over .o files
+# exclusively).
+
+modules_thick.builtin: modules.builtin vmlinux_prereq $(vmlinux-deps)
+	$(Q)(rm -f modules_thick.builtin; \
+	cat modules.builtin | sed 's,^kernel/,,; s,\.ko$$,.o,' | \
+			while read -r module; do \
+		if file $$module | grep -qvF " ELF "; then \
+			$(AR) t $$module | sed 's,^,'"$$module:," >> modules_thick.builtin; \
+		else \
+			printf "%s\n" "$$module" >> modules_thick.builtin; \
+		fi; \
+	done)
+
+modules.builtin: $(vmlinux-dirs:%=%/modules.builtin)
+	$(Q)$(AWK) '!x[$$0]++' $^ > $(objtree)/modules.builtin
+
+%/modules.builtin: include/config/auto.conf
+	$(Q)$(MAKE) $(modbuiltin)=$*
+
 ###
 # Cleaning is done on three levels.
 # make clean     Delete most generated files
@@ -1283,7 +1346,8 @@ endif # CONFIG_MODULES
 # make distclean Remove editor backup files, patch leftover files and the like
 
 # Directories & files removed with 'make clean'
-CLEAN_DIRS  += $(MODVERDIR)
+CLEAN_DIRS  += $(MODVERDIR) .ctf
+CLEAN_FILES += .ctf.filelist
 
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config usr/include include/generated          \
@@ -1381,6 +1445,8 @@ help:
 	@echo  '                    (requires a recent binutils and recent build (System.map))'
 	@echo  '  dir/file.ko     - Build module including final link'
 	@echo  '  modules_prepare - Set up for building external modules'
+	@echo  '  ctf             - Generate CTF type information for DTrace, installed by '
+	@echo  '                    make modules_install'
 	@echo  '  tags/TAGS	  - Generate tags file for editors'
 	@echo  '  cscope	  - Generate cscope index'
 	@echo  '  gtags           - Generate GNU GLOBAL index'
@@ -1557,11 +1623,13 @@ clean: $(clean-dirs)
 		-o -name '*.ko.*' \
 		-o -name '*.dwo'  \
 		-o -name '*.su'  \
+		-o -name '*.sdtinfo.c' -o -name '*.sdtstub.S' \
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
 		-o -name '*.symtypes' -o -name 'modules.order' \
-		-o -name modules.builtin -o -name '.tmp_*.o.*' \
-		-o -name '*.c.[012]*.*' \
-		-o -name '*.ll' \
+		-o -name modules.builtin -o -name modules_thick.builtin \
+		-o -name 'objects.builtin' \
+		-o -name '.tmp_*.o.*' -o -name '*.c.[012]*.*' \
+		-o -name '*.ll' -o -name '*.ctfa' \
 		-o -name '*.gcno' \) -type f -print | xargs rm -f
 
 # Generate tags for editors
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index c2abb4e88ff2..4513377fd6fa 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -251,6 +251,9 @@ config PGTABLE_LEVELS
 config ARCH_SUPPORTS_UPROBES
 	def_bool y
 
+config ARCH_SUPPORTS_DTRACE
+	def_bool y
+
 config ARCH_PROC_KCORE_TEXT
 	def_bool y
 
diff --git a/arch/arm64/dtrace/Makefile.arch b/arch/arm64/dtrace/Makefile.arch
new file mode 100644
index 000000000000..f4aa2e1fced7
--- /dev/null
+++ b/arch/arm64/dtrace/Makefile.arch
@@ -0,0 +1,17 @@
+#
+# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+#
+
+DTARCHDIR = ../arch/arm64/dtrace
+
+ccflags-y	+= -Iarch/arm64/dtrace/include -Idtrace
+
+dtrace-obj	+= dtrace_asm_arm64.o dtrace_isa_arm64.o
+fasttrap-obj	+= fasttrap_arm64.o
+fbt-obj		+= fbt_arm64.o
+sdt-obj		+= sdt_arm64.o
+
+dtrace-y	+= $(addprefix $(DTARCHDIR)/, $(dtrace-obj))
+fasttrap-y	+= $(addprefix $(DTARCHDIR)/, $(fasttrap-obj))
+fbt-y		+= $(addprefix $(DTARCHDIR)/, $(fbt-obj))
+sdt-y		+= $(addprefix $(DTARCHDIR)/, $(sdt-obj))
diff --git a/arch/arm64/dtrace/dtrace_asm_arm64.S b/arch/arm64/dtrace/dtrace_asm_arm64.S
new file mode 100644
index 000000000000..248fe5e26646
--- /dev/null
+++ b/arch/arm64/dtrace/dtrace_asm_arm64.S
@@ -0,0 +1,50 @@
+/*
+ * Dynamic Tracing for Linux - ARM64 specific assembly
+ *
+ * Copyright (c) 2017 Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+
+ENTRY(dtrace_caller)
+	mov	x0, #-1
+	ret
+ENDPROC(dtrace_caller)
+
+ENTRY(dtrace_copy)
+	ret
+ENDPROC(dtrace_copy)
+
+ENTRY(dtrace_copystr)
+	ret
+ENDPROC(dtrace_copystr)
+
+ENTRY(dtrace_fuword8_nocheck)
+	ldrb	w0, [x0]
+	ret
+ENDPROC(dtrace_fuword8_nocheck)
+
+ENTRY(dtrace_fuword16_nocheck)
+	ldrh	w0, [x0]
+	ret
+ENDPROC(dtrace_fuword16_nocheck)
+
+ENTRY(dtrace_fuword32_nocheck)
+	ldr	w0, [x0]
+	ret
+ENDPROC(dtrace_fuword32_nocheck)
+
+ENTRY(dtrace_fuword64_nocheck)
+	ldr	x0, [x0]
+	ret
+ENDPROC(dtrace_fuword64_nocheck)
diff --git a/arch/arm64/dtrace/dtrace_isa_arm64.c b/arch/arm64/dtrace/dtrace_isa_arm64.c
new file mode 100644
index 000000000000..afa5c5815043
--- /dev/null
+++ b/arch/arm64/dtrace/dtrace_isa_arm64.c
@@ -0,0 +1,94 @@
+/*
+ * FILE:	dtrace_isa_arm64.c
+ * DESCRIPTION:	DTrace - arm64 architecture specific support functions
+ *
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ptrace.h>
+#include <asm/stacktrace.h>
+
+#include "dtrace.h"
+
+uintptr_t _userlimit = 0x0000ffffffffffffLL;
+
+void dtrace_copyin_arch(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+			volatile uint16_t *flags)
+{
+}
+
+void dtrace_copyinstr_arch(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+			   volatile uint16_t *flags)
+{
+}
+
+void dtrace_copyout(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		    volatile uint16_t *flags)
+{
+}
+
+void dtrace_copyoutstr(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		       volatile uint16_t *flags)
+{
+}
+
+#define DTRACE_FUWORD(bits) \
+	uint##bits##_t dtrace_fuword##bits(void *uaddr)			      \
+	{								      \
+		extern uint##bits##_t	dtrace_fuword##bits##_nocheck(void *);\
+									      \
+		if ((uintptr_t)uaddr > _userlimit) {			      \
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);		      \
+			this_cpu_core->cpuc_dtrace_illval = (uintptr_t)uaddr; \
+		}							      \
+									      \
+		return dtrace_fuword##bits##_nocheck(uaddr);		      \
+	}
+
+DTRACE_FUWORD(8)
+DTRACE_FUWORD(16)
+DTRACE_FUWORD(32)
+DTRACE_FUWORD(64)
+
+uint64_t dtrace_getarg(int argno, int aframes)
+{
+	return 0;
+}
+
+ulong_t dtrace_getreg(struct task_struct *task, uint_t reg)
+{
+	struct pt_regs	*rp = task_pt_regs(task);
+
+	return regs_get_register(rp, reg * sizeof(uint64_t));
+}
+
+void pdata_init(dtrace_module_t *pdata, struct module *mp)
+{
+	/*
+	 * Throw away existing data as we don't support reusal at
+	 * the moment.
+	 */
+	if (mp->pdata != NULL)
+		pdata_cleanup(pdata, mp);
+
+	pdata->sdt_tab = NULL;
+	pdata->fbt_tab = NULL;
+}
+
+void pdata_cleanup(dtrace_module_t *pdata, struct module *mp)
+{
+	if (pdata->sdt_tab != NULL)
+		dtrace_free_text(pdata->sdt_tab);
+	if (pdata->fbt_tab != NULL)
+		dtrace_free_text(pdata->fbt_tab);
+}
diff --git a/arch/arm64/dtrace/include/dtrace/sdt_arch.h b/arch/arm64/dtrace/include/dtrace/sdt_arch.h
new file mode 100644
index 000000000000..b17486510ef0
--- /dev/null
+++ b/arch/arm64/dtrace/include/dtrace/sdt_arch.h
@@ -0,0 +1,27 @@
+/*
+ * Dynamic Tracing for Linux - SDT Implementation defines
+ *
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _ARM64_SDT_ARCH_H
+#define _ARM64_SDT_ARCH_H
+
+#define SDT_AFRAMES	1
+
+#endif /* _ARM64_SDT_ARCH_H */
diff --git a/arch/arm64/include/asm/cpu.h b/arch/arm64/include/asm/cpu.h
index 889226b4c6e1..d3c15b63cbe0 100644
--- a/arch/arm64/include/asm/cpu.h
+++ b/arch/arm64/include/asm/cpu.h
@@ -62,6 +62,7 @@ struct cpuinfo_arm64 {
 };
 
 DECLARE_PER_CPU(struct cpuinfo_arm64, cpu_data);
+#define cpu_data(cpu)		per_cpu(cpu_data, (cpu))
 
 void cpuinfo_store_cpu(void);
 void __init cpuinfo_store_boot_cpu(void);
diff --git a/arch/arm64/include/asm/dtrace_arch.h b/arch/arm64/include/asm/dtrace_arch.h
new file mode 100644
index 000000000000..dad5a69a0683
--- /dev/null
+++ b/arch/arm64/include/asm/dtrace_arch.h
@@ -0,0 +1,30 @@
+/* Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved. */
+
+#ifndef _ASM_ARM64_DTRACE_ARCH_H
+#define _ASM_ARM64_DTRACE_ARCH_H
+
+/* Number of argumens stored inside the mstate. */
+#define	DTRACE_MSTATE_ARGS_MAX		7
+
+typedef uint32_t	asm_instr_t;
+
+typedef int (*prov_exit_f)(void);
+
+/*
+ * Structure to hold DTrace specific information about modules (including the
+ * core kernel module).  Note that each module (and the main kernel) already
+ * has three fields that relate to probing:
+ *	- sdt_probes: description of SDT probes in the module
+ *	- sdt_probec: number of SDT probes in the module
+ *	- pdata: pointer to a dtrace_module struct (for DTrace)
+ */
+typedef struct dtrace_module {
+	int             enabled_cnt;
+	size_t          sdt_probe_cnt;
+	asm_instr_t	*sdt_tab;
+	size_t          fbt_probe_cnt;
+	asm_instr_t	*fbt_tab;
+	prov_exit_f	prov_exit;
+} dtrace_module_t;
+
+#endif /* _ASM_ARM64_DTRACE_ARCH_H */
diff --git a/arch/arm64/include/asm/dtrace_cpuinfo.h b/arch/arm64/include/asm/dtrace_cpuinfo.h
new file mode 100644
index 000000000000..139c4cff11bf
--- /dev/null
+++ b/arch/arm64/include/asm/dtrace_cpuinfo.h
@@ -0,0 +1,12 @@
+/* Copyright (C) 2018 Oracle, Inc. */
+
+#ifndef _ASM_ARM64_DTRACE_CPUINFO_H_
+#define _ASM_ARM64_DTRACE_CPUINFO_H_
+
+#include <asm/cpu.h>
+
+typedef struct cpuinfo_arm64		cpuinfo_arch_t;
+
+#define dtrace_cpuinfo_chip(ci)		((ci)->cpu.node_id)
+
+#endif /* _ASM_ARM64_DTRACE_CPUINFO_H_ */
diff --git a/arch/arm64/include/asm/dtrace_sdt_arch.h b/arch/arm64/include/asm/dtrace_sdt_arch.h
new file mode 100644
index 000000000000..438859a5a9b0
--- /dev/null
+++ b/arch/arm64/include/asm/dtrace_sdt_arch.h
@@ -0,0 +1,11 @@
+/* Copyright (C) 2018 Oracle, Inc. */
+
+#ifndef _ASM_ARM64_DTRACE_SDT_ARCH_H
+#define _ASM_ARM64_DTRACE_SDT_ARCH_H
+
+#define NOP_INSTR	0xd503201f
+
+#define __DTRACE_SDT_ISENABLED_PROTO void
+#define __DTRACE_SDT_ISENABLED_ARGS
+
+#endif /* _ASM_ARM64_DTRACE_SDT_ARCH_H */
diff --git a/arch/arm64/include/asm/dtrace_syscall.h b/arch/arm64/include/asm/dtrace_syscall.h
new file mode 100644
index 000000000000..30731edc124f
--- /dev/null
+++ b/arch/arm64/include/asm/dtrace_syscall.h
@@ -0,0 +1,5 @@
+/*
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ */
+
+DTRACE_SYSCALL_STUB(RT_SIGRETURN,	rt_sigreturn)
diff --git a/arch/arm64/include/asm/dtrace_util.h b/arch/arm64/include/asm/dtrace_util.h
new file mode 100644
index 000000000000..0c8c08633444
--- /dev/null
+++ b/arch/arm64/include/asm/dtrace_util.h
@@ -0,0 +1,10 @@
+/* Copyright (C) 2018, Oracle and/or its affiliates. All rights reserved. */
+
+#ifndef _ASM_ARM64_DTRACE_UTIL_H
+#define _ASM_ARM64_DTRACE_UTIL_H
+
+#include <asm/dtrace_arch.h>
+
+extern int dtrace_user_addr_is_exec(uintptr_t);
+
+#endif /* _ASM_ARM64_DTRACE_UTIL_H */
diff --git a/arch/arm64/include/asm/kdebug.h b/arch/arm64/include/asm/kdebug.h
new file mode 100644
index 000000000000..66c884086d04
--- /dev/null
+++ b/arch/arm64/include/asm/kdebug.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ARM64_KDEBUG_H
+#define _ARM64_KDEBUG_H
+
+/* Grossly misnamed. */
+enum die_val {
+	DIE_OOPS = 1,
+	DIE_PAGE_FAULT,
+};
+
+#endif /* _ARM64_KDEBUG_H */
diff --git a/arch/arm64/kernel/dtrace_fbt.c b/arch/arm64/kernel/dtrace_fbt.c
new file mode 100644
index 000000000000..683134db6ac6
--- /dev/null
+++ b/arch/arm64/kernel/dtrace_fbt.c
@@ -0,0 +1,117 @@
+/*
+ * FILE:        dtrace_fbt.c
+ * DESCRIPTION: Dynamic Tracing: FBT registration code (arch-specific)
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <linux/kernel.h>
+#include <linux/kallsyms.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_fbt.h>
+#include <linux/sort.h>
+#include <asm/insn.h>
+#include <asm/sections.h>
+
+#define BL_SENTRY(tp, nm)	extern tp nm;
+#define BL_DENTRY(tp, nm)
+#include "fbt_blacklist.h"
+#undef BL_DENTRY
+#undef BL_SENTRY
+
+static void
+dtrace_fbt_populate_bl(void)
+{
+#define	BL_SENTRY(tp, nm)	dtrace_fbt_bl_add((unsigned long)&nm, __stringify(nm));
+#define BL_DENTRY(tp, nm)	dtrace_fbt_bl_add(0, __stringify(nm));
+#include "fbt_blacklist.h"
+#undef BL_SENTRY
+#undef BL_DENTRY
+}
+
+void dtrace_fbt_init(fbt_add_probe_fn fbt_add_probe, struct module *mp,
+		     void *arg)
+{
+	loff_t			pos;
+	struct kallsym_iter	sym;
+	dt_fbt_bl_entry_t	*blent = NULL;
+
+	/*
+	 * Look up any unresolved symbols in the blacklist, and sort the list
+	 * by ascending address.
+	 */
+	dtrace_fbt_populate_bl();
+	blent = dtrace_fbt_bl_first();
+
+	pos = 0;
+	kallsyms_iter_reset(&sym, 0);
+	while (kallsyms_iter_update(&sym, pos++)) {
+		asm_instr_t	*addr, *end;
+
+		/*
+		 * There is no point considering non-function symbols for FBT,
+		 * or symbols that have a zero size.  We could consider weak
+		 * symbols but that gets quite complicated and there is no
+		 * demands for that (so far).
+		 */
+		if (sym.type != 'T' && sym.type != 't')
+			continue;
+		if (!sym.size)
+			continue;
+
+		/*
+		 * The symbol must be at a properly aligned address.
+		 */
+		if (!IS_ALIGNED(sym.value, 4))
+			continue;
+
+		/*
+		 * Handle only symbols that belong to the module we have been
+		 * asked for.
+		 */
+		if (mp == dtrace_kmod && !core_kernel_text(sym.value))
+			continue;
+
+		/*
+		 * Ensure we have not been given .init symbol from kallsyms
+		 * interface. This could lead to memory corruption once DTrace
+		 * tries to enable probe in already freed memory.
+		 */
+		if (mp != dtrace_kmod && !within_module_core(sym.value, mp))
+			continue;
+
+		/*
+		 * See if the symbol is on the FBT's blacklist.  Since both
+		 * iterators are workng in sort order by ascending address we
+		 * can use concurrent traversal.
+		 */
+		while (blent != NULL &&
+		       dtrace_fbt_bl_entry_addr(blent) < sym.value) {
+			blent = dtrace_fbt_bl_next(blent);
+		}
+		if (dtrace_fbt_bl_entry_addr(blent) == sym.value)
+			continue;
+
+		/*
+		 * No FBT tracing for DTrace functions, and functions that are
+		 * crucial to probe processing.
+		 * Also weed out symbols that are not relevant here.
+		 */
+		if (strncmp(sym.name, "dtrace_", 7) == 0)
+			continue;
+		if (strncmp(sym.name, "_GLOBAL_", 8) == 0)
+			continue;
+		if (strncmp(sym.name, "do_", 3) == 0)
+			continue;
+
+		addr = (asm_instr_t *)sym.value;
+		end = (asm_instr_t *)(sym.value + sym.size);
+
+		/*
+		 * FIXME:
+		 * Add code here to determine which functions we can put FBT
+		 * probes on.
+		 */
+	}
+}
+EXPORT_SYMBOL(dtrace_fbt_init);
diff --git a/arch/arm64/kernel/dtrace_sdt.c b/arch/arm64/kernel/dtrace_sdt.c
new file mode 100644
index 000000000000..5daf5bce2538
--- /dev/null
+++ b/arch/arm64/kernel/dtrace_sdt.c
@@ -0,0 +1,33 @@
+/*
+ * FILE:        dtrace_sdt.c
+ * DESCRIPTION: Dynamic Tracing: SDT registration code (arch-specific)
+ *
+ * Copyright (C) 2018 Oracle Corporation
+ */
+
+#include <linux/module.h>
+#include <asm/cacheflush.h>
+#include <asm/dtrace_arch.h>
+#include <asm/dtrace_sdt_arch.h>
+
+void __init_or_module dtrace_sdt_nop_multi(asm_instr_t **addrs,
+					   int * __always_unused is_enabled,
+					   int cnt)
+{
+	int		i;
+	asm_instr_t	*addr;
+
+	for (i = 0; i < cnt; i++) {
+		addr = addrs[i];
+		*addr = NOP_INSTR;
+		flush_icache_range((uintptr_t)addr, (uintptr_t)(addr + 1));
+	}
+}
+
+/*
+ * Perform architecture dependent initialization for SDT.  On arm64, we need
+ * not do anything.
+ */
+void dtrace_sdt_init_arch(void)
+{
+}
diff --git a/arch/arm64/kernel/dtrace_syscall.c b/arch/arm64/kernel/dtrace_syscall.c
new file mode 100644
index 000000000000..74b00d6eeefa
--- /dev/null
+++ b/arch/arm64/kernel/dtrace_syscall.c
@@ -0,0 +1,96 @@
+/*
+ * FILE:	dtrace_syscall.c
+ * DESCRIPTION:	Dynamic Tracing: system call tracing support (arch-specific)
+ *
+ * Copyright (C) 2010-2014 Oracle Corporation
+ */
+
+#include <linux/dtrace_syscall.h>
+#include <linux/ptrace.h>
+#include <asm/syscall.h>
+
+void (*systrace_probe)(dtrace_id_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t,
+		       uintptr_t, uintptr_t, uintptr_t);
+
+void systrace_stub(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
+		   uintptr_t arg2, uintptr_t arg3, uintptr_t arg4,
+		   uintptr_t arg5, uintptr_t arg6)
+{
+}
+
+asmlinkage long systrace_syscall(uintptr_t, uintptr_t, uintptr_t, uintptr_t,
+				 uintptr_t, uintptr_t, uintptr_t);
+
+static systrace_info_t	systrace_info = {
+				&systrace_probe,
+				systrace_stub,
+				systrace_syscall,
+				{
+#define DTRACE_SYSCALL_STUB(id, name) \
+				[SCE_##id] (dt_sys_call_t)dtrace_stub_##name,
+#include <asm/dtrace_syscall.h>
+#undef DTRACE_SYSCALL_STUB
+				},
+				{
+#undef __SYSCALL
+#define __SYSCALL(nr, sym)	[nr] { .name = __stringify(sym), },
+#include <asm/unistd.h>
+#undef __SYSCALL
+				}
+			};
+
+
+asmlinkage long systrace_syscall(uintptr_t arg0, uintptr_t arg1,
+				 uintptr_t arg2, uintptr_t arg3,
+				 uintptr_t arg4, uintptr_t arg5,
+				 uintptr_t arg6)
+{
+	long			rc = 0;
+	unsigned long		sysnum;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sysnum = syscall_get_nr(current, current_pt_regs());
+	sc = &systrace_info.sysent[sysnum];
+
+	id = sc->stsy_entry;
+	if (id != DTRACE_IDNONE)
+		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5,
+				  arg6);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	if (sc->stsy_underlying != NULL)
+		rc = (*sc->stsy_underlying)(arg0, arg1, arg2, arg3, arg4,
+					    arg5, arg6);
+
+	id = sc->stsy_return;
+	if (id != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0, 0);
+
+	return rc;
+}
+
+systrace_info_t *dtrace_syscalls_init()
+{
+	int			i;
+
+	/*
+	 * Only initialize this stuff once...
+	 */
+	if (systrace_info.sysent[0].stsy_tblent != NULL)
+		return &systrace_info;
+
+	for (i = 0; i < NR_syscalls; i++) {
+		systrace_info.sysent[i].stsy_tblent =
+					(dt_sys_call_t *)&sys_call_table[i];
+		systrace_info.sysent[i].stsy_underlying =
+					(dt_sys_call_t)sys_call_table[i];
+	}
+
+	return &systrace_info;
+}
+EXPORT_SYMBOL(dtrace_syscalls_init);
diff --git a/arch/arm64/kernel/dtrace_syscall_stubs.S b/arch/arm64/kernel/dtrace_syscall_stubs.S
new file mode 100644
index 000000000000..d53dc44df085
--- /dev/null
+++ b/arch/arm64/kernel/dtrace_syscall_stubs.S
@@ -0,0 +1,12 @@
+/*
+ * FILE:        dtrace_stubs_arm64.S
+ * DESCRIPTION: Dynamic Tracing: Syscall tracing stubs (arch-specific)
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+#include <linux/linkage.h>
+
+ENTRY(dtrace_stub_rt_sigreturn)
+	mov	x0, sp
+	b	sys_rt_sigreturn
+ENDPROC(dtrace_stub_rt_sigreturn)
diff --git a/arch/arm64/kernel/dtrace_util.c b/arch/arm64/kernel/dtrace_util.c
new file mode 100644
index 000000000000..5d2d5b78d588
--- /dev/null
+++ b/arch/arm64/kernel/dtrace_util.c
@@ -0,0 +1,94 @@
+/*
+ * FILE:	dtrace_util.c
+ * DESCRIPTION:	Dynamic Tracing: Architecture utility functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/notifier.h>
+#include <linux/ptrace.h>
+#include <linux/kdebug.h>
+
+void dtrace_skip_instruction(struct pt_regs *regs)
+{
+	instruction_pointer_set(regs, instruction_pointer(regs) + 4);
+}
+
+void dtrace_handle_badaddr(struct pt_regs *regs)
+{
+	unsigned long	addr = current->thread.fault_address;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+	this_cpu_core->cpuc_dtrace_illval = addr;
+
+	dtrace_skip_instruction(regs);
+}
+
+int dtrace_die_notifier(struct notifier_block *nb, unsigned long val,
+			void *args)
+{
+	struct die_args		*dargs = args;
+
+	switch (val) {
+	case DIE_PAGE_FAULT: {
+		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
+			return NOTIFY_DONE;
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+		this_cpu_core->cpuc_dtrace_illval = dargs->err;
+
+		dtrace_skip_instruction(dargs->regs);
+
+		return NOTIFY_OK | NOTIFY_STOP_MASK;
+	}
+	case DIE_OOPS: {
+		pr_info("DTrace: probe ctx %d last probe %ld\n",
+		       !!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_PROBE_CTX),
+		       this_cpu_core->cpu_dtrace_caller);
+		return NOTIFY_DONE;
+	}
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+int dtrace_user_addr_is_exec(uintptr_t addr)
+{
+	/*
+	 * FIXME:
+	 * Placeholder
+	 */
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_user_addr_is_exec);
+
+void dtrace_user_stacktrace(stacktrace_state_t *st)
+{
+	struct pt_regs		*regs = current_pt_regs();
+	uint64_t		*pcs = st->pcs;
+	int			limit = st->limit;
+
+	if (!user_mode(regs))
+		goto out;
+
+	st->depth = 1;
+	if (pcs)
+		*pcs++ = (uint64_t)instruction_pointer(regs);
+	limit--;
+
+out:
+	if (pcs) {
+		while (limit--)
+			*pcs++ = 0;
+	}
+}
+
+void dtrace_mod_pdata_init(dtrace_module_t *pdata)
+{
+}
+
+void dtrace_mod_pdata_cleanup(dtrace_module_t *pdata)
+{
+}
diff --git a/arch/arm64/kernel/fbt_blacklist.h b/arch/arm64/kernel/fbt_blacklist.h
new file mode 100644
index 000000000000..a8b31e8dafe3
--- /dev/null
+++ b/arch/arm64/kernel/fbt_blacklist.h
@@ -0,0 +1,89 @@
+/*
+ * FIXME:
+ * This is a placeholder.
+ */
+
+/*
+ * Functions used in die notifier chain calling.
+ */
+BL_DENTRY(void *, notify_die)
+BL_DENTRY(void *, notifier_call_chain)
+BL_DENTRY(typeof(__atomic_notifier_call_chain), __atomic_notifier_call_chain)
+BL_DENTRY(typeof(atomic_notifier_call_chain), atomic_notifier_call_chain)
+BL_DENTRY(typeof(__raw_notifier_call_chain), __raw_notifier_call_chain)
+BL_DENTRY(typeof(raw_notifier_call_chain), raw_notifier_call_chain)
+BL_DENTRY(void *, hw_breakpoint_exceptions_notify)
+BL_DENTRY(void *, kprobe_exceptions_notify)
+
+/*
+ * Functions used to update vtime in probe context.
+ */
+BL_DENTRY(typeof(ktime_get_raw_fast_ns), ktime_get_raw_fast_ns)
+BL_DENTRY(void *, raw_read_seqcount)
+BL_DENTRY(void *, read_seqcount_retry)
+BL_DENTRY(void *, __read_seqcount_retry)
+
+/* xen_clocksource */
+BL_DENTRY(void *, xen_clocksource_get_cycles)
+BL_DENTRY(void *, xen_clocksource_read)
+BL_DENTRY(void *, pvclock_clocksource_read)
+BL_DENTRY(void *, pvclock_touch_watchdogs)
+BL_DENTRY(void *, touch_softlockup_watchdog_sync)
+BL_DENTRY(void *, clocksource_touch_watchdog)
+BL_DENTRY(void *, clocksource_resume_watchdog)
+BL_DENTRY(void *, reset_hung_task_detector)
+/* clocksource_tsc */
+BL_DENTRY(void *, read_tsc)
+BL_DENTRY(void *, get_cycles)
+/* clocksource_hpet */
+BL_DENTRY(void *, read_hpet)
+BL_DENTRY(void *, hpet_readl)
+/* kvm_clock */
+BL_DENTRY(void *, kvm_clock_get_cycles)
+BL_DENTRY(void *, kvm_clock_read)
+
+/*
+ * Functions used in trap handling.
+ */
+BL_DENTRY(void *, fixup_exception)
+BL_DENTRY(void *, paranoid_entry)
+BL_DENTRY(void *, kgdb_ll_trap)
+BL_DENTRY(void *, error_entry)
+BL_DENTRY(void *, xen_int3)
+BL_DENTRY(void *, ftrace_int3_handler)
+BL_DENTRY(typeof(poke_int3_handler), poke_int3_handler)
+BL_DENTRY(void *, fixup_bad_iret)
+BL_DENTRY(void *, xen_adjust_exception_frame)
+BL_DENTRY(void *, paravirt_nop)
+BL_DENTRY(void *, ist_enter)
+BL_DENTRY(void *, rcu_nmi_enter)
+BL_DENTRY(void *, rcu_dynticks_curr_cpu_in_eqs)
+BL_DENTRY(void *, rcu_dynticks_eqs_exit)
+BL_DENTRY(void *, rcu_nmi_exit)
+BL_DENTRY(void *, rcu_dynticks_eqs_enter)
+BL_DENTRY(void *, ist_exit)
+
+/*
+ * Functions used in page fault handling.
+ */
+BL_DENTRY(void *, do_page_fault)
+BL_DENTRY(void *, __do_page_fault)
+BL_DENTRY(void *, down_read_trylock)
+BL_DENTRY(void *, __get_user_pages_fast)
+BL_DENTRY(void *, gup_pud_range)
+BL_DENTRY(void *, gup_huge_pud)
+BL_DENTRY(void *, gup_pmd_range)
+BL_DENTRY(void *, gup_huge_pmd)
+BL_DENTRY(void *, gup_pte_range)
+BL_DENTRY(void *, pte_mfn_to_pfn)
+
+/*
+ * Functions used under 4.12 idr_find
+ */
+BL_DENTRY(void *, find_next_bit)
+BL_DENTRY(void *, _find_next_bit)
+BL_DENTRY(void *, radix_tree_lookup)
+BL_DENTRY(void *, __radix_tree_lookup)
+BL_DENTRY(void *, radix_tree_load_root)
+BL_DENTRY(void *, radix_tree_descend)
+BL_DENTRY(void *, is_sibling_entry)
diff --git a/arch/arm64/kernel/sys.c b/arch/arm64/kernel/sys.c
index 26fe8ea93ea2..94a35e56c8f1 100644
--- a/arch/arm64/kernel/sys.c
+++ b/arch/arm64/kernel/sys.c
@@ -59,7 +59,11 @@ asmlinkage long sys_rt_sigreturn_wrapper(void);
  * The sys_call_table array must be 4K aligned to be accessible from
  * kernel/entry.S.
  */
-void * const sys_call_table[__NR_syscalls] __aligned(4096) = {
+#if IS_ENABLED(CONFIG_DT_SYSTRACE)
+void *sys_call_table[__NR_syscalls] __aligned(4096) = {
+#else
+void *const sys_call_table[__NR_syscalls] __aligned(4096) = {
+#endif /* IS_ENABLED(CONFIG_DT_SYSTRACE) */
 	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
 #include <asm/unistd.h>
 };
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index 5edb706aacb0..c2f7b97bd68d 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -23,6 +23,7 @@
 #include <linux/mm.h>
 #include <linux/hardirq.h>
 #include <linux/init.h>
+#include <linux/kdebug.h>
 #include <linux/kprobes.h>
 #include <linux/uaccess.h>
 #include <linux/page-flags.h>
@@ -83,6 +84,19 @@ static inline int notify_page_fault(struct pt_regs *regs, unsigned int esr)
 }
 #endif
 
+#ifdef CONFIG_DTRACE
+static int dtrace_fault(struct pt_regs *regs, unsigned long addr)
+{
+	preempt_disable();
+	if (notify_die(DIE_PAGE_FAULT, "page fault", regs, addr, 14,
+		       SIGKILL) == NOTIFY_STOP)
+		return 1;
+	preempt_enable();
+
+	return 0;
+}
+#endif
+
 static void data_abort_decode(unsigned int esr)
 {
 	pr_alert("Data abort info:\n");
@@ -405,6 +419,10 @@ static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,
 
 	if (notify_page_fault(regs, esr))
 		return 0;
+#ifdef CONFIG_DTRACE
+	if (dtrace_fault(regs, addr))
+		return 0;
+#endif
 
 	tsk = current;
 	mm  = tsk->mm;
diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig
index 4e83f950713e..290ab5c10611 100644
--- a/arch/sparc/Kconfig
+++ b/arch/sparc/Kconfig
@@ -167,6 +167,9 @@ config PGTABLE_LEVELS
 config ARCH_SUPPORTS_UPROBES
 	def_bool y if SPARC64
 
+config ARCH_SUPPORTS_DTRACE
+	def_bool y if SPARC64
+
 source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
diff --git a/arch/sparc/dtrace/Makefile.arch b/arch/sparc/dtrace/Makefile.arch
new file mode 100644
index 000000000000..7f9e96904395
--- /dev/null
+++ b/arch/sparc/dtrace/Makefile.arch
@@ -0,0 +1,17 @@
+#
+# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+DTARCHDIR = ../arch/sparc/dtrace
+
+ccflags-y	+= -Iarch/sparc/dtrace/include -Idtrace
+
+dtrace-obj	+= dtrace_asm_sparc64.o dtrace_isa_sparc64.o
+fasttrap-obj	+= fasttrap_sparc64.o
+fbt-obj		+= fbt_sparc64.o
+sdt-obj		+= sdt_sparc64.o
+
+dtrace-y	+= $(addprefix $(DTARCHDIR)/, $(dtrace-obj))
+fasttrap-y	+= $(addprefix $(DTARCHDIR)/, $(fasttrap-obj))
+fbt-y		+= $(addprefix $(DTARCHDIR)/, $(fbt-obj))
+sdt-y		+= $(addprefix $(DTARCHDIR)/, $(sdt-obj))
diff --git a/arch/sparc/dtrace/dtrace_asm_sparc64.S b/arch/sparc/dtrace/dtrace_asm_sparc64.S
new file mode 100644
index 000000000000..393078942c9d
--- /dev/null
+++ b/arch/sparc/dtrace/dtrace_asm_sparc64.S
@@ -0,0 +1,295 @@
+/*
+ * Dynamic Tracing for Linux - sparc64 specific assembly
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/asi.h>
+
+#define CPU_DTRACE_BADADDR	0x0004	/* DTrace fault: bad address */
+#define	ASI_USER		ASI_AIUS
+#define nwin_minus_one		0x7
+
+	ENTRY(dtrace_getfp)
+	retl
+	mov	%fp, %o0
+	ENDPROC(dtrace_getfp)
+
+	ENTRY(dtrace_cas32)
+	cas	[%o0], %o1, %o2
+	retl
+	mov	%o2, %o0
+	ENDPROC(dtrace_cas32)
+
+	ENTRY(dtrace_casptr)
+	casn	[%o0], %o1, %o2
+	retl
+	mov	%o2, %o0
+	ENDPROC(dtrace_casptr)
+
+/* FIXME */
+	ENTRY(dtrace_fish)
+	rd	%pc, %g5
+	ba	0f
+	add	%g5, 12, %g5
+	mov	%l0, %g4
+	mov	%l1, %g4
+	mov	%l2, %g4
+	mov	%l3, %g4
+	mov	%l4, %g4
+	mov	%l5, %g4
+	mov	%l6, %g4
+	mov	%l7, %g4
+	mov	%i0, %g4
+	mov	%i1, %g4
+	mov	%i2, %g4
+	mov	%i3, %g4
+	mov	%i4, %g4
+	mov	%i5, %g4
+	mov	%i6, %g4
+	mov	%i7, %g4
+0:
+	sub	%o1, 16, %o1		! Can only retrieve %l's and %i's
+	sll	%o1, 2, %o1		! Multiply by instruction size
+	add	%g5, %o1, %g5		! %g5 now contains the instr. to pick
+
+	mov	nwin_minus_one, %g4
+
+	!
+	! First we need to see if the frame that we're fishing in is still
+	! contained in the register windows.
+	!
+	rdpr	%canrestore, %g2
+	cmp	%g2, %o0
+	bl	%icc, 2f
+	rdpr	%cwp, %g1
+	sub	%g1, %o0, %g3
+	brgez,a,pt	%g3, 0f
+	wrpr	%g3, %cwp
+
+	!
+	! CWP minus the number of frames is negative; we must perform the
+	! arithmetic modulo MAXWIN.
+	!
+	add	%g4, %g3, %g3
+	inc	%g3
+	wrpr	%g3, %cwp
+0:
+	jmp	%g5
+	ba	1f
+1:
+	wrpr	%g1, %cwp
+	stn	%g4, [%o2]
+	retl
+	clr	%o0			! Success; return 0.
+2:
+	!
+	! The frame that we're looking for has been flushed to the stack; the
+	! caller will be forced to retrieve regiters from there.
+	!
+	retl
+	add	%g2, 1, %o0		! Failure; return deepest frame + 1
+	ENDPROC(dtrace_fish)
+
+	/*
+	 * Try to find caller in register windows.
+	 *
+	 * This is tricky as we must use globals during window rotation
+	 * and must preserve them at the same time. For that reason the 2nd
+	 * argument is not used. This allows us to use %o1 as a scratch to
+	 * keep value of %g4 in and prevents caller to keep something in %o1.
+	 */
+	ENTRY(dtrace_caller)
+	mov	%g4, %o1
+	mov	nwin_minus_one, %g4
+	rdpr	%canrestore, %g2
+	cmp	%g2, %o0
+	bl	%icc, 1f
+	rdpr	%cwp, %g1
+	sub	%g1, %o0, %g3
+	brgez,a,pt %g3, 0f
+	wrpr	%g3, %cwp
+	/*
+	 * CWP minus the number of frames is negative; we must perform the
+	 * arithmetic modulo MAXWIN.
+	 */
+	add	%g4, %g3, %g3
+	inc	%g3
+	wrpr	%g3, %cwp
+0:
+	mov	%i7, %g4
+	wrpr	%g1, %cwp
+	mov	%g4, %o0
+	retl
+	mov	%o1, %g4
+1:
+	/*
+	 * The caller has been flushed to the stack.  This is unlikely
+         * (interrupts are disabled in dtrace_probe()), but possible (the
+         * interrupt inducing the spill may have been taken before the
+         * call to dtrace_probe()).
+	 */
+	mov	%o1, %g4
+	retl
+	mov	-1, %o0
+	ENDPROC(dtrace_caller)
+
+	ENTRY(dtrace_copyin_arch)
+	tst	%o2
+	bz	2f
+	clr	%g1
+	lduba	[%o0 + %g1]ASI_USER, %g2
+0:
+	! check for an error if the count is 4k-aligned
+	andcc	%g1, 0xfff, %g0
+	bnz,pt	%icc, 1f
+	stub	%g2, [%o1 + %g1]
+	lduh	[%o3], %g3
+	andcc	%g3, CPU_DTRACE_BADADDR, %g0
+	bnz,pn	%icc, 2f
+	nop
+1:
+	inc	%g1
+	cmp	%g1, %o2
+	bl,a	0b
+	lduba	[%o0 + %g1]ASI_USER, %g2
+2:
+	retl
+	nop
+	ENDPROC(dtrace_copyin_arch)
+
+	ENTRY(dtrace_copyinstr_arch)
+	tst	%o2
+	bz	2f
+	clr	%g1
+	lduba	[%o0 + %g1]ASI_USER, %g2
+0:
+	stub	%g2, [%o1 + %g1]
+	! check for an error if the count is 4k-aligned
+	andcc	%g1, 0xfff, %g0
+	bnz,pt	%icc, 1f
+	inc	%g1
+	lduh	[%o3], %g3
+	andcc	%g3, CPU_DTRACE_BADADDR, %g0
+	bnz,pn	%icc, 2f
+	nop
+1:
+	cmp	%g2, 0
+	be	2f
+	cmp	%g1, %o2
+	bl,a	0b
+	lduba	[%o0 + %g1]ASI_USER, %g2
+2:
+	retl
+	nop
+	ENDPROC(dtrace_copyinstr_arch)
+
+	ENTRY(dtrace_copyout)
+	tst	%o2
+	bz	2f
+	clr	%g1
+	ldub	[%o0 + %g1], %g2
+0:
+	! check for an error if the count is 4k-aligned
+	andcc	%g1, 0xfff, %g0
+	bnz,pt	%icc, 1f
+	stuba	%g2, [%o1 + %g1]ASI_USER
+	lduh	[%o3], %g3
+	andcc	%g3, CPU_DTRACE_BADADDR, %g0
+	bnz,pn	%icc, 2f
+	nop
+1:
+	inc	%g1
+	cmp	%g1, %o2
+	bl,a	0b
+	ldub	[%o0 + %g1], %g2
+2:
+	retl
+	nop
+	ENDPROC(dtrace_copyout)
+
+	ENTRY(dtrace_copyoutstr)
+	tst	%o2
+	bz	2f
+	clr	%g1
+	ldub	[%o0 + %g1], %g2
+0:
+	stuba	%g2, [%o1 + %g1]ASI_USER
+	! check for an error if the count is 4k-aligned
+	andcc	%g1, 0xfff, %g0
+	bnz,pt	%icc, 1f
+	inc	%g1
+	lduh	[%o3], %g3
+	andcc	%g3, CPU_DTRACE_BADADDR, %g0
+	bnz,pn	%icc, 2f
+	nop
+1:
+	cmp	%g2, 0
+	be	2f
+	cmp	%g1, %o2
+	bl,a	0b
+	ldub	[%o0 + %g1], %g2
+2:
+	retl
+	nop
+	ENDPROC(dtrace_copyoutstr)
+
+	ENTRY(dtrace_fulword)
+	clr	%o1
+	ldna	[%o0]ASI_USER, %o1
+	retl
+	mov	%o1, %o0
+	ENDPROC(dtrace_fulword)
+
+	ENTRY(dtrace_fuword8)
+	clr	%o1
+	lduba	[%o0]ASI_AIUS, %o1
+	retl
+	mov	%o1, %o0
+	ENDPROC(dtrace_fuword8)
+
+	ENTRY(dtrace_fuword16)
+	clr	%o1
+	lduha	[%o0]ASI_AIUS, %o1
+	retl
+	mov	%o1, %o0
+	ENDPROC(dtrace_fuword16)
+
+	ENTRY(dtrace_fuword32)
+	clr	%o1
+	lda	[%o0]ASI_AIUS, %o1
+	retl
+	mov	%o1, %o0
+	ENDPROC(dtrace_fuword32)
+
+	ENTRY(dtrace_fuword64)
+	clr	%o1
+	ldxa	[%o0]ASI_AIUS, %o1
+	retl
+	mov	%o1, %o0
+	ENDPROC(dtrace_fuword64)
+
+	ENTRY(dtrace_probe_error)
+	save	%sp, -192, %sp
+	sethi	%hi(dtrace_probeid_error), %l0
+	ld	[%l0 + %lo(dtrace_probeid_error)], %o0
+	mov	%i0, %o1
+	mov	%i1, %o2
+	mov	%i2, %o3
+	mov	%i3, %o4
+	call	dtrace_probe
+	mov	%i4, %o5
+	ret
+	restore
+	ENDPROC(dtrace_probe_error)
diff --git a/arch/sparc/dtrace/dtrace_isa_sparc64.c b/arch/sparc/dtrace/dtrace_isa_sparc64.c
new file mode 100644
index 000000000000..58a89258d5f0
--- /dev/null
+++ b/arch/sparc/dtrace/dtrace_isa_sparc64.c
@@ -0,0 +1,146 @@
+/*
+ * FILE:	dtrace_isa_sparc64.c
+ * DESCRIPTION:	DTrace - sparc64 architecture specific support functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/uaccess.h>
+#include <asm/cacheflush.h>
+#include <asm/stacktrace.h>
+
+#include "dtrace.h"
+#include "dtrace/isa_arch.h"
+
+uint64_t dtrace_getarg(int argno, int aframes)
+{
+	struct sparc_v9_frame	*fp;
+	uint64_t		rval;
+
+	/*
+	 * Account for the fact that dtrace_getarg() consumes an additional
+	 * stack frame.
+	 */
+	aframes++;
+
+#ifdef FIXME
+	if (argno < 6) {
+		if ((lvl = dtrace_fish(aframes, ASM_REG_I0 + argno, &val)) == 0)
+			return val;
+	} else {
+		if ((lvl = dtrace_fish(aframes, ASM_REG_I6, &val)) == 0) {
+			/*
+			 * We have a stack pointer; grab the argument.
+			 */
+			fp = (struct sparc_v9_frame *)(val + STACK_BIAS);
+
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			rval = fp->ins[argno - 6];
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+			return rval;
+		}
+	}
+#endif
+	/*
+	 * This is the slow way to get to function arguments.  We force a full
+	 * register windows flush, and then walk the chain of frames until we
+	 * get to the one we need.  The flush is expensive, so we should try to
+	 * avoid this whenever possible.
+	 */
+	fp = (struct sparc_v9_frame *)((uintptr_t)dtrace_getfp() + STACK_BIAS);
+	flushw_all();
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+
+	for (aframes -= 1; aframes; aframes--)
+		fp = (struct sparc_v9_frame *)((uintptr_t)fp->fp + STACK_BIAS);
+
+	if (argno < 6) {
+		rval = fp->ins[argno];
+	} else {
+		fp = (struct sparc_v9_frame *)((uintptr_t)fp->fp + STACK_BIAS);
+		rval = fp->xxargs[argno - 6];
+	}
+
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return rval;
+}
+
+ulong_t dtrace_getreg(struct task_struct *task, uint_t reg)
+{
+	struct pt_regs	*rp = task_pt_regs(task);
+
+	if (reg <= ASM_REG_O7)			/* G[0-7], O[0-7] */
+		return rp->u_regs[reg];		/* 0 .. 15 */
+
+	if (reg <= ASM_REG_I7) {		/* L[0-7], I[0-7] */
+		if (rp->tstate & TSTATE_PRIV) {
+			struct reg_window	*rw;
+
+			rw = (struct reg_window *)(rp->u_regs[14] + STACK_BIAS);
+
+			if (reg <= ASM_REG_L7)
+				return rw->locals[reg - ASM_REG_L0];
+			else
+				return rw->ins[reg - ASM_REG_I0];
+		} else {
+			mm_segment_t			old_fs;
+			struct reg_window __user	*rw;
+			ulong_t				val;
+
+			rw = (struct reg_window __user *)
+				(rp->u_regs[14] + STACK_BIAS);
+
+			old_fs = get_fs();
+			set_fs(USER_DS);
+
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+
+			if (reg <= ASM_REG_L7)
+				val = dtrace_fulword(
+					&rw->locals[reg - ASM_REG_L0]
+				      );
+			else
+				val = dtrace_fulword(
+					&rw->locals[reg - ASM_REG_I0]
+				      );
+
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+			set_fs(old_fs);
+
+			return val;
+		}
+	}
+
+	switch (reg) {
+	case REG_CCR:
+		return (rp->tstate & TSTATE_CCR) >> TSTATE_CCR_SHIFT;
+	case REG_PC:
+		return rp->tpc;
+	case REG_nPC:
+		return rp->tnpc;
+	case REG_Y:
+		return rp->y;
+	case REG_ASI:
+		return (rp->tstate & TSTATE_ASI) >> TSTATE_ASI_SHIFT;
+	case REG_FPRS:
+		return 0; /* FIXME */
+	default:
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return 0;
+	}
+}
diff --git a/arch/sparc/dtrace/fasttrap_sparc64.c b/arch/sparc/dtrace/fasttrap_sparc64.c
new file mode 100644
index 000000000000..a8e79cb3f997
--- /dev/null
+++ b/arch/sparc/dtrace/fasttrap_sparc64.c
@@ -0,0 +1,111 @@
+/*
+ * FILE:	fasttrap_sparc64.c
+ * DESCRIPTION:	DTrace - fasttrap provider implementation for sparc64
+ *
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/uaccess.h>
+#include <asm/cacheflush.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fasttrap_impl.h"
+#include "dtrace/isa_arch.h"
+
+static uint64_t getarg_arch(struct pt_regs *r, int argno)
+{
+	struct pt_regs			*regs = r;
+	uint64_t			rval;
+
+	if (regs == NULL) {
+		regs = this_cpu_core->cpu_dtrace_regs;
+		if (regs == NULL)
+			return 0;
+	}
+
+	if (argno < 6)
+		return regs->u_regs[UREG_I0 + argno];
+
+	ASSERT(argno > 5);
+
+	/*
+	 * This is the slow way to get to function arguments.  We force a full
+	 * user register windows flush, and then walk the chain of frames until
+	 * we get to the one we need.  The flush is expensive, so we should try
+	 * to avoid this whenever possible.
+	 */
+
+	flushw_user();
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	if (test_thread_flag(TIF_32BIT)) {
+		/* XXX not implemented */
+		return 0; /* ugh */
+	} else {
+		/*
+		 * This relies on argno > 5, since we are plucking data directly
+		 * from the xxargs overflow area.
+		 */
+		__copy_from_user_inatomic_nocache(
+			&rval, (void * __user) regs->u_regs[UREG_I6] + STACK_BIAS,
+			sizeof(struct sparc_v9_frame) -
+			(sizeof (unsigned long) +
+			 (sizeof (unsigned long) * (argno - 6))));
+		/* XXX should we be ignoring aframes here? */
+	}
+
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return rval;
+}
+
+uint64_t fasttrap_usdt_getarg(void *arg, dtrace_id_t id, void *parg,
+			      int argno, int aframes)
+{
+	return getarg_arch(NULL, argno);
+}
+
+static void fasttrap_map_args(fasttrap_probe_t *probe, struct pt_regs *regs,
+			      int argc, uintptr_t *argv)
+{
+	int		i, x, cap = min(argc, (int)probe->ftp_nargs);
+	for (i = 0; i < cap; i++) {
+		x = probe->ftp_argmap[i];
+		argv[i] = getarg_arch(regs, x);
+	}
+
+	while (i < argc)
+		argv[i++] = 0;
+}
+
+void fasttrap_pid_probe_arch(fasttrap_probe_t *ftp, struct pt_regs *regs)
+{
+	if (ftp->ftp_argmap == NULL)
+		dtrace_probe(ftp->ftp_id, regs->u_regs[UREG_I0],
+			     regs->u_regs[UREG_I1], regs->u_regs[UREG_I2],
+			     regs->u_regs[UREG_I3], regs->u_regs[UREG_I4]);
+	else {
+		uintptr_t	t[5];
+
+		fasttrap_map_args(ftp, regs, sizeof(t) / sizeof(t[0]), t);
+		dtrace_probe(ftp->ftp_id, t[0], t[1], t[2], t[3],
+			     t[4]);
+	}
+}
+
+void fasttrap_set_enabled(struct pt_regs *regs)
+{
+	regs->u_regs[ASM_REG_O0] = 1;
+}
+
diff --git a/arch/sparc/dtrace/fbt_sparc64.c b/arch/sparc/dtrace/fbt_sparc64.c
new file mode 100644
index 000000000000..1bc522138c4d
--- /dev/null
+++ b/arch/sparc/dtrace/fbt_sparc64.c
@@ -0,0 +1,459 @@
+/*
+ * FILE:	fbt_sparc64.c
+ * DESCRIPTION:	DTrace - FBT provider implementation for sparc64
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/dtrace_fbt.h>
+#include <asm/cacheflush.h>
+#include <asm/dtrace_util.h>
+#include <dtrace/isa_arch.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fbt_impl.h"
+
+/*
+ * For entry probes, we generate the following trampoline (for id < 0xfff):
+ *
+ *	sethi	%hi(id), %o0
+ *	or	%o0, %lo(id), %o0
+ *	mov	%i0, %o1
+ *	mov	%i1, %o2
+ *	mov	%i2, %o3
+ *	mov	%i3, %o4
+ *	mov	%i4, %o5
+ *	call	dtrace_probe
+ *	 nop
+ *	sethi	%hi(instr), %o7
+ *	or	%o7, %lo(instr), %o7
+ *	retl
+ *	 nop
+ *
+ * otherwise we use:
+ *
+ *	or	%g0, id, %o0
+ *	mov	%i0, %o1
+ *	mov	%i1, %o2
+ *	mov	%i2, %o3
+ *	mov	%i3, %o4
+ *	mov	%i4, %o5
+ *	call	dtrace_probe
+ *	 nop
+ *	sethi	%hi(instr), %o7
+ *	or	%o7, %lo(instr), %o7
+ *	retl
+ *	 nop
+ */
+#define	FBT_TRAMP_SIZE	19
+
+
+static void add_entry_tramp(fbt_probe_t *fbp, int nargs)
+{
+	struct module	*mp = fbp->fbp_module;
+	dtrace_id_t	id = fbp->fbp_id;
+	size_t		idx = PDATA(mp)->fbt_probe_cnt;
+	asm_instr_t	*trampoline = &(PDATA(mp)->fbt_tab[idx *
+							   FBT_TRAMP_SIZE]);
+	asm_instr_t	*instr = trampoline;
+
+	if (id > (uint32_t)ASM_SIMM13_MAX) {
+		*instr++ = ASM_SETHI(id, ASM_REG_O0);
+		*instr++ = ASM_ORLO(ASM_REG_O0, id, ASM_REG_O0);
+	} else
+		*instr++ = ASM_ORSIMM13(ASM_REG_G0, id, ASM_REG_O0);
+
+	if (nargs >= 1)
+		*instr++ = ASM_MOV(ASM_REG_I0, ASM_REG_O1);
+	if (nargs >= 2)
+		*instr++ = ASM_MOV(ASM_REG_I1, ASM_REG_O2);
+	if (nargs >= 3)
+		*instr++ = ASM_MOV(ASM_REG_I2, ASM_REG_O3);
+	if (nargs >= 4)
+		*instr++ = ASM_MOV(ASM_REG_I3, ASM_REG_O4);
+	if (nargs >= 5)
+		*instr++ = ASM_MOV(ASM_REG_I4, ASM_REG_O5);
+
+	*instr = ASM_CALL(instr, dtrace_probe);
+        instr++;
+
+	*instr++ = ASM_NOP;
+
+	if ((uintptr_t)fbp->fbp_patchpoint > (uintptr_t)ASM_SIMM13_MAX) {
+		*instr++ = ASM_SETHI(
+				(uintptr_t)fbp->fbp_patchpoint, ASM_REG_O7
+			   );
+		*instr++ = ASM_ORLO(ASM_REG_O7, (uintptr_t)fbp->fbp_patchpoint,
+				    ASM_REG_O7);
+	} else
+		*instr++ = ASM_ORSIMM13(ASM_REG_G0,
+					(uintptr_t)fbp->fbp_patchpoint,
+                                        ASM_REG_O7);
+
+	*instr++ = ASM_RETL;
+	*instr++ = ASM_NOP;
+
+	fbp->fbp_patchval = ASM_CALL(fbp->fbp_patchpoint, trampoline);
+	fbp->fbp_savedval = *fbp->fbp_patchpoint;
+	fbp->fbp_isret = 0;
+}
+
+/*
+ * This function should always succeed as we have removed all problematic cases
+ * in advance.
+ */
+static void add_return_tramp(fbt_probe_t *fbp, int stype)
+{
+	struct module	*mp = fbp->fbp_module;
+	dtrace_id_t	id = fbp->fbp_id;
+	uint64_t	roffset = fbp->fbp_roffset;
+	size_t		idx = PDATA(mp)->fbt_probe_cnt;
+	asm_instr_t	*trampoline = &(PDATA(mp)->fbt_tab[idx *
+							   FBT_TRAMP_SIZE]);
+	asm_instr_t	*instr = trampoline;
+	asm_instr_t	instr_ret = *fbp->fbp_patchpoint;
+	asm_instr_t	instr_delay = *(fbp->fbp_patchpoint + 1);
+
+	uint32_t	locals[ASM_REG_NLOCALS];
+	uint32_t	local, tmpreg, saved_g1, saved_g2;
+
+	/*
+	 * The RETURN case is bit more complex compared to others. The RETURN
+	 * performs ret and restore at the same time. Thus the instruction in
+	 * delay slot operates on callers register window. In case there is
+	 * something else than NOP in the delay slot we have to do following:
+	 *
+	 *     1) RESTORE
+	 *     2) Execute Delay slot
+	 *     3) SAVE
+	 *     4) Handle probe
+	 *     5) Simulate return by pair of ret/restore
+	 */
+	if (ASM_FMT3_OP(instr_ret) == ASM_OP_RETURN) {
+		if (instr_delay != ASM_NOP) {
+			*instr++ = ASM_RESTORE(ASM_REG_G0, ASM_REG_G0, ASM_REG_G0);
+			*instr++ = instr_delay;
+			*instr++ = ASM_SAVEIMM(ASM_REG_O6, -ASM_MINFRAME, ASM_REG_O6);
+		}
+
+		/* This is safe as we support only return %i7 + 8. */
+		instr_ret = ASM_RET;
+		instr_delay = ASM_RESTORE(ASM_REG_G0, ASM_REG_G0, ASM_REG_G0);
+	}
+
+	/*
+	 * Now we need to remap arguments so we use safe location that is not
+	 * destroyed during call to dtrace_probe(). This is done in multiple steps:
+	 *
+	 *     1) Mark currently used locals
+	 *     2) Move non-locals to unused locals
+	 *     3) Update instruction to use locals only
+	 */
+	ASM_REG_INITLOCALS(local, locals);
+
+	/* Only JMPL needs extra care here. */
+	if (ASM_FMT3_OP(instr_ret) == ASM_OP_JMPL) {
+		ASM_REG_MARKLOCAL(locals, ASM_FMT3_RS1(instr_ret));
+		if (!ASM_FMT3_ISIMM(instr_ret)) {
+			ASM_REG_MARKLOCAL(locals, ASM_FMT3_RS2(instr_ret));
+		}
+	}
+
+	/* At this point isntr_delay can hold RESTORE only. */
+	ASM_REG_MARKLOCAL(locals, ASM_FMT3_RS1(instr_delay));
+	if (!ASM_FMT3_ISIMM(instr_delay)) {
+		ASM_REG_MARKLOCAL(locals, ASM_FMT3_RS2(instr_delay));
+	}
+
+	/* Remap */
+	if (ASM_FMT3_OP(instr_ret) == ASM_OP_JMPL) {
+		tmpreg = ASM_FMT3_RS1(instr_ret);
+
+		if (ASM_REG_ISVOLATILE(tmpreg)) {
+			ASM_REG_ALLOCLOCAL(local, locals);
+			*instr++ = ASM_MOV(tmpreg, local);
+			ASM_FMT3_RS1_SET(instr_ret, local);
+		}
+
+		if (!ASM_FMT3_ISIMM(instr_ret)) {
+			tmpreg = ASM_FMT3_RS2(instr_ret);
+
+			if (ASM_REG_ISVOLATILE(tmpreg)) {
+				ASM_REG_ALLOCLOCAL(local, locals);
+				*instr++ = ASM_MOV(tmpreg, local);
+				ASM_FMT3_RS2_SET(instr_ret, local);
+			}
+		}
+	}
+
+	tmpreg = ASM_FMT3_RS1(instr_delay);
+	if (ASM_REG_ISVOLATILE(tmpreg)) {
+		ASM_REG_ALLOCLOCAL(local, locals);
+		*instr++ = ASM_MOV(tmpreg, local);
+		ASM_FMT3_RS1_SET(instr_delay, local);
+	}
+
+	if (!ASM_FMT3_ISIMM(instr_delay)) {
+		tmpreg = ASM_FMT3_RS2(instr_delay);
+
+		if (ASM_REG_ISVOLATILE(tmpreg)) {
+			ASM_REG_ALLOCLOCAL(local, locals);
+			*instr++ = ASM_MOV(tmpreg, local);
+			ASM_FMT3_RS2_SET(instr_delay, local);
+		}
+	}
+
+	/* backup globals */
+	ASM_REG_ALLOCLOCAL(local, locals);
+	saved_g1 = local;
+	*instr++ = ASM_MOV(ASM_REG_G1, saved_g1);
+	ASM_REG_ALLOCLOCAL(local, locals);
+	saved_g2 = local;
+	*instr++ = ASM_MOV(ASM_REG_G2, saved_g2);
+
+	/* prepare arguments */
+	if (id > (uint32_t)ASM_SIMM13_MAX) {
+		*instr++ = ASM_SETHI(id, ASM_REG_O0);
+		*instr++ = ASM_ORLO(ASM_REG_O0, id, ASM_REG_O0);
+	} else {
+		*instr++ = ASM_ORSIMM13(ASM_REG_G0, id, ASM_REG_O0);
+	}
+
+	if (roffset > (uint32_t)ASM_SIMM13_MAX) {
+		*instr++ = ASM_SETHI(roffset, ASM_REG_O1);
+		*instr++ = ASM_ORLO(ASM_REG_O1, roffset, ASM_REG_O1);
+	} else {
+		*instr++ = ASM_ORSIMM13(ASM_REG_G0, roffset, ASM_REG_O1);
+	}
+
+	/* fire probe */
+	*instr = ASM_CALL(instr, dtrace_probe);
+	instr++;
+
+	/* recover return value */
+	if (ASM_FMT3_RD(instr_delay) == ASM_REG_O0) {
+		uint32_t instr_add = (instr_delay & ~ASM_FMT3_OP_MASK) |
+				     ASM_OP_ADD;
+		instr_add = (instr_add & ~ASM_FMT3_RD_MASK) |
+			    (ASM_REG_O2 << ASM_FMT3_RD_SHIFT);
+		*instr++ = instr_add;
+	} else {
+		*instr++ = ASM_MOV(ASM_REG_I0, ASM_REG_O2);
+	}
+
+	/* restore globals */
+	*instr++ = ASM_MOV(saved_g1, ASM_REG_G1);
+	*instr++ = ASM_MOV(saved_g2, ASM_REG_G2);
+
+	/*
+	 * Emit original instruction return pair. In case of call update it's
+	 * label to correct value.
+	 */
+	if (ASM_FMT1_OP(instr_ret) == ASM_OP_CALL) {
+		asm_instr_t *dest = fbp->fbp_patchpoint + ASM_FMT1_DISP30(instr_ret);
+		*instr = ASM_CALL(instr, dest);
+		instr++;
+	} else {
+		*instr++ = instr_ret;
+	}
+	*instr++ = instr_delay;
+
+	fbp->fbp_patchval = ASM_TA(0x75);
+	fbp->fbp_savedval = *fbp->fbp_patchpoint;
+	fbp->fbp_isret = 1;
+	fbp->fbp_trampdest = trampoline;
+}
+
+void fbt_provide_probe_arch(fbt_probe_t *fbp, int type, int stype)
+{
+	switch (type) {
+	case FBT_ENTRY:
+		add_entry_tramp(fbp, stype);
+		break;
+	case FBT_RETURN:
+		add_return_tramp(fbp, stype);
+		break;
+	default:
+		pr_info("%s: %s: Unknown FBT type %d\n",
+			__func__, fbp->fbp_name, type);
+		return;
+	}
+}
+
+/*
+ * We filetered out unsupported return probes (DCTIs, PC-relative instructions
+ * in the delay slot) in kernel. Rest of the logic is in the module to give us
+ * flexibility when we need to alter the logic later.
+ *
+ * At the moment we rely on the fact that every supported function has SAVE in
+ * its prologue. Thus there is no need to support RETL stuff. A call to probe
+ * may destroy globals and outs so they are not supported. It is in theory
+ * possible to support RETL but current mechanism of FBT guarantees it is going
+ * to destroy value in %o7 but that would need bigger changes to how we allocate
+ * trampolines.
+ *
+ * Possible return cases:
+ *
+ *   1) ret/restore
+ *   2) return/delay
+ *   3) call/restore
+ *
+ * The function assumes that it is safe to touch instruction at (addr + 1) to
+ * access delay slot.
+ */
+int fbt_can_patch_return_arch(asm_instr_t *addr)
+{
+	int	rd;
+
+	/* RETURN %i7, 8*/
+	if (ASM_FMT3_OP(*addr) == ASM_OP_RETURN &&
+	    *addr == ASM_RETURN(ASM_REG_I7, 8)) {
+		return 1;
+	}
+
+	/* RESTORE in delay */
+	if (ASM_FMT3_OP(*(addr + 1)) != ASM_OP_RESTORE)
+		return 0;
+
+	/* CALL */
+	if (ASM_FMT1_OP(*addr) == ASM_OP_CALL)
+		return 1;
+
+	/* JMPL %i7 + 8, %g0 */
+	if (ASM_FMT3_OP(*addr) != ASM_OP_JMPL)
+		return 0;
+
+	rd = ASM_FMT3_RD(*addr);
+	if (rd == ASM_REG_G0 || rd == ASM_REG_I7)
+		return 1;
+
+	/* unsupported */
+	return 0;
+}
+
+static void *fbt_count_probe(struct module *mp, char *func, int type,
+			     int stype, asm_instr_t *addr, uint64_t offset,
+			     void *pfbt, void *arg)
+{
+	static int dummy;
+	size_t *count = arg;
+
+	switch (type) {
+	case FBT_ENTRY:
+		(*count)++;
+		return NULL;
+	case FBT_RETURN:
+		if (!fbt_can_patch_return_arch(addr))
+			return pfbt;
+
+		(*count)++;
+		if (pfbt == NULL)
+			return &dummy;
+		return pfbt;
+	default:
+		printk(KERN_INFO "FBT: Invalid probe type %d (%d) for %s\n",
+		       type, stype, func);
+		return NULL;
+	}
+}
+
+int fbt_provide_module_arch(void *arg, struct module *mp)
+{
+	size_t probe_cnt = 0;
+
+	/* First estimate the size of trampoline we need */
+	dtrace_fbt_init((fbt_add_probe_fn)fbt_count_probe, mp, &probe_cnt);
+
+	if (probe_cnt > 0 && PDATA(mp)->fbt_tab == NULL) {
+		asm_instr_t *tramp = dtrace_alloc_text(mp, probe_cnt *
+						       FBT_TRAMP_SIZE *
+						       sizeof (asm_instr_t));
+
+		if (tramp == NULL) {
+			printk(KERN_INFO "FBT: can't allocate FBT trampoline"
+			       " for %s\n", mp->name);
+			return 0;
+		}
+
+		PDATA(mp)->fbt_tab = tramp;
+		return 1;
+	}
+
+	return 0;
+}
+
+void fbt_destroy_module(void *arg, struct module *mp)
+{
+	if (PDATA(mp)->fbt_tab != NULL) {
+		dtrace_free_text(PDATA(mp)->fbt_tab);
+		PDATA(mp)->fbt_tab = NULL;
+	}
+}
+
+void fbt_enable_arch(fbt_probe_t *fbp, dtrace_id_t id, void *arg)
+{
+	*fbp->fbp_patchpoint = fbp->fbp_patchval;
+	flushi(fbp->fbp_patchpoint);
+}
+
+void fbt_disable_arch(fbt_probe_t *fbp, dtrace_id_t id, void *arg)
+{
+	*fbp->fbp_patchpoint = fbp->fbp_savedval;
+	flushi(fbp->fbp_patchpoint);
+}
+
+static void fbt_handler(struct pt_regs *regs)
+{
+	fbt_probe_t	*fbp = fbt_probetab[FBT_ADDR2NDX(regs->tpc)];
+
+	for(; fbp != NULL; fbp = fbp->fbp_hashnext) {
+		if ((uintptr_t)fbp->fbp_patchpoint == regs->tpc) {
+			regs->tpc = (uintptr_t)fbp->fbp_trampdest;
+			regs->tnpc = regs->tpc + 4;
+
+			return;
+		}
+	}
+
+	/*
+	 * The only way that ends here is that we hit our trap in kernel mode.
+	 * The trap is not shared with anyone else so it means we have lost a
+	 * tracpoint somehow. We must die as there is no safe way how we could
+	 * restore original instruction stream.
+	 */
+	dtrace_panic(KERN_EMERG, "FBT trap without a probe at %p",
+		     regs->tpc);
+}
+
+int fbt_dev_init_arch(void)
+{
+	fbt_probetab_mask = fbt_probetab_size - 1;
+	fbt_probetab = dtrace_vzalloc_try(fbt_probetab_size *
+					  sizeof (fbt_probe_t *));
+
+	if (fbt_probetab == NULL)
+		return -ENOMEM;
+
+	return dtrace_fbt_set_handler(fbt_handler);
+}
+
+void fbt_dev_exit_arch(void)
+{
+	vfree(fbt_probetab);
+	fbt_probetab_mask = 0;
+	fbt_probetab_size = 0;
+
+	(void) dtrace_fbt_set_handler(NULL);
+}
diff --git a/arch/sparc/dtrace/include/dtrace/fasttrap_arch.h b/arch/sparc/dtrace/include/dtrace/fasttrap_arch.h
new file mode 100644
index 000000000000..eff3607afa2f
--- /dev/null
+++ b/arch/sparc/dtrace/include/dtrace/fasttrap_arch.h
@@ -0,0 +1,27 @@
+/*
+ * Dynamic Tracing for Linux - Fasttrap Implementation defines
+ *
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _SPARC64_FASTTRAP_ARCH_H
+#define _SPARC64_FASTTRAP_ARCH_H
+
+#define FASTTRAP_OFFSET_AFRAMES	0
+
+#endif /* _SPARC64_FASTTRAP_ARCH_H */
diff --git a/arch/sparc/dtrace/include/dtrace/fbt_arch.h b/arch/sparc/dtrace/include/dtrace/fbt_arch.h
new file mode 100644
index 000000000000..6cf668879f86
--- /dev/null
+++ b/arch/sparc/dtrace/include/dtrace/fbt_arch.h
@@ -0,0 +1,44 @@
+/*
+ * Dynamic Tracing for Linux - FBT Implementation defines
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _SPARC64_FBT_ARCH_H
+#define _SPARC64_FBT_ARCH_H
+
+#define FBT_AFRAMES	1
+
+typedef struct fbt_probe {
+        char			*fbp_name;	/* name of probe */
+        dtrace_id_t		fbp_id;		/* probe ID */
+        struct module		*fbp_module;	/* defining module */
+        int			fbp_loadcnt;	/* load count for module */
+        int			fbp_primary;	/* non-zero if primary mod */
+        asm_instr_t		*fbp_patchpoint;/* patch point */
+        asm_instr_t		fbp_patchval;	/* instruction to patch */
+        asm_instr_t		fbp_savedval;	/* saved instruction value */
+	uint64_t		fbp_roffset;	/* relative offset */
+        int			fbp_rval;
+        struct fbt_probe	*fbp_next;	/* next probe */
+        struct fbt_probe	*fbp_hashnext;	/* next on hash */
+	int			fbp_isret;
+	asm_instr_t		*fbp_trampdest;
+} fbt_probe_t;
+
+#endif /* _SPARC64_FBT_ARCH_H */
diff --git a/arch/sparc/dtrace/include/dtrace/isa_arch.h b/arch/sparc/dtrace/include/dtrace/isa_arch.h
new file mode 100644
index 000000000000..fc411373febc
--- /dev/null
+++ b/arch/sparc/dtrace/include/dtrace/isa_arch.h
@@ -0,0 +1,327 @@
+/*
+ * FILE:        isa_arch.c
+ * DESCRIPTION: DTrace - sparc64 ISA-specific definitions
+ *
+ * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SPARC64_ISA_ARCH_H
+#define _SPARC64_ISA_ARCH_H
+
+
+/* Register indices */
+#define ASM_REG_G0		0
+#define ASM_REG_G1		(ASM_REG_G0 + 1)
+#define ASM_REG_G2		(ASM_REG_G0 + 2)
+#define ASM_REG_G3		(ASM_REG_G0 + 3)
+#define ASM_REG_G4		(ASM_REG_G0 + 4)
+#define ASM_REG_G5		(ASM_REG_G0 + 5)
+#define ASM_REG_G6		(ASM_REG_G0 + 6)
+#define ASM_REG_G7		(ASM_REG_G0 + 7)
+
+#define ASM_REG_O0		(ASM_REG_G7 + 1)	/* 8 */
+#define ASM_REG_O1		(ASM_REG_O0 + 1)
+#define ASM_REG_O2		(ASM_REG_O0 + 2)
+#define ASM_REG_O3		(ASM_REG_O0 + 3)
+#define ASM_REG_O4		(ASM_REG_O0 + 4)
+#define ASM_REG_O5		(ASM_REG_O0 + 5)
+#define ASM_REG_O6		(ASM_REG_O0 + 6)
+#define ASM_REG_O7		(ASM_REG_O0 + 7)
+
+#define ASM_REG_L0		(ASM_REG_O7 + 1)	/* 16 */
+#define ASM_REG_L1		(ASM_REG_L0 + 1)
+#define ASM_REG_L2		(ASM_REG_L0 + 2)
+#define ASM_REG_L3		(ASM_REG_L0 + 3)
+#define ASM_REG_L4		(ASM_REG_L0 + 4)
+#define ASM_REG_L5		(ASM_REG_L0 + 5)
+#define ASM_REG_L6		(ASM_REG_L0 + 6)
+#define ASM_REG_L7		(ASM_REG_L0 + 7)
+
+#define ASM_REG_I0		(ASM_REG_L7 + 1)	/* 24 */
+#define ASM_REG_I1		(ASM_REG_I0 + 1)
+#define ASM_REG_I2		(ASM_REG_I0 + 2)
+#define ASM_REG_I3		(ASM_REG_I0 + 3)
+#define ASM_REG_I4		(ASM_REG_I0 + 4)
+#define ASM_REG_I5		(ASM_REG_I0 + 5)
+#define ASM_REG_I6		(ASM_REG_I0 + 6)
+#define ASM_REG_I7		(ASM_REG_I0 + 7)
+
+#define REG_CCR			(ASM_REG_I7 + 1)	/* 32 */
+#define REG_PC			(REG_CCR + 1)		/* 33 */
+#define REG_nPC			(REG_PC + 1)		/* 34 */
+#define REG_Y			(REG_nPC + 1)		/* 35 */
+#define REG_ASI			(REG_Y + 1)		/* 36 */
+#define REG_FPRS		(REG_ASI + 1)		/* 37 */
+
+#define ASM_REG_PC		5
+
+#define ASM_REG_ISGLOBAL(r)	((r) >= ASM_REG_G0 && (r) <= ASM_REG_G7)
+#define ASM_REG_ISOUTPUT(r)	((r) >= ASM_REG_O0 && (r) <= ASM_REG_O7)
+#define ASM_REG_ISLOCAL(r)	((r) >= ASM_REG_L0 && (r) <= ASM_REG_L7)
+#define ASM_REG_ISINPUT(r)	((r) >= ASM_REG_I0 && (r) <= ASM_REG_I7)
+#define ASM_REG_ISVOLATILE(r)						      \
+        ((ASM_REG_ISGLOBAL(r) || ASM_REG_ISOUTPUT(r)) && (r) != ASM_REG_G0)
+#define ASM_REG_NLOCALS		8
+
+#define ASM_REG_MARKLOCAL(locals, r)					      \
+	if (ASM_REG_ISLOCAL(r))						      \
+		(locals)[(r) - ASM_REG_L0] = 1;
+
+#define ASM_REG_INITLOCALS(local, locals)				      \
+	for ((local) = 0; (local) < ASM_REG_NLOCALS; (local)++)		      \
+		(locals)[(local)] = 0;					      \
+	(local) = ASM_REG_L0
+
+#define ASM_REG_ALLOCLOCAL(local, locals)				      \
+	while ((locals)[(local) - ASM_REG_L0])				      \
+		(local)++;						      \
+	(locals)[(local) - ASM_REG_L0] = 1;
+
+#define ASM_OP_MASK		0xc0000000
+#define ASM_OP_SHIFT		30
+#define ASM_OP(val)		((val) & ASM_OP_MASK)
+
+#define ASM_SIMM13_MASK		0x1fff
+#define ASM_SIMM13_MAX		((int32_t)0xfff)
+#define ASM_IMM22_MASK		0x3fffff
+#define ASM_IMM22_SHIFT		10
+#define ASM_IMM10_MASK		0x3ff
+
+#define ASM_DISP30_MASK		0x3fffffff
+#define ASM_DISP30(from, to)						      \
+	(((long)(to) - (long)(from)) >= 0				      \
+	  ? ((((uintptr_t)(to) - (uintptr_t)(from)) >> 2) & ASM_DISP30_MASK)  \
+	  : ((((long)(to) - (long)(from)) >> 2) & ASM_DISP30_MASK))
+
+#define ASM_DISP22_MASK		0x3fffff
+#define ASM_DISP22(from, to)						      \
+	((((uintptr_t)(to) - (uintptr_t)(from)) >> 2) & ASM_DISP22_MASK)
+
+#define ASM_DISP19_MASK		0x7ffff
+#define ASM_DISP19(from, to)						      \
+	((((uintptr_t)(to) - (uintptr_t)(from)) >> 2) & ASM_DISP19_MASK)
+
+#define ASM_DISP16_HISHIFT	20
+#define ASM_DISP16_HIMASK	(0x3 << ASM_DISP16_HISHIFT)
+#define ASM_DISP16_LOMASK	(0x3fff)
+#define ASM_DISP16_MASK		(ASM_DISP16_HIMASK | ASM_DISP16_LOMASK)
+#define ASM_DISP16(val)							      \
+	((((val) & ASM_DISP16_HIMASK) >> 6) | ((val) & ASM_DISP16_LOMASK))
+
+#define ASM_DISP14_MASK		0x3fff
+#define ASM_DISP14(from, to)						      \
+	(((uintptr_t)(to) - (uintptr_t)(from) >> 2) & ASM_DISP14_MASK)
+
+#define ASM_OP0			(((uint32_t)0) << ASM_OP_SHIFT)
+#define ASM_OP1			(((uint32_t)1) << ASM_OP_SHIFT)
+#define ASM_OP2			(((uint32_t)2) << ASM_OP_SHIFT)
+#define ASM_ILLTRAP		0
+
+#define ASM_ANNUL_SHIFT		29
+#define ASM_ANNUL		(1 << ASM_ANNUL_SHIFT)
+
+#define ASM_FMT3_OP3_SHIFT	19
+#define ASM_FMT3_OP_MASK	0xc1f80000
+#define ASM_FMT3_OP(val)	((val) & ASM_FMT3_OP_MASK)
+
+#define	ASM_FMT3_OP_TCC		(0x3a << ASM_FMT3_OP3_SHIFT)
+
+#define ASM_FMT3_RD_SHIFT	25
+#define ASM_FMT3_RD_MASK	(0x1f << ASM_FMT3_RD_SHIFT)
+#define ASM_FMT3_RD(val)						      \
+	(((val) & ASM_FMT3_RD_MASK) >> ASM_FMT3_RD_SHIFT)
+
+#define ASM_FMT3_RS1_SHIFT	14
+#define ASM_FMT3_RS1_MASK	(0x1f << ASM_FMT3_RS1_SHIFT)
+#define ASM_FMT3_RS1(val)						      \
+	(((val) & ASM_FMT3_RS1_MASK) >> ASM_FMT3_RS1_SHIFT)
+#define ASM_FMT3_RS1_SET(val, rs1)					      \
+	(val) = ((val) & ~ASM_FMT3_RS1_MASK) | ((rs1) << ASM_FMT3_RS1_SHIFT)
+
+#define ASM_FMT3_RS2_SHIFT	0
+#define ASM_FMT3_RS2_MASK	(0x1f << ASM_FMT3_RS2_SHIFT)
+#define ASM_FMT3_RS2(val)						      \
+	(((val) & ASM_FMT3_RS2_MASK) >> ASM_FMT3_RS2_SHIFT)
+#define ASM_FMT3_RS2_SET(val, rs2)					      \
+	(val) = ((val) & ~ASM_FMT3_RS2_MASK) | ((rs2) << ASM_FMT3_RS2_SHIFT)
+
+#define ASM_FMT3_IMM_SHIFT	13
+#define ASM_FMT3_IMM		(1 << ASM_FMT3_IMM_SHIFT)
+#define ASM_FMT3_SIMM13_MASK	ASM_SIMM13_MASK
+
+#define ASM_FMT3_ISIMM(val)	((val) & ASM_FMT3_IMM)
+#define ASM_FMT3_SIMM13(val)	((val) & ASM_FMT3_SIMM13_MASK)
+
+#define ASM_FMT2_OP2_SHIFT	22
+#define ASM_FMT2_OP2_MASK	(0x7 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_RD_SHIFT	25
+
+#define ASM_FMT1_OP(val)	((val) & ASM_OP_MASK)
+#define ASM_FMT1_DISP30(val)	((val) & ASM_DISP30_MASK)
+
+#define ASM_FMT2_OP2_BPCC	(0x01 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_OP2_BCC	(0x02 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_OP2_BPR	(0x03 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_OP2_SETHI	(0x04 << ASM_FMT2_OP2_SHIFT)
+
+#define ASM_FMT2_COND_SHIFT	25
+#define ASM_FMT2_COND_BA	(0x8 << ASM_FMT2_COND_SHIFT)
+#define ASM_FMT2_COND_BL	(0x3 << ASM_FMT2_COND_SHIFT)
+#define ASM_FMT2_COND_BGE	(0xb << ASM_FMT2_COND_SHIFT)
+
+#define ASM_OP_RESTORE		(ASM_OP2 | (0x3d << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_SAVE		(ASM_OP2 | (0x3c << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_JMPL		(ASM_OP2 | (0x38 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_RETURN		(ASM_OP2 | (0x39 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_CALL		ASM_OP1
+#define ASM_OP_SETHI		(ASM_OP0 | ASM_FMT2_OP2_SETHI)
+#define ASM_OP_ADD		(ASM_OP2 | (0x00 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_OR		(ASM_OP2 | (0x02 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_SUB		(ASM_OP2 | (0x04 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_CC		(ASM_OP2 | (0x10 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_UDIV		(ASM_OP2 | (0x0e << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_BA		(ASM_OP0 | ASM_FMT2_OP2_BCC | ASM_FMT2_COND_BA)
+#define ASM_OP_BL		(ASM_OP0 | ASM_FMT2_OP2_BCC | ASM_FMT2_COND_BL)
+#define ASM_OP_BGE		(ASM_OP0 | ASM_FMT2_OP2_BCC | ASM_FMT2_COND_BGE)
+#define ASM_OP_BAPCC		(ASM_OP0 | ASM_FMT2_OP2_BPCC | ASM_FMT2_COND_BA)
+#define ASM_OP_RD		(ASM_OP2 | (0x28 << ASM_FMT3_OP3_SHIFT))
+#define	ASM_OP_TA		(ASM_OP2 | ASM_FMT3_OP_TCC | ASM_FMT2_COND_BA)
+
+#define ASM_ORLO(rs, val, rd)						      \
+	(ASM_OP_OR | ((rs) << ASM_FMT3_RS1_SHIFT) |			      \
+	 ((rd) << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM | ((val) & ASM_IMM10_MASK))
+
+#define ASM_ORSIMM13(rs, val, rd)					      \
+	(ASM_OP_OR | ((rs) << ASM_FMT3_RS1_SHIFT) |			      \
+	 ((rd) << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM |			      \
+	 ((val) & ASM_SIMM13_MASK))
+
+#define ASM_ADDSIMM13(rs, val, rd)					      \
+	(ASM_OP_ADD | ((rs) << ASM_FMT3_RS1_SHIFT) |			      \
+	 ((rd) << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM |			      \
+	 ((val) & ASM_SIMM13_MASK))
+
+#define ASM_UDIVSIMM13(rs, val, rd)					      \
+	(ASM_OP_UDIV | ((rs) << ASM_FMT3_RS1_SHIFT) |			      \
+	 ((rd) << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM |			      \
+	 ((val) & ASM_SIMM13_MASK))
+
+#define ASM_ADD(rs1, rs2, rd)						      \
+	(ASM_OP_ADD | ((rs1) << ASM_FMT3_RS1_SHIFT) |			      \
+	 ((rs2) << ASM_FMT3_RS2_SHIFT) | ((rd) << ASM_FMT3_RD_SHIFT))
+
+#define ASM_CMP(rs1, rs2)						      \
+	(ASM_OP_SUB | ASM_OP_CC | ((rs1) << ASM_FMT3_RS1_SHIFT) |	      \
+	 ((rs2) << ASM_FMT3_RS2_SHIFT) | (ASM_REG_G0 << ASM_FMT3_RD_SHIFT))
+
+#define ASM_MOV(rs, rd)							      \
+	(ASM_OP_OR | (ASM_REG_G0 << ASM_FMT3_RS1_SHIFT) |		      \
+	 ((rs) << ASM_FMT3_RS2_SHIFT) | ((rd) << ASM_FMT3_RD_SHIFT))
+
+#define ASM_SETHI(val, reg)						      \
+	(ASM_OP_SETHI | (reg << ASM_FMT2_RD_SHIFT) |			      \
+	 ((val >> ASM_IMM22_SHIFT) & ASM_IMM22_MASK))
+
+#define ASM_NOP			ASM_SETHI(0, 0)
+
+#define ASM_CALL(orig, dest)	(ASM_OP_CALL | ASM_DISP30(orig, dest))
+
+#define	ASM_TA(lvl)	(ASM_OP_TA | ASM_FMT3_IMM | ((lvl) & 0xff))
+
+#define ASM_RET								      \
+	(ASM_OP_JMPL | (ASM_REG_I7 << ASM_FMT3_RS1_SHIFT) |		      \
+	 (ASM_REG_G0 << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM |		      \
+	 (sizeof (asm_instr_t) << 1))
+
+#define ASM_RETL							      \
+	(ASM_OP_JMPL | (ASM_REG_O7 << ASM_FMT3_RS1_SHIFT) |		      \
+	 (ASM_REG_G0 << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM |		      \
+	 (sizeof (asm_instr_t) << 1))
+
+#define	ASM_MINFRAME	(22 * 8)
+#define ASM_SAVEIMM(rd, val, rs1)					      \
+	(ASM_OP_SAVE | ((rs1) << ASM_FMT3_RS1_SHIFT) |			      \
+	 ((rd) << ASM_FMT3_RD_SHIFT) | ASM_FMT3_IMM | ((val) & ASM_SIMM13_MASK))
+
+#define ASM_RESTORE(rd, rs1, rs2)					      \
+	(ASM_OP_RESTORE | ((rs1) << ASM_FMT3_RS1_SHIFT) |		      \
+	 ((rd) << ASM_FMT3_RD_SHIFT) | ((rs2) << ASM_FMT3_RS2_SHIFT))
+
+#define ASM_RETURN(rs1, val)						      \
+	(ASM_OP_RETURN | ((rs1) << ASM_FMT3_RS1_SHIFT) |		      \
+	 ASM_FMT3_IMM | ((val) & ASM_SIMM13_MASK))
+
+#define ASM_BA(orig, dest)	(ASM_OP_BA | ASM_DISP22(orig, dest))
+#define ASM_BAA(orig, dest)	(ASM_BA(orig, dest) | ASM_ANNUL)
+#define ASM_BL(orig, dest)	(ASM_OP_BL | ASM_DISP22(orig, dest))
+#define ASM_BGE(orig, dest)	(ASM_OP_BGE | ASM_DISP22(orig, dest))
+#define ASM_BDEST(va, instr)	((uintptr_t)(va) +			      \
+	(((int32_t)(((instr) & ASM_DISP22_MASK) << 10)) >> 8))
+#define ASM_BPCCDEST(va, instr)	((uintptr_t)(va) +			      \
+	(((int32_t)(((instr) & ASM_DISP19_MASK) << 13)) >> 11))
+#define ASM_BPRDEST(va, instr)	((uintptr_t)(va) +			      \
+	(((int32_t)((ASM_DISP16(instr)) << 16)) >> 14))
+
+/*
+ * We're only going to treat a save as safe if
+ *   (a) both rs1 and rd are %sp and
+ *   (b) if the instruction has a simm, the value isn't 0.
+ */
+#define ASM_IS_SAVE(instr)						      \
+	(ASM_FMT3_OP(instr) == ASM_OP_SAVE &&				      \
+	 ASM_FMT3_RD(instr) == ASM_REG_O6 &&				      \
+	 ASM_FMT3_RS1(instr) == ASM_REG_O6 &&				      \
+	 !(ASM_FMT3_ISIMM(instr) && ASM_FMT3_SIMM13(instr) == 0))
+
+#define ASM_IS_BA(instr)	(((instr) & ~ASM_DISP22_MASK) == ASM_OP_BA)
+#define ASM_IS_BAPCC(instr)	(((instr) & ~ASM_DISP22_MASK) == ASM_OP_BAPCC)
+
+#define ASM_IS_RDPC(instr)	((ASM_FMT3_OP(instr) == ASM_OP_RD) &&	      \
+				 (ASM_FMT3_RD(instr) == ASM_REG_PC))
+
+#define ASM_IS_PCRELATIVE(instr)					      \
+        ((((instr) & ASM_OP_MASK) == ASM_OP0 &&				      \
+	  ((instr) & ASM_FMT2_OP2_MASK) != ASM_FMT2_OP2_SETHI) ||	      \
+	 ((instr) & ASM_OP_MASK) == ASM_OP1 ||				      \
+	 ASM_IS_RDPC(instr))
+
+#define ASM_IS_CTI(instr)						      \
+	((((instr) & ASM_OP_MASK) == ASM_OP0 &&				      \
+	  ((instr) & ASM_FMT2_OP2_MASK) != ASM_FMT2_OP2_SETHI) ||	      \
+	 ((instr) & ASM_OP_MASK) == ASM_OP1 ||				      \
+	 (ASM_FMT3_OP(instr) == ASM_OP_JMPL) ||				      \
+	 (ASM_FMT3_OP(instr) == ASM_OP_RETURN))
+
+#define ASM_IS_NOP(instr)	((instr) == ASM_NOP)
+
+#define ASM_IS_CALL(instr)	(((instr) & ASM_OP_MASK) == ASM_OP_CALL)
+
+#define ASM_MOD_INPUTS(instr)	(ASM_OP(instr) == ASM_OP2 &&		      \
+				 ASM_REG_ISINPUT(ASM_FMT3_RD(instr)))
+#define ASM_MOD_OUTPUTS(instr)	(ASM_OP(instr) == ASM_OP2 &&		      \
+				 ASM_REG_ISOUTPUT(ASM_FMT3_RD(instr)))
+
+/*
+ * Our own personal SPARC V9 stack layout structure, because the one in
+ * <kernel-source-tree>/arch/sparc/include/uapi/asm/ptrace.h is wrong.
+ */
+struct sparc_v9_frame {
+	unsigned long locals[8];
+	unsigned long ins[6];
+	struct sparc_v9_frame *fp;
+	unsigned long callers_pc;
+	unsigned long xargs[6];
+	unsigned long xxargs[1];
+};
+
+#endif /* _SPARC64_ISA_ARCH_H */
diff --git a/arch/sparc/dtrace/include/dtrace/sdt_arch.h b/arch/sparc/dtrace/include/dtrace/sdt_arch.h
new file mode 100644
index 000000000000..da9571534610
--- /dev/null
+++ b/arch/sparc/dtrace/include/dtrace/sdt_arch.h
@@ -0,0 +1,27 @@
+/*
+ * Dynamic Tracing for Linux - SDT Implementation defines
+ *
+ * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _SPARC64_SDT_ARCH_H
+#define _SPARC64_SDT_ARCH_H
+
+#define SDT_AFRAMES	1
+
+#endif /* _SPARC64_SDT_ARCH_H */
diff --git a/arch/sparc/dtrace/sdt_sparc64.c b/arch/sparc/dtrace/sdt_sparc64.c
new file mode 100644
index 000000000000..5578965c5fa1
--- /dev/null
+++ b/arch/sparc/dtrace/sdt_sparc64.c
@@ -0,0 +1,202 @@
+/*
+ * FILE:	sdt_sparc64.c
+ * DESCRIPTION:	DTrace - SDT provider implementation for sparc64
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/sdt.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <asm/cacheflush.h>
+#include <asm/pgtable.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "sdt_impl.h"
+
+/*
+ * The trampoline follows the instruction sequence (if sdp_id > 0xfff):
+ *	save
+ *	sethi	%hi(sdp->sdp_id), %o0
+ *	or	%o0, %lo(sdp->sdp_id), %o0
+ *	mov	%i0, %o1
+ *	mov	%i1, %o2
+ *	mov	%i2, %o3
+ *	mov	%i3, %o4
+ *	call	dtrace_probe
+ *	 mov	%i4, %o5
+ *	ret
+ *	 restore
+ *
+ * otherwise it follows:
+ *	save
+ *	or	%g0, sdp->sdp_id, %o0
+ *	mov	%i0, %o1
+ *	mov	%i1, %o2
+ *	mov	%i2, %o3
+ *	mov	%i3, %o4
+ *	call	dtrace_probe
+ *	 mov	%i4, %o5
+ *	ret
+ *	 restore
+ *
+ * For is-enabled probes, we just drop an "or %g0, 1, %o0"
+ * directly into the delay slot.
+ */
+#define	SDT_TRAMP_SIZE	11
+
+#define SA(x)			((long)ALIGN((x), 4))
+#define MINFRAME		STACKFRAME_SZ
+
+#define	SDT_REG_G0		0
+#define	SDT_REG_O0		8
+#define	SDT_REG_O1		(SDT_REG_O0 + 1)
+#define	SDT_REG_O2		(SDT_REG_O1 + 1)
+#define	SDT_REG_O3		(SDT_REG_O2 + 1)
+#define	SDT_REG_O4		(SDT_REG_O3 + 1)
+#define	SDT_REG_O5		(SDT_REG_O4 + 1)
+#define	SDT_REG_I0		24
+#define	SDT_REG_I1		(SDT_REG_I0 + 1)
+#define	SDT_REG_I2		(SDT_REG_I1 + 1)
+#define	SDT_REG_I3		(SDT_REG_I2 + 1)
+#define	SDT_REG_I4		(SDT_REG_I3 + 1)
+#define	SDT_REG_I5		(SDT_REG_I4 + 1)
+
+#define SDT_OP_SETHI		0x1000000
+#define SDT_OP_OR		0x80100000
+
+#define SDT_FMT2_RD_SHIFT	25
+#define SDT_IMM22_SHIFT		10
+#define SDT_IMM22_MASK		0x3fffff
+#define SDT_IMM10_MASK		0x3ff
+
+#define SDT_FMT3_RD_SHIFT	25
+#define SDT_FMT3_RS1_SHIFT	14
+#define SDT_FMT3_RS2_SHIFT	0
+#define SDT_FMT3_IMM		(1 << 13)
+
+#define	SDT_SIMM13_MASK		0x1fff
+#define SDT_SIMM13_MAX		((int32_t)0xfff)
+
+#define	SDT_SAVE		(0x9de3a000 | \
+				 ((-SA(MINFRAME)) & SDT_SIMM13_MASK))
+#define SDT_SETHI(v, rd)	(SDT_OP_SETHI | (rd << SDT_FMT2_RD_SHIFT) | \
+				 ((v >> SDT_IMM22_SHIFT) & SDT_IMM22_MASK))
+#define	SDT_ORLO(rs, v, rd)	(SDT_OP_OR | ((rs) << SDT_FMT3_RS1_SHIFT) | \
+				 ((rd) << SDT_FMT3_RD_SHIFT) | SDT_FMT3_IMM | \
+				 ((v) & SDT_IMM10_MASK))
+#define	SDT_ORSIMM13(rs, v, rd)	(SDT_OP_OR | ((rs) << SDT_FMT3_RS1_SHIFT) | \
+				 ((rd) << SDT_FMT3_RD_SHIFT) | SDT_FMT3_IMM | \
+				 ((v) & SDT_SIMM13_MASK))
+#define	SDT_MOV(rs, rd)		(SDT_OP_OR | \
+				 (SDT_REG_G0 << SDT_FMT3_RS1_SHIFT) | \
+				 ((rs) << SDT_FMT3_RS2_SHIFT) | \
+				 ((rd) << SDT_FMT3_RD_SHIFT))
+#define SDT_CALL(s, d)		(((uint32_t)1 << 30) | \
+				 ((((uintptr_t)(d) - (uintptr_t)(s)) >> 2) & \
+				  0x3fffffff))
+#define	SDT_RET			0x81c7e008
+#define	SDT_RESTORE		0x81e80000
+
+void sdt_provide_probe_arch(sdt_probe_t *sdp, struct module *mp, int idx)
+{
+	asm_instr_t	*trampoline = &(PDATA(mp)->sdt_tab[idx *
+							   SDT_TRAMP_SIZE]);
+	asm_instr_t	*instr = trampoline;
+
+	if (sdp->sdp_ptype == SDTPT_OFFSETS) {
+		*instr++ = SDT_SAVE;
+
+		if (sdp->sdp_id > (uint32_t)SDT_SIMM13_MAX)  {
+			*instr++ = SDT_SETHI(sdp->sdp_id, SDT_REG_O0);
+			*instr++ = SDT_ORLO(SDT_REG_O0, sdp->sdp_id,
+					    SDT_REG_O0);
+		} else {
+			*instr++ = SDT_ORSIMM13(SDT_REG_G0, sdp->sdp_id,
+						SDT_REG_O0);
+		}
+
+		*instr++ = SDT_MOV(SDT_REG_I0, SDT_REG_O1);
+		*instr++ = SDT_MOV(SDT_REG_I1, SDT_REG_O2);
+		*instr++ = SDT_MOV(SDT_REG_I2, SDT_REG_O3);
+		*instr++ = SDT_MOV(SDT_REG_I3, SDT_REG_O4);
+		*instr = SDT_CALL(instr, dtrace_probe);
+		instr++;
+		*instr++ = SDT_MOV(SDT_REG_I4, SDT_REG_O5);
+
+		*instr++ = SDT_RET;
+		*instr++ = SDT_RESTORE;
+
+		sdp->sdp_patchval = SDT_CALL(sdp->sdp_patchpoint, trampoline);
+	} else {				/* SDTPT_IS_ENABLED */
+		/*
+		 * We want to change the insn in the delay slot,
+		 * which will be the arg setup.  There is no
+		 * trampoline.
+		 */
+		sdp->sdp_patchpoint++; /* next insn */
+		sdp->sdp_patchval = SDT_ORSIMM13(SDT_REG_G0, 1, SDT_REG_O0);
+	}
+
+	sdp->sdp_savedval = *sdp->sdp_patchpoint;
+}
+
+/*
+ * Allocates SDT trampoline that is executable.
+ */
+int sdt_provide_module_arch(void *arg, struct module *mp)
+{
+	if (mp->sdt_probec > 0 && PDATA(mp)->sdt_tab == NULL) {
+		asm_instr_t *tramp = dtrace_alloc_text(mp, mp->sdt_probec *
+						       SDT_TRAMP_SIZE *
+						       sizeof (asm_instr_t));
+
+		if (tramp == NULL)
+			return 0;
+
+		PDATA(mp)->sdt_tab = tramp;
+	}
+
+	return 1;
+}
+
+void sdt_destroy_module(void *arg, struct module *mp)
+{
+	if (PDATA(mp)->sdt_tab != NULL) {
+		dtrace_free_text(PDATA(mp)->sdt_tab);
+		PDATA(mp)->sdt_tab = NULL;
+	}
+}
+
+void sdt_enable_arch(sdt_probe_t *sdp, dtrace_id_t id, void *arg)
+{
+	*sdp->sdp_patchpoint = sdp->sdp_patchval;
+	flushi(sdp->sdp_patchpoint);
+}
+
+void sdt_disable_arch(sdt_probe_t *sdp, dtrace_id_t id, void *arg)
+{
+	*sdp->sdp_patchpoint = sdp->sdp_savedval;
+	flushi(sdp->sdp_patchpoint);
+}
+
+int sdt_dev_init_arch(void)
+{
+	return 0;
+}
+
+void sdt_dev_exit_arch(void)
+{
+}
diff --git a/arch/sparc/include/asm/dtrace_arch.h b/arch/sparc/include/asm/dtrace_arch.h
new file mode 100644
index 000000000000..eefb0dc0221c
--- /dev/null
+++ b/arch/sparc/include/asm/dtrace_arch.h
@@ -0,0 +1,34 @@
+/* Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved. */
+
+#ifndef _SPARC_DTRACE_ARCH_H
+#define _SPARC_DTRACE_ARCH_H
+
+#include <linux/module.h>
+
+/* Number of argumens stored inside the mstate. */
+#define	DTRACE_MSTATE_ARGS_MAX		6
+
+typedef uint32_t	asm_instr_t;
+
+asmlinkage void dtrace_fbt_trap(unsigned long, struct pt_regs *);
+
+typedef int (*prov_exit_f)(void);
+
+/*
+ * Structure to hold DTrace specific information about modules (including the
+ * core kernel module).  Note that each module (and the main kernel) already
+ * has three fields that relate to probing:
+ *	- sdt_probes: description of SDT probes in the module
+ *	- sdt_probec: number of SDT probes in the module
+ *	- pdata: pointer to a dtrace_module struct (for DTrace)
+ */
+typedef struct dtrace_module {
+	int             enabled_cnt;
+	size_t          sdt_probe_cnt;
+	asm_instr_t	*sdt_tab;
+	size_t          fbt_probe_cnt;
+	asm_instr_t	*fbt_tab;
+	prov_exit_f	prov_exit;
+} dtrace_module_t;
+
+#endif /* _SPARC_DTRACE_ARCH_H */
diff --git a/arch/sparc/include/asm/dtrace_cpuinfo.h b/arch/sparc/include/asm/dtrace_cpuinfo.h
new file mode 100644
index 000000000000..fdc2d0a11b6d
--- /dev/null
+++ b/arch/sparc/include/asm/dtrace_cpuinfo.h
@@ -0,0 +1,15 @@
+/* Copyright (C) 2013,2014 Oracle, Inc. */
+
+#ifndef _ASM_SPARC_DTRACE_CPUINFO_H_
+#define _ASM_SPARC_DTRACE_CPUINFO_H_
+
+#include <asm/cpudata.h>
+
+typedef cpuinfo_sparc		cpuinfo_arch_t;
+
+#define dtrace_cpuinfo_chip(ci)	((ci)->proc_id)
+
+#define TSTATE_CCR_SHIFT	32
+#define TSTATE_ASI_SHIFT	24
+
+#endif /* _ASM_SPARC_DTRACE_CPUINFO_H_ */
diff --git a/arch/sparc/include/asm/dtrace_sdt_arch.h b/arch/sparc/include/asm/dtrace_sdt_arch.h
new file mode 100644
index 000000000000..00267cda504f
--- /dev/null
+++ b/arch/sparc/include/asm/dtrace_sdt_arch.h
@@ -0,0 +1,9 @@
+/* Copyright (C) 2016 Oracle, Inc. */
+
+#ifndef _SPARC_DTRACE_SDT_ARCH_H
+#define _SPARC_DTRACE_SDT_ARCH_H
+
+#define __DTRACE_SDT_ISENABLED_PROTO long
+#define __DTRACE_SDT_ISENABLED_ARGS 0
+
+#endif /* _SPARC_DTRACE_SDT_ARCH_H */
diff --git a/arch/sparc/include/asm/dtrace_syscall.h b/arch/sparc/include/asm/dtrace_syscall.h
new file mode 100644
index 000000000000..4bdc51021147
--- /dev/null
+++ b/arch/sparc/include/asm/dtrace_syscall.h
@@ -0,0 +1,12 @@
+/* Copyright (C) 2011-2014 Oracle, Inc. */
+
+DTRACE_SYSCALL_STUB(EXECVE,		execve)
+DTRACE_SYSCALL_STUB(EXECVEAT,		execveat)
+DTRACE_SYSCALL_STUB(PIPE,		pipe)
+DTRACE_SYSCALL_STUB(MEMORY_ORDERING,	memory_ordering)
+DTRACE_SYSCALL_STUB(RT_SIGRETURN,	rt_sigreturn)
+DTRACE_SYSCALL_STUB(VFORK,		vfork)
+DTRACE_SYSCALL_STUB(FORK,		fork)
+DTRACE_SYSCALL_STUB(CLONE,		clone)
+DTRACE_SYSCALL_STUB(EXIT_GROUP,		exit_group)
+DTRACE_SYSCALL_STUB(EXIT,		exit)
diff --git a/arch/sparc/include/asm/dtrace_util.h b/arch/sparc/include/asm/dtrace_util.h
new file mode 100644
index 000000000000..77a6201ce38c
--- /dev/null
+++ b/arch/sparc/include/asm/dtrace_util.h
@@ -0,0 +1,15 @@
+/* Copyright (C) 2013, 2017, Oracle and/or its affiliates. All rights reserved. */
+
+#ifndef _SPARC_DTRACE_UTIL_H
+#define _SPARC_DTRACE_UTIL_H
+
+#include <asm/dtrace_arch.h>
+
+extern int dtrace_user_addr_is_exec(uintptr_t);
+
+extern int dtrace_fbt_set_handler(void (*func)(struct pt_regs *));
+
+extern void dtrace_mod_pdata_init(dtrace_module_t *);
+extern void dtrace_mod_pdata_cleanup(dtrace_module_t *);
+
+#endif /* _SPARC_DTRACE_UTIL_H */
diff --git a/arch/sparc/include/asm/kdebug_64.h b/arch/sparc/include/asm/kdebug_64.h
index 89428bd4f94b..5742bd0ca249 100644
--- a/arch/sparc/include/asm/kdebug_64.h
+++ b/arch/sparc/include/asm/kdebug_64.h
@@ -19,6 +19,8 @@ enum die_val {
 	DIE_CALL,
 	DIE_NMI,
 	DIE_NMIWATCHDOG,
+	DIE_GPF,
+	DIE_PAGE_FAULT,
 };
 
 #endif
diff --git a/arch/sparc/include/asm/ttable.h b/arch/sparc/include/asm/ttable.h
index ede2b66cf4a0..2d2b91ed6ddc 100644
--- a/arch/sparc/include/asm/ttable.h
+++ b/arch/sparc/include/asm/ttable.h
@@ -199,6 +199,12 @@
 #define KGDB_TRAP(lvl) TRAP_ARG(bad_trap, lvl)
 #endif
 
+#ifdef CONFIG_DTRACE
+#define DTRACE_FBT_TRAP(lvl) TRAP_IRQ(dtrace_fbt_trap, lvl)
+#else
+#define DTRACE_FBT_TRAP(lvl) TRAP_ARG(bad_trap, lvl)
+#endif
+
 #define SUN4V_ITSB_MISS					\
 	ldxa	[%g0] ASI_SCRATCHPAD, %g2;		\
 	ldx	[%g2 + HV_FAULT_I_ADDR_OFFSET], %g4;	\
diff --git a/arch/sparc/include/uapi/asm/unistd.h b/arch/sparc/include/uapi/asm/unistd.h
index 09acf0ddec10..749baca05727 100644
--- a/arch/sparc/include/uapi/asm/unistd.h
+++ b/arch/sparc/include/uapi/asm/unistd.h
@@ -427,8 +427,9 @@
 #define __NR_preadv2		358
 #define __NR_pwritev2		359
 #define __NR_statx		360
+#define __NR_waitfd		361
 
-#define NR_syscalls		361
+#define NR_syscalls		362
 
 /* Bitmask values returned from kern_features system call.  */
 #define KERN_FEATURE_MIXED_MODE_STACK	0x00000001
diff --git a/arch/sparc/kernel/dtrace_fbt.c b/arch/sparc/kernel/dtrace_fbt.c
new file mode 100644
index 000000000000..3d3707a76c43
--- /dev/null
+++ b/arch/sparc/kernel/dtrace_fbt.c
@@ -0,0 +1,362 @@
+/*
+ * FILE:        dtrace_fbt.c
+ * DESCRIPTION: Dynamic Tracing: FBT registration code (arch-specific)
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <linux/kernel.h>
+#include <linux/kallsyms.h>
+#include <linux/kdebug.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/context_tracking.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_fbt.h>
+#include <linux/moduleloader.h>
+#include <linux/vmalloc.h>
+#include <asm/bug.h>
+#include <asm/dtrace_arch.h>
+#include <asm/sections.h>
+
+#define ASM_REG_G0		0
+#define ASM_REG_G1		1
+#define ASM_REG_O0		8
+#define ASM_REG_O1		9
+#define ASM_REG_O2		10
+#define ASM_REG_O3		11
+#define ASM_REG_O4		12
+#define ASM_REG_O5		13
+#define ASM_REG_O6		14
+#define ASM_REG_O7		15
+#define ASM_REG_I0		24
+#define ASM_REG_I1		25
+#define ASM_REG_I2		26
+#define ASM_REG_I3		27
+#define ASM_REG_I4		28
+#define ASM_REG_I7		31
+#define ASM_REG_L0		16
+#define ASM_REG_L1		17
+#define ASM_REG_L2		18
+#define ASM_REG_L3		19
+#define ASM_REG_PC		5
+
+#define ASM_REG_ISOUTPUT(r)	((r) >= 8 && (r) < 16)
+#define ASM_REG_ISINPUT(r)	((r) >= 24 && (r) < 32)
+
+#define ASM_OP_MASK		0xc0000000
+#define ASM_OP_SHIFT		30
+#define ASM_OP(val)		((val) & ASM_OP_MASK)
+
+#define ASM_SIMM13_MASK		0x1fff
+#define ASM_SIMM13_MAX		((int32_t)0xfff)
+#define ASM_IMM22_MASK		0x3fffff
+#define ASM_IMM22_SHIFT		10
+
+#define ASM_OP0			(((uint32_t)0) << ASM_OP_SHIFT)
+#define ASM_OP1			(((uint32_t)1) << ASM_OP_SHIFT)
+#define ASM_OP2			(((uint32_t)2) << ASM_OP_SHIFT)
+
+#define ASM_FMT3_OP3_SHIFT	19
+#define ASM_FMT3_OP_MASK	0xc1f80000
+#define ASM_FMT3_OP(val)	((val) & ASM_FMT3_OP_MASK)
+
+#define ASM_FMT3_RD_SHIFT	25
+#define ASM_FMT3_RD_MASK	(0x1f << ASM_FMT3_RD_SHIFT)
+#define ASM_FMT3_RD(val)						      \
+	(((val) & ASM_FMT3_RD_MASK) >> ASM_FMT3_RD_SHIFT)
+
+#define ASM_FMT3_RS1_SHIFT	14
+#define ASM_FMT3_RS1_MASK	(0x1f << ASM_FMT3_RS1_SHIFT)
+#define ASM_FMT3_RS1(val)						      \
+	(((val) & ASM_FMT3_RS1_MASK) >> ASM_FMT3_RS1_SHIFT)
+#define ASM_FMT3_RS1_SET(val, rs1)					      \
+	(val) = ((val) & ~ASM_FMT3_RS1_MASK) | ((rs1) << ASM_FMT3_RS1_SHIFT)
+
+#define ASM_FMT3_RS2_SHIFT	0
+#define ASM_FMT3_RS2_MASK	(0x1f << ASM_FMT3_RS2_SHIFT)
+#define ASM_FMT3_RS2(val)						      \
+	(((val) & ASM_FMT3_RS2_MASK) >> ASM_FMT3_RS2_SHIFT)
+#define ASM_FMT3_RS2_SET(val, rs2)					      \
+	(val) = ((val) & ~ASM_FMT3_RS2_MASK) | ((rs2) << ASM_FMT3_RS2_SHIFT)
+
+#define ASM_FMT3_IMM_SHIFT	13
+#define ASM_FMT3_IMM		(1 << ASM_FMT3_IMM_SHIFT)
+#define ASM_FMT3_SIMM13_MASK	ASM_SIMM13_MASK
+
+#define ASM_FMT3_ISIMM(val)	((val) & ASM_FMT3_IMM)
+#define ASM_FMT3_SIMM13(val)	((val) & ASM_FMT3_SIMM13_MASK)
+
+#define ASM_FMT2_OP2_SHIFT	22
+#define ASM_FMT2_OP2_MASK	(0x7 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_RD_SHIFT	25
+
+#define ASM_FMT2_OP2_BPCC	(0x01 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_OP2_BCC	(0x02 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_OP2_BPR	(0x03 << ASM_FMT2_OP2_SHIFT)
+#define ASM_FMT2_OP2_SETHI	(0x04 << ASM_FMT2_OP2_SHIFT)
+
+#define ASM_FMT2_COND_SHIFT	25
+#define ASM_FMT2_COND_BA	(0x8 << ASM_FMT2_COND_SHIFT)
+#define ASM_FMT2_COND_BL	(0x3 << ASM_FMT2_COND_SHIFT)
+#define ASM_FMT2_COND_BGE	(0xb << ASM_FMT2_COND_SHIFT)
+
+#define ASM_OP_SAVE		(ASM_OP2 | (0x3c << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_JMPL		(ASM_OP2 | (0x38 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_RETURN		(ASM_OP2 | (0x39 << ASM_FMT3_OP3_SHIFT))
+#define ASM_OP_SETHI		(ASM_OP0 | ASM_FMT2_OP2_SETHI)
+#define ASM_OP_RD		(ASM_OP2 | (0x28 << ASM_FMT3_OP3_SHIFT))
+
+#define ASM_SETHI(val, reg)						      \
+	(ASM_OP_SETHI | (reg << ASM_FMT2_RD_SHIFT) |			      \
+	 ((val >> ASM_IMM22_SHIFT) & ASM_IMM22_MASK))
+
+#define ASM_NOP			ASM_SETHI(0, 0)
+
+/*
+ * We're only going to treat a save as safe if
+ *   (a) both rs1 and rd are %sp and
+ *   (b) if the instruction has a simm, the value isn't 0.
+ */
+#define ASM_IS_SAVE(instr)						      \
+	(ASM_FMT3_OP(instr) == ASM_OP_SAVE &&				      \
+	 ASM_FMT3_RD(instr) == ASM_REG_O6 &&				      \
+	 ASM_FMT3_RS1(instr) == ASM_REG_O6 &&				      \
+	 !(ASM_FMT3_ISIMM(instr) && ASM_FMT3_SIMM13(instr) == 0))
+
+#define ASM_IS_RDPC(instr)	((ASM_FMT3_OP(instr) == ASM_OP_RD) &&	      \
+				 (ASM_FMT3_RD(instr) == ASM_REG_PC))
+
+#define ASM_IS_PCRELATIVE(instr)					      \
+        ((((instr) & ASM_OP_MASK) == ASM_OP0 &&				      \
+	  ((instr) & ASM_FMT2_OP2_MASK) != ASM_FMT2_OP2_SETHI) ||	      \
+	 ((instr) & ASM_OP_MASK) == ASM_OP1 ||				      \
+	 ASM_IS_RDPC(instr))
+
+#define ASM_IS_CTI(instr)						      \
+	((((instr) & ASM_OP_MASK) == ASM_OP0 &&				      \
+	  ((instr) & ASM_FMT2_OP2_MASK) != ASM_FMT2_OP2_SETHI) ||	      \
+	 ((instr) & ASM_OP_MASK) == ASM_OP1 ||				      \
+	 (ASM_FMT3_OP(instr) == ASM_OP_JMPL) ||				      \
+	 (ASM_FMT3_OP(instr) == ASM_OP_RETURN))
+
+#define ASM_IS_NOP(instr)	((instr) == ASM_NOP)
+
+#define ASM_MOD_INPUTS(instr)	(ASM_OP(instr) == ASM_OP2 &&		      \
+				 ASM_REG_ISINPUT(ASM_FMT3_RD(instr)))
+#define ASM_MOD_OUTPUTS(instr)	(ASM_OP(instr) == ASM_OP2 &&		      \
+				 ASM_REG_ISOUTPUT(ASM_FMT3_RD(instr)))
+
+#define BL_SENTRY(tp, nm)	extern tp nm;
+#define BL_DENTRY(tp, nm)
+#include "fbt_blacklist.h"
+#undef BL_DENTRY
+#undef BL_SENTRY
+
+static void
+dtrace_fbt_populate_bl(void)
+{
+#define BL_SENTRY(tp, nm)	dtrace_fbt_bl_add((unsigned long)&nm, __stringify(nm));
+#define BL_DENTRY(tp, nm)	dtrace_fbt_bl_add(0, __stringify(nm));
+#include "fbt_blacklist.h"
+#undef BL_DENTRY
+#undef BL_SENTRY
+};
+
+void dtrace_fbt_init(fbt_add_probe_fn fbt_add_probe, struct module *mp,
+		     void *arg)
+{
+	loff_t			pos;
+	struct kallsym_iter	sym;
+	asm_instr_t		*paddr = NULL;
+	dt_fbt_bl_entry_t	*blent = NULL;
+
+	/*
+	 * Look up any unresolved symbols in the blacklist, and sort the list
+	 * by ascending address.
+	 */
+	dtrace_fbt_populate_bl();
+	blent = dtrace_fbt_bl_first();
+
+	pos = 0;
+	kallsyms_iter_reset(&sym, 0);
+	while (kallsyms_iter_update(&sym, pos++)) {
+		asm_instr_t	*addr, *end, *ins;
+		void *fbtp = NULL;
+
+		/*
+		 * There is no point considering non-function symbols for FBT,
+		 * or symbols that have a zero size.  We could consider weak
+		 * symbols but that gets quite complicated and there is no
+		 * demands for that (so far).
+		 */
+		if (sym.type != 'T' && sym.type != 't')
+			continue;
+		if (!sym.size)
+			continue;
+
+		/*
+		 * The symbol must be at a properly aligned address.
+		 */
+		if (!IS_ALIGNED(sym.value, 4))
+			continue;
+
+		/*
+		 * Handle only symbols that belong to the module we have been
+		 * asked for.
+		 */
+		if (mp == dtrace_kmod && !core_kernel_text(sym.value))
+			continue;
+
+		/*
+		 * Ensure we have not been given .init symbol from kallsyms
+		 * interface. This could lead to memory corruption once DTrace
+		 * tries to enable probe in already freed memory.
+		 */
+		if (mp != dtrace_kmod && !within_module_core(sym.value, mp))
+			continue;
+
+		/*
+		 * See if the symbol is on the FBT's blacklist.  Since both
+		 * iterators are workng in sort order by ascending address we
+		 * can use concurrent traversal.
+		 */
+		while (blent != NULL &&
+		       dtrace_fbt_bl_entry_addr(blent) < sym.value) {
+			blent = dtrace_fbt_bl_next(blent);
+		}
+		if (dtrace_fbt_bl_entry_addr(blent) == sym.value)
+			continue;
+
+		/*
+		 * No FBT tracing for DTrace functions.  Also weed out symbols
+		 * that are not relevant here.
+		 */
+		if (strncmp(sym.name, "dtrace_", 7) == 0)
+			continue;
+		if (strncmp(sym.name, "_GLOBAL_", 8) == 0)
+			continue;
+		if (strncmp(sym.name, "do_", 3) == 0)
+			continue;
+		if (!sym.size)
+			continue;
+
+		addr = (asm_instr_t *)sym.value;
+		end = (asm_instr_t *)(sym.value + sym.size);
+
+		/*
+		 * When there are multiple symbols for the same address we
+		 * should link them together as probes that are associated with
+		 * the same function.  When a probe for that function is
+		 * triggered, all the associated probes should fire.
+		 *
+		 * For now, we're ignoring all but the first symbol...
+		 */
+		if (addr == paddr)
+			continue;
+		paddr = addr;
+
+		if (ASM_IS_SAVE(*addr)) {
+			/*
+			 * If there are other saves, this function has multiple
+			 * entry points or some other complex construct - we'll
+			 * skip it.
+			 */
+			ins = addr;
+			while (++ins < end) {
+				if (ASM_IS_SAVE(*ins))
+					break;
+			}
+			if (ins != end)
+				continue;
+
+			/*
+			 * What we are really looking for is a sequence like:
+			 *	save %sp, <num>, %sp
+			 *	call _mcount
+			 *	nop
+			 * but due to ftrace patching in executable code, that
+			 * call actually gets rewritten as a NOP before we even
+			 * get to looking at it.  We depend on ftrace already
+			 * to get a count of functions that are potential
+			 * candidates for FBT.
+			 */
+			if (!ASM_IS_NOP(*(addr + 1)))
+				continue;
+
+			/*
+			 * We should be OK as long as the instruction in the
+			 * delay slot after the call to the trampoline does not
+			 * modify input or output registers.
+			 */
+			if (!ASM_IS_NOP(*(addr + 2)) &&
+			    (ASM_MOD_INPUTS(*(addr + 2)) ||
+			     ASM_MOD_OUTPUTS(*(addr + 2))))
+				continue;
+
+			fbt_add_probe(mp, sym.name, FBT_ENTRY, 32,
+				      addr + 1, 0, NULL, arg);
+		} else
+			continue;
+
+		/* Scan function for possible return probes. */
+		for (ins = addr; ins + 1 < end; ins++) {
+
+			/* Only CTIs may become return probe. */
+			if (!ASM_IS_CTI(*ins))
+				continue;
+
+			/*
+			 * Check the delay slot for incompatible instructions:
+			 *   - DCTI
+			 *   - PC relative instruction
+			 *
+			 * More detailed analysis is performed in the fbt module.
+			 */
+			if (ASM_IS_CTI(*(ins + 1)))
+				continue;
+
+			if (ASM_IS_PCRELATIVE(*(ins + 1)))
+				continue;
+
+			/* Create or update the return probe. */
+			fbtp = fbt_add_probe(mp, sym.name, FBT_RETURN, 32, ins,
+					     (uintptr_t)ins - (uintptr_t)addr,
+					     fbtp, arg);
+		}
+	}
+}
+EXPORT_SYMBOL(dtrace_fbt_init);
+
+static void (*fbt_handler)(struct pt_regs *) = NULL;
+
+int dtrace_fbt_set_handler(void (*func)(struct pt_regs *))
+{
+	fbt_handler = func;
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_fbt_set_handler);
+
+asmlinkage void dtrace_fbt_trap(unsigned long traplevel, struct pt_regs *regs)
+{
+	enum ctx_state prev_state = exception_enter();
+
+	if (user_mode(regs)) {
+		local_irq_enable();
+		bad_trap(regs, traplevel);
+		goto out;
+	}
+
+        /*
+	 * If we take this trap and fbt_handler is not set we are out of luck.
+	 * Since we don't know why the trap fired (it should never happen in
+	 * DTrace code unless fbt_handler is set), there is no way of knowing
+	 * whether it is safe to just do nothing.
+	 */
+        BUG_ON(fbt_handler == NULL);
+
+	fbt_handler(regs);
+
+out:
+	exception_exit(prev_state);
+}
diff --git a/arch/sparc/kernel/dtrace_sdt.c b/arch/sparc/kernel/dtrace_sdt.c
new file mode 100644
index 000000000000..a9293f207dda
--- /dev/null
+++ b/arch/sparc/kernel/dtrace_sdt.c
@@ -0,0 +1,38 @@
+/*
+ * FILE:        dtrace_sdt.c
+ * DESCRIPTION: Dynamic Tracing: SDT registration code (arch-specific)
+ *
+ * Copyright (C) 2010-2014 Oracle Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/dtrace_os.h>
+#include <linux/sdt.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/cacheflush.h>
+#include <asm/dtrace_arch.h>
+
+void __init_or_module dtrace_sdt_nop_multi(asm_instr_t **addrs,
+					   int * __always_unused is_enabled,
+					   int cnt)
+{
+	int		i;
+	asm_instr_t	*addr;
+
+	for (i = 0; i < cnt; i++) {
+		addr = addrs[i];
+		*addr = 0x01000000;
+		flushi(addr);
+	}
+}
+
+/*
+ * Perform architecture dependent initialization for SDT.  On sparc64, we need
+ * not do anything.
+ */
+void dtrace_sdt_init_arch(void)
+{
+}
diff --git a/arch/sparc/kernel/dtrace_syscall.c b/arch/sparc/kernel/dtrace_syscall.c
new file mode 100644
index 000000000000..197f15992334
--- /dev/null
+++ b/arch/sparc/kernel/dtrace_syscall.c
@@ -0,0 +1,380 @@
+/*
+ * FILE:	dtrace_syscall.c
+ * DESCRIPTION:	Dynamic Tracing: system call tracing support (arch-specific)
+ *
+ * Copyright (C) 2010-2014 Oracle Corporation
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_syscall.h>
+#include <linux/fs.h>
+#include <linux/kallsyms.h>
+#include <linux/module.h>
+#include <linux/namei.h>
+#include <linux/binfmts.h>
+#include <linux/syscalls.h>
+#include <asm/compat.h>
+
+#include "systbls.h"
+
+/*---------------------------------------------------------------------------*\
+(* SYSTEM CALL TRACING SUPPORT                                               *)
+\*---------------------------------------------------------------------------*/
+void (*systrace_probe)(dtrace_id_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t,
+		       uintptr_t, uintptr_t);
+
+void systrace_stub(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
+		   uintptr_t arg2, uintptr_t arg3, uintptr_t arg4,
+		   uintptr_t arg5)
+{
+}
+
+asmlinkage long systrace_syscall(uintptr_t, uintptr_t,
+				 uintptr_t, uintptr_t,
+				 uintptr_t, uintptr_t);
+
+static systrace_info_t	systrace_info =
+		{
+			&systrace_probe,
+			&systrace_stub,
+			&systrace_syscall,
+			{
+#define DTRACE_SYSCALL_STUB(t, n) \
+			    [SCE_##t] dtrace_stub_##n,
+#include <asm/dtrace_syscall.h>
+#undef DTRACE_SYSCALL_STUB
+			},
+			{
+			}
+		};
+
+
+long systrace_syscall(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
+		      uintptr_t arg3, uintptr_t arg4, uintptr_t arg5)
+{
+	long			rc = 0;
+	unsigned long		sysnum;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sysnum = syscall_get_nr(current, current_pt_regs());
+	sc = &systrace_info.sysent[sysnum];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	if (sc->stsy_underlying != NULL)
+		rc = (*sc->stsy_underlying)(arg0, arg1, arg2, arg3, arg4,
+					    arg5);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+systrace_info_t *dtrace_syscalls_init() {
+	int			i;
+
+	/*
+	 * Only initialize this stuff once...
+	 */
+	if (systrace_info.sysent[0].stsy_tblent != NULL)
+		return &systrace_info;
+
+	for (i = 0; i < NR_syscalls; i++) {
+		char	sym[KSYM_SYMBOL_LEN];
+		char	*p = sym;
+
+		/*
+		 * We (ab)use the knowledge that the perfctr system call is
+		 * not implemented, and is directed to sys_nis_syscall.  We'd
+		 * rather refer to that function directly, but it is not a
+		 * global symbol.
+		 */
+		if (sys_call_table[i] == (uintptr_t)sys_ni_syscall ||
+		    sys_call_table[i] == sys_call_table[__NR_perfctr])
+			continue;
+
+		lookup_symbol_name(sys_call_table[i],  sym);
+		p = strchr(sym, '_');
+		if (p == NULL)
+			continue;
+		p++;
+
+		systrace_info.sysent[i].name = kstrdup(p, GFP_KERNEL);
+		systrace_info.sysent[i].stsy_tblent =
+				(dt_sys_call_t *)&sys_call_table[i];
+		systrace_info.sysent[i].stsy_underlying =
+				(dt_sys_call_t)(uintptr_t)sys_call_table[i];
+	}
+
+	return &systrace_info;
+}
+EXPORT_SYMBOL(dtrace_syscalls_init);
+
+asmlinkage long dtrace_sys_clone(unsigned long clone_flags,
+				 unsigned long newsp, struct pt_regs *regs,
+				 unsigned long stack_size)
+{
+	int __user		*parent_tidptr, *child_tidptr;
+	long			rc = 0;
+	unsigned long		orig_i1 = regs->u_regs[UREG_I1];
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_clone];
+
+#ifdef CONFIG_COMPAT
+	if (test_thread_flag(TIF_32BIT)) {
+		parent_tidptr = compat_ptr(regs->u_regs[UREG_I2]);
+		child_tidptr = compat_ptr(regs->u_regs[UREG_I4]);
+	} else
+#endif
+	{
+		parent_tidptr = (int __user *) regs->u_regs[UREG_I2];
+		child_tidptr = (int __user *) regs->u_regs[UREG_I4];
+	}
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, clone_flags, newsp,
+				  (uintptr_t)parent_tidptr,
+				  (uintptr_t)child_tidptr, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	rc = do_fork(clone_flags, newsp, stack_size, parent_tidptr,
+		     child_tidptr);
+
+	if ((unsigned long)rc >= -ERESTART_RESTARTBLOCK)
+		regs->u_regs[UREG_I1] = orig_i1;
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_execve(const char __user *name,
+				  const char __user *const __user *argv,
+				  const char __user *const __user *envp)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_execve];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)name, (uintptr_t)argv,
+				  (uintptr_t)envp, 0, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	rc = do_execve(getname(name), argv, envp);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_execveat(int fd, const char __user *name,
+				    const char __user *const __user *argv,
+				    const char __user *const __user *envp,
+				    int flags)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+	int			lookup_flags =
+				(flags & AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0;
+
+	sc = &systrace_info.sysent[__NR_execveat];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, fd, (uintptr_t)name, (uintptr_t)argv,
+				  (uintptr_t)envp, flags, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	rc = do_execveat(fd, getname_flags(name, lookup_flags, NULL), argv,
+			 envp, flags);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_exit(int error_code)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_exit];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, error_code, 0, 0, 0, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	do_exit((error_code&0xff)<<8);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_exit_group(int error_code)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_exit_group];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, error_code, 0, 0, 0, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	do_group_exit((error_code & 0xff) << 8);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_memory_ordering(unsigned long model,
+					    struct pt_regs *regs)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_memory_ordering];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)regs, 0, 0, 0, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	if (model >= 3)
+		rc = -EINVAL;
+	else
+		regs->tstate = (regs->tstate & ~TSTATE_MM) | (model << 14);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_pipe(struct pt_regs *regs)
+{
+	int			fd[2];
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_pipe];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, 0, 0, 0, 0, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	rc = do_pipe_flags(fd, 0);
+	if (rc)
+		goto out;
+
+	regs->u_regs[UREG_I1] = fd[1];
+	rc = fd[0];
+
+out:
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_rt_sigreturn(struct pt_regs *regs)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_rt_sigreturn];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)regs, 0, 0, 0, 0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	do_rt_sigreturn(regs);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
+
+asmlinkage long dtrace_sys_sigaltstack(const stack_t __user *uss,
+				       stack_t __user *uoss, unsigned long sp)
+{
+	long			rc = 0;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sc = &systrace_info.sysent[__NR_sigaltstack];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)uss, (uintptr_t)uoss, sp, 0,
+				  0, 0);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	rc = do_sigaltstack(uss, uoss, sp);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0);
+
+	return rc;
+}
diff --git a/arch/sparc/kernel/dtrace_syscall_stubs.S b/arch/sparc/kernel/dtrace_syscall_stubs.S
new file mode 100644
index 000000000000..19ddaf81011b
--- /dev/null
+++ b/arch/sparc/kernel/dtrace_syscall_stubs.S
@@ -0,0 +1,91 @@
+/*
+ * FILE:        dtrace_syscall_stubs.S
+ * DESCRIPTION: Dynamic Tracing: Syscall tracing stubs (arch-specific)
+ *
+ * Copyright (C) 2010-2014 Oracle Corporation
+ */
+
+#include <linux/linkage.h>
+#include <asm/head.h>
+#include <asm/ptrace.h>
+#include <asm/signal.h>
+#include <asm/thread_info.h>
+
+	ENTRY(dtrace_stub_execve)
+	set	dtrace_sys_execve, %g1
+	jmpl	%g1, %g0
+	 flushw
+	ENDPROC(dtrace_stub_execve)
+
+	ENTRY(dtrace_stub_execveat)
+	set	dtrace_sys_execveat, %g1
+	jmpl	%g1, %g0
+	 flushw
+	ENDPROC(dtrace_stub_execveat)
+
+	ENTRY(dtrace_stub_pipe)
+	ba,pt	%xcc, dtrace_sys_pipe
+	 add	%sp, PTREGS_OFF, %o0
+	ENDPROC(dtrace_stub_pipe)
+
+	ENTRY(dtrace_stub_memory_ordering)
+	ba,pt	%xcc, dtrace_sys_memory_ordering
+	 add	%sp, PTREGS_OFF, %o1
+	ENDPROC(dtrace_stub_memory_ordering)
+
+	ENTRY(dtrace_stub_rt_sigreturn)
+	add	%sp, PTREGS_OFF, %o0
+	call	dtrace_sys_rt_sigreturn
+	 add	%o7, 1f-.-4, %o7
+	nop
+	.align	32
+1:	ldx	[%g6 + TI_FLAGS], %l5
+	andcc	%l5, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT|_TIF_SYSCALL_TRACEPOINT), %g0
+	be,pt	%icc, 2f
+	 nop
+	call	syscall_trace_leave
+	 add	%sp, PTREGS_OFF, %o0
+2:	set	rtrap, %g1
+	jmpl	%g1, %g0
+	 nop
+	ENDPROC(dtrace_stub_rt_sigreturn)
+
+	ENTRY(dtrace_stub_vfork)
+	sethi	%hi(0x4000 | 0x0100 | SIGCHLD), %o0
+	or	%o0, %lo(0x4000 | 0x0100 | SIGCHLD), %o0
+	ba,pt	%xcc, dtrace_stub_clone
+
+	ENTRY(dtrace_stub_fork)
+	 clr	%o1
+	mov	SIGCHLD, %o0
+
+	ENTRY(dtrace_stub_clone)
+	flushw
+	movrz	%o1, %fp, %o1
+	mov	0, %o3
+	ba,pt	%xcc, dtrace_sys_clone
+	 add	%sp, PTREGS_OFF, %o2
+	ENDPROC(dtrace_stub_clone)
+	ENDPROC(dtrace_stub_fork)
+	ENDPROC(dtrace_stub_vfork)
+
+	ENTRY(dtrace_stub_exit_group)
+	sethi	%hi(dtrace_sys_exit_group), %g7
+	ba,pt	%xcc, 1f
+	 or	%g7, %lo(dtrace_sys_exit_group), %g7
+	ENDPROC(dtrace_stub_exit_group)
+
+	ENTRY(dtrace_stub_exit)
+	sethi	%hi(dtrace_sys_exit), %g7
+	or	%g7, %lo(dtrace_sys_exit), %g7
+1:	rdpr	%pstate, %g2
+	wrpr	%g2, PSTATE_IE, %pstate
+	rdpr	%otherwin, %g1
+	rdpr	%cansave, %g3
+	add	%g3, %g1, %g3
+	wrpr	%g3, 0x0, %cansave
+	wrpr	%g0, 0x0, %otherwin
+	wrpr	%g2, 0x0, %pstate
+	jmpl	%g7, %g0
+	stb	%g0, [%g6 + TI_WSAVED]
+	ENDPROC(dtrace_stub_exit)
diff --git a/arch/sparc/kernel/dtrace_util.c b/arch/sparc/kernel/dtrace_util.c
new file mode 100644
index 000000000000..d3c134c365ad
--- /dev/null
+++ b/arch/sparc/kernel/dtrace_util.c
@@ -0,0 +1,244 @@
+/*
+ * FILE:	dtrace_util.c
+ * DESCRIPTION:	Dynamic Tracing: Architecture utility functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/kdebug.h>
+#include <linux/mm.h>
+#include <linux/notifier.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <asm/cacheflush.h>
+#include <asm/pgtable.h>
+#include <asm/ptrace.h>
+#include <asm/switch_to.h>
+
+void dtrace_skip_instruction(struct pt_regs *regs)
+{
+	regs->tpc = regs->tnpc;
+	regs->tnpc += 4;
+}
+
+void dtrace_handle_badaddr(struct pt_regs *regs) {
+	unsigned long	addr = current_thread_info()->fault_address;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+	this_cpu_core->cpuc_dtrace_illval = addr;
+
+	dtrace_skip_instruction(regs);
+}
+
+int dtrace_die_notifier(struct notifier_block *nb, unsigned long val,
+			void *args)
+{
+	struct die_args		*dargs = args;
+
+	switch (val) {
+	case DIE_PAGE_FAULT: {
+		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
+			return NOTIFY_DONE;
+
+		dtrace_handle_badaddr(dargs->regs);
+
+		return NOTIFY_OK | NOTIFY_STOP_MASK;
+	}
+	case DIE_GPF: {
+		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
+			return NOTIFY_DONE;
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+
+		dtrace_skip_instruction(dargs->regs);
+
+		return NOTIFY_OK | NOTIFY_STOP_MASK;
+	}
+	case DIE_TRAP: {
+		if (dargs->trapnr != 0x34 && dargs->trapnr != 0x08)
+			return NOTIFY_DONE;
+
+		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
+			return NOTIFY_DONE;
+
+		dtrace_handle_badaddr(dargs->regs);
+
+		return NOTIFY_OK | NOTIFY_STOP_MASK;
+	}
+	case DIE_OOPS: {
+		printk("DTrace: probe ctx %d last probe %ld\n",
+		       !!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_PROBE_CTX),
+		       this_cpu_core->cpu_dtrace_caller);
+		return NOTIFY_DONE;
+	}
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+int dtrace_user_addr_is_exec(uintptr_t addr)
+{
+	struct mm_struct	*mm = current->mm;
+	pgd_t			pgd;
+	pud_t			pud;
+	pmd_t			pmd;
+	unsigned long		flags;
+	int			ret = 0;
+
+	if (mm == NULL)
+		return 0;
+
+	addr &= PAGE_MASK;
+
+	local_irq_save(flags);
+
+	pgd = *pgd_offset(mm, addr);
+	if (pgd_none(pgd))
+		goto out;
+
+	pud = *pud_offset(&pgd, addr);
+	if (pud_none(pud))
+		goto out;
+
+	pmd = *pmd_offset(&pud, addr);
+	if (pmd_none(pmd))
+		goto out;
+	if (unlikely(pmd_large(pmd))) {
+		/* not sure how to do this */
+		goto out;
+	} else {
+		pte_t	pte;
+
+		pte = *pte_offset_kernel(&pmd, addr);
+
+		ret = pte_exec(pte);
+	}
+
+out:
+	local_irq_restore(flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(dtrace_user_addr_is_exec);
+
+void dtrace_user_stacktrace(stacktrace_state_t *st)
+{
+	struct thread_info	*t = current_thread_info();
+	struct pt_regs		*regs = current_pt_regs();
+	uint64_t		*pcs = st->pcs;
+	int			limit = st->limit;
+	unsigned long		window;
+	unsigned long		sp = user_stack_pointer(regs);
+	int			ret;
+
+	if (!user_mode(regs))
+		goto out;
+
+	flush_user_windows();
+
+	st->depth = 1;
+	if (pcs)
+		*pcs++ = (uint64_t)instruction_pointer(regs);
+	limit--;
+
+	if (!limit)
+		goto out;
+
+	if (test_thread_flag(TIF_32BIT))
+		sp = (uint32_t)sp;
+
+	/*
+	 * First we have to process all user windows that have not been flushed
+	 * to the stack save area.
+	 */
+	window = get_thread_wsaved();
+	while (window--) {
+		unsigned long	addr;
+
+		sp = t->rwbuf_stkptrs[window];
+
+		if (test_thread_64bit_stack((unsigned long)sp)) {
+			addr = t->reg_window[window].ins[7];
+		} else {
+			addr = ((struct reg_window32 *)(&t->reg_window[window]))->ins[7];
+		}
+
+		if (pcs)
+			*pcs++ = addr;
+		limit--;
+		st->depth++;
+
+		if (!limit)
+			goto out;
+
+		/* Grab %fp so we can continue iteration on stack. */
+		if (window == 0) {
+			if (test_thread_64bit_stack((unsigned long)sp)) {
+				sp = t->reg_window[window].ins[6];
+			} else {
+				sp = ((struct reg_window32 *)(&t->reg_window[window]))->ins[6];
+			}
+		}
+	}
+
+	/* continue iteration on the stack */
+	while ((sp != 0 || sp != STACK_BIAS) && limit > 0) {
+		unsigned long addr;
+
+		pagefault_disable();
+		if (test_thread_64bit_stack(sp)) {
+			ret = __copy_from_user_inatomic(&addr, (unsigned long *)(sp + STACK_BIAS + SF_V9_PC),
+							sizeof(addr));
+		} else {
+			unsigned int addr32;
+
+			ret = __copy_from_user_inatomic(&addr32, (unsigned int *)(sp + SF_PC), sizeof(addr32));
+			addr = addr32;
+		}
+		pagefault_enable();
+
+		if (ret)
+			break;
+
+		if (pcs)
+			*pcs++ = addr;
+		limit--;
+		st->depth++;
+
+		pagefault_disable();
+		if (test_thread_64bit_stack(sp)) {
+			ret = __copy_from_user_inatomic(&sp, (unsigned long *)(sp + STACK_BIAS + SF_V9_FP),
+							sizeof (sp));
+		} else {
+			unsigned int sp_tmp;
+
+			ret = __copy_from_user_inatomic(&sp_tmp, (unsigned int *)(sp + SF_FP), sizeof (sp_tmp));
+			sp = sp_tmp;
+		}
+		pagefault_enable();
+
+		if (ret)
+			break;
+	}
+
+out:
+	if (pcs) {
+		while (limit--)
+			*pcs++ = 0;
+	}
+}
+
+void dtrace_mod_pdata_init(dtrace_module_t *pdata)
+{
+}
+
+void dtrace_mod_pdata_cleanup(dtrace_module_t *pdata)
+{
+	if (pdata->sdt_tab != NULL)
+		dtrace_free_text(pdata->sdt_tab);
+	if (pdata->fbt_tab != NULL)
+		dtrace_free_text(pdata->fbt_tab);
+}
diff --git a/arch/sparc/kernel/fbt_blacklist.h b/arch/sparc/kernel/fbt_blacklist.h
new file mode 100644
index 000000000000..79d6a3a12fb9
--- /dev/null
+++ b/arch/sparc/kernel/fbt_blacklist.h
@@ -0,0 +1,33 @@
+BL_DENTRY(void *, notifier_call_chain)
+BL_SENTRY(typeof(__atomic_notifier_call_chain), __atomic_notifier_call_chain)
+BL_SENTRY(typeof(atomic_notifier_call_chain), atomic_notifier_call_chain)
+BL_SENTRY(typeof(__raw_notifier_call_chain), __raw_notifier_call_chain)
+BL_SENTRY(typeof(raw_notifier_call_chain), raw_notifier_call_chain)
+BL_DENTRY(void *, notify_die)
+BL_SENTRY(void *, rcu_nmi_exit)
+BL_SENTRY(void *, rcu_nmi_enter)
+BL_SENTRY(typeof(ktime_get_raw_fast_ns), ktime_get_raw_fast_ns)
+BL_DENTRY(void *, kprobe_exceptions_notify)
+BL_DENTRY(void *, arch_uprobe_exception_notify)
+BL_DENTRY(void *, sun4v_data_access_exception)
+BL_DENTRY(void *, sun4v_do_mna)
+BL_DENTRY(void *, get_fault_insn)
+BL_DENTRY(void *, kernel_unaligned_trap)
+BL_DENTRY(typeof(save_stack_trace), save_stack_trace)
+BL_DENTRY(typeof(__save_stack_trace), __save_stack_trace)
+BL_DENTRY(typeof(stack_trace_flush), stack_trace_flush)
+BL_DENTRY(typeof(in_sched_functions), in_sched_functions)
+BL_DENTRY(typeof(search_exception_tables), search_exception_tables) 
+BL_DENTRY(void *, down_read_trylock)
+BL_DENTRY(void *, __down_read_trylock)
+BL_DENTRY(void *, __get_user_pages_fast)
+BL_DENTRY(void *, gup_pud_range)
+BL_DENTRY(void *, gup_pmd_range)
+BL_DENTRY(void *, gup_huge_pmd)
+BL_DENTRY(void *, gup_pte_range)
+
+/*
+ * Functions used in dtrace_sync().
+ */
+BL_DENTRY(void *, find_next_bit)
+BL_DENTRY(void *, _find_next_bit)
diff --git a/arch/sparc/kernel/module.c b/arch/sparc/kernel/module.c
index df39580f398d..5cc9604f967a 100644
--- a/arch/sparc/kernel/module.c
+++ b/arch/sparc/kernel/module.c
@@ -18,6 +18,9 @@
 #include <asm/processor.h>
 #include <asm/spitfire.h>
 #include <asm/cacheflush.h>
+#ifdef CONFIG_DTRACE
+# include <asm/dtrace_arch.h>
+#endif
 
 #include "entry.h"
 
@@ -223,6 +226,11 @@ int module_finalize(const Elf_Ehdr *hdr,
 		__asm__ __volatile__("flush %g6");
 	}
 
+# ifdef CONFIG_DTRACE
+	me->pdata = NULL;
+# endif
+
 	return 0;
 }
+
 #endif /* CONFIG_SPARC64 */
diff --git a/arch/sparc/kernel/systbls_64.S b/arch/sparc/kernel/systbls_64.S
index 293c1cb31262..d380f5b2bb37 100644
--- a/arch/sparc/kernel/systbls_64.S
+++ b/arch/sparc/kernel/systbls_64.S
@@ -173,4 +173,4 @@ sys_call_table:
 	.word sys_renameat2, sys_seccomp, sys_getrandom, sys_memfd_create, sys_bpf
 /*350*/	.word sys64_execveat, sys_membarrier, sys_userfaultfd, sys_bind, sys_listen
 	.word sys_setsockopt, sys_mlock2, sys_copy_file_range, sys_preadv2, sys_pwritev2
-/*360*/	.word sys_statx
+/*360*/	.word sys_statx, sys_waitfd
diff --git a/arch/sparc/kernel/ttable_64.S b/arch/sparc/kernel/ttable_64.S
index 18685fe69b91..46e72ba625d1 100644
--- a/arch/sparc/kernel/ttable_64.S
+++ b/arch/sparc/kernel/ttable_64.S
@@ -166,7 +166,7 @@ tl0_resv169:	BTRAP(0x169) BTRAP(0x16a) BTRAP(0x16b) BTRAP(0x16c)
 tl0_linux64:	LINUX_64BIT_SYSCALL_TRAP
 tl0_gsctx:	TRAP(sparc64_get_context) TRAP(sparc64_set_context)
 tl0_resv170:	KPROBES_TRAP(0x170) KPROBES_TRAP(0x171) KGDB_TRAP(0x172)
-tl0_resv173:	UPROBES_TRAP(0x173) UPROBES_TRAP(0x174) BTRAP(0x175) BTRAP(0x176) BTRAP(0x177)
+tl0_resv173:	UPROBES_TRAP(0x173) UPROBES_TRAP(0x174) DTRACE_FBT_TRAP(0x175) BTRAP(0x176) BTRAP(0x177)
 tl0_resv178:	BTRAP(0x178) BTRAP(0x179) BTRAP(0x17a) BTRAP(0x17b) BTRAP(0x17c)
 tl0_resv17d:	BTRAP(0x17d) BTRAP(0x17e) BTRAP(0x17f)
 #define BTRAPS(x) BTRAP(x) BTRAP(x+1) BTRAP(x+2) BTRAP(x+3) BTRAP(x+4) BTRAP(x+5) BTRAP(x+6) BTRAP(x+7)
diff --git a/arch/sparc/mm/fault_64.c b/arch/sparc/mm/fault_64.c
index 815c03d7a765..cd3100c79f99 100644
--- a/arch/sparc/mm/fault_64.c
+++ b/arch/sparc/mm/fault_64.c
@@ -25,6 +25,7 @@
 #include <linux/percpu.h>
 #include <linux/context_tracking.h>
 #include <linux/uaccess.h>
+#include <linux/dtrace_os.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -263,7 +264,9 @@ static void __kprobes do_kernel_fault(struct pt_regs *regs, int si_code,
 	}
 
 cannot_handle:
-	unhandled_fault (address, current, regs);
+	if (notify_die(DIE_PAGE_FAULT, "page fault", regs, fault_code, 14,
+		       SIGKILL) != NOTIFY_STOP)
+		unhandled_fault (address, current, regs);
 }
 
 static void noinline __kprobes bogus_32bit_fault_tpc(struct pt_regs *regs)
@@ -325,6 +328,12 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 	} else
 		flags |= FAULT_FLAG_USER;
 
+	/*
+	 * DTrace may want the page fault ignored...
+	 */
+	if (unlikely(dtrace_no_pf(regs)))
+		return;
+
 	/*
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 559b37bf5a2e..3b5d4d4e1dd3 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -334,6 +334,9 @@ config PGTABLE_LEVELS
 	default 3 if X86_PAE
 	default 2
 
+config ARCH_SUPPORTS_DTRACE
+	def_bool y if X86_64
+
 source "init/Kconfig"
 source "kernel/Kconfig.freezer"
 
diff --git a/arch/x86/dtrace/Makefile.arch b/arch/x86/dtrace/Makefile.arch
new file mode 100644
index 000000000000..0ff2b1e8930f
--- /dev/null
+++ b/arch/x86/dtrace/Makefile.arch
@@ -0,0 +1,17 @@
+#
+# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+DTARCHDIR = ../arch/x86/dtrace
+
+ccflags-y	+= -Iarch/x86/dtrace/include -Idtrace
+
+dtrace-obj	+= dtrace_asm_x86_64.o dtrace_isa_x86_64.o
+fasttrap-obj	+= fasttrap_x86_64.o
+fbt-obj		+= fbt_x86_64.o
+sdt-obj		+= sdt_x86_64.o
+
+dtrace-y	+= $(addprefix $(DTARCHDIR)/, $(dtrace-obj))
+fasttrap-y	+= $(addprefix $(DTARCHDIR)/, $(fasttrap-obj))
+fbt-y		+= $(addprefix $(DTARCHDIR)/, $(fbt-obj))
+sdt-y		+= $(addprefix $(DTARCHDIR)/, $(sdt-obj))
diff --git a/arch/x86/dtrace/dtrace_asm_x86_64.S b/arch/x86/dtrace/dtrace_asm_x86_64.S
new file mode 100644
index 000000000000..5a3ccf52e404
--- /dev/null
+++ b/arch/x86/dtrace/dtrace_asm_x86_64.S
@@ -0,0 +1,227 @@
+/*
+ * Dynamic Tracing for Linux - x86 specific assembly
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/smap.h>
+
+#define CPU_DTRACE_BADADDR	0x0004	/* DTrace fault: bad address */
+
+#if defined(__x86_64__)
+	ENTRY(dtrace_caller)
+	movq	$-1, %rax
+	ret
+	ENDPROC(dtrace_caller)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_caller)
+	movl	$-1, %eax
+	ret
+	ENDPROC(dtrace_caller)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	ENTRY(dtrace_copy)
+	pushq	%rbp
+	movq	%rsp, %rbp
+
+	ASM_STAC
+	xchgq	%rdi, %rsi		# make %rsi source, %rdi dest
+	movq	%rdx, %rcx		# load count
+	repz				# repeat for count ...
+	smovb				#   move from %ds:rsi to %ed:rdi
+	ASM_CLAC
+	leave
+	ret
+	ENDPROC(dtrace_copy)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_copy)
+	pushl	%ebp
+	movl	%esp, %ebp
+	pushl	%esi
+	pushl	%edi
+
+	movl	8(%ebp), %esi		# Load source address
+	movl	12(%ebp), %edi		# Load destination address
+	movl	16(%ebp), %ecx		# Load count
+	repz				# Repeat for count...
+	smovb				#   move from %ds:si to %es:di
+
+	popl	%edi
+	popl	%esi
+	movl	%ebp, %esp
+	popl	%ebp
+	ret
+	ENDPROC(dtrace_copy)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	ENTRY(dtrace_copystr)
+	pushq	%rbp
+	movq	%rsp, %rbp
+
+	ASM_STAC
+0:
+	movb	(%rdi), %al		# load from source
+	movb	%al, (%rsi)		# store to destination
+	addq	$1, %rdi		# increment source pointer
+	addq	$1, %rsi		# increment destination pointer
+	subq	$1, %rdx		# decrement remaining count
+	cmpb	$0, %al
+	je	2f
+	testq	$0xfff, %rdx		# test if count is 4k-aligned
+	jnz	1f			# if not, continue with copying
+	testq	$CPU_DTRACE_BADADDR, (%rcx) # load and test dtrace flags
+	jnz	2f
+1:
+	cmpq	$0, %rdx
+	jne	0b
+2:
+	ASM_CLAC
+	leave
+	ret
+
+	ENDPROC(dtrace_copystr)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_copystr)
+
+	pushl	%ebp			# Setup stack frame
+	movl	%esp, %ebp
+	pushl	%ebx			# Save registers
+
+	movl	8(%ebp), %ebx		# Load source address
+	movl	12(%ebp), %edx		# Load destination address
+	movl	16(%ebp), %ecx		# Load count
+
+0:
+	movb	(%ebx), %al		# Load from source
+	movb	%al, (%edx)		# Store to destination
+	incl	%ebx			# Increment source pointer
+	incl	%edx			# Increment destination pointer
+	decl	%ecx			# Decrement remaining count
+	cmpb	$0, %al
+	je	2f
+	testl	$0xfff, %ecx		# Check if count is 4k-aligned
+	jnz	1f
+	movl	20(%ebp), %eax		# load flags pointer
+	testl	$CPU_DTRACE_BADADDR, (%eax) # load and test dtrace flags
+	jnz	2f
+1:
+	cmpl	$0, %ecx
+	jne	0b
+
+2:
+	popl	%ebx
+	movl	%ebp, %esp
+	popl	%ebp
+	ret
+
+	ENDPROC(dtrace_copystr)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	ENTRY(dtrace_fuword8_nocheck)
+	xorq	%rax, %rax
+	ASM_STAC
+	movb	(%rdi), %al
+	ASM_CLAC
+	ret
+	ENDPROC(dtrace_fuword8_nocheck)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_fuword8_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	movzbl	(%ecx), %eax
+	ret
+	ENDPROC(dtrace_fuword8_nocheck)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	ENTRY(dtrace_fuword16_nocheck)
+	xorq	%rax, %rax
+	ASM_STAC
+	movw	(%rdi), %ax
+	ASM_CLAC
+	ret
+	ENDPROC(dtrace_fuword16_nocheck)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_fuword16_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	movzwl	(%ecx), %eax
+	ret
+	ENDPROC(dtrace_fuword16_nocheck)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	ENTRY(dtrace_fuword32_nocheck)
+	xorq	%rax, %rax
+	ASM_STAC
+	movl	(%rdi), %eax
+	ASM_CLAC
+	ret
+	ENDPROC(dtrace_fuword32_nocheck)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_fuword32_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	movl	(%ecx), %eax
+	ret
+	ENDPROC(dtrace_fuword32_nocheck)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	ENTRY(dtrace_fuword64_nocheck)
+	ASM_STAC
+	movq	(%rdi), %rax
+	ASM_CLAC
+	ret
+	ENDPROC(dtrace_fuword64_nocheck)
+
+#elif defined(__i386__)
+
+	ENTRY(dtrace_fuword64_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	xorl	%edx, %edx
+	movl	(%ecx), %eax
+	movl	4(%ecx), %edx
+	ret
+	ENDPROC(dtrace_fuword64_nocheck)
+
+#endif	/* __i386__ */
diff --git a/arch/x86/dtrace/dtrace_isa_x86_64.c b/arch/x86/dtrace/dtrace_isa_x86_64.c
new file mode 100644
index 000000000000..b29618ec8dda
--- /dev/null
+++ b/arch/x86/dtrace/dtrace_isa_x86_64.c
@@ -0,0 +1,227 @@
+/*
+ * FILE:	dtrace_isa_x86_64.c
+ * DESCRIPTION:	DTrace - x86_64 architecture specific support functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <asm/unwind.h>
+
+#include "dtrace.h"
+
+/* Register indices */
+#define REG_TRAPNO	25
+#define REG_GS		24
+#define REG_FS		23
+#define REG_ES		22
+#define REG_DS		21
+#define REG_SS		20
+#define REG_RSP		19
+#define REG_RFL		18
+#define REG_CS		17
+#define REG_RIP		16
+#define REG_ERR		15
+#define REG_RDI		14
+#define REG_RSI		13
+#define REG_RDX		12
+#define REG_RCX		11
+#define REG_RAX		10
+#define REG_R8		9
+#define REG_R9		8
+#define REG_R10		7
+#define REG_R11		6
+#define REG_RBX		5
+#define REG_RBP		4
+#define REG_R12		3
+#define REG_R13		2
+#define REG_R14		1
+#define REG_R15		0
+
+extern void	dtrace_copy(uintptr_t, uintptr_t, size_t);
+extern void	dtrace_copystr(uintptr_t, uintptr_t, size_t,
+			       volatile uint16_t *);
+
+uintptr_t _userlimit = 0x00007fffffffffffLL;
+uintptr_t kernelbase = 0xffff880000000000LL;
+
+static int dtrace_copycheck(uintptr_t uaddr, uintptr_t kaddr, size_t size)
+{
+#ifdef FIXME
+	ASSERT(kaddr >= kernelbase && kaddr + size >= kaddr);
+#else
+	if (kaddr < kernelbase || kaddr + size < kaddr) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+		this_cpu_core->cpuc_dtrace_illval = kaddr;
+		return 0;
+	}
+#endif
+
+	if (uaddr + size >= kernelbase || uaddr + size < uaddr) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+		this_cpu_core->cpuc_dtrace_illval = uaddr;
+		return 0;
+	}
+
+	return 1;
+}
+
+void dtrace_copyin_arch(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+			volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copy(uaddr, kaddr, size);
+}
+
+void dtrace_copyout(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		    volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copy(kaddr, uaddr, size);
+}
+
+void dtrace_copyinstr_arch(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+			   volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copystr(uaddr, kaddr, size, flags);
+}
+
+void dtrace_copyoutstr(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		       volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copystr(kaddr, uaddr, size, flags);
+}
+
+#define DTRACE_FUWORD(bits) \
+	uint##bits##_t dtrace_fuword##bits(void *uaddr)			      \
+	{								      \
+		extern uint##bits##_t	dtrace_fuword##bits##_nocheck(void *);\
+									      \
+		if ((uintptr_t)uaddr > _userlimit) {			      \
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);		      \
+			this_cpu_core->cpuc_dtrace_illval = (uintptr_t)uaddr; \
+			return 0;					      \
+		}							      \
+									      \
+		return dtrace_fuword##bits##_nocheck(uaddr);		      \
+	}
+
+DTRACE_FUWORD(8)
+DTRACE_FUWORD(16)
+DTRACE_FUWORD(32)
+DTRACE_FUWORD(64)
+
+uint64_t dtrace_getarg(int argno, int aframes)
+{
+	unsigned long		bp;
+	uint64_t		*st;
+	uint64_t		val;
+	int			i;
+	struct unwind_state	state;
+
+	if (this_cpu_core->cpu_dtrace_regs)
+		bp = this_cpu_core->cpu_dtrace_regs->bp;
+	else {
+		unwind_start(&state, current, NULL, NULL);
+		for (i = 0; !unwind_done(&state) && i < aframes;
+		     unwind_next_frame(&state)) {
+			i++;
+		}
+
+		bp = (unsigned long)state.bp;
+	}
+
+	ASSERT(argno >= 5);
+
+	/*
+	 * The first 5 arguments (arg0 through arg4) are passed in registers
+	 * to dtrace_probe().  The remaining arguments (arg5 through arg9) are
+	 * passed on the stack.
+	 *
+	 * Stack layout:
+	 * bp[0] = pushed bp from caller
+	 * bp[1] = return address
+	 * bp[2] = 6th argument (arg5 -> argno = 5)
+	 * bp[3] = 7th argument (arg6 -> argno = 6)
+	 * ...
+	 */
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	st = (uint64_t *)bp;
+	val = st[2 + (argno - 5)];
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return val;
+}
+
+ulong_t dtrace_getreg(struct task_struct *task, uint_t reg)
+{
+	struct pt_regs	*rp = task_pt_regs(task);
+
+	int	regmap[] = {
+				REG_RBX,	/*  0 -> EBX */
+				REG_RCX,	/*  1 -> ECX */
+				REG_RDX,	/*  2 -> EDX */
+				REG_RSI,	/*  3 -> ESI */
+				REG_RDI,	/*  4 -> EDI */
+				REG_RBP,	/*  5 -> EBP */
+				REG_RAX,	/*  6 -> EAX */
+				REG_DS,		/*  7 -> DS */
+				REG_ES,		/*  8 -> ES */
+				REG_FS,		/*  9 -> FS */
+				REG_GS,		/* 10 -> GS */
+				REG_TRAPNO,	/* 11 -> TRAPNO */
+				REG_RIP,	/* 12 -> EIP */
+				REG_CS,		/* 13 -> CS */
+				REG_RFL,	/* 14 -> EFL */
+				REG_RSP,	/* 15 -> UESP */
+				REG_SS,		/* 16 -> SS */
+			   };
+
+	if (reg > REG_TRAPNO) {
+		/*
+		 * Convert register alias index into register mapping index.
+		 */
+		reg -= REG_TRAPNO + 1;
+
+		if (reg >= sizeof(regmap) / sizeof(int)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			return 0;
+		}
+
+		reg = regmap[reg];
+	}
+
+	/*
+	 * Most common case: direct index into pt_regs structure.
+	 */
+	if (reg <= REG_SS)
+		return (&rp->r15)[reg];
+
+	switch (reg) {
+	case REG_DS:
+		return task->thread.ds;
+	case REG_ES:
+		return task->thread.es;
+	case REG_FS:
+		return task->thread.fsbase;
+	case REG_GS:
+		return task->thread.gsbase;
+	case REG_TRAPNO:
+		return task->thread.trap_nr;
+	default:
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return 0;
+	}
+}
diff --git a/arch/x86/dtrace/fasttrap_x86_64.c b/arch/x86/dtrace/fasttrap_x86_64.c
new file mode 100644
index 000000000000..b7be3f32e109
--- /dev/null
+++ b/arch/x86/dtrace/fasttrap_x86_64.c
@@ -0,0 +1,117 @@
+/*
+ * FILE:	fasttrap_x86_64.c
+ * DESCRIPTION:	DTrace - fasttrap provider implementation for x86
+ *
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/uaccess.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fasttrap_impl.h"
+
+uint64_t fasttrap_usdt_getarg(void *arg, dtrace_id_t id, void *parg,
+			      int argno, int aframes)
+{
+	struct pt_regs	*regs = this_cpu_core->cpu_dtrace_regs;
+	uint64_t	*st;
+	uint64_t	val;
+
+	if (regs == NULL)
+		return 0;
+
+	switch (argno) {
+	case 0:
+		return regs->di;
+	case 1:
+		return regs->si;
+	case 2:
+		return regs->dx;
+	case 3:
+		return regs->cx;
+	case 4:
+		return regs->r8;
+	case 5:
+		return regs->r9;
+	}
+
+	ASSERT(argno > 5);
+
+	st = (uint64_t *)regs->sp;
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	__copy_from_user_inatomic_nocache(&val, (void *)&st[argno - 6],
+					  sizeof(st[0]));
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return val;
+}
+
+static void fasttrap_map_args(fasttrap_probe_t *probe, struct pt_regs *regs,
+			      int argc, uintptr_t *argv)
+{
+	int		i, x, cap = min(argc, (int)probe->ftp_nargs);
+	uintptr_t	*st = (uintptr_t *)regs->sp;
+
+	for (i = 0; i < cap; i++) {
+		switch (x = probe->ftp_argmap[i]) {
+		case 0:
+			argv[i] = regs->di;
+			break;
+		case 1:
+			argv[i] = regs->si;
+			break;
+		case 2:
+			argv[i] = regs->dx;
+			break;
+		case 3:
+			argv[i] = regs->cx;
+			break;
+		case 4:
+			argv[i] = regs->r8;
+			break;
+		case 5:
+			argv[i] = regs->r9;
+			break;
+		default:
+			ASSERT(x > 5);
+
+			__copy_from_user_inatomic_nocache(&argv[i],
+							  (void *)&st[x - 6],
+							  sizeof(st[0]));
+		}
+	}
+
+	while (i < argc)
+		argv[i++] = 0;
+}
+
+void fasttrap_pid_probe_arch(fasttrap_probe_t *ftp, struct pt_regs *regs)
+{
+	if (ftp->ftp_argmap == NULL) {
+		dtrace_probe(ftp->ftp_id, regs->di, regs->si, regs->dx,
+			     regs->cx, regs->r8, regs->r9, 0);
+	} else {
+		uintptr_t	t[6];
+
+		fasttrap_map_args(ftp, regs, sizeof(t) / sizeof(t[0]), t);
+		dtrace_probe(ftp->ftp_id, t[0], t[1], t[2], t[3],
+			     t[4], t[5], 0);
+	}
+}
+
+void fasttrap_set_enabled(struct pt_regs *regs)
+{
+	regs->ax = 1;
+}
+
diff --git a/arch/x86/dtrace/fbt_x86_64.c b/arch/x86/dtrace/fbt_x86_64.c
new file mode 100644
index 000000000000..c0ca13f11925
--- /dev/null
+++ b/arch/x86/dtrace/fbt_x86_64.c
@@ -0,0 +1,153 @@
+/*
+ * FILE:	fbt_x86_64.c
+ * DESCRIPTION:	DTrace - FBT provider implementation for x86
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_fbt.h>
+#include <linux/vmalloc.h>
+#include <asm/dtrace_util.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fbt_impl.h"
+
+/*
+ * Use 0xf0 (LOCK Prefix) and X86_TRAP_UD for Invalid Opcode traps to be used.
+ * Use 0xcc (INT 3) and X86_TRAP_BP for Breakpoint traps to be used.
+ */
+#define FBT_ENTRY_PATCHVAL		0xcc
+#define FBT_ENTRY_TRAP			X86_TRAP_BP
+#define FBT_RETURN_PATCHVAL		0xcc
+#define FBT_RETURN_TRAP			X86_TRAP_BP
+
+static uint8_t fbt_invop(struct pt_regs *regs)
+{
+	fbt_probe_t	*fbp = fbt_probetab[FBT_ADDR2NDX(regs->ip)];
+
+	for (; fbp != NULL; fbp = fbp->fbp_hashnext) {
+		if ((uintptr_t)fbp->fbp_patchpoint == regs->ip) {
+			this_cpu_core->cpu_dtrace_regs = regs;
+			if (fbp->fbp_roffset == 0) {
+				dtrace_probe(fbp->fbp_id, regs->di, regs->si,
+					     regs->dx, regs->cx, regs->r8,
+					     regs->r9, 0);
+			} else {
+				dtrace_probe(fbp->fbp_id, fbp->fbp_roffset,
+					     regs->ax, 0, 0, 0, 0, 0);
+			}
+
+			this_cpu_core->cpu_dtrace_regs = NULL;
+
+			return fbp->fbp_rval;
+		}
+	}
+
+	return 0;
+}
+
+uint64_t fbt_getarg(void *arg, dtrace_id_t id, void *parg, int argno,
+		    int aframes)
+{
+	struct pt_regs  *regs = this_cpu_core->cpu_dtrace_regs;
+	uint64_t	*st;
+	uint64_t	val;
+
+	if (regs == NULL)
+		return 0;
+
+	switch (argno) {
+	case 0:
+		return regs->di;
+	case 1:
+		return regs->si;
+	case 2:
+		return regs->dx;
+	case 3:
+		return regs->cx;
+	case 4:
+		return regs->r8;
+	case 5:
+		return regs->r9;
+	}
+
+	ASSERT(argno > 5);
+
+	st = (uint64_t *)regs->sp;
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	/*
+	 * Skip the topmost slot of the stack because that holds the return
+	 * address for the call to the function we are entering.  At this point
+	 * the BP has not been pushed yet, so we are still working within the
+	 * caller's stack frame.
+	 */
+	val = st[1 + argno - 6];
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return val;
+}
+
+void fbt_provide_probe_arch(fbt_probe_t *fbp, int type, int stype)
+{
+	fbp->fbp_patchval = type == FBT_ENTRY ? FBT_ENTRY_PATCHVAL
+					      : FBT_RETURN_PATCHVAL;
+	fbp->fbp_savedval = *fbp->fbp_patchpoint;
+	fbp->fbp_rval = type == FBT_ENTRY ? DTRACE_INVOP_PUSH_BP
+					  : DTRACE_INVOP_RET;
+}
+
+int fbt_can_patch_return_arch(asm_instr_t *addr)
+{
+	return 1;
+}
+
+int fbt_provide_module_arch(void *arg, struct module *mp)
+{
+	return 1;
+}
+
+void fbt_destroy_module(void *arg, struct module *mp)
+{
+}
+
+void fbt_enable_arch(fbt_probe_t *fbp, dtrace_id_t id, void *arg)
+{
+	dtrace_invop_enable(fbp->fbp_patchpoint, fbp->fbp_patchval);
+}
+
+void fbt_disable_arch(fbt_probe_t *fbp, dtrace_id_t id, void *arg)
+{
+	dtrace_invop_disable(fbp->fbp_patchpoint, fbp->fbp_savedval);
+}
+
+int fbt_dev_init_arch(void)
+{
+	fbt_probetab_mask = fbt_probetab_size - 1;
+	fbt_probetab = dtrace_vzalloc_try(fbt_probetab_size *
+					  sizeof (fbt_probe_t *));
+
+	if (fbt_probetab == NULL)
+		return -ENOMEM;
+
+	return dtrace_invop_add(fbt_invop);
+}
+
+void fbt_dev_exit_arch(void)
+{
+	vfree(fbt_probetab);
+	fbt_probetab_mask = 0;
+	fbt_probetab_size = 0;
+
+	dtrace_invop_remove(fbt_invop);
+}
diff --git a/arch/x86/dtrace/include/dtrace/fasttrap_arch.h b/arch/x86/dtrace/include/dtrace/fasttrap_arch.h
new file mode 100644
index 000000000000..8a00fbde8c4a
--- /dev/null
+++ b/arch/x86/dtrace/include/dtrace/fasttrap_arch.h
@@ -0,0 +1,27 @@
+/*
+ * Dynamic Tracing for Linux - Fasttrap provider implementation defines
+ *
+ * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _X86_64_FASTTRAP_ARCH_H
+#define _X86_64_FASTTRAP_ARCH_H
+
+#define FASTTRAP_OFFSET_AFRAMES	3
+
+#endif /* _X86_64_FASTTRAP_ARCH_H */
diff --git a/arch/x86/dtrace/include/dtrace/fbt_arch.h b/arch/x86/dtrace/include/dtrace/fbt_arch.h
new file mode 100644
index 000000000000..e79984b7b59a
--- /dev/null
+++ b/arch/x86/dtrace/include/dtrace/fbt_arch.h
@@ -0,0 +1,42 @@
+/*
+ * Dynamic Tracing for Linux - FBT Implementation defines
+ *
+ * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _X86_64_FBT_ARCH_H
+#define _X86_64_FBT_ARCH_H
+
+#define FBT_AFRAMES	7
+
+typedef struct fbt_probe {
+        char			*fbp_name;	/* name of probe */
+        dtrace_id_t		fbp_id;		/* probe ID */
+        struct module		*fbp_module;	/* defining module */
+        int			fbp_loadcnt;	/* load count for module */
+        int			fbp_primary;	/* non-zero if primary mod */
+        asm_instr_t		*fbp_patchpoint;/* patch point */
+        asm_instr_t		fbp_patchval;	/* instruction to patch */
+        asm_instr_t		fbp_savedval;	/* saved instruction value */
+	uintptr_t		fbp_roffset;	/* relative offset */
+        int			fbp_rval;
+        struct fbt_probe	*fbp_next;	/* next probe */
+        struct fbt_probe	*fbp_hashnext;	/* next on hash */
+} fbt_probe_t;
+
+#endif /* _X86_64_FBT_ARCH_H */
diff --git a/arch/x86/dtrace/include/dtrace/sdt_arch.h b/arch/x86/dtrace/include/dtrace/sdt_arch.h
new file mode 100644
index 000000000000..da9cc5c801d2
--- /dev/null
+++ b/arch/x86/dtrace/include/dtrace/sdt_arch.h
@@ -0,0 +1,27 @@
+/*
+ * Dynamic Tracing for Linux - SDT Implementation defines
+ *
+ * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _X86_64_SDT_ARCH_H
+#define _X86_64_SDT_ARCH_H
+
+#define SDT_AFRAMES	4
+
+#endif /* _X86_64_SDT_ARCH_H */
diff --git a/arch/x86/dtrace/sdt_x86_64.c b/arch/x86/dtrace/sdt_x86_64.c
new file mode 100644
index 000000000000..7c6a761d7e81
--- /dev/null
+++ b/arch/x86/dtrace/sdt_x86_64.c
@@ -0,0 +1,122 @@
+/*
+ * FILE:	sdt_dev.c
+ * DESCRIPTION:	DTrace - SDT provider implementation for x86
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/sdt.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/dtrace_util.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "sdt_impl.h"
+
+#define SDT_PATCHVAL		0xf0
+
+static uint8_t sdt_invop(struct pt_regs *regs)
+{
+	sdt_probe_t	*sdt = sdt_probetab[SDT_ADDR2NDX(regs->ip)];
+
+	for (; sdt != NULL; sdt = sdt->sdp_hashnext) {
+		if ((uintptr_t)sdt->sdp_patchpoint == regs->ip) {
+			if (sdt->sdp_ptype == SDTPT_IS_ENABLED)
+				regs->ax = 1;
+			else {
+				this_cpu_core->cpu_dtrace_regs = regs;
+
+				dtrace_probe(sdt->sdp_id, regs->di, regs->si,
+					     regs->dx, regs->cx, regs->r8,
+					     regs->r9, 0);
+
+				this_cpu_core->cpu_dtrace_regs = NULL;
+			}
+
+			return DTRACE_INVOP_NOPS;
+		}
+	}
+
+	return 0;
+}
+
+void sdt_provide_probe_arch(sdt_probe_t *sdp, struct module *mp, int idx)
+{
+	sdp->sdp_patchval = SDT_PATCHVAL;
+	sdp->sdp_savedval = *sdp->sdp_patchpoint;
+}
+
+int sdt_provide_module_arch(void *arg, struct module *mp)
+{
+	return 1;
+}
+
+void sdt_destroy_module(void *arg, struct module *mp)
+{
+}
+
+void sdt_enable_arch(sdt_probe_t *sdp, dtrace_id_t id, void *arg)
+{
+	dtrace_invop_enable(sdp->sdp_patchpoint, sdp->sdp_patchval);
+}
+
+void sdt_disable_arch(sdt_probe_t *sdp, dtrace_id_t id, void *arg)
+{
+	dtrace_invop_disable(sdp->sdp_patchpoint, sdp->sdp_savedval);
+}
+
+uint64_t sdt_getarg(void *arg, dtrace_id_t id, void *parg, int argno,
+		    int aframes)
+{
+	struct pt_regs  *regs = this_cpu_core->cpu_dtrace_regs;
+	uint64_t	*st;
+	uint64_t	val;
+
+	if (regs == NULL)
+		return 0;
+
+	switch (argno) {
+	case 0:
+		return regs->di;
+	case 1:
+		return regs->si;
+	case 2:
+		return regs->dx;
+	case 3:
+		return regs->cx;
+	case 4:
+		return regs->r8;
+	case 5:
+		return regs->r9;
+	}
+
+	ASSERT(argno > 5);
+
+	st = (uint64_t *)regs->sp;
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	val = st[argno - 6];
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return val;
+}
+
+int sdt_dev_init_arch(void)
+{
+	return dtrace_invop_add(sdt_invop);
+}
+
+void sdt_dev_exit_arch(void)
+{
+	dtrace_invop_remove(sdt_invop);
+}
diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S
index 68a2d76e4f8f..14f1baca7ee5 100644
--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@ -38,6 +38,7 @@
 #include <asm/export.h>
 #include <asm/frame.h>
 #include <asm/nospec-branch.h>
+#include <asm/dtrace_util.h>
 #include <linux/err.h>
 
 #include "calling.h"
@@ -911,6 +912,11 @@ ENTRY(\sym)
 	addq	$EXCEPTION_STKSZ, CPU_TSS_IST(\shift_ist)
 	.endif
 
+#ifdef CONFIG_DTRACE
+	test %rax,%rax
+	jnz dtrace_error_exit
+#endif
+
 	/* these procedures expect "no swapgs" flag in ebx */
 	.if \paranoid
 	jmp	paranoid_exit
@@ -943,6 +949,151 @@ ENTRY(\sym)
 END(\sym)
 .endm
 
+#ifdef CONFIG_DTRACE
+ENTRY(dtrace_error_exit)
+	UNWIND_HINT_REGS
+	DISABLE_INTERRUPTS(CLBR_NONE)
+	TRACE_IRQS_OFF
+
+	/*
+	 * The iretq could re-enable interrupts:
+	 */
+	TRACE_IRQS_IRETQ
+
+	negq %rax
+
+	cmpl $DTRACE_INVOP_MOV_RSP_RBP,%eax
+	je dtrace_emu_mov
+	cmpl $DTRACE_INVOP_PUSH_BP,%eax
+	je dtrace_emu_push
+	cmpl $DTRACE_INVOP_LEAVE,%eax
+	je dtrace_emu_leave
+	cmpl $DTRACE_INVOP_NOP,%eax
+	je dtrace_emu_nop
+	cmpl $DTRACE_INVOP_RET,%eax
+	je dtrace_emu_ret
+
+	leaq dtrace_error_msg(%rip),%rdi
+	movq %rax,%rsi
+	movq (%rsp),%rdx
+	call printk
+
+	POP_REGS
+	addq	$8, %rsp	/* skip regs->orig_ax */
+	jmp dtrace_retint_kernel
+
+dtrace_emu_mov:
+	POP_REGS
+	addq	$8, %rsp	/* skip regs->orig_ax */
+
+	/* Emulate "mov %rsp, %rbp" instruction. */
+	pushq %rax			/* push temp */
+	movq 8(%rsp),%rax		/* load calling RIP */
+	addq $3,%rax			/* increment over trapping instr */
+	movq %rax,8(%rsp)		/* store calling RIP */
+	movq 32(%rsp),%rbp		/* load %rsp into %rbp */
+	popq %rax			/* pop off temp */
+
+	jmp dtrace_retint_kernel
+
+dtrace_emu_push:
+	POP_REGS
+	addq	$8, %rsp	/* skip regs->orig_ax */
+
+	/*
+	 * Emulate a "pushq %rbp" instruction.  We need to move the stack down
+	 * to make room for the extra address getting pushed.
+	 */
+	subq $16,%rsp			/* make room for %rbp */
+	pushq %rax			/* push temp */
+	movq 24(%rsp),%rax		/* load calling RIP */
+	addq $1,%rax			/* increment over trapping instr */
+	movq %rax,8(%rsp)		/* store calling RIP */
+	movq 32(%rsp),%rax		/* load calling CS */
+	movq %rax,16(%rsp)		/* store calling CS */
+	movq 40(%rsp),%rax		/* load calling RFLAGS */
+	movq %rax,24(%rsp)		/* store calling RFLAGS */
+	movq 48(%rsp),%rax		/* load calling RSP */
+	subq $8,%rax			/* make room for %rbp */
+	movq %rax,32(%rsp)		/* store calling RSP */
+	movq 56(%rsp),%rax		/* load calling SS */
+	movq %rax,40(%rsp)		/* store calling SS */
+	movq 32(%rsp),%rax		/* reload calling RSP */
+	movq %rbp,(%rax)		/* store %rbp there */
+	popq %rax			/* pop off temp */
+
+	jmp dtrace_retint_kernel
+
+dtrace_emu_nop:
+	POP_REGS
+	addq	$8, %rsp	/* skip regs->orig_ax */
+
+	/* Emulate a "nop" instruction. */
+	incq (%rsp)
+
+	jmp dtrace_retint_kernel
+
+dtrace_emu_leave:
+	POP_REGS
+	addq	$8, %rsp	/* skip regs->orig_ax */
+
+	/*
+	 * Emulate a "leave" instruction.  This is equivalent to the sequence:
+	 *	movq %rbp,%rsp
+	 *	popq %rbp
+	 * We can use the fact that on x86_64 %rsp is saved explicitly, so we
+	 * do not need to move any data around.
+	 */
+	pushq %rax			/* push temp */
+	movq 8(%rsp),%rax		/* load calling RIP */
+	addq $1,%rax			/* increment over trapping instr */
+	movq %rax,8(%rsp)		/* store calling RIP */
+	movq (%rbp),%rax		/* get new %rbp */
+	addq $8,%rbp			/* adjust new %rsp */
+	movq %rbp,32(%rsp)		/* store new %rsp */
+	movq %rax,%rbp			/* set new %rbp */
+	popq %rax			/* pop off temp */
+
+	jmp dtrace_retint_kernel
+
+dtrace_emu_ret:
+	POP_REGS
+	addq	$8, %rsp	/* skip regs->orig_ax */
+
+	/* Emulate a "ret" instruction. */
+	pushq %rax			/* push temp */
+	movq 32(%rsp),%rax		/* load %rsp */
+	movq (%rax),%rax		/* load calling RIP */
+	movq %rax,8(%rsp)		/* store calling RIP */
+	addq $8,32(%rsp)		/* adjust new %rsp */
+	popq %rax			/* pop off temp */
+
+	/* fallthrough */
+
+dtrace_retint_kernel:
+
+#ifdef CONFIG_PREEMPT
+	/* Interrupts are off */
+	/* Check if we need preemption */
+	bt      $9,2*8(%rsp) /* interrupts were off? (EFLAGS) */
+	jnc     1f
+0:      cmpl    $0,PER_CPU_VAR(__preempt_count)
+	jnz     1f
+	call    preempt_schedule_irq
+	jmp     0b
+1:
+#endif
+
+	INTERRUPT_RETURN
+
+END(dtrace_error_exit)
+
+.pushsection .rodata, "a"
+dtrace_error_msg:
+	.asciz "DTRACE: non-zero (%x) return from trap at %x\n"
+.popsection
+#endif
+
 idtentry divide_error			do_divide_error			has_error_code=0
 idtentry overflow			do_overflow			has_error_code=0
 idtentry bounds				do_bounds			has_error_code=0
@@ -1102,7 +1253,7 @@ idtentry stack_segment		do_stack_segment	has_error_code=1
 #ifdef CONFIG_XEN
 idtentry xennmi			do_nmi			has_error_code=0
 idtentry xendebug		do_debug		has_error_code=0
-idtentry xenint3		do_int3			has_error_code=0
+idtentry xenint3		do_int3			has_error_code=0	paranoid=1 shift_ist=DEBUG_STACK
 #endif
 
 idtentry general_protection	do_general_protection	has_error_code=1
diff --git a/arch/x86/entry/syscall_32.c b/arch/x86/entry/syscall_32.c
index 95c294963612..7c7e0c4a2783 100644
--- a/arch/x86/entry/syscall_32.c
+++ b/arch/x86/entry/syscall_32.c
@@ -15,7 +15,11 @@
 
 extern asmlinkage long sys_ni_syscall(unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long);
 
+#if defined(CONFIG_DT_SYSTRACE) || defined(CONFIG_DT_SYSTRACE_MODULE)
+__visible sys_call_ptr_t ia32_sys_call_table[__NR_syscall_compat_max+1] = {
+#else
 __visible const sys_call_ptr_t ia32_sys_call_table[__NR_syscall_compat_max+1] = {
+#endif /* CONFIG_DT_SYSTRACE || CONFIG_DT_SYSTRACE_MODULE */
 	/*
 	 * Smells like a compiler bug -- it doesn't work
 	 * when the & below is removed.
diff --git a/arch/x86/entry/syscall_64.c b/arch/x86/entry/syscall_64.c
index c176d2fab1da..42c235054b52 100644
--- a/arch/x86/entry/syscall_64.c
+++ b/arch/x86/entry/syscall_64.c
@@ -15,7 +15,11 @@
 
 extern long sys_ni_syscall(unsigned long, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long);
 
+#if defined(CONFIG_DT_SYSTRACE) || defined(CONFIG_DT_SYSTRACE_MODULE)
+asmlinkage sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
+#else
 asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
+#endif /* CONFIG_DT_SYSTRACE || CONFIG_DT_SYSTRACE_MODULE */
 	/*
 	 * Smells like a compiler bug -- it doesn't work
 	 * when the & below is removed.
diff --git a/arch/x86/entry/syscalls/syscall_32.tbl b/arch/x86/entry/syscalls/syscall_32.tbl
index 448ac2161112..88dd649522e3 100644
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@ -391,3 +391,6 @@
 382	i386	pkey_free		sys_pkey_free
 383	i386	statx			sys_statx
 384	i386	arch_prctl		sys_arch_prctl			compat_sys_arch_prctl
+# This one is a temporary number, designed for no clashes.
+# Nothing but DTrace should use it.
+473    i386    waitfd                  sys_waitfd
diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 5aef183e2f85..a138ac50f3a5 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -339,6 +339,9 @@
 330	common	pkey_alloc		sys_pkey_alloc
 331	common	pkey_free		sys_pkey_free
 332	common	statx			sys_statx
+# This one is a temporary number, designed for no clashes.
+# Nothing but DTrace should use it.
+473	common	waitfd			sys_waitfd
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/arch/x86/include/asm/dtrace_arch.h b/arch/x86/include/asm/dtrace_arch.h
new file mode 100644
index 000000000000..df7e74e0125d
--- /dev/null
+++ b/arch/x86/include/asm/dtrace_arch.h
@@ -0,0 +1,30 @@
+/* Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved. */
+
+#ifndef _X86_DTRACE_ARCH_H
+#define _X86_DTRACE_ARCH_H
+
+/* Number of argumens stored inside the mstate. */
+#define	DTRACE_MSTATE_ARGS_MAX		6
+
+typedef uint8_t		asm_instr_t;
+
+#define ASM_CALL_SIZE			5
+
+typedef int (*prov_exit_f)(void);
+
+/*
+ * Structure to hold DTrace specific information about modules (including the
+ * core kernel module).  Note that each module (and the main kernel) already
+ * has three fields that relate to probing:
+ *	- sdt_probes: description of SDT probes in the module
+ *	- sdt_probec: number of SDT probes in the module
+ *	- pdata: pointer to a dtrace_module struct (for DTrace)
+ */
+typedef struct dtrace_module {
+	int             enabled_cnt;
+	size_t          sdt_probe_cnt;
+	size_t          fbt_probe_cnt;
+	prov_exit_f	prov_exit;
+} dtrace_module_t;
+
+#endif /* _X86_DTRACE_ARCH_H */
diff --git a/arch/x86/include/asm/dtrace_cpuinfo.h b/arch/x86/include/asm/dtrace_cpuinfo.h
new file mode 100644
index 000000000000..68ce09ccd764
--- /dev/null
+++ b/arch/x86/include/asm/dtrace_cpuinfo.h
@@ -0,0 +1,12 @@
+/* Copyright (C) 2013-2014 Oracle, Inc. */
+
+#ifndef _ASM_X86_DTRACE_CPUINFO_H_
+#define _ASM_X86_DTRACE_CPUINFO_H_
+
+#include <asm/processor.h>
+
+typedef struct cpuinfo_x86	cpuinfo_arch_t;
+
+#define dtrace_cpuinfo_chip(ci)	((ci)->phys_proc_id)
+
+#endif /* _ASM_X86_DTRACE_CPUINFO_H_ */
diff --git a/arch/x86/include/asm/dtrace_sdt_arch.h b/arch/x86/include/asm/dtrace_sdt_arch.h
new file mode 100644
index 000000000000..692ab7278369
--- /dev/null
+++ b/arch/x86/include/asm/dtrace_sdt_arch.h
@@ -0,0 +1,9 @@
+/* Copyright (C) 2016 Oracle, Inc. */
+
+#ifndef _X86_DTRACE_SDT_ARCH_H
+#define _X86_DTRACE_SDT_ARCH_H
+
+#define __DTRACE_SDT_ISENABLED_PROTO void
+#define __DTRACE_SDT_ISENABLED_ARGS
+
+#endif /* _X86_DTRACE_SDT_ARCH_H */
diff --git a/arch/x86/include/asm/dtrace_syscall.h b/arch/x86/include/asm/dtrace_syscall.h
new file mode 100644
index 000000000000..402826562478
--- /dev/null
+++ b/arch/x86/include/asm/dtrace_syscall.h
@@ -0,0 +1,3 @@
+/*
+ * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ */
diff --git a/arch/x86/include/asm/dtrace_util.h b/arch/x86/include/asm/dtrace_util.h
new file mode 100644
index 000000000000..8abd9420a4b3
--- /dev/null
+++ b/arch/x86/include/asm/dtrace_util.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _X86_DTRACE_UTIL_H
+#define _X86_DTRACE_UTIL_H
+
+#define DTRACE_INVOP_NOPS		0x0f	/* 5-byte NOP sequence */
+#define DTRACE_INVOP_MOV_RSP_RBP	0x48	/* mov %rsp, %rbp = 48 89 e5 */
+#define DTRACE_INVOP_PUSH_BP		0x55	/* push %rbp = 55 */
+#define DTRACE_INVOP_NOP		0x90	/* nop = 90 */
+#define DTRACE_INVOP_LEAVE		0xc9	/* leave = c9 */
+#define DTRACE_INVOP_RET		0xc3	/* ret = c3 */
+
+#ifndef __ASSEMBLY__
+
+#include <asm/dtrace_arch.h>
+#include <asm/ptrace.h>
+
+extern int dtrace_invop_add(uint8_t (*func)(struct pt_regs *));
+extern void dtrace_invop_remove(uint8_t (*func)(struct pt_regs *));
+
+extern void dtrace_invop_enable(asm_instr_t *, asm_instr_t);
+extern void dtrace_invop_disable(asm_instr_t *, asm_instr_t);
+
+extern int dtrace_user_addr_is_exec(uintptr_t);
+
+#endif
+
+#endif /* _X86_DTRACE_UTIL_H */
diff --git a/arch/x86/include/asm/mce.h b/arch/x86/include/asm/mce.h
index b1e8d8db921f..3c7a10977602 100644
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@ -293,8 +293,8 @@ extern void mce_disable_bank(int bank);
  */
 
 /* Call the installed machine check handler for this CPU setup. */
-extern void (*machine_check_vector)(struct pt_regs *, long error_code);
-void do_machine_check(struct pt_regs *, long);
+extern int (*machine_check_vector)(struct pt_regs *, long error_code);
+int do_machine_check(struct pt_regs *, long);
 
 /*
  * Threshold handler
diff --git a/arch/x86/include/asm/spinlock.h b/arch/x86/include/asm/spinlock.h
index b34625796eb2..415d71fe0604 100644
--- a/arch/x86/include/asm/spinlock.h
+++ b/arch/x86/include/asm/spinlock.h
@@ -9,6 +9,7 @@
 #include <linux/compiler.h>
 #include <asm/paravirt.h>
 #include <asm/bitops.h>
+#include <linux/sdt.h>
 
 /*
  * Your basic SMP spinlocks, allowing only a single CPU anywhere
diff --git a/arch/x86/include/asm/syscall.h b/arch/x86/include/asm/syscall.h
index 03eedc21246d..8be275ee00c7 100644
--- a/arch/x86/include/asm/syscall.h
+++ b/arch/x86/include/asm/syscall.h
@@ -23,7 +23,11 @@
 typedef asmlinkage long (*sys_call_ptr_t)(unsigned long, unsigned long,
 					  unsigned long, unsigned long,
 					  unsigned long, unsigned long);
+#if defined(CONFIG_DT_SYSTRACE) || defined(CONFIG_DT_SYSTRACE_MODULE)
+extern sys_call_ptr_t sys_call_table[];
+#else
 extern const sys_call_ptr_t sys_call_table[];
+#endif
 
 #if defined(CONFIG_X86_32)
 #define ia32_sys_call_table sys_call_table
@@ -32,8 +36,12 @@ extern const sys_call_ptr_t sys_call_table[];
 #endif
 
 #if defined(CONFIG_IA32_EMULATION)
+#if defined(CONFIG_DT_SYSTRACE) || defined(CONFIG_DT_SYSTRACE_MODULE)
+extern sys_call_ptr_t ia32_sys_call_table[];
+#else
 extern const sys_call_ptr_t ia32_sys_call_table[];
 #endif
+#endif
 
 /*
  * Only the low 32 bits of orig_ax are meaningful, so we return int.
diff --git a/arch/x86/include/asm/text-patching.h b/arch/x86/include/asm/text-patching.h
index 2ecd34e2d46c..4bc0cc3b127e 100644
--- a/arch/x86/include/asm/text-patching.h
+++ b/arch/x86/include/asm/text-patching.h
@@ -18,6 +18,7 @@ static inline void apply_paravirt(struct paravirt_patch_site *start,
 #define __parainstructions_end	NULL
 #endif
 
+extern void add_nops(void *insns, unsigned int len);
 extern void *text_poke_early(void *addr, const void *opcode, size_t len);
 
 /*
diff --git a/arch/x86/include/asm/traps.h b/arch/x86/include/asm/traps.h
index 3de69330e6c5..787c76bc1b32 100644
--- a/arch/x86/include/asm/traps.h
+++ b/arch/x86/include/asm/traps.h
@@ -61,32 +61,32 @@ asmlinkage void xen_machine_check(void);
 asmlinkage void xen_simd_coprocessor_error(void);
 #endif
 
-dotraplinkage void do_divide_error(struct pt_regs *, long);
-dotraplinkage void do_debug(struct pt_regs *, long);
-dotraplinkage void do_nmi(struct pt_regs *, long);
-dotraplinkage void do_int3(struct pt_regs *, long);
-dotraplinkage void do_overflow(struct pt_regs *, long);
-dotraplinkage void do_bounds(struct pt_regs *, long);
-dotraplinkage void do_invalid_op(struct pt_regs *, long);
-dotraplinkage void do_device_not_available(struct pt_regs *, long);
-dotraplinkage void do_coprocessor_segment_overrun(struct pt_regs *, long);
-dotraplinkage void do_invalid_TSS(struct pt_regs *, long);
-dotraplinkage void do_segment_not_present(struct pt_regs *, long);
-dotraplinkage void do_stack_segment(struct pt_regs *, long);
+dotraplinkage int do_divide_error(struct pt_regs *, long);
+dotraplinkage int do_debug(struct pt_regs *, long);
+dotraplinkage int do_nmi(struct pt_regs *, long);
+dotraplinkage int do_int3(struct pt_regs *, long);
+dotraplinkage int do_overflow(struct pt_regs *, long);
+dotraplinkage int do_bounds(struct pt_regs *, long);
+dotraplinkage int do_invalid_op(struct pt_regs *, long);
+dotraplinkage int do_device_not_available(struct pt_regs *, long);
+dotraplinkage int do_coprocessor_segment_overrun(struct pt_regs *, long);
+dotraplinkage int do_invalid_TSS(struct pt_regs *, long);
+dotraplinkage int do_segment_not_present(struct pt_regs *, long);
+dotraplinkage int do_stack_segment(struct pt_regs *, long);
 #ifdef CONFIG_X86_64
-dotraplinkage void do_double_fault(struct pt_regs *, long);
+dotraplinkage int do_double_fault(struct pt_regs *, long);
 #endif
-dotraplinkage void do_general_protection(struct pt_regs *, long);
-dotraplinkage void do_page_fault(struct pt_regs *, unsigned long);
-dotraplinkage void do_spurious_interrupt_bug(struct pt_regs *, long);
-dotraplinkage void do_coprocessor_error(struct pt_regs *, long);
-dotraplinkage void do_alignment_check(struct pt_regs *, long);
+dotraplinkage int do_general_protection(struct pt_regs *, long);
+dotraplinkage int do_page_fault(struct pt_regs *, unsigned long);
+dotraplinkage int do_spurious_interrupt_bug(struct pt_regs *, long);
+dotraplinkage int do_coprocessor_error(struct pt_regs *, long);
+dotraplinkage int do_alignment_check(struct pt_regs *, long);
 #ifdef CONFIG_X86_MCE
-dotraplinkage void do_machine_check(struct pt_regs *, long);
+dotraplinkage int do_machine_check(struct pt_regs *, long);
 #endif
-dotraplinkage void do_simd_coprocessor_error(struct pt_regs *, long);
+dotraplinkage int do_simd_coprocessor_error(struct pt_regs *, long);
 #ifdef CONFIG_X86_32
-dotraplinkage void do_iret_error(struct pt_regs *, long);
+dotraplinkage int do_iret_error(struct pt_regs *, long);
 #endif
 dotraplinkage void do_mce(struct pt_regs *, long);
 
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index b034826a0b3b..c4d57ff70b19 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -245,7 +245,7 @@ void __init arch_init_ideal_nops(void)
 }
 
 /* Use this to add nops to a buffer, then text_poke the whole buffer. */
-static void __init_or_module add_nops(void *insns, unsigned int len)
+void __init_or_module add_nops(void *insns, unsigned int len)
 {
 	while (len > 0) {
 		unsigned int noplen = len;
diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c
index 73237aa271ea..99ca01b18166 100644
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@ -1111,7 +1111,7 @@ static void mce_unmap_kpfn(unsigned long pfn)
  * MCE broadcast. However some CPUs might be broken beyond repair,
  * so be always careful when synchronizing with others.
  */
-void do_machine_check(struct pt_regs *regs, long error_code)
+int do_machine_check(struct pt_regs *regs, long error_code)
 {
 	struct mca_config *cfg = &mca_cfg;
 	struct mce m, *final;
@@ -1164,7 +1164,7 @@ void do_machine_check(struct pt_regs *regs, long error_code)
 		mcgstatus = mce_rdmsrl(MSR_IA32_MCG_STATUS);
 		if (mcgstatus & MCG_STATUS_RIPV) {
 			mce_wrmsrl(MSR_IA32_MCG_STATUS, 0);
-			return;
+			return 0;
 		}
 	}
 
@@ -1326,6 +1326,7 @@ void do_machine_check(struct pt_regs *regs, long error_code)
 
 out_ist:
 	ist_exit(regs);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(do_machine_check);
 
@@ -1783,14 +1784,15 @@ static void __mcheck_cpu_init_timer(void)
 }
 
 /* Handle unconfigured int18 (should never happen) */
-static void unexpected_machine_check(struct pt_regs *regs, long error_code)
+static int unexpected_machine_check(struct pt_regs *regs, long error_code)
 {
 	pr_err("CPU#%d: Unexpected int18 (Machine Check)\n",
 	       smp_processor_id());
+	return 0;
 }
 
 /* Call the installed machine check handler for this CPU setup. */
-void (*machine_check_vector)(struct pt_regs *, long error_code) =
+int (*machine_check_vector)(struct pt_regs *, long error_code) =
 						unexpected_machine_check;
 
 dotraplinkage void do_mce(struct pt_regs *regs, long error_code)
diff --git a/arch/x86/kernel/dtrace_fbt.c b/arch/x86/kernel/dtrace_fbt.c
new file mode 100644
index 000000000000..2d7ed6efb4a8
--- /dev/null
+++ b/arch/x86/kernel/dtrace_fbt.c
@@ -0,0 +1,175 @@
+/*
+ * FILE:        dtrace_fbt.c
+ * DESCRIPTION: Dynamic Tracing: FBT registration code (arch-specific)
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <linux/kernel.h>
+#include <linux/kallsyms.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_fbt.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <asm/insn.h>
+#include <asm/sections.h>
+
+#define FBT_MOV_RSP_RBP_1	0x48
+#define FBT_MOV_RSP_RBP_2	0x89
+#define FBT_MOV_RSP_RBP_3	0xe5
+#define FBT_PUSHL_EBP		0x55
+#define FBT_NOP			0x90
+#define FBT_RET_IMM16		0xc2
+#define FBT_RET			0xc3
+#define FBT_LEAVE		0xc9
+
+#define BL_SENTRY(tp, nm)	extern tp nm;
+#define BL_DENTRY(tp, nm)
+#include "fbt_blacklist.h"
+#undef BL_DENTRY
+#undef BL_SENTRY
+
+static void
+dtrace_fbt_populate_bl(void)
+{
+#define	BL_SENTRY(tp, nm)	dtrace_fbt_bl_add((unsigned long)&nm, __stringify(nm));
+#define BL_DENTRY(tp, nm)	dtrace_fbt_bl_add(0, __stringify(nm));
+#include "fbt_blacklist.h"
+#undef BL_SENTRY
+#undef BL_DENTRY
+}
+
+void dtrace_fbt_init(fbt_add_probe_fn fbt_add_probe, struct module *mp,
+		     void *arg)
+{
+	loff_t			pos;
+	struct kallsym_iter	sym;
+	asm_instr_t		*paddr = NULL;
+	dt_fbt_bl_entry_t	*blent = NULL;
+
+	/*
+	 * Look up any unresolved symbols in the blacklist, and sort the list
+	 * by ascending address.
+	 */
+	dtrace_fbt_populate_bl();
+	blent = dtrace_fbt_bl_first();
+
+	pos = 0;
+	kallsyms_iter_reset(&sym, 0);
+	while (kallsyms_iter_update(&sym, pos++)) {
+		asm_instr_t	*addr, *end;
+		int		state = 0, insc = 0;
+		void		*fbtp = NULL;
+
+		/*
+		 * There is no point considering non-function symbols for FBT,
+		 * or symbols that have a zero size.  We could consider weak
+		 * symbols but that gets quite complicated and there is no
+		 * demands for that (so far).
+		 */
+		if (sym.type != 'T' && sym.type != 't')
+			continue;
+		if (!sym.size)
+			continue;
+
+		/*
+		 * Handle only symbols that belong to the module we have been
+		 * asked for.
+		 */
+		if (mp == dtrace_kmod && !core_kernel_text(sym.value))
+			continue;
+
+		/*
+		 * Ensure we have not been given .init symbol from kallsyms
+		 * interface. This could lead to memory corruption once DTrace
+		 * tries to enable probe in already freed memory.
+		 */
+		if (mp != dtrace_kmod && !within_module_core(sym.value, mp))
+			continue;
+
+		/*
+		 * See if the symbol is on the FBT's blacklist.  Since both
+		 * iterators are workng in sort order by ascending address we
+		 * can use concurrent traversal.
+		 */
+		while (blent != NULL &&
+		       dtrace_fbt_bl_entry_addr(blent) < sym.value) {
+			blent = dtrace_fbt_bl_next(blent);
+		}
+		if (dtrace_fbt_bl_entry_addr(blent) == sym.value)
+			continue;
+
+		/*
+		 * No FBT tracing for DTrace functions, and functions that are
+		 * crucial to probe processing.
+		 * Also weed out symbols that are not relevant here.
+		 */
+		if (strncmp(sym.name, "dtrace_", 7) == 0)
+			continue;
+		if (strncmp(sym.name, "insn_", 5) == 0)
+			continue;
+		if (strncmp(sym.name, "inat_", 5) == 0)
+			continue;
+		if (strncmp(sym.name, "_GLOBAL_", 8) == 0)
+			continue;
+		if (strncmp(sym.name, "do_", 3) == 0)
+			continue;
+		if (strncmp(sym.name, "xen_", 4) == 0)
+			continue;
+
+		addr = (asm_instr_t *)sym.value;
+		end = (asm_instr_t *)(sym.value + sym.size);
+
+		/*
+		 * FIXME:
+		 * When there are multiple symbols for the same address, we
+		 * should link them together as probes associated with the
+		 * same function.  When a probe for that function is triggered
+		 * all associated probes should fire.
+		 *
+		 * For now, we ignore duplicates.
+		 */
+		if (addr == paddr)
+			continue;
+		paddr = addr;
+
+		while (addr < end) {
+			struct insn	insn;
+
+			insc++;
+
+			switch (state) {
+			case 0:	/* start of function */
+				if (*addr == FBT_PUSHL_EBP) {
+					fbt_add_probe(
+						mp, sym.name,
+						FBT_ENTRY, *addr, addr, 0,
+						NULL, arg);
+					state = 1;
+				} else if (insc > 10)
+					state = 2;
+				break;
+			case 1: /* look for ret */
+				if (*addr == FBT_RET) {
+					uintptr_t	off;
+
+					off = addr - (asm_instr_t *)sym.value;
+					fbtp = fbt_add_probe(
+						mp, sym.name,
+						FBT_RETURN, *addr, addr, off,
+						fbtp, arg);
+				}
+				break;
+			}
+
+			if (state == 2)
+				break;
+
+			kernel_insn_init(&insn, addr, MAX_INSN_SIZE);
+			insn_get_length(&insn);
+
+			addr += insn.length;
+		}
+	}
+}
+EXPORT_SYMBOL(dtrace_fbt_init);
diff --git a/arch/x86/kernel/dtrace_sdt.c b/arch/x86/kernel/dtrace_sdt.c
new file mode 100644
index 000000000000..fb6abcae8260
--- /dev/null
+++ b/arch/x86/kernel/dtrace_sdt.c
@@ -0,0 +1,74 @@
+/*
+ * FILE:        dtrace_sdt.c
+ * DESCRIPTION: Dynamic Tracing: SDT registration code (arch-specific)
+ *
+ * Copyright (C) 2010-2016 Oracle Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/dtrace_os.h>
+#include <linux/sdt.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/nmi.h>
+#include <asm/nops.h>
+#include <asm/dtrace_arch.h>
+#include <asm/text-patching.h>
+
+static uint8_t nops[ASM_CALL_SIZE];
+static uint8_t movs[ASM_CALL_SIZE];
+
+#define DT_OP_REX_RAX           0x48
+#define DT_OP_XOR_EAX_0         0x33
+#define DT_OP_XOR_EAX_1         0xc0
+
+/* This code is based on apply_alternatives and text_poke_early.  It needs to
+ * run before SMP is initialized in order to avoid SMP problems with patching
+ * code that might be accessed on another CPU.
+ */
+void __init_or_module dtrace_sdt_nop_multi(asm_instr_t **addrs,
+					   int *is_enabled, int cnt)
+{
+	int			i;
+	asm_instr_t		*addr;
+	unsigned long		flags;
+
+	stop_nmi();
+	local_irq_save(flags);
+
+	for (i = 0; i < cnt; i++) {
+		addr = addrs[i];
+		if (likely(!is_enabled[i]))
+			memcpy(addr, nops, sizeof(nops));
+		else
+			memcpy(addr, movs, sizeof(movs));
+	}
+
+	sync_core();
+	local_irq_restore(flags);
+	restart_nmi();
+}
+
+void dtrace_sdt_init_arch(void)
+{
+	/*
+	 * A little unusual, but potentially necessary.  While we could use a
+	 * single NOP sequence of length ASM_CALL_SIZE, we need to consider the
+	 * fact that when a SDT probe point is enabled, a single invalid opcode
+	 * is written on the first byte of this NOP sequence.  By using a
+	 * sequence of a 1-byte NOP, followed by a (ASM_CALL_SIZE - 1) byte NOP
+	 * sequence, we play it pretty safe.
+	 */
+	add_nops(nops, 1);
+	add_nops(nops + 1, ASM_CALL_SIZE - 1);
+
+	/*
+	 * Is-enabled probe points contain an "xor %rax, %rax" when disabled.
+	 */
+	movs[0] = DT_OP_REX_RAX;
+	movs[1] = DT_OP_XOR_EAX_0;
+	movs[2] = DT_OP_XOR_EAX_1;
+	add_nops(movs + 3, ASM_CALL_SIZE - 3);
+}
diff --git a/arch/x86/kernel/dtrace_syscall.c b/arch/x86/kernel/dtrace_syscall.c
new file mode 100644
index 000000000000..84502d61c210
--- /dev/null
+++ b/arch/x86/kernel/dtrace_syscall.c
@@ -0,0 +1,100 @@
+/*
+ * FILE:	dtrace_syscall.c
+ * DESCRIPTION:	Dynamic Tracing: system call tracing support (arch-specific)
+ *
+ * Copyright (C) 2010-2014 Oracle Corporation
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_syscall.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/namei.h>
+#include <linux/sched.h>
+#include <asm/insn.h>
+#include <asm/stacktrace.h>
+#include <asm/syscalls.h>
+
+/*---------------------------------------------------------------------------*\
+(* SYSTEM CALL TRACING SUPPORT                                               *)
+\*---------------------------------------------------------------------------*/
+void (*systrace_probe)(dtrace_id_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t,
+		       uintptr_t, uintptr_t, uintptr_t);
+
+void systrace_stub(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
+		   uintptr_t arg2, uintptr_t arg3, uintptr_t arg4,
+		   uintptr_t arg5, uintptr_t arg6)
+{
+}
+
+asmlinkage long systrace_syscall(uintptr_t, uintptr_t, uintptr_t, uintptr_t,
+				 uintptr_t, uintptr_t, uintptr_t);
+
+asmlinkage long dtrace_stub_ptregs(uintptr_t, uintptr_t, uintptr_t, uintptr_t,
+				   uintptr_t, uintptr_t, uintptr_t);
+
+static systrace_info_t	systrace_info =
+		{
+			&systrace_probe,
+			systrace_stub,
+			systrace_syscall,
+			{
+#define DTRACE_SYSCALL_STUB(id, name) \
+				[SCE_##id] dtrace_stub_ptregs,
+#include <asm/dtrace_syscall.h>
+			},
+			{
+#define __SYSCALL_64(nr, sym, compat)		[nr] { __stringify(sym), },
+#define __SYSCALL_COMMON(nr, sym, compat)	__SYSCALL_64(nr, sym, compat)
+#define __SYSCALL_X32(nt, sym, compat)
+#include <asm/syscalls_64.h>
+			}
+		};
+
+
+asmlinkage long systrace_syscall(uintptr_t arg0, uintptr_t arg1,
+				 uintptr_t arg2, uintptr_t arg3,
+				 uintptr_t arg4, uintptr_t arg5,
+				 uintptr_t arg6)
+{
+	long			rc = 0;
+	unsigned long		sysnum;
+	dtrace_id_t		id;
+	dtrace_syscalls_t	*sc;
+
+	sysnum = syscall_get_nr(current, current_pt_regs());
+	sc = &systrace_info.sysent[sysnum];
+
+	if ((id = sc->stsy_entry) != DTRACE_IDNONE)
+		(*systrace_probe)(id, arg0, arg1, arg2, arg3, arg4, arg5,
+				  arg6);
+
+	/*
+	 * FIXME: Add stop functionality for DTrace.
+	 */
+
+	if (sc->stsy_underlying != NULL)
+		rc = (*sc->stsy_underlying)(arg0, arg1, arg2, arg3, arg4, arg5,
+					    arg6);
+
+	if ((id = sc->stsy_return) != DTRACE_IDNONE)
+		(*systrace_probe)(id, (uintptr_t)rc, (uintptr_t)rc,
+				  (uintptr_t)((uint64_t)rc >> 32), 0, 0, 0, 0);
+
+	return rc;
+}
+
+systrace_info_t *dtrace_syscalls_init() {
+	int			i;
+
+	for (i = 0; i < NR_syscalls; i++) {
+		systrace_info.sysent[i].stsy_tblent =
+					(dt_sys_call_t *)&sys_call_table[i];
+		systrace_info.sysent[i].stsy_underlying =
+					(dt_sys_call_t)sys_call_table[i];
+	}
+
+	return &systrace_info;
+}
+EXPORT_SYMBOL(dtrace_syscalls_init);
diff --git a/arch/x86/kernel/dtrace_syscall_stubs.S b/arch/x86/kernel/dtrace_syscall_stubs.S
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/arch/x86/kernel/dtrace_util.c b/arch/x86/kernel/dtrace_util.c
new file mode 100644
index 000000000000..08305422ad65
--- /dev/null
+++ b/arch/x86/kernel/dtrace_util.c
@@ -0,0 +1,441 @@
+/*
+ * FILE:	dtrace_util.c
+ * DESCRIPTION:	Dynamic Tracing: Architecture utility functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/kdebug.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/memory.h>
+#include <linux/notifier.h>
+#include <linux/ptrace.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/sched/task_stack.h>
+#include <asm/insn.h>
+#include <asm/pgtable.h>
+#include <asm/ptrace.h>
+#include <asm/text-patching.h>
+#include <asm/dtrace_arch.h>
+#include <asm/dtrace_util.h>
+
+/*
+ * Move the instruction pointer forward to the next instruction, effectiely
+ * skipping the current one.
+ */
+void dtrace_skip_instruction(struct pt_regs *regs) {
+	struct insn		insn;
+
+	kernel_insn_init(&insn, (void *)regs->ip, MAX_INSN_SIZE);
+	insn_get_length(&insn);
+
+	regs->ip += insn.length;
+}
+
+void dtrace_handle_badaddr(struct pt_regs *regs) {
+	unsigned long	addr = read_cr2();
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+	this_cpu_core->cpuc_dtrace_illval = addr;
+
+	dtrace_skip_instruction(regs);
+}
+
+typedef struct dtrace_invop_hdlr {
+	uint8_t				(*dtih_func)(struct pt_regs *);
+	struct dtrace_invop_hdlr	*dtih_next;
+} dtrace_invop_hdlr_t;
+
+static dtrace_invop_hdlr_t	*dtrace_invop_hdlrs;
+
+#if 1
+# define INVOP_TRAP_INSTR	0xf0
+#else
+# define INVOP_TRAP_INSTR	0xcc
+#endif
+
+/*
+ * Trap notification handler.
+ */
+int dtrace_die_notifier(struct notifier_block *nb, unsigned long val,
+			void *args)
+{
+	struct die_args		*dargs = args;
+	int			orig_trapnr = 0;
+
+	switch (val) {
+	case DIE_PAGE_FAULT: {
+		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
+			return NOTIFY_DONE;
+
+		dtrace_handle_badaddr(dargs->regs);
+
+		return NOTIFY_OK | NOTIFY_STOP_MASK;
+	}
+	case DIE_GPF: {
+		/*
+		 * This gets messy...  For one, some versions of Xen deliver
+		 * the invalid opcode generated by the LOCK prefix (0xf0) as a
+		 * GP fault rather than a UD fault.  So, we need to figure out
+		 * whether the GP we're processing here is one of those
+		 * misreported faults.
+		 *
+		 * But, it is possible that the instruction that caused the
+		 * fault (0xf0) gets overwritten by a different CPU with the
+		 * original valid opcode before we get to look at it here,
+		 * which makes it kind of hard to recognize.
+		 *
+		 * So...  we're going to assume that a GP fault that gets
+		 * triggered for the LOCK prefix opcode (0xf0) *or* for an
+		 * opcode that can get overwritten with the LOCK prefix for
+		 * probing is actually a UD fault.
+		 *
+		 * If we are wrong, the handlers will simply see a fault that
+		 * isn't theirs, and return without consuming it.  And in that
+		 * case, the kernel will report a UD fault that may have been
+		 * a real GP fault...  Sorry.
+		 */
+		asm_instr_t	opc = *(asm_instr_t *)dargs->regs->ip;
+
+		if (opc != 0xf0 && opc != 0x55 && opc != 0xc3) {
+			if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
+				return NOTIFY_DONE;
+
+			dtrace_handle_badaddr(dargs->regs);
+
+			return NOTIFY_OK | NOTIFY_STOP_MASK;
+		}
+
+		/*
+		 * ... and instead treat them as the SDT probe point traps that
+		 * they are.
+		 */
+		orig_trapnr = dargs->trapnr;
+		dargs->trapnr = 6;
+	}
+	case DIE_TRAP: {
+		dtrace_invop_hdlr_t	*hdlr;
+		int			rval = 0;
+
+		if (dargs->trapnr != 6)
+			return NOTIFY_DONE;
+
+		for (hdlr = dtrace_invop_hdlrs; hdlr != NULL;
+		     hdlr = hdlr->dtih_next) {
+			if ((rval = hdlr->dtih_func(dargs->regs)) != 0)
+				break;
+		}
+
+		switch (rval) {
+		case DTRACE_INVOP_NOPS:
+			/*
+			 * SDT probe points are encoded as either:
+			 *   - a 1-byte NOP followed by a multi-byte NOP
+			 *   - a multi-byte code sequence (to set AX to 0),
+			 *     followed by a multi-byte NOP
+			 * In both cases, the total length of the probe point
+			 * instruction is ASM_CALL_SITE bytes, so we can safely
+			 * skip that number of bytes here.
+			 */
+			dargs->regs->ip += ASM_CALL_SIZE;
+			return NOTIFY_OK | NOTIFY_STOP_MASK;
+		case DTRACE_INVOP_MOV_RSP_RBP:
+		case DTRACE_INVOP_NOP:
+		case DTRACE_INVOP_PUSH_BP:
+		case DTRACE_INVOP_RET:
+			return notifier_from_errno(-rval);
+		default:
+			/*
+			 * This must not have been a trap triggered from a
+			 * probe point.  Let someone else deal with it...
+			 *
+			 * If we got here because of a GPF that we thought
+			 * was a UD (due to a bug in some versions of Xen),
+			 * undo our change to dargs->trapnr.
+			 */
+			if (unlikely(orig_trapnr))
+				dargs->trapnr = orig_trapnr;
+
+			return NOTIFY_DONE;
+		}
+	}
+	case DIE_INT3: {
+		dtrace_invop_hdlr_t	*hdlr;
+		int			rval = 0;
+
+		/*
+		 * Let's assume that this is a DTrace probe firing, so we need
+		 * to adjust the IP (to be consistent with #UD processing) so
+		 * that it reflects the address of the #BP rather than the
+		 * following intruction.
+		 *
+		 * If it turns out that this was not DTrace related, we'll have
+		 * to reverse this adjustment.
+		 */
+		dargs->regs->ip--;
+		for (hdlr = dtrace_invop_hdlrs; hdlr != NULL;
+		     hdlr = hdlr->dtih_next) {
+			rval = hdlr->dtih_func(dargs->regs);
+			if (rval != 0)
+				break;
+		}
+
+		switch (rval) {
+		case DTRACE_INVOP_NOPS:
+			/*
+			 * SDT probe points are encoded as either:
+			 *   - a 1-byte NOP followed by a multi-byte NOP
+			 *   - a multi-byte code sequence (to set AX to 0),
+			 *     followed by a multi-byte NOP
+			 * In both cases, the total length of the probe point
+			 * instruction is ASM_CALL_SITE bytes, so we can safely
+			 * skip that number of bytes here.
+			 */
+			dargs->regs->ip += ASM_CALL_SIZE;
+			return NOTIFY_OK | NOTIFY_STOP_MASK;
+		case DTRACE_INVOP_MOV_RSP_RBP:
+		case DTRACE_INVOP_NOP:
+		case DTRACE_INVOP_PUSH_BP:
+		case DTRACE_INVOP_RET:
+			return notifier_from_errno(-rval);
+		default:
+			/*
+			 * This must not have been a trap triggered from a
+			 * probe point.  Re-adjust the instruction pointer
+			 * and let someone else deal with it...
+			 */
+			dargs->regs->ip++;
+		}
+	}
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+/*
+ * Add an INVOP trap handler.
+ */
+int dtrace_invop_add(uint8_t (*func)(struct pt_regs *))
+{
+	dtrace_invop_hdlr_t	*hdlr;
+
+	hdlr = kmalloc(sizeof(dtrace_invop_hdlr_t), GFP_KERNEL);
+	if (hdlr == NULL) {
+		pr_warn("Failed to add invop handler: out of memory\n");
+		return -ENOMEM;
+	}
+
+	hdlr->dtih_func = func;
+	hdlr->dtih_next = dtrace_invop_hdlrs;
+	dtrace_invop_hdlrs = hdlr;
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_invop_add);
+
+/*
+ * Remove an INVOP trap handler.
+ */
+void dtrace_invop_remove(uint8_t (*func)(struct pt_regs *))
+{
+	dtrace_invop_hdlr_t	*hdlr = dtrace_invop_hdlrs, *prev = NULL;
+
+	for (;;) {
+		if (hdlr == NULL)
+			return;
+
+		if (hdlr->dtih_func == func)
+			break;
+
+		prev = hdlr;
+		hdlr = hdlr->dtih_next;
+	}
+
+	if (prev == NULL) {
+		dtrace_invop_hdlrs = hdlr->dtih_next;
+	} else
+		prev->dtih_next = hdlr->dtih_next;
+
+	kfree(hdlr);
+}
+EXPORT_SYMBOL(dtrace_invop_remove);
+
+/*
+ * Enable an INVOP-based probe, i.e. ensure that an INVOP trap is triggered at
+ * the specified address.
+ */
+void dtrace_invop_enable(asm_instr_t *addr, asm_instr_t opcode)
+{
+	mutex_lock(&text_mutex);
+	text_poke(addr, ((unsigned char []){opcode}), 1);
+	mutex_unlock(&text_mutex);
+}
+EXPORT_SYMBOL(dtrace_invop_enable);
+
+/*
+ * Disable an INVOP-based probe.
+ */
+void dtrace_invop_disable(asm_instr_t *addr, asm_instr_t opcode)
+{
+	mutex_lock(&text_mutex);
+	text_poke(addr, ((unsigned char []){opcode}), 1);
+	mutex_unlock(&text_mutex);
+}
+EXPORT_SYMBOL(dtrace_invop_disable);
+
+static inline int dtrace_bad_address(void *addr)
+{
+	unsigned long	dummy;
+
+	return probe_kernel_address((unsigned long *)addr, dummy);
+}
+
+int dtrace_user_addr_is_exec(uintptr_t addr)
+{
+	struct mm_struct	*mm = current->mm;
+	pgd_t			*pgd;
+
+#if CONFIG_PGTABLE_LEVELS > 3
+	p4d_t			*p4d;
+#endif
+
+	pud_t			*pud;
+	pmd_t			*pmd;
+	pte_t			*pte;
+	unsigned long		flags;
+	int			ret = 0;
+
+	if (mm == NULL)
+		return 0;
+
+	addr &= PAGE_MASK;
+
+	local_irq_save(flags);
+
+	pgd = pgd_offset(mm, addr);
+	if (dtrace_bad_address(pgd))
+		goto out;
+	if (pgd_none(*pgd) || !pgd_present(*pgd))
+		goto out;
+
+#if CONFIG_PGTABLE_LEVELS > 3
+	p4d = p4d_offset(pgd, addr);
+	if (dtrace_bad_address(p4d))
+		goto out;
+	if (p4d_none(*p4d) || !p4d_present(*p4d))
+		goto out;
+
+	pud = pud_offset(p4d, addr);
+#else
+	pud = pud_offset(pgd, addr);
+#endif
+
+	if (dtrace_bad_address(pud))
+		goto out;
+	if (pud_none(*pud) || !pud_present(*pud))
+		goto out;
+	if (unlikely(pud_large(*pud))) {
+		pte = (pte_t *)pud;
+		if (dtrace_bad_address(pte))
+			goto out;
+
+		ret = pte_exec(*pte);
+		goto out;
+	}
+
+	pmd = pmd_offset(pud, addr);
+	if (dtrace_bad_address(pmd))
+		goto out;
+	if (pmd_none(*pmd))
+		goto out;
+	if (unlikely(pmd_large(*pmd) || !pmd_present(*pmd))) {
+		pte = (pte_t *)pmd;
+		if (dtrace_bad_address(pte))
+			goto out;
+
+		ret = pte_exec(*pte);
+		goto out;
+	}
+
+	pte = pte_offset_map(pmd, addr);
+	if (dtrace_bad_address(pte))
+		goto out;
+	if (pte_protnone(*pte))
+		goto out;
+	if ((pte_flags(*pte) & (_PAGE_PRESENT|_PAGE_USER|_PAGE_SPECIAL)) !=
+	    (_PAGE_PRESENT|_PAGE_USER))
+		goto out;
+
+	ret = pte_exec(*pte);
+
+out:
+	local_irq_restore(flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(dtrace_user_addr_is_exec);
+
+void dtrace_user_stacktrace(stacktrace_state_t *st)
+{
+	struct pt_regs		*regs = current_pt_regs();
+	uint64_t		*pcs = st->pcs;
+	int			limit = st->limit;
+	unsigned long		*bos;
+	unsigned long		*sp = (unsigned long *)user_stack_pointer(regs);
+	int			ret;
+
+	if (!user_mode(regs))
+		goto out;
+
+	if (!current->dtrace_psinfo)
+		goto out;
+
+	bos = current->dtrace_psinfo->ustack;
+
+	st->depth = 1;
+	if (pcs)
+		*pcs++ = (uint64_t)instruction_pointer(regs);
+	limit--;
+
+	if (!limit)
+		goto out;
+
+	while (sp <= bos && limit) {
+		unsigned long	pc;
+
+		pagefault_disable();
+		ret = __copy_from_user_inatomic(&pc, sp, sizeof(pc));
+		pagefault_enable();
+
+		if (ret)
+			break;
+
+		if (dtrace_user_addr_is_exec(pc)) {
+			if (pcs)
+				*pcs++ = pc;
+			limit--;
+			st->depth++;
+		}
+
+		sp++;
+	}
+
+out:
+	if (pcs) {
+		while (limit--)
+			*pcs++ = 0;
+	}
+}
+
+void dtrace_mod_pdata_init(dtrace_module_t *pdata)
+{
+}
+
+void dtrace_mod_pdata_cleanup(dtrace_module_t *pdata)
+{
+}
diff --git a/arch/x86/kernel/fbt_blacklist.h b/arch/x86/kernel/fbt_blacklist.h
new file mode 100644
index 000000000000..aa56bcf386c1
--- /dev/null
+++ b/arch/x86/kernel/fbt_blacklist.h
@@ -0,0 +1,84 @@
+/*
+ * Functions used in die notifier chain calling.
+ */
+BL_SENTRY(void *, notify_die)
+BL_DENTRY(void *, notifier_call_chain)
+BL_SENTRY(typeof(__atomic_notifier_call_chain), __atomic_notifier_call_chain)
+BL_SENTRY(typeof(atomic_notifier_call_chain), atomic_notifier_call_chain)
+BL_SENTRY(typeof(__raw_notifier_call_chain), __raw_notifier_call_chain)
+BL_SENTRY(typeof(raw_notifier_call_chain), raw_notifier_call_chain)
+BL_DENTRY(void *, hw_breakpoint_exceptions_notify)
+BL_DENTRY(void *, kprobe_exceptions_notify)
+
+/*
+ * Functions used to update vtime in probe context.
+ */
+BL_SENTRY(typeof(ktime_get_raw_fast_ns), ktime_get_raw_fast_ns)
+BL_DENTRY(void *, raw_read_seqcount)
+BL_DENTRY(void *, read_seqcount_retry)
+BL_DENTRY(void *, __read_seqcount_retry)
+
+/* xen_clocksource */
+BL_DENTRY(void *, xen_clocksource_get_cycles)
+BL_DENTRY(void *, xen_clocksource_read)
+BL_DENTRY(void *, pvclock_clocksource_read)
+BL_DENTRY(void *, pvclock_touch_watchdogs)
+BL_DENTRY(void *, touch_softlockup_watchdog_sync)
+BL_DENTRY(void *, clocksource_touch_watchdog)
+BL_DENTRY(void *, clocksource_resume_watchdog)
+BL_DENTRY(void *, reset_hung_task_detector)
+/* clocksource_tsc */
+BL_DENTRY(void *, read_tsc)
+BL_DENTRY(void *, get_cycles)
+/* clocksource_hpet */
+BL_DENTRY(void *, read_hpet)
+BL_DENTRY(void *, hpet_readl)
+/* kvm_clock */
+BL_DENTRY(void *, kvm_clock_get_cycles)
+BL_DENTRY(void *, kvm_clock_read)
+
+/*
+ * Functions used in trap handling.
+ */
+BL_DENTRY(void *, fixup_exception)
+BL_DENTRY(void *, paranoid_entry)
+BL_DENTRY(void *, kgdb_ll_trap)
+BL_DENTRY(void *, error_entry)
+BL_DENTRY(void *, xen_int3)
+BL_DENTRY(void *, ftrace_int3_handler)
+BL_DENTRY(typeof(poke_int3_handler), poke_int3_handler)
+BL_DENTRY(void *, fixup_bad_iret)
+BL_DENTRY(void *, xen_adjust_exception_frame)
+BL_DENTRY(void *, paravirt_nop)
+BL_DENTRY(void *, ist_enter)
+BL_DENTRY(void *, rcu_nmi_enter)
+BL_DENTRY(void *, rcu_dynticks_curr_cpu_in_eqs)
+BL_DENTRY(void *, rcu_dynticks_eqs_exit)
+BL_DENTRY(void *, rcu_nmi_exit)
+BL_DENTRY(void *, rcu_dynticks_eqs_enter)
+BL_DENTRY(void *, ist_exit)
+
+/*
+ * Functions used in page fault handling.
+ */
+BL_SENTRY(void *, do_page_fault)
+BL_DENTRY(void *, __do_page_fault)
+BL_DENTRY(void *, down_read_trylock)
+BL_DENTRY(void *, __get_user_pages_fast)
+BL_DENTRY(void *, gup_pud_range)
+BL_DENTRY(void *, gup_huge_pud)
+BL_DENTRY(void *, gup_pmd_range)
+BL_DENTRY(void *, gup_huge_pmd)
+BL_DENTRY(void *, gup_pte_range)
+BL_DENTRY(void *, pte_mfn_to_pfn)
+
+/*
+ * Functions used under 4.12 idr_find
+ */
+BL_DENTRY(void *, find_next_bit)
+BL_DENTRY(void *, _find_next_bit)
+BL_DENTRY(void *, radix_tree_lookup)
+BL_DENTRY(void *, __radix_tree_lookup)
+BL_DENTRY(void *, radix_tree_load_root)
+BL_DENTRY(void *, radix_tree_descend)
+BL_DENTRY(void *, is_sibling_entry)
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index a94de09edbed..2f7654c80ae8 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -263,7 +263,7 @@ u32 kvm_read_and_reset_pf_reason(void)
 EXPORT_SYMBOL_GPL(kvm_read_and_reset_pf_reason);
 NOKPROBE_SYMBOL(kvm_read_and_reset_pf_reason);
 
-dotraplinkage void
+dotraplinkage int
 do_async_page_fault(struct pt_regs *regs, unsigned long error_code)
 {
 	enum ctx_state prev_state;
@@ -284,6 +284,8 @@ do_async_page_fault(struct pt_regs *regs, unsigned long error_code)
 		rcu_irq_exit();
 		break;
 	}
+
+	return 0;
 }
 NOKPROBE_SYMBOL(do_async_page_fault);
 
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index 35aafc95e4b8..b8b84f61fabc 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -489,12 +489,12 @@ static DEFINE_PER_CPU(unsigned long, nmi_cr2);
 static DEFINE_PER_CPU(int, update_debug_stack);
 #endif
 
-dotraplinkage notrace void
+dotraplinkage notrace int
 do_nmi(struct pt_regs *regs, long error_code)
 {
 	if (this_cpu_read(nmi_state) != NMI_NOT_RUNNING) {
 		this_cpu_write(nmi_state, NMI_LATCHED);
-		return;
+		return 0;
 	}
 	this_cpu_write(nmi_state, NMI_EXECUTING);
 	this_cpu_write(nmi_cr2, read_cr2());
@@ -533,6 +533,7 @@ do_nmi(struct pt_regs *regs, long error_code)
 		write_cr2(this_cpu_read(nmi_cr2));
 	if (this_cpu_dec_return(nmi_state))
 		goto nmi_restart;
+	return 0;
 }
 NOKPROBE_SYMBOL(do_nmi);
 
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index a66428dc92ae..d8c2bf4bb2bc 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -281,10 +281,11 @@ do_trap(int trapnr, int signr, char *str, struct pt_regs *regs,
 }
 NOKPROBE_SYMBOL(do_trap);
 
-static void do_error_trap(struct pt_regs *regs, long error_code, char *str,
-			  unsigned long trapnr, int signr)
+static int do_error_trap(struct pt_regs *regs, long error_code, char *str,
+			 unsigned long trapnr, int signr)
 {
 	siginfo_t info;
+	int ret;
 
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
 
@@ -293,20 +294,21 @@ static void do_error_trap(struct pt_regs *regs, long error_code, char *str,
 	 * notifier chain.
 	 */
 	if (!user_mode(regs) && fixup_bug(regs, trapnr))
-		return;
+		return 0;
 
-	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=
-			NOTIFY_STOP) {
+	ret = notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr);
+	if ((ret & NOTIFY_STOP_MASK) != NOTIFY_STOP_MASK) {
 		cond_local_irq_enable(regs);
 		do_trap(trapnr, signr, str, regs, error_code,
 			fill_trap_info(regs, signr, trapnr, &info));
 	}
+	return notifier_to_errno(ret);
 }
 
 #define DO_ERROR(trapnr, signr, str, name)				\
-dotraplinkage void do_##name(struct pt_regs *regs, long error_code)	\
+dotraplinkage int do_##name(struct pt_regs *regs, long error_code)	\
 {									\
-	do_error_trap(regs, error_code, str, trapnr, signr);		\
+	return do_error_trap(regs, error_code, str, trapnr, signr);	\
 }
 
 DO_ERROR(X86_TRAP_DE,     SIGFPE,  "divide error",		divide_error)
@@ -335,7 +337,7 @@ __visible void __noreturn handle_stack_overflow(const char *message,
 
 #ifdef CONFIG_X86_64
 /* Runs on IST stack */
-dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
+dotraplinkage int do_double_fault(struct pt_regs *regs, long error_code)
 {
 	static const char str[] = "double fault";
 	struct task_struct *tsk = current;
@@ -385,7 +387,7 @@ dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
 		regs->ip = (unsigned long)general_protection;
 		regs->sp = (unsigned long)&gpregs->orig_ax;
 
-		return;
+		return 0;
 	}
 #endif
 
@@ -447,10 +449,12 @@ dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)
 	 */
 	for (;;)
 		die(str, regs, error_code);
+
+	return 0;
 }
 #endif
 
-dotraplinkage void do_bounds(struct pt_regs *regs, long error_code)
+dotraplinkage int do_bounds(struct pt_regs *regs, long error_code)
 {
 	const struct mpx_bndcsr *bndcsr;
 	siginfo_t *info;
@@ -458,7 +462,7 @@ dotraplinkage void do_bounds(struct pt_regs *regs, long error_code)
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
 	if (notify_die(DIE_TRAP, "bounds", regs, error_code,
 			X86_TRAP_BR, SIGSEGV) == NOTIFY_STOP)
-		return;
+		return 0;
 	cond_local_irq_enable(regs);
 
 	if (!user_mode(regs))
@@ -515,7 +519,7 @@ dotraplinkage void do_bounds(struct pt_regs *regs, long error_code)
 		die("bounds", regs, error_code);
 	}
 
-	return;
+	return 0;
 
 exit_trap:
 	/*
@@ -526,12 +530,14 @@ dotraplinkage void do_bounds(struct pt_regs *regs, long error_code)
 	 * time..
 	 */
 	do_trap(X86_TRAP_BR, SIGSEGV, "bounds", regs, error_code, NULL);
+	return 0;
 }
 
-dotraplinkage void
+dotraplinkage int
 do_general_protection(struct pt_regs *regs, long error_code)
 {
 	struct task_struct *tsk;
+	int ret = 0;
 
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
 	cond_local_irq_enable(regs);
@@ -539,20 +545,21 @@ do_general_protection(struct pt_regs *regs, long error_code)
 	if (v8086_mode(regs)) {
 		local_irq_enable();
 		handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
-		return;
+		return 0;
 	}
 
 	tsk = current;
 	if (!user_mode(regs)) {
 		if (fixup_exception(regs, X86_TRAP_GP))
-			return;
+			return 0;
 
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_nr = X86_TRAP_GP;
-		if (notify_die(DIE_GPF, "general protection fault", regs, error_code,
-			       X86_TRAP_GP, SIGSEGV) != NOTIFY_STOP)
+		ret = notify_die(DIE_GPF, "general protection fault", regs,
+					 error_code, X86_TRAP_GP, SIGSEGV);
+		if ((ret & NOTIFY_STOP_MASK) != NOTIFY_STOP_MASK)
 			die("general protection fault", regs, error_code);
-		return;
+		return notifier_to_errno(ret);
 	}
 
 	tsk->thread.error_code = error_code;
@@ -568,12 +575,14 @@ do_general_protection(struct pt_regs *regs, long error_code)
 	}
 
 	force_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);
+	return 0;
 }
 NOKPROBE_SYMBOL(do_general_protection);
 
 /* May run on IST stack. */
-dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)
+dotraplinkage int notrace do_int3(struct pt_regs *regs, long error_code)
 {
+	int ret = 0;
 #ifdef CONFIG_DYNAMIC_FTRACE
 	/*
 	 * ftrace must be first, everything else may cause a recursive crash.
@@ -581,10 +590,10 @@ dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)
 	 */
 	if (unlikely(atomic_read(&modifying_ftrace_code)) &&
 	    ftrace_int3_handler(regs))
-		return;
+		return 0;
 #endif
 	if (poke_int3_handler(regs))
-		return;
+		return 0;
 
 	ist_enter(regs);
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
@@ -599,9 +608,12 @@ dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)
 		goto exit;
 #endif
 
-	if (notify_die(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,
-			SIGTRAP) == NOTIFY_STOP)
+	ret = notify_die(DIE_INT3, "int3", regs, error_code, X86_TRAP_BP,
+			 SIGTRAP);
+	if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK) {
+		ret = notifier_to_errno(ret);
 		goto exit;
+	}
 
 	/*
 	 * Let others (NMI) know that the debug stack is in use
@@ -614,6 +626,7 @@ dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)
 	debug_stack_usage_dec();
 exit:
 	ist_exit(regs);
+	return ret;
 }
 NOKPROBE_SYMBOL(do_int3);
 
@@ -710,7 +723,7 @@ static bool is_sysenter_singlestep(struct pt_regs *regs)
  *
  * May run on IST stack.
  */
-dotraplinkage void do_debug(struct pt_regs *regs, long error_code)
+dotraplinkage int do_debug(struct pt_regs *regs, long error_code)
 {
 	struct task_struct *tsk = current;
 	int user_icebp = 0;
@@ -811,6 +824,7 @@ dotraplinkage void do_debug(struct pt_regs *regs, long error_code)
 
 exit:
 	ist_exit(regs);
+	return 0;
 }
 NOKPROBE_SYMBOL(do_debug);
 
@@ -860,26 +874,29 @@ static void math_error(struct pt_regs *regs, int error_code, int trapnr)
 	force_sig_info(SIGFPE, &info, task);
 }
 
-dotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)
+dotraplinkage int do_coprocessor_error(struct pt_regs *regs, long error_code)
 {
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
 	math_error(regs, error_code, X86_TRAP_MF);
+	return 0;
 }
 
-dotraplinkage void
+dotraplinkage int
 do_simd_coprocessor_error(struct pt_regs *regs, long error_code)
 {
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), "entry code didn't wake RCU");
 	math_error(regs, error_code, X86_TRAP_XF);
+	return 0;
 }
 
-dotraplinkage void
+dotraplinkage int
 do_spurious_interrupt_bug(struct pt_regs *regs, long error_code)
 {
 	cond_local_irq_enable(regs);
+	return 0;
 }
 
-dotraplinkage void
+dotraplinkage int
 do_device_not_available(struct pt_regs *regs, long error_code)
 {
 	unsigned long cr0;
@@ -894,7 +911,7 @@ do_device_not_available(struct pt_regs *regs, long error_code)
 
 		info.regs = regs;
 		math_emulate(&info);
-		return;
+		return 0;
 	}
 #endif
 
@@ -911,6 +928,7 @@ do_device_not_available(struct pt_regs *regs, long error_code)
 		 */
 		die("unexpected #NM exception", regs, error_code);
 	}
+	return 0;
 }
 NOKPROBE_SYMBOL(do_device_not_available);
 
diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S
index 9b138a06c1a4..1eb744cac068 100644
--- a/arch/x86/kernel/vmlinux.lds.S
+++ b/arch/x86/kernel/vmlinux.lds.S
@@ -395,7 +395,8 @@ INIT_PER_CPU(irq_stack_union);
 /*
  * Build-time check on the image size:
  */
-. = ASSERT((_end - _text <= KERNEL_IMAGE_SIZE),
+. = ASSERT(((_end < _text) ? (_end < KERNEL_IMAGE_SIZE)
+			   : (_end - _text <= KERNEL_IMAGE_SIZE)),
 	   "kernel image bigger than KERNEL_IMAGE_SIZE");
 
 #ifdef CONFIG_SMP
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 9150fe2c9b26..6710998b93f1 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -16,6 +16,7 @@
 #include <linux/prefetch.h>		/* prefetchw			*/
 #include <linux/context_tracking.h>	/* exception_enter(), ...	*/
 #include <linux/uaccess.h>		/* faulthandler_disabled()	*/
+#include <linux/dtrace_os.h>		/* dtrace_no_pf			*/
 
 #include <asm/cpufeature.h>		/* boot_cpu_has, ...		*/
 #include <asm/traps.h>			/* dotraplinkage, ...		*/
@@ -784,6 +785,16 @@ no_context(struct pt_regs *regs, unsigned long error_code,
 	    (((unsigned long)tsk->stack - 1 - address < PAGE_SIZE) ||
 	     address - ((unsigned long)tsk->stack + THREAD_SIZE) < PAGE_SIZE)) {
 		unsigned long stack = this_cpu_read(orig_ist.ist[DOUBLEFAULT_STACK]) - sizeof(void *);
+
+		/*
+		 * Allow for the possibility that we know what we are doing and
+		 * ignore this fault.  E.g. the address may come from a source
+		 * we cannot trust and it is OK if we cannot access it.
+		 */
+		 if (notify_die(DIE_PAGE_FAULT, "page fault", regs, error_code,
+				14, SIGKILL) == NOTIFY_STOP)
+			return;
+
 		/*
 		 * We're likely to be running with very little stack space
 		 * left.  It's plausible that we'd hit this condition but
@@ -824,8 +835,13 @@ no_context(struct pt_regs *regs, unsigned long error_code,
 
 	/*
 	 * Oops. The kernel tried to access some bad page. We'll have to
-	 * terminate things with extreme prejudice:
+	 * terminate things with extreme prejudice, unless a notifier decides
+	 * to let this one slide.
 	 */
+	if (notify_die(DIE_PAGE_FAULT, "page fault", regs, error_code, 14,
+		       SIGKILL) == NOTIFY_STOP)
+		return;
+
 	flags = oops_begin();
 
 	show_fault_oops(regs, error_code, address);
@@ -1296,6 +1312,10 @@ __do_page_fault(struct pt_regs *regs, unsigned long error_code,
 		return;
 	}
 
+	/*
+	 * From here on, we know this must be a fault in userspace.
+	 */
+
 	/* kprobes don't want to hook the spurious faults: */
 	if (unlikely(kprobes_fault(regs)))
 		return;
@@ -1308,6 +1328,12 @@ __do_page_fault(struct pt_regs *regs, unsigned long error_code,
 		return;
 	}
 
+	/*
+	 * DTrace doesn't want to either.
+	 */
+	if (unlikely(dtrace_no_pf(regs)))
+		return;
+
 	/*
 	 * If we're in an interrupt, have no user context or are running
 	 * in a region with pagefaults disabled then we must not take the fault
@@ -1492,7 +1518,7 @@ trace_page_fault_entries(unsigned long address, struct pt_regs *regs,
  *
  * exception_{enter,exit}() contains all sorts of tracepoints.
  */
-dotraplinkage void notrace
+dotraplinkage int notrace
 do_page_fault(struct pt_regs *regs, unsigned long error_code)
 {
 	unsigned long address = read_cr2(); /* Get the faulting address */
@@ -1504,5 +1530,6 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)
 
 	__do_page_fault(regs, error_code, address);
 	exception_exit(prev_state);
+	return 0;
 }
 NOKPROBE_SYMBOL(do_page_fault);
diff --git a/block/bio.c b/block/bio.c
index 7f978eac9a7a..b532f7bd7002 100644
--- a/block/bio.c
+++ b/block/bio.c
@@ -953,7 +953,11 @@ int submit_bio_wait(struct bio *bio)
 	bio->bi_end_io = submit_bio_wait_endio;
 	bio->bi_opf |= REQ_SYNC;
 	submit_bio(bio);
+	DTRACE_IO(wait__start, struct bio * : (bufinfo_t *, devinfo_t *), bio,
+		  struct file * : fileinfo_t *, NULL);
 	wait_for_completion_io(&ret.event);
+	DTRACE_IO(wait__done, struct bio * : (bufinfo_t *, devinfo_t *), bio,
+		  struct file * : fileinfo_t *, NULL);
 
 	return ret.error;
 }
@@ -1852,6 +1856,9 @@ void bio_endio(struct bio *bio)
 	}
 
 	blk_throtl_bio_endio(bio);
+	DTRACE_IO(done, struct bio * :
+		  (bufinfo_t *, devinfo_t *), bio,
+		  struct file * : fileinfo_t *, NULL);
 	/* release cgroup info */
 	bio_uninit(bio);
 	if (bio->bi_end_io)
diff --git a/block/blk-core.c b/block/blk-core.c
index f3750389e351..97abccd5d37f 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -2129,11 +2129,15 @@ generic_make_request_checks(struct bio *bio)
 		 */
 		bio_set_flag(bio, BIO_TRACE_COMPLETION);
 	}
+	DTRACE_IO(start, struct bio * : (bufinfo_t *, devinfo_t *), bio,
+		  struct file * : fileinfo_t *, NULL);
 	return true;
 
 not_supported:
 	status = BLK_STS_NOTSUPP;
 end_io:
+	DTRACE_IO(start, struct bio * : (bufinfo_t *, devinfo_t *), bio,
+		  struct file * : fileinfo_t *, NULL);
 	bio->bi_status = status;
 	bio_endio(bio);
 	return false;
diff --git a/drivers/vfio/virqfd.c b/drivers/vfio/virqfd.c
index 4797217e5e72..ec180aa5322b 100644
--- a/drivers/vfio/virqfd.c
+++ b/drivers/vfio/virqfd.c
@@ -79,7 +79,8 @@ static int virqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void
 }
 
 static void virqfd_ptable_queue_proc(struct file *file,
-				     wait_queue_head_t *wqh, poll_table *pt)
+				     wait_queue_head_t *wqh, poll_table *pt,
+				     unsigned long unused)
 {
 	struct virqfd *virqfd = container_of(pt, struct virqfd, pt);
 	add_wait_queue(wqh, &virqfd->wait);
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index d6dbb28245e6..7d624662bacd 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -156,7 +156,7 @@ static void vhost_flush_work(struct vhost_work *work)
 }
 
 static void vhost_poll_func(struct file *file, wait_queue_head_t *wqh,
-			    poll_table *pt)
+			    poll_table *pt, unsigned long unused)
 {
 	struct vhost_poll *poll;
 
diff --git a/dtrace/.gitignore b/dtrace/.gitignore
new file mode 100644
index 000000000000..d9e47cc0d9ec
--- /dev/null
+++ b/dtrace/.gitignore
@@ -0,0 +1,39 @@
+#
+# NOTE! Don't add files that are generated in specific
+# subdirectories here. Add them in the ".gitignore" file
+# in that subdirectory instead.
+#
+# NOTE! Please use 'git ls-files -i --exclude-standard'
+# command after changing this file, to see if there are
+# any tracked files which get ignored after the change.
+#
+# Normal rules
+#
+.*
+*.o
+*.o.*
+*.a
+*.s
+*.ko
+*.mod.c
+modules.builtin
+modules.order
+Module.symvers
+
+#
+# Generated DTrace SDT files
+#
+*.sdtinfo.c
+*.sdtstub.S
+
+#
+# cscope files
+#
+cscope.*
+ncscope.*
+
+#
+# Top-level tag files
+#
+/tags
+/*TAGS
diff --git a/dtrace/Makefile b/dtrace/Makefile
new file mode 100644
index 000000000000..35b8b098123f
--- /dev/null
+++ b/dtrace/Makefile
@@ -0,0 +1,29 @@
+#
+# Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+obj-$(CONFIG_DT_CORE)		+= dtrace.o
+obj-$(CONFIG_DT_FASTTRAP)	+= fasttrap.o
+obj-$(CONFIG_DT_FBT)		+= fbt.o
+obj-$(CONFIG_DT_PROFILE)	+= profile.o
+obj-$(CONFIG_DT_SDT)		+= sdt.o
+obj-$(CONFIG_DT_SYSTRACE)	+= systrace.o
+obj-$(CONFIG_DT_DT_TEST)	+= dt_test.o
+
+dtrace-y			:= dtrace_mod.o dtrace_dev.o \
+				   dtrace_actdesc.o dtrace_anon.o \
+				   dtrace_buffer.o dtrace_dif.o dtrace_dof.o \
+				   dtrace_ecb.o dtrace_enable.o \
+				   dtrace_fmt.o dtrace_hash.o dtrace_isa.o \
+				   dtrace_match.o dtrace_priv.o \
+				   dtrace_probe.o dtrace_probe_ctx.o \
+				   dtrace_ptofapi.o dtrace_predicate.o \
+				   dtrace_spec.o dtrace_state.o dtrace_util.o
+fasttrap-y			:= fasttrap_mod.o fasttrap_dev.o
+fbt-y				:= fbt_mod.o fbt_dev.o
+profile-y			:= profile_mod.o profile_dev.o
+sdt-y				:= sdt_mod.o sdt_dev.o
+systrace-y			:= systrace_mod.o systrace_dev.o
+dt_test-y			:= dt_test_mod.o dt_test_dev.o
+
+-include arch/$(SRCARCH)/dtrace/Makefile.arch
diff --git a/dtrace/NEWS b/dtrace/NEWS
new file mode 100644
index 000000000000..db04b44fe159
--- /dev/null
+++ b/dtrace/NEWS
@@ -0,0 +1,531 @@
+DTrace Kernel Modules News
+==========================
+
+Release 0.6.0 (Apr  3rd, 2017)
+------------------------------
+Kernel release: 4.1.12-97.el6uek
+
+New features:
+
+ - Userspace tracepoints (USDT) now work on SPARC for both 64- and 32-bit
+   processes.
+
+ - The types and translators used by SDT probes are now acquired from the
+   DTRACE_PROBE macros in the kernel source.  New probe argument types and
+   translations are picked up automatically without needing to change the
+   module at all.  perf-event probe argument types are acquired in the
+   same way.
+
+ - The DTRACE_PROBEn() macros used for SDT probes have been supplanted by a
+   new DTRACE_PROBE() macro which works exactly the same except that you don't
+   need to count the arguments any more and misuses (args with no types, etc)
+   are diagnosed even when CONFIG_DTRACE is disabled.
+
+ - is-enabled probes are now supported for SDT: these are expressions which
+   always return false unless the specified probe is enabled, generally used
+   directly in if statements, and can be used to suppress collection of
+   expensive data only needed for probes until the probes that use them are
+   enabled:
+
+     if (DTRACE_PROBE_ENABLED(probename)) /* expensive stuff */
+
+   Per-provider wrappers for DTRACE_PROBE_ENABLED() can be used, as with
+   DTRACE_PROBE() itself.
+
+ - Function boundary tracing (FBT) is supported for entry probes to most
+   functions in the core kernel.  The current implementation does not support
+   retrieval of function arguments or return probes (except for some limited
+   support on x86_64).  These features are currently under development.
+
+Changes:
+
+ - The implementation of the D 'ustack' action has been moved into the kernel
+   proper.  This change was motivated by the need to access page table
+   structures directly using a lock-free mechanism.
+
+ - Probe processing will be bypassed when the system is entering panic mode,
+   This ensures that DTrace will not cause panic related output to be
+   disrupted.
+
+Bugfixes:
+
+ - Due to a logic error in preemption handling, it was possible that code was
+   being executed under the assumption that preemption was disabled when in
+   fact it was not.
+
+ - Probe processing (probe context) is not re-entrant, yet probes firing as a
+   result of processing another probe would cause re-entry into the processing
+   core, with often horrible effects.  The processing core has been modified to
+   block any re-entry attempt except for ERROR probe processing.  That is a
+   deliberate (and acceptable) exception in the DTrace design.
+
+ - The fast path implementation for obtaining the value of the D 'caller'
+   variable for sparc64 has been corrected.
+
+ - The implemenation of the D 'stack' action has been made more robust, making
+   sure that memory access faults are not fatal.
+
+ - The implementation of the D 'ustack' action has been reworked completely to
+   improve stability and accuracy.
+
+ - The number of stack frames to skip has been adjusted to changes in the
+   implementation of various providers, ensuring that DTrace related frames
+   are skipped as they should.  This makes the D 'stack' action and the D
+   'caller' variable values correct.
+
+ - The implementation of the D 'stackdepth' variable could cause memory writes
+   beyond the end of the DTrace probe scratch buffer.
+
+
+Release 0.5.3 (May 25th, 2016)
+------------------------------
+Kernel release: 4.1.12-43.el6uek
+
+New features:
+
+ - It is now possible to have perf-events presented as DTrace SDT probes.
+   This feature is turned on by default in the kernel.  The probes will
+   appear with the same names as the perf-events and are grouped under the
+   new 'perf' SDT provider.
+
+   In its current implementation, the perf-events DTrace probes do not offer
+   argument type informtation as is seen with standard DTrace SDT probes.
+
+Bugfixes:
+
+ - On sparc64, it was possible to crash the system by unloading and reloading
+   the sdt DTrace multi-provider module due to the handling of memory that is
+   set aside for SDT probe trampolines.  This bug has been fixed.
+
+
+Release 0.5.2 (Feb 3rd, 2016)
+-----------------------------
+Kernel release: 4.1.12-33.el6uek
+
+Bugfixes:
+
+ - When both entry and return probes were enabled for a system call, upon
+   disabling the first, the function pointer in the system call table got
+   reset to its default value even though the 2nd probe might still be
+   active.  This could cause race conditions in the state of the system
+   call probing.
+
+ - Access to the SPARC64 R_L7 register was consistenly failing due to an
+   off-by-one bug.
+
+ - It was possible to read past the beginning of the stack for a user
+   process.  The mechanism for reading stack slots also got updated to
+   increase efficiency, consistency and reliability across architectures.
+
+ - While reading the stack of a userspace process, the stack bias was not
+   being applied for architectures that need it, causing an abundance of
+   essentially invalid values to polute the result.
+
+
+Release 0.5.1 (Nov 17th, 2015)
+------------------------------
+Kernel release: 4.1.12-24.el6uek
+
+Bugfixes:
+
+ - When copyout() or copyoutstr() is used in a D script, safety checks are now
+   enforced to protect against unprivileged memory accesses.
+
+ - The DTrace modules package no longer prevents automated kernel RPM removal
+   when the install limit is reached.
+
+ - It is now possible to access the envp and argv arrays in the psinfo for a
+   task using copyin().  This is the convention across DTrace-capable systems.
+
+
+Release 0.5.0 (Aug 10th, 2015)
+------------------------------
+Kernel release: 4.1.4-4.el6uek
+
+New features:
+
+ - DTrace is now supported on the sparc64 architecture for the following
+   providers: dtrace, profile, syscall, and SDT.
+
+ - The uid / gid handling has been updated to accommodate namespace support
+   at the kernel level (kuid and kgid).  All uid / gid values reported by
+   D subroutines (or obtained from structures) are evaluated based on the
+   initial user namespace.
+
+Changes:
+
+ - Accessing kernel memory under NOFAULT protection now implies NOPF (no
+   page fault) as well.  Previously, NOPF was an option that could be set
+   in addition to NOFAULT.
+
+ - Debugging output has been improved (to be enabled at compile time).
+
+ - The datatype formerly known as sdt_instr_t has been renamed asm_instr_t.
+   The rationale behind this change is that it will be used in code beyond
+   the SDT provider and therefore a more generic name is appropriate.
+
+
+Release 0.4.5 (Jun 17th, 2015)
+------------------------------
+Kernel release: 3.8.13-87.el6uek
+
+New features:
+
+ - It is now possible to use USDT probes in 32-bit applications on 64-bit
+   hosts.
+
+Changes:
+
+ - The code has been restructured to facilitate supporting architectures
+   other than x86_64 in future releases.
+
+ - The d_path() D subroutine requires its argument to be a pointer to a
+   path struct that corresponds to a file that is known to the current
+   task (see bugfixes below).
+
+Bugfixes:
+
+ - Fixed a (minor) memory leak problem with the help tracing facility in
+   DTrace.  Upon loading the dtrace.ko module, a buffer (by default 64K)
+   was being allocated, and it was never released.
+
+ - Stack backtraces are more accurate as a result of various fixes to
+   adjust the number of frames to skip for specific probes.
+
+ - Datatypes have been adjusted to be more carefully specified after a
+   detailed audit in preparation for supporting architectures other than
+   x86_64.
+
+ - The stack depth was being determined by requesting a backtrace to be
+   written into a temporary buffer that was being allocated (vmalloc),
+   which posed significant problems when probes were executing in a
+   context that does not support memory allocations.  The buffer is now
+   obtained from the scratch area of memory that DTrace provides for
+   probe processing.
+
+ - It was possible to cause a system crash by passing an invalid pointer
+   to d_path().  Due to its implementation, it is not possible to depend
+   on safe memory accesses to avoid this.  Instead, the pointer passed as
+   argument must be validated prior to calling d_path() in the kernel.
+
+
+Release 0.4.4 (Mar 12th, 2015)
+------------------------------
+Kernel release: 3.8.13-69.el6uek
+
+Bugfixes:
+
+ - Renamed the dtrace-modules-headers package to dtrace-modules-shared-headers
+   to work around problems in Yum where a symbol has had both versioned and
+   unversioned provides over time.
+
+
+Release 0.4.3 (May 1st, 2014)
+-----------------------------
+Kernel release: 3.8.13-33.el6uek
+
+New features:
+
+ - Timer based profile-* probes (profile provider).  These probes use the
+   omni-present cyclic support in the UEK3 kernel (3.8.13-32 and later) to
+   fire probes at a speciic frequency/interval on every active CPU.
+
+Changes:
+
+ - The pid and ppid variables were being reported based on the kernel task
+   PID, which is not the same as the userspace concept of a PID (for threaded
+   applications).  We now pass (more correctly) the thread group id (tgid).
+
+ - Since userspace doesn't know about thread kernel level) pids, we are now
+   also passing the tgid in the result of ustack, usym, etc...  We pass the
+   tgid in the first slot, and the (kernel) pid in the second slot.
+
+Bugfixes:
+
+ - Major reworking of the dtracce_getufpstack() implementation to handle
+   locking, stack detection, and potential page fault while accessing the
+   stack of a task.
+
+Known problems:
+
+ - As a result of earlier code changes to ensure that all memory allocation
+   requests are checked for failures, the test for auto-resize behaviour of
+   the principal buffer allocations results in the dtrace utility aborted
+   processing rather than continuing operation with the reduced buffer size.
+   This is overall a non-harmful regression that will be addressed in a future
+   release.
+
+
+Release 0.4.2 (Dec 20th, 2013)
+------------------------------
+Kernel release: 3.8.13-22.el6uek
+
+Changes:
+
+ - SDT probe points in kernel modules are now supported.
+
+ - The 'vtimestamp' D variable has been implemented.
+
+
+Release 0.4.1 (Nov  6th, 2013)
+------------------------------
+Kernel release: 3.8.13-16.2.1.el6uek
+
+Changes:
+
+ - It is no longer permissible to have non-unique provider names within the
+   context of a userspace process.  I.e. it is not permissible for the main
+   executable and a loaded shared library, or two loaded shared libraries, to
+   list the same provider name in their DOF sections.
+
+ - A new cyclic implementation has been included in the UEK3 kernel, replacing
+   the more error prone former version.  The modules code has been updated to
+   use that new implementation.
+
+Bugfixes:
+
+ - Lock ordering problems that were inherited from the original code are fixed.
+
+ - Userspace stack memory accesses are now performed in a safe manner.
+
+ - A race condition between speculative tracing buffer cleaning and destroying
+   consumer state has been resolved.
+
+ - A memory leak related to consumer state has been fixed.
+
+ - A provider reference counter calculation problem was resolved.
+
+ - The 'errno' D variable now holds the correct value during syscall:::return
+   probe action execution, i.e. 0 if the syscall completed without an error,
+   and a valid error code if the syscall failed.
+
+
+Release 0.4.0 (Sep 20th, 2013)
+------------------------------
+Kernel release: 3.8.13-16.el6uek
+
+New features:
+
+ - Support for meta-providers, such as fasttrap (used for userspace tracing).
+   A meta-provider implements a framework to instantiate providers dynamically
+   (on demand).
+
+ - Userspace Statically Defined Tracing (USDT) provides support for SDT-alike
+   probes in userspace executable and libraries.  Two types of probes are
+   available: regular SDT-alike probes, and is-enabled probes.
+
+ - The fasttrap provider has been implemented, although it is currently only
+   supporting USDT probes.
+
+Changes:
+
+ - What was previously defined as a meta-provider (see 0.2.0 below) is in fact
+   better defined as a multi-provider, i.e. a provider framework that handles
+   multiple providers that essentially share (the majority of) a single
+   implementation, such as SDT where probes are grouped together into providers
+   even though they are all provided by the same provider (sdt).
+
+ - The DTrace header files in the kernel proper, the kernel modules, and the
+   userspace utility have been restructured to avoid duplication and to offer
+   a more consistent and clean design.  This also offers better support for
+   custom consumers or other DTrace-related utilities.
+
+ - The systrace provider has been updated to account for changes in the Linux
+   kernel (between 2.6.39 and 3.8.13).
+
+Bugfixes:
+
+ - It is now possible to get the correct value for the ERR registers.
+
+ - The ustack() and jstack() actions were not passing the PID correctly as the
+   first element in the result array.
+
+ - The ustack() action implementation has been replaced.
+
+ - Several obscure locking problems have been resolved.
+
+ - Correct handling of arg5 through arg9.
+
+
+Release 0.3.0 (Sep 14th, 2012)
+------------------------------
+Kernel release: 2.6.39-201.0.1.el6uek
+
+New features:
+
+ - The curcpu builtin variable has been implemented as a DIF builtin variable
+   on Linux, providing a pointer to the CPU info structure for the CPU that is
+   currently active.
+
+ - A new DIF subroutine has been implemented: d_path().  This subroutine takes
+   a pointer to a path structure as argument, and returns a string representing
+   the full pathname for that path.
+
+ - The raise() action has been implemented.  This action allows a D script to
+   raise a signal in the current task.
+
+ - The io provider probes has been implemented.  It provides the following SDT
+   probes: start, wait-start, wait-done, and done.
+
+ - The proc provider has been implemented.  It provides the following SDT
+   probes: create, exec, exec-failure, exit, lwp-create, lwp-exit, lwp-start,
+   signal-clear, signal-discard, signal-handle, signal-send, start.
+
+ - The sched provider has been implemented.  It provides the following SDT
+   probes: change-pri, dequeue, enqueue, off-cpu, on-cpu, preempt, remain-cpu,
+   sleep, surrender, tick, wakeup.
+
+ - Argument mappings have been provided for io, proc, and sched provider
+   probes.  This information is used by userspace consumers.
+
+Changes:
+
+ - The invalid operand trap logic previously provided to support SDT probes has
+   been made more generic to support any probes that wish to utilie this
+   facility.
+
+ - The DTrace core module now depends on the core kernel CTF data-module, to
+   ensure that when DTrace modules are loaded on the system, CTF data for the
+   kernel will be available also.
+
+Bugfixes:
+
+ - Various DIF builtin variables that were providing a hardcoded value based on
+   the init task whenever a probe was executing in interrupt context are now
+   providing the actual value from the current task.  In Linux, there is always
+   a valid task structure available as 'current'.
+
+ - The numbering of the registers for the x86_64 architecture has been updated
+   to match the order of registers pushed onto the stack.
+
+ - It is now possible to get the correct value for the DS, ES, FS, and GS
+   registers.
+
+ - SDT probes are now correctly cleaned up when the SDT meta-provider module is
+   unloaded from the system.
+
+ - The rw_read_held() DIF subroutine will now verify whether it can safely
+   access the passed in argument based on the correct argument datatype.
+
+
+Release 0.2.4 (Feb 15th, 2012)
+------------------------------
+Kernel release: 2.6.39-101.0.1.el6uek
+
+Bugfixes:
+
+ - Provider modules now use a reference counter to determine whether any of
+   their probes are currently enabled.  Whenever the reference counter has a
+   value greater than zero, the provider module is referenced to ensure that
+   it cannot be unloaded.  Once the counter drops down to zero, the reference
+   on the module is released.  This prevents providers from being unloaded
+   while some of their probes are still in use (which would typically lead to
+   a kernel panic).
+
+
+Release 0.2.3 (Feb 10th, 2012)
+------------------------------
+Kernel release: 2.6.39-101.0.1.el6uek
+
+Changes:
+
+ - The DTrace core has been updated to support 28 DTrace option settings, to
+   account for the 'quietresize' options that was added to the userspace dtrace
+   consumer utility.
+
+Bugfixes:
+
+ - Various assertions in the DTrace core implementation incorrectly used
+   mutex_is_locked() where the test was meant to determine whether the current
+   task holds the mutex.  This has been corrected.
+
+
+Release 0.2.1 (Jan 31st, 2012)
+------------------------------
+Kernel release: 2.6.39-101.0.1.el6uek
+
+Bugfixes:
+
+ - Failed memory allocations from DIF code no longer trigger kernel warnings.
+
+
+Release 0.2.0 (Jan 25th, 2012)
+------------------------------
+Kernel release: 2.6.39-101.0.1.el6uek
+
+This release brings DTrace for Linux to the 2.6.39 kernel, as an upgrade from
+the previous release based on 2.6.32.
+
+New features:
+
+ - The DTrace core and provider API now support meta-providers, a framework
+   that provides multiple providers using a common implementation.
+
+ - The Statically Defined Tracing (SDT) meta-provider has been implemented.
+   Some of the proc-provider probes are now available using this facility.
+
+Changes:
+
+ - The minimal cyclic implementation has been removed from the DTrace modules
+   because it is now provided by an equivalent GPL impementation in the core
+   kernel.
+
+ - CPU core information is now maintained at the core kernel level.
+
+ - Kernel and module code can now perform safe memory accesses by setting a
+   flag in the CPU core information structure.  If a memory access results in
+   a Page Fault or General Protection Fault, the failure will be noted as a CPU
+   fault, and execution will continue rather than causing a kernel panic.
+
+ - Functionality that depends on walking the stack (determining stack depth, or
+   collecting a backtrace) is now provided by a GPL implementation in the core
+   kernel.
+
+ - In the interest of consistency, a pseudo kernel module structure is created
+   at the core kernel level, representing the main kernel image.  This module
+   structure makes it possible to represent all kernel-level objects equally.
+   This structure provides a list of SDT probe locations in the core kernel.
+
+Bugfixes:
+
+ - Entry and return probes for system calls that use assembly code stubs are
+   now supported (systrace provider).
+
+ - All memory accesses from DIF code that cause a Page Fault or General
+   Protection Fault now correctly cause the ERROR probe to fire rather than
+   causing a kernel panic.
+
+ - Dynamic memory allocations from DIF code can now fail.  Such failures are
+   handled appropriately by the callers.
+
+ - The implementation of the division and modulo operations for signed 64-bit
+   values have been corrected.  This fixes various problems observed with
+   aggregations.
+
+ - The min() and max() aggregation functions now operate with correct (signed)
+   initial values.
+
+ - Code that depended on the idr_empty() function has been rewritten to use a
+   more explicit mechanism, because the logic for determining whether an IDR
+   structure had any elements or not was flawed.
+
+
+Release 0.1.0 (Oct 20th, 2011)
+------------------------------
+Kernel release: 2.6.32-201.0.4.el6uek
+
+First public release.
+
+Features:
+
+ - The vast majority of the DTrace core functionality has been implemented,
+   providing a nearly complete DIF/DOF implementation (including predicates,
+   aggregates, and speculative tracing support), provider API, ioctl interface
+   for userspace consumers, and direct probe invocation.
+
+ - BEGIN, END, and ERROR probes (dtrace provider).
+
+ - Timer based tick-* probes (profile provider).
+
+ - Syscall entry and return probes (systrace provider), with the exception of
+   system calls that rely on assembly code stubs, such as clone().
diff --git a/dtrace/ctf_api.h b/dtrace/ctf_api.h
new file mode 100644
index 000000000000..75c6a5d6ad7e
--- /dev/null
+++ b/dtrace/ctf_api.h
@@ -0,0 +1,32 @@
+/*
+ * Compact C Type format
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CTF_API_H_
+#define __CTF_API_H_
+
+/*
+ * The CTF data model is inferred to be the caller's data model or the data
+ * model of the given object, unless ctf_setmodel() is explicitly called.
+ */
+#define CTF_MODEL_ILP32		1	/* object data model is ILP32 */
+#define CTF_MODEL_LP64		2	/* object data model is LP64 */
+#ifdef CONFIG_64BIT
+# define CTF_MODEL_NATIVE	CTF_MODEL_LP64
+#else
+# define CTF_MODEL_NATIVE	CTF_MODEL_ILP32
+#endif
+
+#endif /* __CTF_API_H_ */
diff --git a/dtrace/dt_perf.h b/dtrace/dt_perf.h
new file mode 100644
index 000000000000..581c4ce3ca49
--- /dev/null
+++ b/dtrace/dt_perf.h
@@ -0,0 +1,31 @@
+/*
+ * Dynamic Tracing for Linux - Perf provider
+ *
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_PERF_H_
+#define _DT_PERF_H_
+
+extern void dt_perf_provide(void *, const dtrace_probedesc_t *);
+extern int _dt_perf_enable(void *, dtrace_id_t, void *);
+extern void _dt_perf_disable(void *, dtrace_id_t, void *);
+extern void dt_perf_destroy(void *, dtrace_id_t, void *);
+
+extern dtrace_provider_id_t	dt_perf_id;
+
+extern int dt_perf_dev_init(void);
+extern void dt_perf_dev_exit(void);
+
+#endif /* _DT_PERF_H_ */
diff --git a/dtrace/dt_perf_dev.c b/dtrace/dt_perf_dev.c
new file mode 100644
index 000000000000..3e19cadf4f0e
--- /dev/null
+++ b/dtrace/dt_perf_dev.c
@@ -0,0 +1,142 @@
+/*
+ * FILE:	dt_pref_dev.c
+ * DESCRIPTION:	DTrace - perf provider device driver
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/miscdevice.h>
+#include <trace/syscall.h>
+#include <asm/unistd.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "dt_perf.h"
+
+static dtrace_id_t	invoke_pid = DTRACE_IDNONE;
+static dtrace_id_t	result_pid = DTRACE_IDNONE;
+static int		enabled = 0;
+
+void dt_perf_provide(void *arg, const dtrace_probedesc_t *desc)
+{
+	if (dtrace_probe_lookup(dt_perf_id, "dt_perf", NULL, "invoke") != DTRACE_IDNONE) {
+		invoke_pid = dtrace_probe_create(dt_perf_id,
+						 "dt_perf", NULL, "invoke", 0, NULL);
+	}
+
+	if (dtrace_probe_lookup(dt_perf_id, "dt_perf", NULL, "result") == DTRACE_IDNONE) {
+		result_pid = dtrace_probe_create(dt_perf_id,
+						 "dt_perf", NULL, "result", 0, NULL);
+	}
+}
+
+int _dt_perf_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	enabled = 1;
+
+	return 0;
+}
+
+void _dt_perf_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	enabled = 0;
+}
+
+void dt_perf_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+}
+
+static long dt_perf_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	unsigned long	i;
+	ktime_t		tm0, tm1;
+
+	if (!enabled)
+		return -EAGAIN;
+
+	switch (cmd) {
+	case _IOW(1, 1, int):
+		tm0 = dtrace_gethrtime();
+		for (i = 0; i < arg; i++)
+		    dtrace_probe(invoke_pid, cmd, arg, 2, 3, 4);
+
+		tm1 = dtrace_gethrtime();
+		tm1 -= tm0;
+
+		dtrace_probe(result_pid, cmd, arg, tm1, tm1 >> 32, 0);
+		break;
+
+	case _IOW(1, 2, int): {
+		extern void dtrace_sdt_perf(void);
+
+		tm0 = dtrace_gethrtime();
+		for (i = 0; i < arg; i++)
+		    dtrace_sdt_perf();
+
+		tm1 = dtrace_gethrtime();
+		tm1 -= tm0;
+
+		dtrace_probe(result_pid, cmd, arg, tm1, tm1 >> 32, 0);
+		break;
+	}
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dt_perf_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int dt_perf_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations dt_perf_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = dt_perf_ioctl,
+        .open   = dt_perf_open,
+        .release = dt_perf_close,
+};
+
+static struct miscdevice dt_perf_dev = {
+	.minor = DT_DEV_DT_PERF_MINOR,
+	.name = "dt_perf",
+	.nodename = "dtrace/provider/dt_perf",
+	.fops = &dt_perf_fops,
+};
+
+int dt_perf_dev_init(void)
+{
+	int	ret = 0;
+
+	ret = misc_register(&dt_perf_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       dt_perf_dev.name, dt_perf_dev.minor);
+
+	return ret;
+}
+
+void dt_perf_dev_exit(void)
+{
+	misc_deregister(&dt_perf_dev);
+}
diff --git a/dtrace/dt_perf_mod.c b/dtrace/dt_perf_mod.c
new file mode 100644
index 000000000000..4d56fa99b6f5
--- /dev/null
+++ b/dtrace/dt_perf_mod.c
@@ -0,0 +1,51 @@
+/*
+ * FILE:	dt_perf_mod.c
+ * DESCRIPTION:	DTrace - perf provider kernel module
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "dt_perf.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("DTrace Performance Test Probe");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static const dtrace_pattr_t dt_perf_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pops_t dt_perf_pops = {
+	.dtps_provide = dt_perf_provide,
+	.dtps_provide_module = NULL,
+	.dtps_destroy_module = NULL,
+	.dtps_enable = dt_perf_enable,
+	.dtps_disable = dt_perf_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = NULL,
+	.dtps_getargval = NULL,
+	.dtps_usermode = NULL,
+	.dtps_destroy = dt_perf_destroy
+};
+
+DT_PROVIDER_MODULE(dt_perf, DTRACE_PRIV_USER)
diff --git a/dtrace/dt_test.h b/dtrace/dt_test.h
new file mode 100644
index 000000000000..2045f0b87682
--- /dev/null
+++ b/dtrace/dt_test.h
@@ -0,0 +1,30 @@
+/*
+ * Dynamic Tracing for Linux - test provider
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DT_TEST_H_
+#define _DT_TEST_H_
+
+extern void dt_test_provide(void *, const dtrace_probedesc_t *);
+extern int dt_test_enable(void *arg, dtrace_id_t, void *);
+extern void dt_test_disable(void *arg, dtrace_id_t, void *);
+extern void dt_test_destroy(void *, dtrace_id_t, void *);
+
+extern dtrace_provider_id_t	dt_test_id;
+
+extern int dt_test_dev_init(void);
+extern void dt_test_dev_exit(void);
+
+#endif /* _DT_TEST_H_ */
diff --git a/dtrace/dt_test_dev.c b/dtrace/dt_test_dev.c
new file mode 100644
index 000000000000..ca6539d92fbb
--- /dev/null
+++ b/dtrace/dt_test_dev.c
@@ -0,0 +1,157 @@
+/*
+ * FILE:	dt_test_dev.c
+ * DESCRIPTION:	DTrace - test provider device driver
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <trace/syscall.h>
+#include <asm/unistd.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "dt_test.h"
+
+static dtrace_id_t	pid = DTRACE_IDNONE;
+static int		enabled = 0;
+
+void dt_test_provide(void *arg, const dtrace_probedesc_t *desc)
+{
+	if (dtrace_probe_lookup(dt_test_id, "dt_test", NULL, "test") != DTRACE_IDNONE)
+		return;
+
+	pid = dtrace_probe_create(dt_test_id,
+				  "dt_test", NULL, "test", 1, NULL);
+}
+
+int dt_test_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	enabled = 1;
+
+	return 0;
+}
+
+void dt_test_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	enabled = 0;
+}
+
+void dt_test_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+}
+
+void probe_p(dtrace_id_t pid, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
+	      uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6,
+	      uintptr_t arg7, uintptr_t arg8, uintptr_t arg9)
+{
+}
+
+/*
+ * Direct calling into dtrace_probe() when passing more than 5 parameters to
+ * the probe requires a stub function.  Otherwise we may not be able to get
+ * to the value of all arguments correctly.
+ */
+void dt_test_probe(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
+		   uintptr_t arg3, uintptr_t arg4, uintptr_t arg5,
+		   uintptr_t arg6, uintptr_t arg7, uintptr_t arg8,
+		   uintptr_t arg9)
+{
+	/*
+	 * Yes, this is not nice.
+	 * Not at all...
+	 * But we're doing it anyway...
+	 */
+	typeof(probe_p) *probe_fn = (void *)&dtrace_probe;
+
+	probe_fn(pid, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
+		 arg9);
+}
+
+static long dt_test_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	if (enabled) {
+		dt_test_probe(cmd, arg, 2ULL, 3ULL, 4ULL, 5ULL, 6ULL, 7ULL,
+					8ULL, 9ULL);
+
+		return 0;
+	}
+
+	if (DTRACE_PROBE_ENABLED(sdt__test))
+		DTRACE_PROBE(sdt__test__is__enabled);
+
+	DTRACE_PROBE(sdt__test);
+
+	/*
+	 * Test translation-to-nothing.
+	 */
+	DTRACE_PROBE(sdt__test__ioctl__file, int, cmd, int :, 666,
+		     char * : (), 0, struct file *, file, int, arg);
+
+	/*
+	 * Probes with every valid count of args.
+	 */
+	DTRACE_PROBE(sdt__test__arg1, int, 1);
+	DTRACE_PROBE(sdt__test__arg2, int, 1, int, 2);
+	DTRACE_PROBE(sdt__test__arg3, int, 1, int, 2, int, 3);
+	DTRACE_PROBE(sdt__test__arg4, int, 1, int, 2, int, 3, int, 4);
+	DTRACE_PROBE(sdt__test__arg5, int, 1, int, 2, int, 3, int, 4, int, 5);
+	DTRACE_PROBE(sdt__test__arg6, int, 1, int, 2, int, 3, int, 4, int, 5, int, 6);
+	DTRACE_PROBE(sdt__test__arg7, int, 1, int, 2, int, 3, int, 4, int, 5, int, 6, int, 7);
+	DTRACE_PROBE(sdt__test__arg8, int, 1, int, 2, int, 3, int, 4, int, 5, int, 6, int, 7, int, 8);
+
+	return -EAGAIN;
+}
+
+static int dt_test_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int dt_test_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations dt_test_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = dt_test_ioctl,
+        .open   = dt_test_open,
+        .release = dt_test_close,
+};
+
+static struct miscdevice dt_test_dev = {
+	.minor = DT_DEV_DT_TEST_MINOR,
+	.name = "dt_test",
+	.nodename = "dtrace/provider/dt_test",
+	.fops = &dt_test_fops,
+};
+
+int dt_test_dev_init(void)
+{
+	int	ret = 0;
+
+	ret = misc_register(&dt_test_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       dt_test_dev.name, dt_test_dev.minor);
+
+	return ret;
+}
+
+void dt_test_dev_exit(void)
+{
+	misc_deregister(&dt_test_dev);
+}
diff --git a/dtrace/dt_test_mod.c b/dtrace/dt_test_mod.c
new file mode 100644
index 000000000000..df40b85d6717
--- /dev/null
+++ b/dtrace/dt_test_mod.c
@@ -0,0 +1,56 @@
+/*
+ * FILE:	dt_test_mod.c
+ * DESCRIPTION:	DTrace - test provider kernel module
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "dt_test.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("DTrace Test Probe");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static const dtrace_pattr_t dt_test_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pops_t dt_test_pops = {
+	.dtps_provide = dt_test_provide,
+	.dtps_provide_module = NULL,
+	.dtps_destroy_module = NULL,
+	.dtps_enable = dt_test_enable,
+	.dtps_disable = dt_test_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = NULL,
+	.dtps_getargval = NULL,
+	.dtps_usermode = NULL,
+	.dtps_destroy = dt_test_destroy
+};
+
+DT_PROVIDER_MODULE(dt_test, DTRACE_PRIV_USER)
+
+void foo(void)
+{
+	DTRACE_PROBE(sdt__test2);
+}
diff --git a/dtrace/dtrace.h b/dtrace/dtrace.h
new file mode 100644
index 000000000000..7dbe2bb36f5d
--- /dev/null
+++ b/dtrace/dtrace.h
@@ -0,0 +1,34 @@
+/*
+ * Dynamic Tracing for Linux
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DTRACE_H_
+#define _DTRACE_H_
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include "dtrace_debug.h"
+
+#include <dtrace/types.h>
+
+#include <linux/dtrace/dtrace.h>
+
+#include <dtrace/provider.h>
+#include <dtrace/dtrace_impl.h>
+
+#endif /* _DTRACE_H_ */
diff --git a/dtrace/dtrace_actdesc.c b/dtrace/dtrace_actdesc.c
new file mode 100644
index 000000000000..340709cf3d66
--- /dev/null
+++ b/dtrace/dtrace_actdesc.c
@@ -0,0 +1,87 @@
+/*
+ * FILE:	dtrace_actdesc.c
+ * DESCRIPTION:	DTrace - action implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+dtrace_actdesc_t *dtrace_actdesc_create(dtrace_actkind_t kind, uint32_t ntuple,
+					uint64_t uarg, uint64_t arg)
+{
+	dtrace_actdesc_t	*act;
+
+#ifdef FIXME
+	ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
+	       (arg != 0 && (uintptr_t)arg >= KERNELBASE) ||
+	       (arg == 0 && kind == DTRACEACT_PRINTA));
+#else
+	ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
+	       (arg != 0) ||
+	       (arg == 0 && kind == DTRACEACT_PRINTA));
+#endif
+
+	act = kzalloc(sizeof (dtrace_actdesc_t), GFP_KERNEL);
+	if (act == NULL)
+		return NULL;
+
+	act->dtad_kind = kind;
+	act->dtad_ntuple = ntuple;
+	act->dtad_uarg = uarg;
+	act->dtad_arg = arg;
+	act->dtad_refcnt = 1;
+
+	return act;
+}
+
+void dtrace_actdesc_hold(dtrace_actdesc_t *act)
+{
+	ASSERT(act->dtad_refcnt >= 1);
+
+	act->dtad_refcnt++;
+}
+
+void dtrace_actdesc_release(dtrace_actdesc_t *act, dtrace_vstate_t *vstate)
+{
+	dtrace_actkind_t	kind = act->dtad_kind;
+	dtrace_difo_t		*dp;
+
+	ASSERT(act->dtad_refcnt >= 1);
+
+	if (--act->dtad_refcnt != 0)
+		return;
+
+	if ((dp = act->dtad_difo) != NULL)
+		dtrace_difo_release(dp, vstate);
+
+	if (DTRACEACT_ISPRINTFLIKE(kind)) {
+		char	*str = (char *)(uintptr_t)act->dtad_arg;
+
+#ifdef FIXME
+		ASSERT((str != NULL && (uintptr_t)str >= KERNELBASE) ||
+		       (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+#else
+		ASSERT((str != NULL) ||
+		       (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+#endif
+
+		if (str != NULL)
+			vfree(str);
+	}
+
+	kfree(act);
+}
diff --git a/dtrace/dtrace_anon.c b/dtrace/dtrace_anon.c
new file mode 100644
index 000000000000..f1516d144794
--- /dev/null
+++ b/dtrace/dtrace_anon.c
@@ -0,0 +1,140 @@
+/*
+ * FILE:	dtrace_anon.c
+ * DESCRIPTION:	DTrace - Anonymous state implementation
+ *
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "dtrace.h"
+
+dtrace_anon_t	dtrace_anon;
+
+dtrace_state_t *dtrace_anon_grab(void)
+{
+	dtrace_state_t	*state;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if ((state = dtrace_anon.dta_state) == NULL) {
+		ASSERT(dtrace_anon.dta_enabling == NULL);
+
+		return NULL;
+	}
+
+	ASSERT(dtrace_anon.dta_enabling != NULL);
+	ASSERT(dtrace_retained != NULL);
+
+	dtrace_enabling_destroy(dtrace_anon.dta_enabling);
+	dtrace_anon.dta_enabling = NULL;
+	dtrace_anon.dta_state = NULL;
+
+	return state;
+}
+
+void dtrace_anon_property(void)
+{
+	int		i, rv;
+	dtrace_state_t	*state;
+	dof_hdr_t	*dof;
+	char		c[32];             /* enough for "dof-data-" + digits */
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	for (i = 0; ; i++) {
+		snprintf(c, sizeof (c), "dof-data-%d", i);
+
+		dtrace_err_verbose = 1;
+
+		if ((dof = dtrace_dof_property(c)) == NULL) {
+			dtrace_err_verbose = 0;
+			break;
+		}
+
+#ifdef FIXME
+		/*
+		 * We want to create anonymous state, so we need to transition
+		 * the kernel debugger to indicate that DTrace is active.  If
+		 * this fails (e.g. because the debugger has modified text in
+		 * some way), we won't continue with the processing.
+		 */
+		if (kdi_dtrace_set(KDI_DTSET_DTRACE_ACTIVATE) != 0) {
+			pr_info("kernel debugger active; "
+				"anonymous enabling ignored.");
+			dtrace_dof_destroy(dof);
+			break;
+		}
+#endif
+
+		/*
+		 * If we haven't allocated an anonymous state, we'll do so now.
+		*/
+		if ((state = dtrace_anon.dta_state) == NULL) {
+			state = dtrace_state_create(NULL);
+			dtrace_anon.dta_state = state;
+
+			if (state == NULL) {
+				/*
+				 * This basically shouldn't happen: there is no
+				 * failure mode from dtrace_state_create().
+				 * Still, the interface allows for a failure
+				 * mode, and we want to fail as gracefully as
+				 * possible: we'll emit an error message and
+				 * cease processing anonymous state in this
+				 * case.
+				 */
+				pr_warning("failed to create anonymous state");
+				dtrace_dof_destroy(dof);
+				break;
+			}
+		}
+
+		rv = dtrace_dof_slurp(dof, &state->dts_vstate, current_cred(),
+				      &dtrace_anon.dta_enabling, 0, TRUE);
+
+		if (rv == 0)
+			rv = dtrace_dof_options(dof, state);
+
+		dtrace_err_verbose = 0;
+		dtrace_dof_destroy(dof);
+
+		if (rv != 0) {
+			/*
+			 * This is malformed DOF; chuck any anonymous state
+			 * that we created.
+			 */
+			ASSERT(dtrace_anon.dta_enabling == NULL);
+			dtrace_state_destroy(state);
+			dtrace_anon.dta_state = NULL;
+			break;
+		}
+
+		ASSERT(dtrace_anon.dta_enabling != NULL);
+	}
+
+	if (dtrace_anon.dta_enabling != NULL) {
+		int	rval;
+
+		/*
+		 * dtrace_enabling_retain() can only fail because we are
+		 * trying to retain more enablings than are allowed -- but
+		 * we only have one anonymous enabling, and we are guaranteed
+		 * to be allowed at least one retained enabling; we assert
+		 * that dtrace_enabling_retain() returns success.
+		 */
+		rval = dtrace_enabling_retain(dtrace_anon.dta_enabling);
+		ASSERT(rval == 0);
+
+		dtrace_enabling_dump(dtrace_anon.dta_enabling);
+	}
+}
diff --git a/dtrace/dtrace_buffer.c b/dtrace/dtrace_buffer.c
new file mode 100644
index 000000000000..3f3717a5142c
--- /dev/null
+++ b/dtrace/dtrace_buffer.c
@@ -0,0 +1,486 @@
+/*
+ * FILE:	dtrace_buffer.c
+ * DESCRIPTION:	DTrace - buffer implementation
+ *
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+dtrace_optval_t		dtrace_nonroot_maxsize = (16 * 1024 * 1024);
+
+/*
+ * Note:  called from cross call context.  This function switches the two
+ * buffers on a given CPU.  The atomicity of this operation is assured by
+ * disabling interrupts while the actual switch takes place; the disabling of
+ * interrupts serializes the execution with any execution of dtrace_probe() on
+ * the same CPU.
+ */
+void dtrace_buffer_switch(dtrace_buffer_t *buf)
+{
+	caddr_t			tomax = buf->dtb_tomax;
+	caddr_t			xamot = buf->dtb_xamot;
+	dtrace_icookie_t	cookie;
+
+	ASSERT(!(buf->dtb_flags & DTRACEBUF_NOSWITCH));
+	ASSERT(!(buf->dtb_flags & DTRACEBUF_RING));
+
+	local_irq_save(cookie);
+
+	dt_dbg_buf("Switch (CPU %d): tomax %p (%lld) <-> xamot %p (%lld)\n",
+		   smp_processor_id(), tomax, buf->dtb_offset,
+		   xamot, buf->dtb_xamot_offset );
+
+	buf->dtb_tomax = xamot;
+	buf->dtb_xamot = tomax;
+	buf->dtb_xamot_drops = buf->dtb_drops;
+	buf->dtb_xamot_offset = buf->dtb_offset;
+	buf->dtb_xamot_errors = buf->dtb_errors;
+	buf->dtb_xamot_flags = buf->dtb_flags;
+	buf->dtb_offset = 0;
+	buf->dtb_drops = 0;
+	buf->dtb_errors = 0;
+	buf->dtb_flags &= ~(DTRACEBUF_ERROR | DTRACEBUF_DROPPED);
+
+	local_irq_restore(cookie);
+}
+
+/*
+ * Note:  called from cross call context.  This function activates a buffer
+ * on a CPU.  As with dtrace_buffer_switch(), the atomicity of the operation
+ * is guaranteed by the disabling of interrupts.
+ */
+void dtrace_buffer_activate(dtrace_state_t *state)
+{
+	dtrace_buffer_t		*buf;
+	dtrace_icookie_t	cookie;
+
+	local_irq_save(cookie);
+
+	buf = &state->dts_buffer[smp_processor_id()];
+
+	if (buf->dtb_tomax != NULL) {
+		/*
+		 * We might like to assert that the buffer is marked inactive,
+		 * but this isn't necessarily true:  the buffer for the CPU
+		 * that processes the BEGIN probe has its buffer activated
+		 * manually.  In this case, we take the (harmless) action
+		 * re-clearing the bit INACTIVE bit.
+		 */
+		 buf->dtb_flags &= ~DTRACEBUF_INACTIVE;
+	}
+
+	local_irq_restore(cookie);
+}
+
+int dtrace_buffer_alloc(dtrace_buffer_t *bufs, size_t size, int flags,
+			processorid_t cpuid)
+{
+	processorid_t	cpu;
+	dtrace_buffer_t	*buf;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+#ifdef FIXME
+	if (size > dtrace_nonroot_maxsize &&
+	    !PRIV_POLICY_CHOICE(current_cred(), PRIV_ALL, FALSE))
+		return -EFBIG;
+#endif
+
+	for_each_online_cpu(cpu) {
+		if (cpuid != DTRACE_CPUALL && cpuid != cpu)
+			continue;
+
+		buf = &bufs[cpu];
+
+		/*
+		 * If there is already a buffer allocated for this CPU, it
+		 * is only possible that this is a DR event.  In this case,
+		 * the buffer size must match our specified size.
+		 */
+		if (buf->dtb_tomax != NULL) {
+			ASSERT(buf->dtb_size == size);
+			continue;
+		}
+
+		ASSERT(buf->dtb_xamot == NULL);
+
+		if ((buf->dtb_tomax = dtrace_vzalloc_try(size)) == NULL)
+			goto err;
+
+		buf->dtb_size = size;
+		buf->dtb_flags = flags;
+		buf->dtb_offset = 0;
+		buf->dtb_drops = 0;
+
+		if (flags & DTRACEBUF_NOSWITCH)
+			continue;
+
+		if ((buf->dtb_xamot = dtrace_vzalloc_try(size)) == NULL)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	for_each_online_cpu(cpu) {
+		if (cpuid != DTRACE_CPUALL && cpuid != cpu)
+			continue;
+
+		buf = &bufs[cpu];
+
+		if (buf->dtb_xamot != NULL) {
+			ASSERT(buf->dtb_tomax != NULL);
+			ASSERT(buf->dtb_size == size);
+			vfree(buf->dtb_xamot);
+		}
+
+		if (buf->dtb_tomax != NULL) {
+			ASSERT(buf->dtb_size == size);
+			vfree(buf->dtb_tomax);
+		}
+
+		buf->dtb_tomax = NULL;
+		buf->dtb_xamot = NULL;
+		buf->dtb_size = 0;
+	}
+
+	return -ENOMEM;
+}
+void dtrace_buffer_drop(dtrace_buffer_t *buf)
+{
+	buf->dtb_drops++;
+}
+
+intptr_t dtrace_buffer_reserve(dtrace_buffer_t *buf, size_t needed,
+			       size_t align, dtrace_state_t *state,
+			       dtrace_mstate_t *mstate)
+{
+	intptr_t	offs = buf->dtb_offset, soffs;
+	intptr_t	woffs;
+	caddr_t		tomax;
+	size_t		total;
+
+	if (buf->dtb_flags & DTRACEBUF_INACTIVE)
+		return -1;
+
+	if ((tomax = buf->dtb_tomax) == NULL) {
+		dtrace_buffer_drop(buf);
+		return -1;
+	}
+
+	if (!(buf->dtb_flags & (DTRACEBUF_RING | DTRACEBUF_FILL))) {
+		while (offs & (align - 1)) {
+			/*
+			 * Assert that our alignment is off by a number which
+			 * is itself sizeof (uint32_t) aligned.
+			 */
+			ASSERT(!((align - (offs & (align - 1))) &
+				(sizeof (uint32_t) - 1)));
+			DTRACE_STORE(uint32_t, tomax, offs, DTRACE_EPIDNONE);
+			dt_dbg_buf("    Store: %p[%ld .. %ld] <- EPIDNONE "
+				   "(from %s::%d)\n",
+				   buf, offs, offs + sizeof(uint32_t) - 1,
+				   __FUNCTION__, __LINE__);
+			offs += sizeof (uint32_t);
+		}
+
+		if ((soffs = offs + needed) > buf->dtb_size) {
+			dtrace_buffer_drop(buf);
+			return -1;
+		}
+
+		if (mstate == NULL) {
+			dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+				   buf, offs, offs + needed - 1);
+			return offs;
+		}
+
+		mstate->dtms_scratch_base = (uintptr_t)tomax + soffs;
+		mstate->dtms_scratch_size = buf->dtb_size - soffs;
+		mstate->dtms_scratch_ptr = mstate->dtms_scratch_base;
+
+		dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+			   buf, offs, offs + needed - 1);
+		return offs;
+	}
+
+	if (buf->dtb_flags & DTRACEBUF_FILL) {
+		if (state->dts_activity != DTRACE_ACTIVITY_COOLDOWN &&
+		    (buf->dtb_flags & DTRACEBUF_FULL))
+			return -1;
+
+		goto out;
+	}
+
+	total = needed + (offs & (align - 1));
+
+	/*
+	 * For a ring buffer, life is quite a bit more complicated.  Before
+	 * we can store any padding, we need to adjust our wrapping offset.
+	 * (If we've never before wrapped or we're not about to, no adjustment
+	 * is required.)
+	 */
+	if ((buf->dtb_flags & DTRACEBUF_WRAPPED) ||
+	    offs + total > buf->dtb_size) {
+		woffs = buf->dtb_xamot_offset;
+
+		if (offs + total > buf->dtb_size) {
+			/*
+			 * We can't fit in the end of the buffer.  First, a
+			 * sanity check that we can fit in the buffer at all.
+			 */
+			if (total > buf->dtb_size) {
+				dtrace_buffer_drop(buf);
+				return -1;
+			}
+
+			/*
+			 * We're going to be storing at the top of the buffer,
+			 * so now we need to deal with the wrapped offset.  We
+			 * only reset our wrapped offset to 0 if it is
+			 * currently greater than the current offset.  If it
+			 * is less than the current offset, it is because a
+			 * previous allocation induced a wrap -- but the
+			 * allocation didn't subsequently take the space due
+			 * to an error or false predicate evaluation.  In this
+			 * case, we'll just leave the wrapped offset alone: if
+			 * the wrapped offset hasn't been advanced far enough
+			 * for this allocation, it will be adjusted in the
+			 * lower loop.
+			 */
+			if (buf->dtb_flags & DTRACEBUF_WRAPPED) {
+				if (woffs >= offs)
+					woffs = 0;
+			} else
+				woffs = 0;
+
+			/*
+			 * Now we know that we're going to be storing to the
+			 * top of the buffer and that there is room for us
+			 * there.  We need to clear the buffer from the current
+			 * offset to the end (there may be old gunk there).
+			 */
+			while (offs < buf->dtb_size)
+				tomax[offs++] = 0;
+
+			/*
+			 * We need to set our offset to zero.  And because we
+			 * are wrapping, we need to set the bit indicating as
+			 * much.  We can also adjust our needed space back
+			 * down to the space required by the ECB -- we know
+			 * that the top of the buffer is aligned.
+			 */
+			offs = 0;
+			total = needed;
+			buf->dtb_flags |= DTRACEBUF_WRAPPED;
+		} else {
+			/*
+			 * There is room for us in the buffer, so we simply
+			 * need to check the wrapped offset.
+			 */
+			if (woffs < offs) {
+				/*
+				 * The wrapped offset is less than the offset.
+				 * This can happen if we allocated buffer space
+				 * that induced a wrap, but then we didn't
+				 * subsequently take the space due to an error
+				 * or false predicate evaluation.  This is
+				 * okay; we know that _this_ allocation isn't
+				 * going to induce a wrap.  We still can't
+				 * reset the wrapped offset to be zero,
+				 * however: the space may have been trashed in
+				 * the previous failed probe attempt.  But at
+				 * least the wrapped offset doesn't need to
+				 * be adjusted at all...
+				 */
+				goto out;
+			}
+		}
+
+		while (offs + total > woffs) {
+			dtrace_epid_t	epid = *(uint32_t *)(tomax + woffs);
+			size_t		size;
+
+			if (epid == DTRACE_EPIDNONE)
+				size = sizeof (uint32_t);
+			else {
+				ASSERT(epid <= state->dts_necbs);
+				ASSERT(state->dts_ecbs[epid - 1] != NULL);
+
+				size = state->dts_ecbs[epid - 1]->dte_size;
+			}
+
+			ASSERT(woffs + size <= buf->dtb_size);
+			ASSERT(size != 0);
+
+			if (woffs + size == buf->dtb_size) {
+				/*
+				 * We've reached the end of the buffer; we want
+				 * to set the wrapped offset to 0 and break
+				 * out.  However, if the offs is 0, then we're
+				 * in a strange edge-condition:  the amount of
+				 * space that we want to reserve plus the size
+				 * of the record that we're overwriting is
+				 * space but subsequently don't consume it (due
+				 * to a failed predicate or error) the wrapped
+				 * offset will be 0 -- yet the EPID at offset 0
+				 * will not be committed.  This situation is
+				 * relatively easy to deal with:  if we're in
+				 * this case, the buffer is indistinguishable
+				 * from one that hasn't wrapped; we need only
+				 * finish the job by clearing the wrapped bit,
+				 * explicitly setting the offset to be 0, and
+				 * zero'ing out the old data in the buffer.
+				 */
+				if (offs == 0) {
+					buf->dtb_flags &= ~DTRACEBUF_WRAPPED;
+					buf->dtb_offset = 0;
+					woffs = total;
+
+					while (woffs < buf->dtb_size)
+						tomax[woffs++] = 0;
+				}
+
+				woffs = 0;
+				break;
+			}
+
+			woffs += size;
+		}
+
+		/*
+		 * We have a wrapped offset.  It may be that the wrapped offset
+		 * has become zero -- that's okay.
+		 */
+		buf->dtb_xamot_offset = woffs;
+	}
+
+out:
+	/*
+	 * Now we can plow the buffer with any necessary padding.
+	 */
+	while (offs & (align - 1)) {
+		/*
+		 * Assert that our alignment is off by a number which
+		 * is itself sizeof (uint32_t) aligned.
+		 */
+		ASSERT(!((align - (offs & (align - 1))) &
+			(sizeof (uint32_t) - 1)));
+		DTRACE_STORE(uint32_t, tomax, offs, DTRACE_EPIDNONE);
+		dt_dbg_buf("    Store: %p[%ld .. %ld] <- EPIDNONE "
+			   "(from %s::%d)\n",
+			   buf, offs, offs + sizeof(uint32_t) - 1,
+			   __FUNCTION__, __LINE__);
+		offs += sizeof (uint32_t);
+	}
+
+	if (buf->dtb_flags & DTRACEBUF_FILL) {
+		if (offs + needed > buf->dtb_size - state->dts_reserve) {
+			buf->dtb_flags |= DTRACEBUF_FULL;
+			return -1;
+		}
+	}
+
+	if (mstate == NULL) {
+		dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+			   buf, offs, offs + needed - 1);
+		return offs;
+	}
+
+	/*
+	 * For ring buffers and fill buffers, the scratch space is always
+	 * the inactive buffer.
+	 */
+	mstate->dtms_scratch_base = (uintptr_t)buf->dtb_xamot;
+	mstate->dtms_scratch_size = buf->dtb_size;
+	mstate->dtms_scratch_ptr = mstate->dtms_scratch_base;
+
+	dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+		   buf, offs, offs + needed - 1);
+	return offs;
+}
+
+void dtrace_buffer_polish(dtrace_buffer_t *buf)
+{
+	ASSERT(buf->dtb_flags & DTRACEBUF_RING);
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (!(buf->dtb_flags & DTRACEBUF_WRAPPED))
+		return;
+
+	/*
+	 * We need to polish the ring buffer.  There are three cases:
+	 *
+	 * - The first (and presumably most common) is that there is no gap
+	 *   between the buffer offset and the wrapped offset.  In this case,
+	 *   there is nothing in the buffer that isn't valid data; we can
+	 *   mark the buffer as polished and return.
+	 *
+	 * - The second (less common than the first but still more common
+	 *   than the third) is that there is a gap between the buffer offset
+	 *   and the wrapped offset, and the wrapped offset is larger than the
+	 *   buffer offset.  This can happen because of an alignment issue, or
+	 *   can happen because of a call to dtrace_buffer_reserve() that
+	 *   didn't subsequently consume the buffer space.  In this case,
+	 *   we need to zero the data from the buffer offset to the wrapped
+	 *   offset.
+	 *
+	 * - The third (and least common) is that there is a gap between the
+	 *   buffer offset and the wrapped offset, but the wrapped offset is
+	 *   _less_ than the buffer offset.  This can only happen because a
+	 *   call to dtrace_buffer_reserve() induced a wrap, but the space
+	 *   was not subsequently consumed.  In this case, we need to zero the
+	 *   space from the offset to the end of the buffer _and_ from the
+	 *   top of the buffer to the wrapped offset.
+	 */
+	if (buf->dtb_offset < buf->dtb_xamot_offset)
+		memset(buf->dtb_tomax + buf->dtb_offset, 0,
+		       buf->dtb_xamot_offset - buf->dtb_offset);
+
+	if (buf->dtb_offset > buf->dtb_xamot_offset) {
+		memset(buf->dtb_tomax + buf->dtb_offset, 0,
+		       buf->dtb_size - buf->dtb_offset);
+		memset(buf->dtb_tomax, 0, buf->dtb_xamot_offset);
+	}
+}
+
+void dtrace_buffer_free(dtrace_buffer_t *bufs)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		dtrace_buffer_t	*buf = &bufs[cpu];
+
+		if (buf->dtb_tomax == NULL) {
+			ASSERT(buf->dtb_xamot == NULL);
+			ASSERT(buf->dtb_size == 0);
+
+			continue;
+		}
+
+		if (buf->dtb_xamot != NULL) {
+			ASSERT(!(buf->dtb_flags & DTRACEBUF_NOSWITCH));
+
+			vfree(buf->dtb_xamot);
+			buf->dtb_xamot = NULL;
+		}
+
+		vfree(buf->dtb_tomax);
+		buf->dtb_size = 0;
+		buf->dtb_tomax = NULL;
+	}
+}
diff --git a/dtrace/dtrace_debug.h b/dtrace/dtrace_debug.h
new file mode 100644
index 000000000000..c6f20178ef65
--- /dev/null
+++ b/dtrace/dtrace_debug.h
@@ -0,0 +1,108 @@
+/*
+ * Dynamic Tracing for Linux
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DTRACE_DEBUG_H_
+#define _DTRACE_DEBUG_H_
+
+#ifdef CONFIG_DT_DEBUG
+
+/*
+ * Enable all output and use dynamic debug when supported.
+ */
+# ifdef CONFIG_DYNAMIC_DEBUG
+
+#  define DT_DBG_AGG
+#  define DT_DBG_BUF
+#  define DT_DBG_DIF
+#  define DT_DBG_DOF
+#  define DT_DBG_ENABLE
+#  define DT_DBG_IOCTL
+#  define DT_DBG_PROBE
+
+#  define dt_dbg_print(fmt, ...)	pr_debug(fmt, ## __VA_ARGS__)
+
+# else /* CONFIG_DYNAMIC_DEBUG */
+
+#  undef DT_DBG_AGG
+#  undef DT_DBG_BUF
+#  undef DT_DBG_DIF
+#  undef DT_DBG_DOF
+#  undef DT_DBG_ENABLE
+#  undef DT_DBG_IOCTL
+#  undef DT_DBG_PROBE
+
+#  define dt_dbg_print(fmt, ...)	pr_info(fmt, ## __VA_ARGS__)
+
+# endif /* CONFIG_DYNAMIC_DEBUG */
+
+#else /* CONFIG_DT_DEBUG */
+
+# undef DT_DBG_AGG
+# undef DT_DBG_BUF
+# undef DT_DBG_DIF
+# undef DT_DBG_DOF
+# undef DT_DBG_ENABLE
+# undef DT_DBG_IOCTL
+# undef DT_DBG_PROBE
+
+#endif /* CONFIG_DT_DEBUG */
+
+/*
+ * Here are the actual actions for the various debug cases.
+ */
+#ifdef DT_DBG_AGG
+# define dt_dbg_agg(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_agg(fmt, ...)
+#endif
+
+#ifdef DT_DBG_BUF
+# define dt_dbg_buf(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_buf(fmt, ...)
+#endif
+
+#ifdef DT_DBG_DIF
+# define dt_dbg_dif(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_dif(fmt, ...)
+#endif
+
+#ifdef DT_DBG_DOF
+# define dt_dbg_dof(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_dof(fmt, ...)
+#endif
+
+#ifdef DT_DBG_ENABLE
+# define dt_dbg_enable(fmt, ...)	dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_enable(fmt, ...)
+#endif
+
+#ifdef DT_DBG_IOCTL
+# define dt_dbg_ioctl(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_ioctl(fmt, ...)
+#endif
+
+#ifdef DT_DBG_PROBE
+# define dt_dbg_probe(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_probe(fmt, ...)
+#endif
+
+#endif /* _DTRACE_DEBUG_H_ */
diff --git a/dtrace/dtrace_dev.c b/dtrace/dtrace_dev.c
new file mode 100644
index 000000000000..56e29d324c50
--- /dev/null
+++ b/dtrace/dtrace_dev.c
@@ -0,0 +1,1584 @@
+/*
+ * FILE:	dtrace_dev.c
+ * DESCRIPTION:	DTrace - Framework device driver
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <dtrace/types.h>
+#include <linux/dtrace/ioctl.h>
+#include <linux/fs.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+
+#include "ctf_api.h"
+#include "dtrace.h"
+#include "dtrace_dev.h"
+
+extern char			*dtrace_helptrace_buffer;
+extern int			dtrace_helptrace_bufsize;
+extern int			dtrace_helptrace_enabled;
+
+int				dtrace_opens;
+int				dtrace_err_verbose;
+
+dtrace_pops_t			dtrace_provider_ops = {
+	(void (*)(void *, const dtrace_probedesc_t *))dtrace_nullop,
+	(void (*)(void *, struct module *))dtrace_nullop,
+	(int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	NULL,
+	NULL,
+	NULL,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, struct module *))dtrace_nullop,
+};
+
+static size_t			dtrace_retain_max = 1024;
+
+dtrace_toxrange_t		*dtrace_toxrange;
+int				dtrace_toxranges;
+static int			dtrace_toxranges_max;
+
+struct kmem_cache		*dtrace_state_cachep;
+
+struct user_namespace		*init_user_namespace;
+
+static dtrace_pattr_t		dtrace_provider_attr = {
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+};
+
+DEFINE_MUTEX(dtrace_lock);
+
+void dtrace_nullop(void)
+{
+}
+
+int dtrace_enable_nullop(void)
+{
+	return 0;
+}
+
+
+#ifdef CONFIG_DT_DEBUG
+static void dtrace_ioctl_sizes(void)
+{
+#define DBG_PRINT(x) dt_dbg_ioctl("Size of %s: %lx\n", #x, sizeof(x))
+	DBG_PRINT(dtrace_providerdesc_t);
+	DBG_PRINT(dtrace_probedesc_t);
+	DBG_PRINT(dtrace_bufdesc_t);
+	DBG_PRINT(dtrace_eprobedesc_t);
+	DBG_PRINT(dtrace_argdesc_t);
+	DBG_PRINT(dtrace_conf_t);
+	DBG_PRINT(dtrace_status_t);
+	DBG_PRINT(processorid_t);
+	DBG_PRINT(dtrace_aggdesc_t);
+	DBG_PRINT(dtrace_fmtdesc_t);
+	DBG_PRINT(dof_hdr_t);
+#undef DBG_PRINT
+}
+
+#endif
+
+static int dtrace_open(struct inode *inode, struct file *file)
+{
+	dtrace_state_t	*state;
+	uint32_t	priv;
+	kuid_t		uid;
+
+	dtrace_cred2priv(file->f_cred, &priv, &uid);
+	if (priv == DTRACE_PRIV_NONE)
+		return -EACCES;
+
+#ifdef CONFIG_DT_DEBUG
+	dtrace_ioctl_sizes();
+#endif
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	dtrace_probe_provide(NULL, NULL);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * Do not let a consumer continue if it is not possible to enable
+	 * DTrace.
+	 */
+	if (dtrace_enable() != 0) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&cpu_lock);
+		return -EBUSY;
+	}
+
+	dtrace_opens++;
+	dtrace_membar_producer();
+
+	state = dtrace_state_create(file);
+	mutex_unlock(&cpu_lock);
+
+	if (state == NULL) {
+		if (--dtrace_opens == 0 && dtrace_anon.dta_enabling == NULL)
+			dtrace_disable();
+		mutex_unlock(&dtrace_lock);
+
+		return -EAGAIN;
+	}
+
+	file->private_data = state;
+	mutex_unlock(&dtrace_lock);
+
+	return 0;
+}
+
+static long dtrace_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	dtrace_state_t	*state = (dtrace_state_t *)file->private_data;
+	int		rval;
+	void __user	*argp = (void __user *)arg;
+
+	if (state->dts_anon) {
+		ASSERT(dtrace_anon.dta_state == NULL);
+		state = state->dts_anon;
+	}
+
+	switch (cmd) {
+	case DTRACEIOC_PROVIDER: {
+		dtrace_providerdesc_t	pvd;
+		dtrace_provider_t	*pvp;
+
+		dt_dbg_ioctl("IOCTL PROVIDER (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&pvd, argp, sizeof(pvd)) != 0)
+			return -EFAULT;
+
+		pvd.dtvd_name[DTRACE_PROVNAMELEN - 1] = '\0';
+		mutex_lock(&dtrace_provider_lock);
+
+		for (pvp = dtrace_provider; pvp != NULL; pvp = pvp->dtpv_next) {
+			if (strcmp(pvp->dtpv_name, pvd.dtvd_name) == 0)
+				break;
+		}
+
+		mutex_unlock(&dtrace_provider_lock);
+
+		if (pvp == NULL)
+			return -ESRCH;
+
+		memcpy(&pvd.dtvd_priv, &pvp->dtpv_priv,
+		       sizeof(dtrace_ppriv_t));
+		memcpy(&pvd.dtvd_attr, &pvp->dtpv_attr,
+		       sizeof(dtrace_pattr_t));
+
+		if (copy_to_user(argp, &pvd, sizeof(pvd)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_EPROBE: {
+		dtrace_eprobedesc_t	epdesc;
+		dtrace_ecb_t		*ecb;
+		dtrace_action_t		*act;
+		void			*buf;
+		size_t			size;
+		uint8_t			*dest;
+		int			nrecs;
+
+		dt_dbg_ioctl("IOCTL EPROBE (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&epdesc, argp, sizeof(epdesc)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+
+		if ((ecb = dtrace_epid2ecb(state, epdesc.dtepd_epid)) == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		if (ecb->dte_probe == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		epdesc.dtepd_probeid = ecb->dte_probe->dtpr_id;
+		epdesc.dtepd_uarg = ecb->dte_uarg;
+		epdesc.dtepd_size = ecb->dte_size;
+
+		nrecs = epdesc.dtepd_nrecs;
+		epdesc.dtepd_nrecs = 0;
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (DTRACEACT_ISAGG(act->dta_kind) || act->dta_intuple)
+				continue;
+
+			epdesc.dtepd_nrecs++;
+		}
+
+		/*
+		 * Now that we have the size, we need to allocate a temporary
+		 * buffer in which to store the complete description.  We need
+		 * the temporary buffer to be able to drop dtrace_lock()
+		 * across the copy_to_user(), below.
+		 */
+		size = sizeof(dtrace_eprobedesc_t) +
+		       (epdesc.dtepd_nrecs * sizeof(dtrace_recdesc_t));
+
+		buf = vmalloc(size);
+		if (buf == NULL)
+			return -ENOMEM;
+
+		dest = buf;
+		memcpy(dest, &epdesc, sizeof(epdesc));
+		dest += offsetof(dtrace_eprobedesc_t, dtepd_rec[0]);
+
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (DTRACEACT_ISAGG(act->dta_kind) || act->dta_intuple)
+				continue;
+
+			if (nrecs-- == 0)
+				break;
+
+			memcpy(dest, &act->dta_rec, sizeof(dtrace_recdesc_t));
+			dest += sizeof(dtrace_recdesc_t);
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, buf,
+				 (uintptr_t)(dest - (uint8_t *)buf)) != 0) {
+			vfree(buf);
+			return -EFAULT;
+		}
+
+		vfree(buf);
+		return 0;
+	}
+
+	case DTRACEIOC_AGGDESC: {
+		dtrace_aggdesc_t	aggdesc;
+		dtrace_action_t		*act;
+		dtrace_aggregation_t	*agg;
+		int			nrecs;
+		uint32_t		offs;
+		dtrace_recdesc_t	*lrec;
+		void			*buf;
+		size_t			size;
+		uint8_t			*dest;
+
+		dt_dbg_ioctl("IOCTL AGGDESC (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&aggdesc, argp, sizeof(aggdesc)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+
+		if ((agg = dtrace_aggid2agg(state, aggdesc.dtagd_id)) == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		aggdesc.dtagd_epid = agg->dtag_ecb->dte_epid;
+
+		nrecs = aggdesc.dtagd_nrecs;
+		aggdesc.dtagd_nrecs = 0;
+
+		offs = agg->dtag_base;
+		lrec = &agg->dtag_action.dta_rec;
+		aggdesc.dtagd_size = lrec->dtrd_offset + lrec->dtrd_size -
+				     offs;
+
+		for (act = agg->dtag_first; ; act = act->dta_next) {
+			ASSERT(act->dta_intuple ||
+			       DTRACEACT_ISAGG(act->dta_kind));
+
+			/*
+			 * If this action has a record size of zero, it
+			 * denotes an argument to the aggregating action.
+			 * Because the presence of this record doesn't (or
+			 * shouldn't) affect the way the data is interpreted,
+			 * we don't copy it out to save user-level the
+			 * confusion of dealing with a zero-length record.
+			 */
+			if (act->dta_rec.dtrd_size == 0) {
+				ASSERT(agg->dtag_hasarg);
+				continue;
+			}
+
+			aggdesc.dtagd_nrecs++;
+
+			if (act == &agg->dtag_action)
+				break;
+		}
+
+		/*
+		 * Now that we have the size, we need to allocate a temporary
+		 * buffer in which to store the complete description.  We need
+		 * the temporary buffer to be able to drop dtrace_lock()
+		 * across the copyout(), below.
+		 */
+		size = sizeof(dtrace_aggdesc_t) +
+		       (aggdesc.dtagd_nrecs * sizeof(dtrace_recdesc_t));
+
+		buf = vmalloc(size);
+		if (buf == NULL)
+			return -ENOMEM;
+
+		dest = buf;
+		memcpy(dest, &aggdesc, sizeof(aggdesc));
+		dest += offsetof(dtrace_aggdesc_t, dtagd_rec[0]);
+
+		for (act = agg->dtag_first; ; act = act->dta_next) {
+			dtrace_recdesc_t	rec = act->dta_rec;
+
+			/*
+			 * See the comment in the above loop for why we pass
+			 * over zero-length records.
+			 */
+			if (rec.dtrd_size == 0) {
+				ASSERT(agg->dtag_hasarg);
+				continue;
+			}
+
+			if (nrecs-- == 0)
+				break;
+
+			rec.dtrd_offset -= offs;
+			memcpy(dest, &rec, sizeof(rec));
+			dest += sizeof(dtrace_recdesc_t);
+
+			if (act == &agg->dtag_action)
+				break;
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, buf,
+				 (uintptr_t)(dest - (uint8_t *)buf)) != 0) {
+			vfree(buf);
+			return -EFAULT;
+		}
+
+		vfree(buf);
+		return 0;
+	}
+
+	case DTRACEIOC_ENABLE: {
+		dof_hdr_t		*dof;
+		dtrace_enabling_t	*enab = NULL;
+		dtrace_vstate_t		*vstate;
+		int			err = 0;
+		int			rv;
+
+		dt_dbg_ioctl("IOCTL ENABLE (cmd %#x), argp %p\n", cmd, argp);
+
+		rv = 0;
+
+		/*
+		 * If a NULL argument has been passed, we take this as our
+		 * cue to reevaluate our enablings.
+		 */
+		if (argp == NULL) {
+			dtrace_enabling_matchall();
+
+			return 0;
+		}
+
+		if ((dof = dtrace_dof_copyin(argp, &rval)) == NULL)
+			return rval;
+
+		mutex_lock(&cpu_lock);
+		mutex_lock(&dtrace_lock);
+		vstate = &state->dts_vstate;
+
+		if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&cpu_lock);
+			dtrace_dof_destroy(dof);
+			return -EBUSY;
+		}
+
+		if (dtrace_dof_slurp(dof, vstate, file->f_cred, &enab, 0,
+				     TRUE) != 0) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&cpu_lock);
+			dtrace_dof_destroy(dof);
+			return -EINVAL;
+		}
+
+		if ((rval = dtrace_dof_options(dof, state)) != 0) {
+			dtrace_enabling_destroy(enab);
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&cpu_lock);
+			dtrace_dof_destroy(dof);
+			return rval;
+		}
+
+		if ((err = dtrace_enabling_match(enab, &rv)) == 0)
+			err = dtrace_enabling_retain(enab);
+		else
+			dtrace_enabling_destroy(enab);
+
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&cpu_lock);
+		dtrace_dof_destroy(dof);
+
+		return err == 0 ? rv : err;
+	}
+
+	case DTRACEIOC_REPLICATE: {
+		dtrace_repldesc_t	desc;
+		dtrace_probedesc_t	*match = &desc.dtrpd_match;
+		dtrace_probedesc_t	*create = &desc.dtrpd_create;
+		int			err;
+
+		dt_dbg_ioctl("IOCTL REPLICATE (cmd %#x), argp %p\n",
+			     cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		match->dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+		match->dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+		match->dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+		match->dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+
+		create->dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+		create->dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+		create->dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+		create->dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+
+		mutex_lock(&dtrace_lock);
+		err = dtrace_enabling_replicate(state, match, create);
+		mutex_unlock(&dtrace_lock);
+
+		return err;
+	}
+
+	case DTRACEIOC_PROBEMATCH:
+	case DTRACEIOC_PROBES: {
+		int			id;
+		dtrace_probe_t		*probe = NULL;
+		dtrace_probedesc_t	desc;
+		dtrace_probekey_t	pkey;
+		uint32_t		priv;
+		kuid_t			uid;
+
+		dt_dbg_ioctl("IOCTL %s (cmd %#x), argp %p\n",
+			     cmd == DTRACEIOC_PROBES ? "PROBES"
+						     : "PROBEMATCH",
+			     cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		desc.dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+		desc.dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+		desc.dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+		desc.dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+
+		/*
+		 * Before we attempt to match this probe, we want to give
+		 * all providers the opportunity to provide it.
+		 */
+		if (desc.dtpd_id == DTRACE_IDNONE) {
+			mutex_lock(&module_mutex);
+			mutex_lock(&dtrace_provider_lock);
+			dtrace_probe_provide(&desc, NULL);
+			mutex_unlock(&dtrace_provider_lock);
+			mutex_unlock(&module_mutex);
+		}
+
+		if (cmd == DTRACEIOC_PROBEMATCH)  {
+			dtrace_probekey(&desc, &pkey);
+			pkey.dtpk_id = DTRACE_IDNONE;
+		}
+
+		dtrace_cred2priv(file->f_cred, &priv, &uid);
+
+		mutex_lock(&dtrace_lock);
+
+		id = desc.dtpd_id;
+		if (cmd == DTRACEIOC_PROBEMATCH)  {
+			int	m = 0;
+
+			while ((probe = dtrace_probe_get_next(&id))
+			       != NULL) {
+				if ((m = dtrace_match_probe(
+						probe, &pkey, priv, uid)))
+					break;
+
+				id++;
+			}
+
+			if (m < 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EINVAL;
+			}
+		} else {
+			while ((probe = dtrace_probe_get_next(&id))
+			       != NULL) {
+				if (dtrace_match_priv(probe, priv, uid))
+					break;
+
+				id++;
+			}
+		}
+
+		if (probe == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -ESRCH;
+		}
+
+		dtrace_probe_description(probe, &desc);
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_PROBEARG: {
+		dtrace_argdesc_t	desc;
+		dtrace_probe_t		*probe;
+		dtrace_provider_t	*prov;
+
+		dt_dbg_ioctl("IOCTL PROBEARG (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		if (desc.dtargd_id == DTRACE_IDNONE)
+			return -EINVAL;
+
+		if (desc.dtargd_ndx == DTRACE_ARGNONE)
+			return -EINVAL;
+
+		mutex_lock(&module_mutex);
+		mutex_lock(&dtrace_provider_lock);
+		mutex_lock(&dtrace_lock);
+
+		probe = dtrace_probe_lookup_id(desc.dtargd_id);
+		if (probe == NULL) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+			mutex_unlock(&module_mutex);
+
+			return -EINVAL;
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		prov = probe->dtpr_provider;
+
+		if (prov->dtpv_pops.dtps_getargdesc == NULL) {
+			/*
+			 * There isn't any typed information for this probe.
+			 * Set the argument number to DTRACE_ARGNONE.
+			 */
+			desc.dtargd_ndx = DTRACE_ARGNONE;
+		} else {
+			desc.dtargd_native[0] = '\0';
+			desc.dtargd_xlate[0] = '\0';
+			desc.dtargd_mapping = desc.dtargd_ndx;
+
+			prov->dtpv_pops.dtps_getargdesc(
+				prov->dtpv_arg, probe->dtpr_id,
+				probe->dtpr_arg, &desc);
+		}
+
+		mutex_unlock(&dtrace_provider_lock);
+		mutex_unlock(&module_mutex);
+
+		if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_GO: {
+		processorid_t	cpuid;
+
+		dt_dbg_ioctl("IOCTL GO (cmd %#x), argp %p\n", cmd, argp);
+
+		rval = dtrace_state_go(state, &cpuid);
+
+		if (rval != 0)
+			return rval;
+
+		if (copy_to_user(argp, &cpuid, sizeof(cpuid)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_STOP: {
+		processorid_t	cpuid;
+
+		dt_dbg_ioctl("IOCTL STOP (cmd %#x), argp %p\n", cmd, argp);
+
+		mutex_lock(&dtrace_lock);
+		rval = dtrace_state_stop(state, &cpuid);
+		mutex_unlock(&dtrace_lock);
+
+		if (rval != 0)
+			return rval;
+
+		if (copy_to_user(argp, &cpuid, sizeof(cpuid)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_DOFGET: {
+		dof_hdr_t	hdr, *dof;
+		uint64_t	len;
+
+		dt_dbg_ioctl("IOCTL DOFGET (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&hdr, argp, sizeof(hdr)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+		dof = dtrace_dof_create(state);
+		mutex_unlock(&dtrace_lock);
+		if (dof == NULL)
+			return -ENOMEM;
+
+		len = min(hdr.dofh_loadsz, dof->dofh_loadsz);
+		rval = copy_to_user(argp, dof, len);
+		dtrace_dof_destroy(dof);
+
+		return rval == 0 ? 0 : -EFAULT;
+	}
+
+	case DTRACEIOC_AGGSNAP:
+	case DTRACEIOC_BUFSNAP: {
+		dtrace_bufdesc_t	desc;
+		caddr_t			cached;
+		dtrace_buffer_t		*buf;
+
+		dt_dbg_ioctl("IOCTL %s (cmd %#x), argp %p\n",
+			     cmd == DTRACEIOC_AGGSNAP ? "AGGSNAP"
+						      : "BUFSNAP",
+			     cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		if (desc.dtbd_cpu < 0 || desc.dtbd_cpu >= NR_CPUS)
+			return -EINVAL;
+
+		mutex_lock(&dtrace_lock);
+
+		if (cmd == DTRACEIOC_BUFSNAP)
+			buf = &state->dts_buffer[desc.dtbd_cpu];
+		else
+			buf = &state->dts_aggbuffer[desc.dtbd_cpu];
+
+		if (buf->dtb_flags & (DTRACEBUF_RING | DTRACEBUF_FILL)) {
+			size_t	sz = buf->dtb_offset;
+
+			if (state->dts_activity != DTRACE_ACTIVITY_STOPPED) {
+				mutex_unlock(&dtrace_lock);
+				return -EBUSY;
+			}
+
+			/*
+			 * If this buffer has already been consumed, we're
+			 * going to indicate that there's nothing left here
+			 * to consume.
+			 */
+			if (buf->dtb_flags & DTRACEBUF_CONSUMED) {
+				mutex_unlock(&dtrace_lock);
+
+				desc.dtbd_size = 0;
+				desc.dtbd_drops = 0;
+				desc.dtbd_errors = 0;
+				desc.dtbd_oldest = 0;
+				sz = sizeof(desc);
+
+				if (copy_to_user(argp, &desc, sz) != 0)
+					return -EFAULT;
+
+				return 0;
+			}
+
+			/*
+			 * If this is a ring buffer that has wrapped, we want
+			 * to copy the whole thing out.
+			 */
+			if (buf->dtb_flags & DTRACEBUF_WRAPPED) {
+				dtrace_buffer_polish(buf);
+				sz = buf->dtb_size;
+			}
+
+			if (copy_to_user(desc.dtbd_data, buf->dtb_tomax,
+					 sz) != 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EFAULT;
+			}
+
+			desc.dtbd_size = sz;
+			desc.dtbd_drops = buf->dtb_drops;
+			desc.dtbd_errors = buf->dtb_errors;
+			desc.dtbd_oldest = buf->dtb_xamot_offset;
+
+			mutex_unlock(&dtrace_lock);
+
+			if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+				return -EFAULT;
+
+			buf->dtb_flags |= DTRACEBUF_CONSUMED;
+
+			return 0;
+		}
+
+		if (buf->dtb_tomax == NULL) {
+			ASSERT(buf->dtb_xamot == NULL);
+			mutex_unlock(&dtrace_lock);
+			return -ENOENT;
+		}
+
+		cached = buf->dtb_tomax;
+
+		dtrace_xcall(desc.dtbd_cpu,
+			     (dtrace_xcall_t)dtrace_buffer_switch, buf);
+
+		state->dts_errors += buf->dtb_xamot_errors;
+
+		/*
+		 * If the buffers did not actually switch, then the cross call
+		 * did not take place -- presumably because the given CPU is
+		 * not in the ready set.  If this is the case, we'll return
+		 * ENOENT.
+		 */
+		if (buf->dtb_tomax == cached) {
+			ASSERT(buf->dtb_xamot != cached);
+			mutex_unlock(&dtrace_lock);
+			return -ENOENT;
+		}
+
+		ASSERT(cached == buf->dtb_xamot);
+
+		/*
+		 * We have our snapshot; now copy it out.
+		 */
+		if (copy_to_user(desc.dtbd_data, buf->dtb_xamot,
+				 buf->dtb_xamot_offset) != 0) {
+			mutex_unlock(&dtrace_lock);
+			return -EFAULT;
+		}
+
+		desc.dtbd_size = buf->dtb_xamot_offset;
+		desc.dtbd_drops = buf->dtb_xamot_drops;
+		desc.dtbd_errors = buf->dtb_xamot_errors;
+		desc.dtbd_oldest = 0;
+
+		mutex_unlock(&dtrace_lock);
+
+		/*
+		 * Finally, copy out the buffer description.
+		 */
+		if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_CONF: {
+		dtrace_conf_t	conf;
+
+		dt_dbg_ioctl("IOCTL CONF (cmd %#x), argp %p\n", cmd, argp);
+
+		memset(&conf, 0, sizeof(conf));
+		conf.dtc_difversion = DIF_VERSION;
+		conf.dtc_difintregs = DIF_DIR_NREGS;
+		conf.dtc_diftupregs = DIF_DTR_NREGS;
+		conf.dtc_ctfmodel = CTF_MODEL_NATIVE;
+		conf.dtc_maxbufs = nr_cpu_ids;
+
+		if (copy_to_user(argp, &conf, sizeof(conf)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_STATUS: {
+		dtrace_status_t	stat;
+		dtrace_dstate_t	*dstate;
+		int		i, j;
+		uint64_t	nerrs;
+
+		dt_dbg_ioctl("IOCTL STATUS (cmd %#x), argp %p\n", cmd, argp);
+
+		/*
+		 * See the comment in dtrace_state_deadman() for the reason
+		 * for setting dts_laststatus to UINT64_MAX before setting
+		 * it to the correct value.
+		 */
+		state->dts_laststatus = ns_to_ktime(UINT64_MAX);
+		dtrace_membar_producer();
+		state->dts_laststatus = dtrace_gethrtime();
+
+		memset(&stat, 0, sizeof(stat));
+
+		mutex_lock(&dtrace_lock);
+
+		if (state->dts_activity == DTRACE_ACTIVITY_INACTIVE) {
+			mutex_unlock(&dtrace_lock);
+			return -ENOENT;
+		}
+
+		if (state->dts_activity == DTRACE_ACTIVITY_DRAINING)
+			stat.dtst_exiting = 1;
+
+		nerrs = state->dts_errors;
+		dstate = &state->dts_vstate.dtvs_dynvars;
+
+		for (i = 0; i < NR_CPUS; i++) {
+			dtrace_dstate_percpu_t	*dcpu = &dstate->dtds_percpu[i];
+
+			stat.dtst_dyndrops += dcpu->dtdsc_drops;
+			stat.dtst_dyndrops_dirty += dcpu->dtdsc_dirty_drops;
+			stat.dtst_dyndrops_rinsing += dcpu->dtdsc_rinsing_drops;
+
+			if (state->dts_buffer[i].dtb_flags & DTRACEBUF_FULL)
+				stat.dtst_filled++;
+
+			nerrs += state->dts_buffer[i].dtb_errors;
+
+			for (j = 0; j < state->dts_nspeculations; j++) {
+				dtrace_speculation_t	*spec;
+				dtrace_buffer_t		*buf;
+
+				spec = &state->dts_speculations[j];
+				buf = &spec->dtsp_buffer[i];
+				stat.dtst_specdrops += buf->dtb_xamot_drops;
+			}
+		}
+
+		stat.dtst_specdrops_busy = state->dts_speculations_busy;
+		stat.dtst_specdrops_unavail = state->dts_speculations_unavail;
+		stat.dtst_stkstroverflows = state->dts_stkstroverflows;
+		stat.dtst_dblerrors = state->dts_dblerrors;
+		stat.dtst_killed = (state->dts_activity ==
+				    DTRACE_ACTIVITY_KILLED);
+		stat.dtst_errors = nerrs;
+
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, &stat, sizeof(stat)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_FORMAT: {
+		dtrace_fmtdesc_t	fmt;
+		char			*str;
+		int			len;
+
+		dt_dbg_ioctl("IOCTL FORMAT (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&fmt, argp, sizeof (fmt)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+
+		if (fmt.dtfd_format == 0 ||
+		    fmt.dtfd_format > state->dts_nformats) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		/*
+		 * Format strings are allocated contiguously and they are
+		 * never freed; if a format index is less than the number
+		 * of formats, we can assert that the format map is non-NULL
+		 * and that the format for the specified index is non-NULL.
+		 */
+		ASSERT(state->dts_formats != NULL);
+		str = state->dts_formats[fmt.dtfd_format - 1];
+		ASSERT(str != NULL);
+
+		len = strlen(str) + 1;
+
+		if (len > fmt.dtfd_length) {
+			fmt.dtfd_length = len;
+
+			if (copy_to_user(argp, &fmt, sizeof (fmt)) != 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EINVAL;
+			}
+		} else {
+			if (copy_to_user(fmt.dtfd_string, str, len) != 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EINVAL;
+			}
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		return 0;
+	}
+
+	default:
+		dt_dbg_ioctl("IOCTL ??? (cmd %#x), argp %p\n",
+			     cmd, argp);
+		break;
+	}
+
+	return -ENOTTY;
+}
+
+static int dtrace_close(struct inode *inode, struct file *file)
+{
+	dtrace_state_t	*state = file->private_data;
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * If there is anonymous state, destroy that first.
+	 */
+	if (state->dts_anon) {
+		ASSERT(dtrace_anon.dta_state == NULL);
+		dtrace_state_destroy(state->dts_anon);
+	}
+
+	dtrace_state_destroy(state);
+	ASSERT(dtrace_opens > 0);
+
+	if (--dtrace_opens == 0 && dtrace_anon.dta_enabling == NULL)
+		dtrace_disable();
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&cpu_lock);
+
+	return 0;
+}
+
+static int dtrace_helper_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long dtrace_helper_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	int		rval;
+	dof_helper_t	help, *dhp = NULL;
+	void __user	*argp = (void __user *)arg;
+
+	switch (cmd) {
+	case DTRACEHIOC_ADDDOF:
+		dt_dbg_ioctl("Helper IOCTL ADDDOF (cmd %#x), argp %p\n",
+			     cmd, argp);
+
+		if (copy_from_user(&help, argp, sizeof(help)) != 0) {
+			dtrace_dof_error(NULL, "failed to copy DOF helper");
+			return -EFAULT;
+		}
+
+		dhp = &help;
+		argp = (void __user *)help.dofhp_dof;
+
+		/* fallthrough */
+
+	case DTRACEHIOC_ADD: {
+		dof_hdr_t	*dof = dtrace_dof_copyin(argp, &rval);
+
+		if (dof == NULL)
+			return rval;
+
+		if (cmd == DTRACEHIOC_ADD)
+			dt_dbg_ioctl("Helper IOCTL ADD (cmd %#x), argp %p\n",
+				     cmd, argp);
+
+		mutex_lock(&dtrace_lock);
+
+		/*
+		 * The dtrace_helper_slurp() routine takes responsibility for
+		 * the dof -- it may free it now, or it may save it and free it
+		 * later.
+		 */
+		if ((rval = dtrace_helper_slurp(dof, dhp)) == -1)
+			rval = -EINVAL;
+
+		mutex_unlock(&dtrace_lock);
+
+		dt_dbg_ioctl("Helper IOCTL %s returning %d\n",
+			     cmd == DTRACEHIOC_ADD ? "ADD"
+						   : "ADDDOF",
+			     rval);
+
+		return rval;
+	}
+
+	case DTRACEHIOC_REMOVE:
+		dt_dbg_ioctl("Helper IOCTL REMOVE (cmd %#x), argp %p\n",
+			     cmd, argp);
+
+		mutex_lock(&dtrace_lock);
+
+		rval = dtrace_helper_destroygen((uintptr_t)argp);
+
+		mutex_unlock(&dtrace_lock);
+
+		dt_dbg_ioctl("Helper IOCTL REMOVE returning %d\n", rval);
+
+		return rval;
+	default:
+		dt_dbg_ioctl("Helper IOCTL ??? (cmd %#x), argp %p\n",
+			     cmd, argp);
+		break;
+	}
+
+	return -ENOTTY;
+}
+
+static int dtrace_helper_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations dtrace_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = dtrace_ioctl,
+        .open   = dtrace_open,
+        .release = dtrace_close,
+};
+
+static const struct file_operations helper_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = dtrace_helper_ioctl,
+        .compat_ioctl = dtrace_helper_ioctl,
+        .open   = dtrace_helper_open,
+        .release = dtrace_helper_close,
+};
+
+static struct miscdevice dtrace_dev = {
+	.minor = DT_DEV_DTRACE_MINOR,
+	.name = "dtrace",
+	.nodename = "dtrace/dtrace",
+	.fops = &dtrace_fops,
+};
+
+static struct miscdevice helper_dev = {
+	.minor = DT_DEV_HELPER_MINOR,
+	.name = "helper",
+	.nodename = "dtrace/helper",
+	.fops = &helper_fops,
+};
+
+static void dtrace_module_loaded(struct module *mp)
+{
+	dtrace_provider_t *prv;
+
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+
+	/*
+	 * Give all providers a chance to register probes for this module.
+	 */
+	for (prv = dtrace_provider; prv != NULL; prv = prv->dtpv_next)
+		prv->dtpv_pops.dtps_provide_module(prv->dtpv_arg, mp);
+
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	/*
+	 * If we have any retained enablings, we need to match against them.
+	 */
+	mutex_lock(&dtrace_lock);
+
+	if (dtrace_retained == NULL) {
+		mutex_unlock(&dtrace_lock);
+		return;
+	}
+
+	mutex_unlock(&dtrace_lock);
+	dtrace_enabling_matchall();
+}
+
+static void dtrace_module_unloaded(struct module *mp)
+{
+	dtrace_probe_t template, *probe, *first, *next;
+	dtrace_provider_t *prv;
+
+	template.dtpr_mod = mp->name;
+
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (dtrace_bymod == NULL) {
+		/*
+		 * The DTrace module is loaded (obviously) but not attached;
+		 * we don't have any work to do.
+		 */
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+		mutex_unlock(&module_mutex);
+		return;
+	}
+
+	for (probe = first = dtrace_hash_lookup(dtrace_bymod, &template);
+	     probe != NULL; probe = probe->dtpr_nextmod) {
+		if (probe->dtpr_ecb != NULL) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+			mutex_unlock(&module_mutex);
+
+			/*
+			 * This shouldn't _actually_ be possible -- we're
+			 * unloading a module that has an enabled probe in it.
+			 * (It's normally up to the provider to make sure that
+			 * this can't happen.)  However, because dtps_enable()
+			 * doesn't have a failure mode, there can be an
+			 * enable/unload race.  Upshot:  we don't want to
+			 * assert, but we're not going to disable the
+			 * probe, either.
+			 */
+			if (dtrace_err_verbose) {
+				pr_warning("unloaded module '%s' had "
+				    "enabled probes", mp->name);
+			}
+
+			return;
+		}
+	}
+
+	probe = first;
+
+	for (first = NULL; probe != NULL; probe = next) {
+		dtrace_probe_remove_id(probe->dtpr_id);
+
+		next = probe->dtpr_nextmod;
+		dtrace_hash_remove(dtrace_bymod, probe);
+		dtrace_hash_remove(dtrace_byfunc, probe);
+		dtrace_hash_remove(dtrace_byname, probe);
+
+		if (first == NULL) {
+			first = probe;
+			probe->dtpr_nextmod = NULL;
+		} else {
+			probe->dtpr_nextmod = first;
+			first = probe;
+		}
+	}
+
+	/*
+	 * We've removed all of the module's probes from the hash chains and
+	 * from the probe array.  Now issue a dtrace_sync() to be sure that
+	 * everyone has cleared out from any probe array processing.
+	 */
+	dtrace_sync();
+
+	for (probe = first; probe != NULL; probe = first) {
+		first = probe->dtpr_nextmod;
+		prv = probe->dtpr_provider;
+		prv->dtpv_pops.dtps_destroy(prv->dtpv_arg, probe->dtpr_id,
+		    probe->dtpr_arg);
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kfree(probe);
+	}
+
+	/*
+	 * Notify providers to cleanup per-module data for this module.
+	 */
+	for (prv = dtrace_provider; prv != NULL; prv = prv->dtpv_next)
+		if (prv->dtpv_pops.dtps_destroy_module != NULL)
+			prv->dtpv_pops.dtps_destroy_module(prv->dtpv_arg, mp);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+}
+
+/*
+ * Register a toxic range.
+ */
+static void dtrace_toxrange_add(uintptr_t base, uintptr_t limit)
+{
+	if (dtrace_toxranges >= dtrace_toxranges_max) {
+		int			osize, nsize;
+		dtrace_toxrange_t	*range;
+
+		osize = dtrace_toxranges_max * sizeof(dtrace_toxrange_t);
+
+		if (osize == 0) {
+			ASSERT(dtrace_toxrange == NULL);
+			ASSERT(dtrace_toxranges_max == 0);
+
+			dtrace_toxranges_max = 1;
+		} else
+			dtrace_toxranges_max <<= 1;
+
+		nsize = dtrace_toxranges_max * sizeof(dtrace_toxrange_t);
+		range = vzalloc(nsize);
+		if (range == NULL) {
+			pr_warn("Failed to add toxic range: out of memory\n");
+			return;
+		}
+
+		if (dtrace_toxrange != NULL) {
+			ASSERT(osize != 0);
+
+			memcpy(range, dtrace_toxrange, osize);
+			vfree(dtrace_toxrange);
+		}
+
+		dtrace_toxrange = range;
+	}
+
+	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_base == (uintptr_t)NULL);
+	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_limit == (uintptr_t)NULL);
+
+	dtrace_toxrange[dtrace_toxranges].dtt_base = base;
+	dtrace_toxrange[dtrace_toxranges].dtt_limit = limit;
+	dtrace_toxranges++;
+}
+
+/*
+ * Check if an address falls within a toxic region.
+ */
+int dtrace_istoxic(uintptr_t kaddr, size_t size)
+{
+	uintptr_t	taddr, tsize;
+	int		i;
+
+	for (i = 0; i < dtrace_toxranges; i++) {
+		taddr = dtrace_toxrange[i].dtt_base;
+		tsize = dtrace_toxrange[i].dtt_limit - taddr;
+
+		if (kaddr - taddr < tsize) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+			this_cpu_core->cpuc_dtrace_illval = kaddr;
+			return 1;
+		}
+
+		if (taddr - kaddr < size) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+			this_cpu_core->cpuc_dtrace_illval = kaddr;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int dtrace_mod_notifier(struct notifier_block *nb, unsigned long val,
+			       void *args)
+{
+	struct module	*mp = args;
+
+	if (!mp)
+		return NOTIFY_DONE;
+
+	switch (val) {
+	case MODULE_STATE_LIVE:
+		dtrace_module_loaded(mp);
+		break;
+
+	case MODULE_STATE_GOING:
+		dtrace_module_unloaded(mp);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block    dtrace_modmgmt = {
+	.notifier_call = dtrace_mod_notifier,
+};
+
+/*
+ * Initialize the DTrace core.
+ *
+ * Equivalent to: dtrace_attach()
+ */
+int dtrace_dev_init(void)
+{
+	dtrace_provider_id_t	id;
+	int			rc = 0;
+	struct cred		*cred;
+
+	/*
+	 * Register the device for the DTrace core.
+	 */
+	rc = misc_register(&dtrace_dev);
+	if (rc) {
+		pr_err("%s: Can't register misc device %d\n",
+		       dtrace_dev.name, dtrace_dev.minor);
+
+		return rc;
+	}
+
+	/*
+	 * Register the device for the DTrace helper.
+	 */
+	rc = misc_register(&helper_dev);
+	if (rc) {
+		pr_err("%s: Can't register misc device %d\n",
+		       helper_dev.name, helper_dev.minor);
+
+		misc_deregister(&dtrace_dev);
+		return rc;
+	}
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	rc = dtrace_probe_init();
+	if (rc) {
+		pr_err("Failed to initialize DTrace core\n");
+
+		goto errout;
+	}
+
+#if defined(CONFIG_DT_FASTTRAP) || defined(CONFIG_DT_FASTTRAP_MODULE)
+	dtrace_helpers_cleanup = dtrace_helpers_destroy;
+	dtrace_helpers_fork = dtrace_helpers_duplicate;
+#endif
+#ifdef FIXME
+	dtrace_cpu_init = dtrace_cpu_setup_initial;
+	dtrace_cpustart_init = dtrace_suspend;
+	dtrace_cpustart_fini = dtrace_resume;
+	dtrace_debugger_init = dtrace_suspend;
+	dtrace_debugger_fini = dtrace_resume;
+
+	register_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);
+#endif
+
+#ifdef FIXME
+	dtrace_taskq = taskq_create("dtrace_taskq", 1, maxclsyspri, 1, INT_MAX,
+				    0);
+#endif
+
+        dtrace_state_cachep = kmem_cache_create("dtrace_state_cache",
+				sizeof(dtrace_dstate_percpu_t) * NR_CPUS, 0,
+				SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
+
+	/* From now on the failures are results of failed allocations. */
+	rc = -ENOMEM;
+
+	/*
+	 * Create the probe hashtables.
+	 */
+	dtrace_bymod = dtrace_hash_create(
+				offsetof(dtrace_probe_t, dtpr_mod),
+				offsetof(dtrace_probe_t, dtpr_nextmod),
+				offsetof(dtrace_probe_t, dtpr_prevmod));
+	if (dtrace_bymod == NULL)
+		goto errout;
+
+	dtrace_byfunc = dtrace_hash_create(
+				offsetof(dtrace_probe_t, dtpr_func),
+				offsetof(dtrace_probe_t, dtpr_nextfunc),
+				offsetof(dtrace_probe_t, dtpr_prevfunc));
+	if (dtrace_byfunc == NULL)
+		goto errout;
+
+	dtrace_byname = dtrace_hash_create(
+				offsetof(dtrace_probe_t, dtpr_name),
+				offsetof(dtrace_probe_t, dtpr_nextname),
+				offsetof(dtrace_probe_t, dtpr_prevname));
+	if (dtrace_byname == NULL)
+		goto errout;
+
+	/*
+	 * Initialize cred.
+	 */
+	cred = prepare_kernel_cred(NULL);
+	if (cred == NULL)
+		goto errout;
+
+	init_user_namespace = cred->user_ns;
+	put_cred(cred);
+
+	/*
+	 * Ensure that the X configuration parameter has a legal value.
+	 */
+	if (dtrace_retain_max < 1) {
+		pr_warning("Illegal value (%lu) for dtrace_retain_max; "
+			   "setting to 1", (unsigned long)dtrace_retain_max);
+
+		dtrace_retain_max = 1;
+	}
+
+	/*
+	 * Discover our toxic ranges.
+	 */
+	dtrace_toxic_ranges(dtrace_toxrange_add);
+
+	/*
+	 * Register ourselves as a provider.
+	 */
+	dtrace_register("dtrace", &dtrace_provider_attr, DTRACE_PRIV_NONE, 0,
+			&dtrace_provider_ops, NULL, &id);
+
+	ASSERT(dtrace_provider != NULL);
+	ASSERT((dtrace_provider_id_t)dtrace_provider == id);
+
+	/*
+	 * Create BEGIN, END, and ERROR probes.
+	 */
+	dtrace_probeid_begin = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "BEGIN", 0, NULL);
+	if (dtrace_probeid_begin == DTRACE_IDNONE)
+		goto errout;
+
+	dtrace_probeid_end = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "END", 0, NULL);
+	if (dtrace_probeid_end == DTRACE_IDNONE)
+		goto errout;
+
+	dtrace_probeid_error = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "ERROR", 1, NULL);
+	if (dtrace_probeid_error == DTRACE_IDNONE)
+		goto errout;
+
+	dtrace_anon_property();
+
+	/*
+	 * If DTrace helper tracing is enabled, we need to allocate a trace
+	 * buffer.
+	 */
+	if (dtrace_helptrace_enabled) {
+		ASSERT(dtrace_helptrace_buffer == NULL);
+
+		dtrace_helptrace_buffer = vzalloc(dtrace_helptrace_bufsize);
+
+		if (dtrace_helptrace_buffer == NULL) {
+			pr_warn("Cannot allocate helptrace buffer; "
+				"disabling dtrace_helptrace\n");
+			dtrace_helptrace_enabled = 0;
+		}
+	}
+
+#ifdef FIXME
+	/*
+	 * There is usually code here to handle the case where there already
+	 * are providers when we get to this code.  On Linux, that does not
+	 * seem to be possible since the DTrace core module (this code) is
+	 * loaded as a dependency for each provider, and thus this
+	 * initialization code is executed prior to the initialization code of
+	 * the first provider causing the core to be loaded.
+	 */
+#endif
+
+	if (register_module_notifier(&dtrace_modmgmt))
+		goto errout;
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+	mutex_unlock(&cpu_lock);
+
+	return 0;
+
+errout:
+	if (dtrace_provider != NULL)
+		(void) dtrace_unregister((dtrace_provider_id_t)dtrace_provider);
+
+	dtrace_hash_destroy(dtrace_bymod);
+	dtrace_hash_destroy(dtrace_byfunc);
+	dtrace_hash_destroy(dtrace_byname);
+
+	misc_deregister(&helper_dev);
+	misc_deregister(&dtrace_dev);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+	mutex_unlock(&cpu_lock);
+
+	return rc;
+}
+
+void dtrace_dev_exit(void)
+{
+	mutex_lock(&cpu_lock);
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	dtrace_unregister((dtrace_provider_id_t)dtrace_provider);
+	dtrace_provider = NULL;
+
+	dtrace_probe_exit();
+
+	unregister_module_notifier(&dtrace_modmgmt);
+
+#if defined(CONFIG_DT_FASTTRAP) || defined(CONFIG_DT_FASTTRAP_MODULE)
+	dtrace_helpers_cleanup = NULL;
+	dtrace_helpers_fork = NULL;
+#endif
+#ifdef FIXME
+	dtrace_cpu_init = NULL;
+	dtrace_cpustart_init = NULL;
+	dtrace_cpustart_fini = NULL;
+	dtrace_debugger_init = NULL;
+	dtrace_debugger_fini = NULL;
+
+	unregister_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);
+#endif
+
+	mutex_unlock(&cpu_lock);
+
+	dtrace_hash_destroy(dtrace_bymod);
+	dtrace_hash_destroy(dtrace_byfunc);
+	dtrace_hash_destroy(dtrace_byname);
+	dtrace_bymod = NULL;
+	dtrace_byfunc = NULL;
+	dtrace_byname = NULL;
+
+	/*
+	 * If DTrace helper tracing is enabled, we need to free the trace
+	 * buffer.
+	 */
+	if (dtrace_helptrace_enabled || dtrace_helptrace_buffer)
+		vfree(dtrace_helptrace_buffer);
+
+	kmem_cache_destroy(dtrace_state_cachep);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	misc_deregister(&helper_dev);
+	misc_deregister(&dtrace_dev);
+}
diff --git a/dtrace/dtrace_dev.h b/dtrace/dtrace_dev.h
new file mode 100644
index 000000000000..a7629a1ea63a
--- /dev/null
+++ b/dtrace/dtrace_dev.h
@@ -0,0 +1,34 @@
+/*
+ * Dynamic Tracing for Linux
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DTRACE_DEV_H_
+#define _DTRACE_DEV_H_
+
+#define DT_DEV_DTRACE_MINOR	(16)
+#define DT_DEV_HELPER_MINOR	(DT_DEV_DTRACE_MINOR + 1)
+#define DT_DEV_PROFILE_MINOR	(DT_DEV_HELPER_MINOR + 1)
+#define DT_DEV_SYSTRACE_MINOR	(DT_DEV_PROFILE_MINOR + 1)
+#define DT_DEV_FBT_MINOR	(DT_DEV_SYSTRACE_MINOR + 1)
+#define DT_DEV_SDT_MINOR	(DT_DEV_FBT_MINOR + 1)
+#define DT_DEV_FASTTRAP_MINOR	(DT_DEV_SDT_MINOR + 1)
+#define DT_DEV_LOCKSTAT_MINOR	(DT_DEV_FASTTRAP_MINOR + 1)
+#define DT_DEV_DT_TEST_MINOR	(DT_DEV_LOCKSTAT_MINOR + 1)
+#define DT_DEV_DT_PERF_MINOR	(DT_DEV_DT_TEST_MINOR + 1)
+
+extern int dtrace_dev_init(void);
+extern void dtrace_dev_exit(void);
+
+#endif /* _DTRACE_DEV_H_ */
diff --git a/dtrace/dtrace_dif.c b/dtrace/dtrace_dif.c
new file mode 100644
index 000000000000..b7dceb710cc6
--- /dev/null
+++ b/dtrace/dtrace_dif.c
@@ -0,0 +1,4874 @@
+/*
+ * FILE:	dtrace_dif.c
+ * DESCRIPTION:	DTrace - DIF object implementation
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/fdtable.h>
+#include <linux/hardirq.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_infiniband.h>
+#include <linux/in6.h>
+#include <linux/inet.h>
+#include <linux/kdev_t.h>
+#include <linux/slab.h>
+#include <linux/socket.h>
+#include <linux/vmalloc.h>
+#include <net/ipv6.h>
+#include <asm/byteorder.h>
+
+#include <linux/mount.h>
+
+#include "dtrace.h"
+
+size_t				dtrace_global_maxsize = 16 * 1024;
+
+/*
+ * This externally visible variable (accessible through the backtick (`)
+ * syntax is provided as a source of well-known, zero-filled memory.  Some
+ * translators use this in their implementation.
+ */
+const char			dtrace_zero[256] = { 0, };
+
+uint64_t			dtrace_vtime_references;
+
+static const char		dtrace_hexdigits[] = "0123456789abcdef";
+
+static int dtrace_difo_err(uint_t pc, const char *format, ...)
+{
+	char	buf[256];
+
+	if (dtrace_err_verbose) {
+		va_list	alist;
+		size_t	len = strlen(format);
+
+		pr_err("dtrace DIF object error: [%u]: ", pc);
+
+		if (len >= 256 - sizeof(KERN_ERR)) {
+			pr_err("<invalid format string>");
+			return 1;
+		}
+
+		memcpy(buf, KERN_ERR, sizeof(KERN_ERR));
+		memcpy(buf + sizeof(KERN_ERR), format, len);
+
+		va_start(alist, format);
+		vprintk(buf, alist);
+		va_end(alist);
+	}
+
+	return 1;
+}
+
+/*
+ * Validate a DTrace DIF object by checking the IR instructions.  The following
+ * rules are currently enforced by dtrace_difo_validate():
+ *
+ * 1. Each instruction must have a valid opcode
+ * 2. Each register, string, variable, or subroutine reference must be valid
+ * 3. No instruction can modify register %r0 (must be zero)
+ * 4. All instruction reserved bits must be set to zero
+ * 5. The last instruction must be a "ret" instruction
+ * 6. All branch targets must reference a valid instruction _after_ the branch
+ */
+int dtrace_difo_validate(dtrace_difo_t *dp, dtrace_vstate_t *vstate,
+			 uint_t nregs, const cred_t *cr)
+{
+	int	err = 0, i;
+	int	(*efunc)(uint_t pc, const char *, ...) = dtrace_difo_err;
+	int	kcheckload = 0;
+	uint_t	pc;
+
+	kcheckload = cr == NULL ||
+		     (vstate->dtvs_state->dts_cred.dcr_visible &
+		      DTRACE_CRV_KERNEL) == 0;
+
+	dp->dtdo_destructive = 0;
+
+	for (pc = 0; pc < dp->dtdo_len && err == 0; pc++) {
+		dif_instr_t	instr = dp->dtdo_buf[pc];
+		uint_t		r1 = DIF_INSTR_R1(instr);
+		uint_t		r2 = DIF_INSTR_R2(instr);
+		uint_t		rd = DIF_INSTR_RD(instr);
+		uint_t		rs = DIF_INSTR_RS(instr);
+		uint_t		label = DIF_INSTR_LABEL(instr);
+		uint_t		v = DIF_INSTR_VAR(instr);
+		uint_t		subr = DIF_INSTR_SUBR(instr);
+		uint_t		type = DIF_INSTR_TYPE(instr);
+		uint_t		op = DIF_INSTR_OP(instr);
+
+		switch (op) {
+		case DIF_OP_OR:
+		case DIF_OP_XOR:
+		case DIF_OP_AND:
+		case DIF_OP_SLL:
+		case DIF_OP_SRL:
+		case DIF_OP_SRA:
+		case DIF_OP_SUB:
+		case DIF_OP_ADD:
+		case DIF_OP_MUL:
+		case DIF_OP_SDIV:
+		case DIF_OP_UDIV:
+		case DIF_OP_SREM:
+		case DIF_OP_UREM:
+		case DIF_OP_COPYS:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_NOT:
+		case DIF_OP_MOV:
+		case DIF_OP_ALLOCS:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_LDSB:
+		case DIF_OP_LDSH:
+		case DIF_OP_LDSW:
+		case DIF_OP_LDUB:
+		case DIF_OP_LDUH:
+		case DIF_OP_LDUW:
+		case DIF_OP_LDX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			if (kcheckload)
+				dp->dtdo_buf[pc] = DIF_INSTR_LOAD(
+							op + DIF_OP_RLDSB -
+							     DIF_OP_LDSB,
+							r1, rd);
+			break;
+		case DIF_OP_RLDSB:
+		case DIF_OP_RLDSH:
+		case DIF_OP_RLDSW:
+		case DIF_OP_RLDUB:
+		case DIF_OP_RLDUH:
+		case DIF_OP_RLDUW:
+		case DIF_OP_RLDX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_ULDSB:
+		case DIF_OP_ULDSH:
+		case DIF_OP_ULDSW:
+		case DIF_OP_ULDUB:
+		case DIF_OP_ULDUH:
+		case DIF_OP_ULDUW:
+		case DIF_OP_ULDX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_STB:
+		case DIF_OP_STH:
+		case DIF_OP_STW:
+		case DIF_OP_STX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to 0 address\n");
+			break;
+		case DIF_OP_CMP:
+		case DIF_OP_SCMP:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rd != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			break;
+		case DIF_OP_TST:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0 || rd != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			break;
+		case DIF_OP_BA:
+		case DIF_OP_BE:
+		case DIF_OP_BNE:
+		case DIF_OP_BG:
+		case DIF_OP_BGU:
+		case DIF_OP_BGE:
+		case DIF_OP_BGEU:
+		case DIF_OP_BL:
+		case DIF_OP_BLU:
+		case DIF_OP_BLE:
+		case DIF_OP_BLEU:
+			if (label >= dp->dtdo_len)
+				err += efunc(pc, "invalid branch target %u\n",
+					     label);
+			if (label <= pc)
+				err += efunc(pc, "backward branch to %u\n",
+					     label);
+			break;
+		case DIF_OP_RET:
+			if (r1 != 0 || r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			break;
+		case DIF_OP_NOP:
+		case DIF_OP_POPTS:
+		case DIF_OP_FLUSHTS:
+			if (r1 != 0 || r2 != 0 || rd != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			break;
+		case DIF_OP_SETX:
+			if (DIF_INSTR_INTEGER(instr) >= dp->dtdo_intlen)
+				err += efunc(pc, "invalid integer ref %u\n",
+					     DIF_INSTR_INTEGER(instr));
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_SETS:
+			if (DIF_INSTR_STRING(instr) >= dp->dtdo_strlen)
+				err += efunc(pc, "invalid string ref %u\n",
+					     DIF_INSTR_STRING(instr));
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_LDGA:
+		case DIF_OP_LDTA:
+			if (r1 > DIF_VAR_ARRAY_MAX)
+				err += efunc(pc, "invalid array %u\n", r1);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_LDGS:
+		case DIF_OP_LDTS:
+		case DIF_OP_LDLS:
+		case DIF_OP_LDGAA:
+		case DIF_OP_LDTAA:
+			if (v < DIF_VAR_OTHER_MIN || v > DIF_VAR_OTHER_MAX)
+				err += efunc(pc, "invalid variable %u\n", v);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_STGS:
+		case DIF_OP_STTS:
+		case DIF_OP_STLS:
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA:
+			if (v < DIF_VAR_OTHER_UBASE || v > DIF_VAR_OTHER_MAX)
+				err += efunc(pc, "invalid variable %u\n", v);
+			if (rs >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			break;
+		case DIF_OP_CALL:
+			if (subr > DIF_SUBR_MAX)
+				err += efunc(pc, "invalid subr %u\n", subr);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+
+			if (subr == DIF_SUBR_COPYOUT ||
+			    subr == DIF_SUBR_COPYOUTSTR)
+				dp->dtdo_destructive = 1;
+			break;
+		case DIF_OP_PUSHTR:
+			if (type != DIF_TYPE_STRING && type != DIF_TYPE_CTF)
+				err += efunc(pc, "invalid ref type %u\n", type);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rs >= nregs)
+				err += efunc(pc, "invalid register %u\n", rs);
+			break;
+		case DIF_OP_PUSHTV:
+			if (type != DIF_TYPE_CTF)
+				err += efunc(pc, "invalid val type %u\n", type);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rs >= nregs)
+				err += efunc(pc, "invalid register %u\n", rs);
+			break;
+		default:
+			err += efunc(pc, "invalid opcode %u\n",
+				     DIF_INSTR_OP(instr));
+		}
+	}
+
+	if (dp->dtdo_len != 0 &&
+	    DIF_INSTR_OP(dp->dtdo_buf[dp->dtdo_len - 1]) != DIF_OP_RET) {
+		err += efunc(dp->dtdo_len - 1,
+			     "expected 'ret' as last DIF instruction\n");
+	}
+
+	if (!(dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF)) {
+		/*
+		 * If we're not returning by reference, the size must be either
+		 * 0 or the size of one of the base types.
+		 */
+		switch (dp->dtdo_rtype.dtdt_size) {
+		case 0:
+		case sizeof(uint8_t):
+		case sizeof(uint16_t):
+		case sizeof(uint32_t):
+		case sizeof(uint64_t):
+			break;
+
+		default:
+			err += efunc(dp->dtdo_len - 1, "bad return size\n");
+		}
+	}
+
+	for (i = 0; i < dp->dtdo_varlen && err == 0; i++) {
+		dtrace_difv_t		*v = &dp->dtdo_vartab[i],
+					*existing = NULL;
+		dtrace_diftype_t	*vt, *et;
+		uint_t			id, ndx;
+
+		if (v->dtdv_scope != DIFV_SCOPE_GLOBAL &&
+		    v->dtdv_scope != DIFV_SCOPE_THREAD &&
+		    v->dtdv_scope != DIFV_SCOPE_LOCAL) {
+			err += efunc(i, "unrecognized variable scope %d\n",
+				     v->dtdv_scope);
+			break;
+		}
+
+		if (v->dtdv_kind != DIFV_KIND_ARRAY &&
+		    v->dtdv_kind != DIFV_KIND_SCALAR) {
+			err += efunc(i, "unrecognized variable type %d\n",
+				     v->dtdv_kind);
+			break;
+		}
+
+		if ((id = v->dtdv_id) > DIF_VARIABLE_MAX) {
+			err += efunc(i, "%d exceeds variable id limit\n", id);
+			break;
+		}
+
+		if (id < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		/*
+		 * For user-defined variables, we need to check that this
+		 * definition is identical to any previous definition that we
+		 * encountered.
+		 */
+		ndx = id - DIF_VAR_OTHER_UBASE;
+
+		switch (v->dtdv_scope) {
+		case DIFV_SCOPE_GLOBAL:
+			if (ndx < vstate->dtvs_nglobals) {
+				dtrace_statvar_t	*svar;
+
+				if ((svar = vstate->dtvs_globals[ndx]) != NULL)
+					existing = &svar->dtsv_var;
+			}
+
+			break;
+
+		case DIFV_SCOPE_THREAD:
+			if (ndx < vstate->dtvs_ntlocals)
+				existing = &vstate->dtvs_tlocals[ndx];
+			break;
+
+		case DIFV_SCOPE_LOCAL:
+			if (ndx < vstate->dtvs_nlocals) {
+				dtrace_statvar_t	*svar;
+
+				if ((svar = vstate->dtvs_locals[ndx]) != NULL)
+					existing = &svar->dtsv_var;
+			}
+
+			break;
+		}
+
+		vt = &v->dtdv_type;
+
+		if (vt->dtdt_flags & DIF_TF_BYREF) {
+			if (vt->dtdt_size == 0) {
+				err += efunc(i, "zero-sized variable\n");
+				break;
+			}
+
+			if (v->dtdv_scope == DIFV_SCOPE_GLOBAL &&
+			    vt->dtdt_size > dtrace_global_maxsize) {
+				err += efunc(i, "oversized by-ref global\n");
+				break;
+			}
+		}
+
+		if (existing == NULL || existing->dtdv_id == 0)
+			continue;
+
+		ASSERT(existing->dtdv_id == v->dtdv_id);
+		ASSERT(existing->dtdv_scope == v->dtdv_scope);
+
+		if (existing->dtdv_kind != v->dtdv_kind)
+			err += efunc(i, "%d changed variable kind\n", id);
+
+		et = &existing->dtdv_type;
+
+		if (vt->dtdt_flags != et->dtdt_flags) {
+			err += efunc(i, "%d changed variable type flags\n", id);
+			break;
+		}
+
+		if (vt->dtdt_size != 0 && vt->dtdt_size != et->dtdt_size) {
+			err += efunc(i, "%d changed variable type size\n", id);
+			break;
+		}
+	}
+
+	return err;
+}
+
+/*
+ * Validate a DTrace DIF object that it is to be used as a helper.  Helpers
+ * are much more constrained than normal DIFOs.  Specifically, they may
+ * not:
+ *
+ * 1. Make calls to subroutines other than copyin(), copyinstr() or
+ *    miscellaneous string routines
+ * 2. Access DTrace variables other than the args[] array, and the
+ *    curthread, pid, ppid, tid, execname, zonename, uid and gid variables.
+ * 3. Have thread-local variables.
+ * 4. Have dynamic variables.
+ */
+int dtrace_difo_validate_helper(dtrace_difo_t *dp)
+{
+	int	(*efunc)(uint_t pc, const char *, ...) = dtrace_difo_err;
+	int	err = 0;
+	uint_t	pc;
+
+	for (pc = 0; pc < dp->dtdo_len; pc++) {
+		dif_instr_t	instr = dp->dtdo_buf[pc];
+		uint_t		v = DIF_INSTR_VAR(instr);
+		uint_t		subr = DIF_INSTR_SUBR(instr);
+		uint_t		op = DIF_INSTR_OP(instr);
+
+		switch (op) {
+		case DIF_OP_OR:
+		case DIF_OP_XOR:
+		case DIF_OP_AND:
+		case DIF_OP_SLL:
+		case DIF_OP_SRL:
+		case DIF_OP_SRA:
+		case DIF_OP_SUB:
+		case DIF_OP_ADD:
+		case DIF_OP_MUL:
+		case DIF_OP_SDIV:
+		case DIF_OP_UDIV:
+		case DIF_OP_SREM:
+		case DIF_OP_UREM:
+		case DIF_OP_COPYS:
+		case DIF_OP_NOT:
+		case DIF_OP_MOV:
+		case DIF_OP_RLDSB:
+		case DIF_OP_RLDSH:
+		case DIF_OP_RLDSW:
+		case DIF_OP_RLDUB:
+		case DIF_OP_RLDUH:
+		case DIF_OP_RLDUW:
+		case DIF_OP_RLDX:
+		case DIF_OP_ULDSB:
+		case DIF_OP_ULDSH:
+		case DIF_OP_ULDSW:
+		case DIF_OP_ULDUB:
+		case DIF_OP_ULDUH:
+		case DIF_OP_ULDUW:
+		case DIF_OP_ULDX:
+		case DIF_OP_STB:
+		case DIF_OP_STH:
+		case DIF_OP_STW:
+		case DIF_OP_STX:
+		case DIF_OP_ALLOCS:
+		case DIF_OP_CMP:
+		case DIF_OP_SCMP:
+		case DIF_OP_TST:
+		case DIF_OP_BA:
+		case DIF_OP_BE:
+		case DIF_OP_BNE:
+		case DIF_OP_BG:
+		case DIF_OP_BGU:
+		case DIF_OP_BGE:
+		case DIF_OP_BGEU:
+		case DIF_OP_BL:
+		case DIF_OP_BLU:
+		case DIF_OP_BLE:
+		case DIF_OP_BLEU:
+		case DIF_OP_RET:
+		case DIF_OP_NOP:
+		case DIF_OP_POPTS:
+		case DIF_OP_FLUSHTS:
+		case DIF_OP_SETX:
+		case DIF_OP_SETS:
+		case DIF_OP_LDGA:
+		case DIF_OP_LDLS:
+		case DIF_OP_STGS:
+		case DIF_OP_STLS:
+		case DIF_OP_PUSHTR:
+		case DIF_OP_PUSHTV:
+			break;
+
+		case DIF_OP_LDGS:
+			if (v >= DIF_VAR_OTHER_UBASE)
+				break;
+
+			if (v >= DIF_VAR_ARG0 && v <= DIF_VAR_ARG9)
+				break;
+
+			if (v == DIF_VAR_CURTHREAD || v == DIF_VAR_PID ||
+			    v == DIF_VAR_PPID || v == DIF_VAR_TID ||
+			    v == DIF_VAR_EXECNAME || v == DIF_VAR_ZONENAME ||
+			    v == DIF_VAR_UID || v == DIF_VAR_GID)
+				break;
+
+			err += efunc(pc, "illegal variable %u\n", v);
+			break;
+
+		case DIF_OP_LDTA:
+		case DIF_OP_LDGAA:
+		case DIF_OP_LDTAA:
+			err += efunc(pc, "illegal dynamic variable load\n");
+			break;
+
+		case DIF_OP_STTS:
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA:
+			err += efunc(pc, "illegal dynamic variable store\n");
+			break;
+
+		case DIF_OP_CALL:
+			if (subr == DIF_SUBR_ALLOCA ||
+			    subr == DIF_SUBR_BCOPY ||
+			    subr == DIF_SUBR_COPYIN ||
+			    subr == DIF_SUBR_COPYINTO ||
+			    subr == DIF_SUBR_COPYINSTR ||
+			    subr == DIF_SUBR_INDEX ||
+			    subr == DIF_SUBR_INET_NTOA ||
+			    subr == DIF_SUBR_INET_NTOA6 ||
+			    subr == DIF_SUBR_INET_NTOP ||
+			    subr == DIF_SUBR_LINK_NTOP ||
+			    subr == DIF_SUBR_LLTOSTR ||
+			    subr == DIF_SUBR_RINDEX ||
+			    subr == DIF_SUBR_STRCHR ||
+			    subr == DIF_SUBR_STRJOIN ||
+			    subr == DIF_SUBR_STRRCHR ||
+			    subr == DIF_SUBR_STRSTR ||
+			    subr == DIF_SUBR_HTONS ||
+			    subr == DIF_SUBR_HTONL ||
+			    subr == DIF_SUBR_HTONLL ||
+			    subr == DIF_SUBR_NTOHS ||
+			    subr == DIF_SUBR_NTOHL ||
+			    subr == DIF_SUBR_NTOHLL)
+				break;
+
+			err += efunc(pc, "invalid subr %u\n", subr);
+			break;
+
+		default:
+			err += efunc(pc, "invalid opcode %u\n",
+				     DIF_INSTR_OP(instr));
+		}
+	}
+
+	return err;
+}
+
+/*
+ * Returns 1 if the expression in the DIF object can be cached on a per-thread
+ * basis; 0 if not.
+ */
+int dtrace_difo_cacheable(dtrace_difo_t *dp)
+{
+	int	i;
+
+	if (dp == NULL)
+		return 0;
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t	*v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_scope != DIFV_SCOPE_GLOBAL)
+			continue;
+
+		switch (v->dtdv_id) {
+		case DIF_VAR_CURTHREAD:
+		case DIF_VAR_PID:
+		case DIF_VAR_TID:
+		case DIF_VAR_EXECNAME:
+		case DIF_VAR_ZONENAME:
+			break;
+
+		default:
+			return 0;
+		}
+	}
+
+	/*
+	 * This DIF object may be cacheable.  Now we need to look for any
+	 * array loading instructions, any memory loading instructions, or
+	 * any stores to thread-local variables.
+	 */
+	for (i = 0; i < dp->dtdo_len; i++) {
+		uint_t	op = DIF_INSTR_OP(dp->dtdo_buf[i]);
+
+		if ((op >= DIF_OP_LDSB && op <= DIF_OP_LDX) ||
+		    (op >= DIF_OP_ULDSB && op <= DIF_OP_ULDX) ||
+		    (op >= DIF_OP_RLDSB && op <= DIF_OP_RLDX) ||
+		    op == DIF_OP_LDGA || op == DIF_OP_STTS)
+			return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * This routine calculates the dynamic variable chunksize for a given DIF
+ * object.  The calculation is not fool-proof, and can probably be tricked by
+ * malicious DIF -- but it works for all compiler-generated DIF.  Because this
+ * calculation is likely imperfect, dtrace_dynvar() is able to gracefully fail
+ * if a dynamic variable size exceeds the chunksize.
+ */
+static void dtrace_difo_chunksize(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
+{
+	uint64_t		sval = 0;
+	dtrace_key_t		tupregs[DIF_DTR_NREGS + 2]; /* + thread + id */
+	const dif_instr_t	*text = dp->dtdo_buf;
+	uint_t			pc, srd = 0;
+	uint_t			ttop = 0;
+	size_t			size, ksize;
+	uint_t			id, i;
+
+	for (pc = 0; pc < dp->dtdo_len; pc++) {
+		dif_instr_t	instr = text[pc];
+		uint_t		op = DIF_INSTR_OP(instr);
+		uint_t		rd = DIF_INSTR_RD(instr);
+		uint_t		r1 = DIF_INSTR_R1(instr);
+		uint_t		nkeys = 0;
+		uchar_t		scope;
+		dtrace_key_t	*key = tupregs;
+
+		switch (op) {
+		case DIF_OP_SETX:
+			sval = dp->dtdo_inttab[DIF_INSTR_INTEGER(instr)];
+			srd = rd;
+			continue;
+
+		case DIF_OP_STTS:
+			key = &tupregs[DIF_DTR_NREGS];
+			key[0].dttk_size = 0;
+			key[1].dttk_size = 0;
+			nkeys = 2;
+			scope = DIFV_SCOPE_THREAD;
+			break;
+
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA:
+			nkeys = ttop;
+
+			if (DIF_INSTR_OP(instr) == DIF_OP_STTAA)
+				key[nkeys++].dttk_size = 0;
+
+			key[nkeys++].dttk_size = 0;
+
+			if (op == DIF_OP_STTAA)
+				scope = DIFV_SCOPE_THREAD;
+			else
+				scope = DIFV_SCOPE_GLOBAL;
+
+			break;
+
+		case DIF_OP_PUSHTR:
+			if (ttop == DIF_DTR_NREGS)
+				return;
+
+			/*
+			 * If the register for the size of the "pushtr" is %r0
+			 * (or the value is 0) and the type is a string, we'll
+			 * use the system-wide default string size.
+			 */
+			if ((srd == 0 || sval == 0) && r1 == DIF_TYPE_STRING)
+				tupregs[ttop++].dttk_size =
+						dtrace_strsize_default;
+			else {
+				if (srd == 0)
+					return;
+
+				tupregs[ttop++].dttk_size = sval;
+			}
+
+			break;
+
+		case DIF_OP_PUSHTV:
+			if (ttop == DIF_DTR_NREGS)
+				return;
+
+			tupregs[ttop++].dttk_size = 0;
+			break;
+
+		case DIF_OP_FLUSHTS:
+			ttop = 0;
+			break;
+
+		case DIF_OP_POPTS:
+			if (ttop != 0)
+				ttop--;
+			break;
+		}
+
+		sval = 0;
+		srd = 0;
+
+		if (nkeys == 0)
+			continue;
+
+		/*
+		 * We have a dynamic variable allocation; calculate its size.
+		 */
+		for (ksize = 0, i = 0; i < nkeys; i++)
+			ksize += P2ROUNDUP(key[i].dttk_size, sizeof(uint64_t));
+
+		size = sizeof(dtrace_dynvar_t);
+		size += sizeof(dtrace_key_t) * (nkeys - 1);
+		size += ksize;
+
+		/*
+		 * Now we need to determine the size of the stored data.
+		*/
+		id = DIF_INSTR_VAR(instr);
+
+		for (i = 0; i < dp->dtdo_varlen; i++) {
+			dtrace_difv_t	*v = &dp->dtdo_vartab[i];
+
+			if (v->dtdv_id == id && v->dtdv_scope == scope) {
+				size += v->dtdv_type.dtdt_size;
+				break;
+			}
+		}
+
+		if (i == dp->dtdo_varlen)
+			return;
+
+		/*
+		 * We have the size.  If this is larger than the chunk size
+		 * for our dynamic variable state, reset the chunk size.
+		 */
+		size = P2ROUNDUP(size, sizeof(uint64_t));
+
+		if (size > vstate->dtvs_dynvars.dtds_chunksize)
+			vstate->dtvs_dynvars.dtds_chunksize = size;
+	}
+}
+
+void dtrace_difo_hold(dtrace_difo_t *dp)
+{
+	int	i;
+
+	dp->dtdo_refcnt++;
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t	*v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_id != DIF_VAR_VTIMESTAMP)
+			continue;
+
+		if (dtrace_vtime_references++ == 0)
+			dtrace_vtime_enable();
+	}
+}
+
+void dtrace_difo_init(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
+{
+	int	i, oldsvars, osz, nsz, otlocals, ntlocals;
+	uint_t	id;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp->dtdo_buf != NULL && dp->dtdo_len != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t		*v = &dp->dtdo_vartab[i];
+		dtrace_statvar_t	*svar, ***svarp;
+		size_t			dsize = 0;
+		uint8_t			scope = v->dtdv_scope;
+		int			*np;
+
+		if ((id = v->dtdv_id) < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		id -= DIF_VAR_OTHER_UBASE;
+
+		switch (scope) {
+		case DIFV_SCOPE_THREAD:
+			while (id >= (otlocals = vstate->dtvs_ntlocals)) {
+				dtrace_difv_t	*tlocals;
+
+				if ((ntlocals = (otlocals << 1)) == 0)
+					ntlocals = 1;
+
+				osz = otlocals * sizeof(dtrace_difv_t);
+				nsz = ntlocals * sizeof(dtrace_difv_t);
+
+				tlocals = vzalloc(nsz);
+
+				if (osz != 0) {
+					memcpy(tlocals, vstate->dtvs_tlocals,
+					       osz);
+					vfree(vstate->dtvs_tlocals);
+				}
+
+				vstate->dtvs_tlocals = tlocals;
+				vstate->dtvs_ntlocals = ntlocals;
+			}
+
+			vstate->dtvs_tlocals[id] = *v;
+			continue;
+
+		case DIFV_SCOPE_LOCAL:
+			np = &vstate->dtvs_nlocals;
+			svarp = &vstate->dtvs_locals;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				dsize = NR_CPUS *
+					(v->dtdv_type.dtdt_size +
+					 sizeof(uint64_t));
+			else
+				dsize = NR_CPUS * sizeof(uint64_t);
+
+			break;
+
+		case DIFV_SCOPE_GLOBAL:
+			np = &vstate->dtvs_nglobals;
+			svarp = &vstate->dtvs_globals;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				dsize = v->dtdv_type.dtdt_size +
+					sizeof(uint64_t);
+
+			break;
+
+		default:
+			ASSERT(0);
+			continue; /* not reached */
+		}
+
+		while (id >= (oldsvars = *np)) {
+			dtrace_statvar_t	**statics;
+			int			newsvars, oldsize, newsize;
+
+			if ((newsvars = (oldsvars << 1)) == 0)
+				newsvars = 1;
+
+			oldsize = oldsvars * sizeof(dtrace_statvar_t *);
+			newsize = newsvars * sizeof(dtrace_statvar_t *);
+
+			statics = vzalloc(newsize);
+
+			if (oldsize != 0) {
+				memcpy(statics, *svarp, oldsize);
+				vfree(*svarp);
+			}
+
+			*svarp = statics;
+			*np = newsvars;
+		}
+
+		if ((svar = (*svarp)[id]) == NULL) {
+			svar = kzalloc(sizeof(dtrace_statvar_t), GFP_KERNEL);
+			svar->dtsv_var = *v;
+
+			if ((svar->dtsv_size = dsize) != 0) {
+				svar->dtsv_data =
+					(uint64_t)(uintptr_t)vzalloc(dsize);
+			}
+
+			(*svarp)[id] = svar;
+		}
+
+		svar->dtsv_refcnt++;
+	}
+
+	dtrace_difo_chunksize(dp, vstate);
+	dtrace_difo_hold(dp);
+}
+
+dtrace_difo_t * dtrace_difo_duplicate(dtrace_difo_t *dp,
+				      dtrace_vstate_t *vstate)
+{
+	dtrace_difo_t	*new;
+	size_t		sz;
+
+	ASSERT(dp->dtdo_buf != NULL);
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	new = kzalloc(sizeof(dtrace_difo_t), GFP_KERNEL);
+
+	ASSERT(dp->dtdo_buf != NULL);
+	sz = dp->dtdo_len * sizeof(dif_instr_t);
+	new->dtdo_buf = vmalloc(sz);
+	memcpy(new->dtdo_buf, dp->dtdo_buf, sz);
+	new->dtdo_len = dp->dtdo_len;
+
+	if (dp->dtdo_strtab != NULL) {
+		ASSERT(dp->dtdo_strlen != 0);
+		new->dtdo_strtab = vmalloc(dp->dtdo_strlen);
+		memcpy(new->dtdo_strtab, dp->dtdo_strtab, dp->dtdo_strlen);
+		new->dtdo_strlen = dp->dtdo_strlen;
+	}
+
+	if (dp->dtdo_inttab != NULL) {
+		ASSERT(dp->dtdo_intlen != 0);
+		sz = dp->dtdo_intlen * sizeof(uint64_t);
+		new->dtdo_inttab = vmalloc(sz);
+		memcpy(new->dtdo_inttab, dp->dtdo_inttab, sz);
+		new->dtdo_intlen = dp->dtdo_intlen;
+	}
+
+	if (dp->dtdo_vartab != NULL) {
+		ASSERT(dp->dtdo_varlen != 0);
+		sz = dp->dtdo_varlen * sizeof(dtrace_difv_t);
+		new->dtdo_vartab = vmalloc(sz);
+		memcpy(new->dtdo_vartab, dp->dtdo_vartab, sz);
+		new->dtdo_varlen = dp->dtdo_varlen;
+	}
+
+	dtrace_difo_init(new, vstate);
+
+	return new;
+}
+
+void dtrace_difo_destroy(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
+{
+	int	i;
+
+	ASSERT(dp->dtdo_refcnt == 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t		*v = &dp->dtdo_vartab[i];
+		dtrace_statvar_t	*svar, **svarp;
+		uint_t			id;
+		uint8_t			scope = v->dtdv_scope;
+		int			*np;
+
+		switch (scope) {
+		case DIFV_SCOPE_THREAD:
+			continue;
+
+		case DIFV_SCOPE_LOCAL:
+			np = &vstate->dtvs_nlocals;
+			svarp = vstate->dtvs_locals;
+			break;
+
+		case DIFV_SCOPE_GLOBAL:
+			np = &vstate->dtvs_nglobals;
+			svarp = vstate->dtvs_globals;
+			break;
+
+		default:
+			BUG();
+		}
+
+		if ((id = v->dtdv_id) < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		id -= DIF_VAR_OTHER_UBASE;
+		ASSERT(id < *np);
+
+		svar = svarp[id];
+		ASSERT(svar != NULL);
+		ASSERT(svar->dtsv_refcnt > 0);
+
+		if (--svar->dtsv_refcnt > 0)
+			continue;
+
+		if (svar->dtsv_size != 0) {
+			ASSERT((void *)(uintptr_t)svar->dtsv_data != NULL);
+			vfree((void *)(uintptr_t)svar->dtsv_data);
+		}
+
+		kfree(svar);
+		svarp[id] = NULL;
+	}
+
+	vfree(dp->dtdo_buf);
+        vfree(dp->dtdo_inttab);
+        vfree(dp->dtdo_strtab);
+        vfree(dp->dtdo_vartab);
+        kfree(dp);
+}
+
+void dtrace_difo_release(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
+{
+	int	i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t *v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_id != DIF_VAR_VTIMESTAMP)
+			continue;
+
+		ASSERT(dtrace_vtime_references > 0);
+
+		if (--dtrace_vtime_references == 0)
+			dtrace_vtime_disable();
+	}
+
+	if (--dp->dtdo_refcnt == 0)
+		dtrace_difo_destroy(dp, vstate);
+}
+
+/*
+ * The key for a thread-local variable consists of the lower 60 bits of the
+ * task pid, prefixed by a 4 bits indicating whether a hard_irq is active.
+ * This accounts for a case where some older drivers re-enable interrupts
+ * and can nest in hard irq context.
+ *
+ * All per-cpu idle threads share same pid 0. In this special case we replace
+ * the pid with cpu id (an idle thread is bound to a single cpu). If pid is
+ * not 0 then a NR_CPUS is added. This assures that the thread key for idle
+ * thread never conflicts with regular pids in range 0..NR_CPUS.
+ *
+ * We add DIF_VARIABLE_MAX to the pid to assure that the thread key is never
+ * equal to a variable identifier.  This is necessary (but not sufficient) to
+ * assure that global associative arrays never collide with thread-local
+ * variables.  To guarantee that they cannot collide, we must also define the
+ * order for keying dynamic variables.  That order is:
+ *
+ *   [ key0 ] ... [ keyn ] [ variable-key ] [ tls-key ]
+ *
+ * Because the variable-key and the tls-key are in orthogonal spaces, there is
+ * no way for a global variable key signature to match a thread-local key
+ * signature.
+ */
+#define DTRACE_TLS_THRKEY(where)					\
+	{								\
+		uint_t	intr = hardirq_count() >> HARDIRQ_SHIFT;	\
+		uint_t	cpu = (current->flags & PF_IDLE) ?		\
+				smp_processor_id() : NR_CPUS;		\
+									\
+		(where) = ((current->pid + cpu + DIF_VARIABLE_MAX) &	\
+			   (((uint64_t)1 << 60) - 1)) |			\
+			  ((uint64_t)intr << 60);			\
+	}
+
+#ifndef FIXME
+# define DTRACE_ALIGNCHECK(addr, size, flags)
+#endif
+
+/*
+ * Test whether a range of memory starting at testaddr of size testsz falls
+ * within the range of memory described by addr, sz.  We take care to avoid
+ * problems with overflow and underflow of the unsigned quantities, and
+ * disallow all negative sizes.  Ranges of size 0 are allowed.
+ */
+#define DTRACE_INRANGE(testaddr, testsz, baseaddr, basesz) \
+	((testaddr) - (baseaddr) < (basesz) && \
+	 (testaddr) + (testsz) - (baseaddr) <= (basesz) && \
+	 (testaddr) + (testsz) >= (testaddr))
+
+#define DTRACE_LOADFUNC(bits)						\
+	uint##bits##_t dtrace_load##bits(uintptr_t addr)		\
+	{								\
+		size_t			size = bits / NBBY;		\
+		uint##bits##_t		rval;				\
+		int			i;				\
+		volatile uint16_t	*flags = (volatile uint16_t *)	\
+			    &this_cpu_core->cpuc_dtrace_flags;		\
+									\
+		/*							\
+		 * Deviation from the OpenSolaris code...  Protect	\
+		 * against dereferencing the NULL pointer since that	\
+		 * really causes us a lot of grief (crash).		\
+		 */							\
+		if (addr == 0) {					\
+			*flags |= CPU_DTRACE_BADADDR;			\
+			this_cpu_core->cpuc_dtrace_illval = addr;	\
+			return 0;					\
+		}							\
+									\
+		DTRACE_ALIGNCHECK(addr, size, flags);			\
+									\
+		for (i = 0; i < dtrace_toxranges; i++) {		\
+			if (addr >= dtrace_toxrange[i].dtt_limit)	\
+				continue;				\
+									\
+			if (addr + size <= dtrace_toxrange[i].dtt_base)	\
+				continue;				\
+									\
+			/*						\
+			 * This address falls within a toxic region.	\
+			 */						\
+			*flags |= CPU_DTRACE_BADADDR;			\
+			this_cpu_core->cpuc_dtrace_illval = addr;	\
+			return 0;					\
+		}							\
+									\
+		*flags |= CPU_DTRACE_NOFAULT;				\
+		rval = *((volatile uint##bits##_t *)addr);		\
+		*flags &= ~CPU_DTRACE_NOFAULT;				\
+									\
+		return !(*flags & CPU_DTRACE_FAULT) ? rval : 0;		\
+	}
+
+#ifdef CONFIG_64BIT
+# define dtrace_loadptr	dtrace_load64
+#else
+# define dtrace_loadptr	dtrace_load32
+#endif
+
+/*
+ * Use the DTRACE_LOADFUNC macro to define functions for each of loading a
+ * uint8_t, a uint16_t, a uint32_t and a uint64_t.
+ */
+DTRACE_LOADFUNC(8)
+DTRACE_LOADFUNC(16)
+DTRACE_LOADFUNC(32)
+DTRACE_LOADFUNC(64)
+
+#define DT_BSWAP_8(x)	((x) & 0xff)
+#define DT_BSWAP_16(x)	((DT_BSWAP_8(x) << 8) | DT_BSWAP_8((x) >> 8))
+#define DT_BSWAP_32(x)	((DT_BSWAP_16(x) << 16) | DT_BSWAP_16((x) >> 16))
+#define DT_BSWAP_64(x)	((DT_BSWAP_32(x) << 32) | DT_BSWAP_32((x) >> 32))
+
+static int dtrace_inscratch(uintptr_t dest, size_t size,
+			    dtrace_mstate_t *mstate)
+{
+	if (dest < mstate->dtms_scratch_base)
+		return 0;
+
+	if (dest + size < dest)
+		return 0;
+
+	if (dest + size > mstate->dtms_scratch_ptr)
+		return 0;
+
+	return 1;
+}
+
+static int dtrace_canstore_statvar(uint64_t addr, size_t sz,
+				   dtrace_statvar_t **svars, int nsvars)
+{
+	int i;
+
+	for (i = 0; i < nsvars; i++) {
+		dtrace_statvar_t	*svar = svars[i];
+
+		if (svar == NULL || svar->dtsv_size == 0)
+			continue;
+
+		if (DTRACE_INRANGE(addr, sz, svar->dtsv_data, svar->dtsv_size))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * Check to see if the address is within a memory region to which a store may
+ * be issued.  This includes the DTrace scratch areas, and any DTrace variable
+ * region.  The caller of dtrace_canstore() is responsible for performing any
+ * alignment checks that are needed before stores are actually executed.
+ */
+static int dtrace_canstore(uint64_t addr, size_t sz, dtrace_mstate_t *mstate,
+			   dtrace_vstate_t *vstate)
+{
+	/*
+	 * First, check to see if the address is in scratch space...
+	 */
+	if (DTRACE_INRANGE(addr, sz, mstate->dtms_scratch_base,
+			   mstate->dtms_scratch_size))
+		return 1;
+
+	/*
+	 * Now check to see if it's a dynamic variable.  This check will pick
+	 * up both thread-local variables and any global dynamically-allocated
+	 * variables.
+	 */
+	if (DTRACE_INRANGE(addr, sz, (uintptr_t)vstate->dtvs_dynvars.dtds_base,
+			   vstate->dtvs_dynvars.dtds_size)) {
+		dtrace_dstate_t	*dstate = &vstate->dtvs_dynvars;
+		uintptr_t	base = (uintptr_t)dstate->dtds_base +
+				       (dstate->dtds_hashsize *
+					sizeof(dtrace_dynhash_t));
+		uintptr_t	chunkoffs;
+		uint64_t	num;
+
+		/*
+		 * Before we assume that we can store here, we need to make
+		 * sure that it isn't in our metadata -- storing to our
+		 * dynamic variable metadata would corrupt our state.  For
+		 * the range to not include any dynamic variable metadata,
+		 * it must:
+		 *
+		 *      (1) Start above the hash table that is at the base of
+		 *      the dynamic variable space
+		 *
+		 *      (2) Have a starting chunk offset that is beyond the
+		 *      dtrace_dynvar_t that is at the base of every chunk
+		 *
+		 *      (3) Not span a chunk boundary
+		 */
+		if (addr < base)
+			return 0;
+
+		num = addr - base;
+		chunkoffs = do_div(num, dstate->dtds_chunksize);
+
+		if (chunkoffs < sizeof(dtrace_dynvar_t))
+			return 0;
+
+		if (chunkoffs + sz > dstate->dtds_chunksize)
+			return 0;
+
+		return 1;
+	}
+
+	/*
+	 * Finally, check the static local and global variables.  These checks
+	 * take the longest, so we perform them last.
+	 */
+	if (dtrace_canstore_statvar(addr, sz, vstate->dtvs_locals,
+				    vstate->dtvs_nlocals))
+		return 1;
+
+	if (dtrace_canstore_statvar(addr, sz, vstate->dtvs_globals,
+				    vstate->dtvs_nglobals))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Convenience routine to check to see if the address is within a memory
+ * region in which a load may be issued given the user's privilege level;
+ * if not, it sets the appropriate error flags and loads 'addr' into the
+ * illegal value slot.
+ *
+ * DTrace subroutines (DIF_SUBR_*) should use this helper to implement
+ * appropriate memory access protection.
+ */
+static int
+dtrace_canload(uint64_t addr, size_t sz, dtrace_mstate_t *mstate,
+	       dtrace_vstate_t *vstate)
+{
+	volatile uintptr_t	*illval = &this_cpu_core->cpuc_dtrace_illval;
+
+	/*
+	 * If we hold the privilege to read from kernel memory, then
+	 * everything is readable.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return 1;
+
+	/*
+	 * You can obviously read that which you can store.
+	 */
+	if (dtrace_canstore(addr, sz, mstate, vstate))
+		return 1;
+
+	/*
+	 * We're allowed to read from our own string table.
+	 */
+	if (DTRACE_INRANGE(addr, sz, (uintptr_t)mstate->dtms_difo->dtdo_strtab,
+			   mstate->dtms_difo->dtdo_strlen))
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
+	*illval = addr;
+
+	return 0;
+}
+
+/*
+ * Convenience routine to check to see if a given string is within a memory
+ * region in which a load may be issued given the user's privilege level;
+ * this exists so that we don't need to issue unnecessary dtrace_strlen()
+ * calls in the event that the user has all privileges.
+ */
+static int
+dtrace_strcanload(uint64_t addr, size_t sz, dtrace_mstate_t *mstate,
+    dtrace_vstate_t *vstate)
+{
+	size_t	strsz;
+
+	/*
+	 * If we hold the privilege to read from kernel memory, then
+	 * everything is readable.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return 1;
+
+	strsz = 1 + dtrace_strlen((char *)(uintptr_t)addr, sz);
+	if (dtrace_canload(addr, strsz, mstate, vstate))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Convenience routine to check to see if a given variable is within a memory
+ * region in which a load may be issued given the user's privilege level.
+ */
+int dtrace_vcanload(void *src, dtrace_diftype_t *type, dtrace_mstate_t *mstate,
+		    dtrace_vstate_t *vstate)
+{
+	size_t	sz;
+
+	ASSERT(type->dtdt_flags & DIF_TF_BYREF);
+
+	/*
+	 * If we hold the privilege to read from kernel memory, then
+	 * everything is readable.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return 1;
+
+	if (type->dtdt_kind == DIF_TYPE_STRING)
+		sz = dtrace_strlen(
+			src,
+			vstate->dtvs_state->dts_options[DTRACEOPT_STRSIZE]
+		     ) + 1;
+	else
+		sz = type->dtdt_size;
+
+	return dtrace_canload((uintptr_t)src, sz, mstate, vstate);
+}
+
+/*
+ * Copy src to dst using safe memory accesses.  The src is assumed to be unsafe
+ * memory specified by the DIF program.  The dst is assumed to be safe memory
+ * that we can store to directly because it is managed by DTrace.  As with
+ * standard bcopy, overlapping copies are handled properly.
+ */
+static void dtrace_bcopy(const void *src, void *dst, size_t len)
+{
+	if (len != 0) {
+		uint8_t		*s1 = dst;
+		const uint8_t	*s2 = src;
+
+		if (s1 <= s2) {
+			do {
+				*s1++ = dtrace_load8((uintptr_t)s2++);
+			} while (--len != 0);
+		} else {
+			s2 += len;
+			s1 += len;
+
+			do {
+				*--s1 = dtrace_load8((uintptr_t)--s2);
+			} while (--len != 0);
+		}
+	}
+}
+
+/*
+ * Copy src to dst using safe memory accesses, up to either the specified
+ * length, or the point that a nul byte is encountered.  The src is assumed to
+ * be unsafe memory specified by the DIF program.  The dst is assumed to be
+ * safe memory that we can store to directly because it is managed by DTrace.
+ * Unlike dtrace_bcopy(), overlapping regions are not handled.
+ */
+static void dtrace_strcpy(const void *src, void *dst, size_t len)
+{
+	if (len != 0) {
+		uint8_t		*s1 = dst, c;
+		const uint8_t	*s2 = src;
+
+		do {
+			*s1++ = c = dtrace_load8((uintptr_t)s2++);
+		} while (--len != 0 && c != '\0');
+	}
+}
+/*
+ * Copy src to dst, deriving the size and type from the specified (BYREF)
+ * variable type.  The src is assumed to be unsafe memory specified by the DIF
+ * program.  The dst is assumed to be DTrace variable memory that is of the
+ * specified type; we assume that we can store to directly.
+ */
+static void dtrace_vcopy(void *src, void *dst, dtrace_diftype_t *type)
+{
+	ASSERT(type->dtdt_flags & DIF_TF_BYREF);
+
+	if (type->dtdt_kind == DIF_TYPE_STRING)
+		dtrace_strcpy(src, dst, type->dtdt_size);
+	else
+		dtrace_bcopy(src, dst, type->dtdt_size);
+}
+
+/*
+ * Compare s1 to s2 using safe memory accesses.  The s1 data is assumed to be
+ * unsafe memory specified by the DIF program.  The s2 data is assumed to be
+ * safe memory that we can access directly because it is managed by DTrace.
+ */
+static int dtrace_bcmp(const void *s1, const void *s2, size_t len)
+{
+	volatile uint16_t	*flags;
+
+	flags = (volatile uint16_t *)&this_cpu_core->cpuc_dtrace_flags;
+
+	if (s1 == s2)
+		return 0;
+
+	if (s1 == NULL || s2 == NULL)
+		return 1;
+
+	if (s1 != s2 && len != 0) {
+		const uint8_t	*ps1 = s1;
+		const uint8_t	*ps2 = s2;
+
+		do {
+			if (dtrace_load8((uintptr_t)ps1++) != *ps2++)
+				return 1;
+		} while (--len != 0 && !(*flags & CPU_DTRACE_FAULT));
+	}
+
+	return 0;
+}
+
+/*
+ * Zero the specified region using a simple byte-by-byte loop.  Note that this
+ * is for safe DTrace-managed memory only.
+ */
+void dtrace_bzero(void *dst, size_t len)
+{
+	uchar_t	*cp;
+
+	for (cp = dst; len != 0; len--)
+		*cp++ = 0;
+}
+
+#define DTRACE_DYNHASH_FREE	0
+#define DTRACE_DYNHASH_SINK	1
+#define DTRACE_DYNHASH_VALID	2
+
+/*
+ * Depending on the value of the op parameter, this function looks-up,
+ * allocates or deallocates an arbitrarily-keyed dynamic variable.  If an
+ * allocation is requested, this function will return a pointer to a
+ * dtrace_dynvar_t corresponding to the allocated variable -- or NULL if no
+ * variable can be allocated.  If NULL is returned, the appropriate counter
+ * will be incremented.
+ */
+static dtrace_dynvar_t *dtrace_dynvar(dtrace_dstate_t *dstate, uint_t nkeys,
+				      dtrace_key_t *key, size_t dsize,
+				      dtrace_dynvar_op_t op,
+				      dtrace_mstate_t *mstate,
+				      dtrace_vstate_t *vstate)
+{
+	uint64_t		hashval = DTRACE_DYNHASH_VALID;
+	dtrace_dynhash_t	*hash = dstate->dtds_hash;
+	dtrace_dynvar_t		*free, *new_free, *next, *dvar, *start,
+				*prev = NULL;
+	processorid_t		me = smp_processor_id(), cpu = me;
+	dtrace_dstate_percpu_t	*dcpu = &dstate->dtds_percpu[me];
+	size_t			bucket, ksize;
+	size_t			chunksize = dstate->dtds_chunksize;
+	uintptr_t		kdata, lock;
+	dtrace_dstate_state_t	nstate;
+	uint_t			i;
+
+        ASSERT(nkeys != 0);
+
+	/*
+	 * Hash the key.  As with aggregations, we use Jenkins' "One-at-a-time"
+	 * algorithm.  For the by-value portions, we perform the algorithm in
+	 * 16-bit chunks (as opposed to 8-bit chunks).  This speeds things up a
+	 * bit, and seems to have only a minute effect on distribution.  For
+	 * the by-reference data, we perform "One-at-a-time" iterating (safely)
+	 * over each referenced byte.  It's painful to do this, but it's much
+	 * better than pathological hash distribution.  The efficacy of the
+	 * hashing algorithm (and a comparison with other algorithms) may be
+	 * found by running the ::dtrace_dynstat MDB dcmd.
+	 */
+	for (i = 0; i < nkeys; i++) {
+		if (key[i].dttk_size == 0) {
+			uint64_t	val = key[i].dttk_value;
+
+			hashval += (val >> 48) & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			hashval += (val >> 32) & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			hashval += (val >> 16) & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			hashval += val & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+		} else {
+			/*
+			 * This is incredibly painful, but it beats the hell
+			 * out of the alternative.
+			 */
+			uint64_t	j, size = key[i].dttk_size;
+			uintptr_t	base = (uintptr_t)key[i].dttk_value;
+
+			if (!dtrace_canload(base, size, mstate, vstate))
+				break;
+
+			for (j = 0; j < size; j++) {
+				hashval += dtrace_load8(base + j);
+				hashval += (hashval << 10);
+				hashval ^= (hashval >> 6);
+			}
+		}
+	}
+
+	if (DTRACE_CPUFLAG_ISSET(CPU_DTRACE_FAULT))
+		return NULL;
+
+	hashval += (hashval << 3);
+	hashval ^= (hashval >> 11);
+	hashval += (hashval << 15);
+
+	/*
+	 * There is a remote chance (ideally, 1 in 2^31) that our hashval
+	 * comes out to be one of our two sentinel hash values.  If this
+	 * actually happens, we set the hashval to be a value known to be a
+	 * non-sentinel value.
+	 */
+	if (hashval == DTRACE_DYNHASH_FREE || hashval == DTRACE_DYNHASH_SINK)
+		hashval = DTRACE_DYNHASH_VALID;
+
+	/*
+	 * Yes, it's painful to do a divide here.  If the cycle count becomes
+	 * important here, tricks can be pulled to reduce it.  (However, it's
+	 * critical that hash collisions be kept to an absolute minimum;
+	 * they're much more painful than a divide.)  It's better to have a
+	 * solution that generates few collisions and still keeps things
+	 * relatively simple.
+	 *
+	 * Linux cannot do a straight 64-bit divide without gcc requiring
+	 * linking in code that the kernel doesn't link, so we need to use an
+	 * alternative.
+	 *
+	 *	bucket = hashval % dstate->dtds_hashsize;
+	 */
+	{
+	    uint64_t	num;
+
+	    num = hashval;
+	    bucket = do_div(num, dstate->dtds_hashsize);
+	}
+
+	if (op == DTRACE_DYNVAR_DEALLOC) {
+		volatile uintptr_t	*lockp = &hash[bucket].dtdh_lock;
+
+		for (;;) {
+			while ((lock = *lockp) & 1)
+				continue;
+
+			if (cmpxchg(lockp, lock, (lock + 1)) == lock)
+				break;
+		}
+
+		dtrace_membar_producer();
+	}
+
+top:
+	prev = NULL;
+	lock = hash[bucket].dtdh_lock;
+
+	dtrace_membar_consumer();
+
+	start = hash[bucket].dtdh_chain;
+	ASSERT(start != NULL && (start->dtdv_hashval == DTRACE_DYNHASH_SINK ||
+	       start->dtdv_hashval != DTRACE_DYNHASH_FREE ||
+	       op != DTRACE_DYNVAR_DEALLOC));
+
+	for (dvar = start; dvar != NULL; dvar = dvar->dtdv_next) {
+		dtrace_tuple_t	*dtuple = &dvar->dtdv_tuple;
+		dtrace_key_t	*dkey = &dtuple->dtt_key[0];
+
+		if (dvar->dtdv_hashval != hashval) {
+			if (dvar->dtdv_hashval == DTRACE_DYNHASH_SINK) {
+				/*
+				 * We've reached the sink, and therefore the
+				 * end of the hash chain; we can kick out of
+				 * the loop knowing that we have seen a valid
+				 * snapshot of state.
+				 */
+				ASSERT(dvar->dtdv_next == NULL);
+				ASSERT(dvar == &dtrace_dynhash_sink);
+				break;
+			}
+
+			if (dvar->dtdv_hashval == DTRACE_DYNHASH_FREE) {
+				/*
+				 * We've gone off the rails:  somewhere along
+				 * the line, one of the members of this hash
+				 * chain was deleted.  Note that we could also
+				 * detect this by simply letting this loop run
+				 * to completion, as we would eventually hit
+				 * the end of the dirty list.  However, we
+				 * want to avoid running the length of the
+				 * dirty list unnecessarily (it might be quite
+				 * long), so we catch this as early as
+				 * possible by detecting the hash marker.  In
+				 * this case, we simply set dvar to NULL and
+				 * break; the conditional after the loop will
+				 * send us back to top.
+				 */
+				dvar = NULL;
+				break;
+			}
+
+			goto next;
+		}
+
+		if (dtuple->dtt_nkeys != nkeys)
+			goto next;
+
+		for (i = 0; i < nkeys; i++, dkey++) {
+			if (dkey->dttk_size != key[i].dttk_size)
+				goto next;	/* size or type mismatch */
+
+			if (dkey->dttk_size != 0) {
+				if (dtrace_bcmp(
+					  (void *)(uintptr_t)key[i].dttk_value,
+					  (void *)(uintptr_t)dkey->dttk_value,
+					  dkey->dttk_size))
+					goto next;
+			} else {
+				if (dkey->dttk_value != key[i].dttk_value)
+					goto next;
+			}
+		}
+
+		if (op != DTRACE_DYNVAR_DEALLOC)
+			return dvar;
+
+		ASSERT(dvar->dtdv_next == NULL ||
+		dvar->dtdv_next->dtdv_hashval != DTRACE_DYNHASH_FREE);
+
+		if (prev != NULL) {
+			ASSERT(hash[bucket].dtdh_chain != dvar);
+			ASSERT(start != dvar);
+			ASSERT(prev->dtdv_next == dvar);
+			prev->dtdv_next = dvar->dtdv_next;
+		} else {
+			if (cmpxchg(&hash[bucket].dtdh_chain, start,
+				    dvar->dtdv_next) != start) {
+				/*
+				 * We have failed to atomically swing the
+				 * hash table head pointer, presumably because
+				 * of a conflicting allocation on another CPU.
+				 * We need to reread the hash chain and try
+				 * again.
+				 */
+				goto top;
+			}
+		}
+
+		dtrace_membar_producer();
+
+		/*
+		 * Now set the hash value to indicate that it's free.
+		 */
+		ASSERT(hash[bucket].dtdh_chain != dvar);
+		dvar->dtdv_hashval = DTRACE_DYNHASH_FREE;
+
+		dtrace_membar_producer();
+
+		/*
+		 * Set the next pointer to point at the dirty list, and
+		 * atomically swing the dirty pointer to the newly freed dvar.
+		 */
+		do {
+			next = dcpu->dtdsc_dirty;
+			dvar->dtdv_next = next;
+		} while (cmpxchg(&dcpu->dtdsc_dirty, next, dvar) != next);
+
+		/*
+		 * Finally, unlock this hash bucket.
+		 */
+		ASSERT(hash[bucket].dtdh_lock == lock);
+		ASSERT(lock & 1);
+		hash[bucket].dtdh_lock++;
+
+		return NULL;
+next:
+		prev = dvar;
+		continue;
+	}
+
+	if (dvar == NULL) {
+		/*
+		 * If dvar is NULL, it is because we went off the rails:
+		 * one of the elements that we traversed in the hash chain
+		 * was deleted while we were traversing it.  In this case,
+		 * we assert that we aren't doing a dealloc (deallocs lock
+		 * the hash bucket to prevent themselves from racing with
+		 * one another), and retry the hash chain traversal.
+		 */
+		ASSERT(op != DTRACE_DYNVAR_DEALLOC);
+		goto top;
+	}
+
+	if (op != DTRACE_DYNVAR_ALLOC) {
+		/*
+		 * If we are not to allocate a new variable, we want to
+		 * return NULL now.  Before we return, check that the value
+		 * of the lock word hasn't changed.  If it has, we may have
+		 * seen an inconsistent snapshot.
+		 */
+		if (op == DTRACE_DYNVAR_NOALLOC) {
+			if (hash[bucket].dtdh_lock != lock)
+				goto top;
+		} else {
+			ASSERT(op == DTRACE_DYNVAR_DEALLOC);
+			ASSERT(hash[bucket].dtdh_lock == lock);
+			ASSERT(lock & 1);
+			hash[bucket].dtdh_lock++;
+		}
+
+		return NULL;
+	}
+
+	/*
+	 * We need to allocate a new dynamic variable.  The size we need is the
+	 * size of dtrace_dynvar plus the size of nkeys dtrace_key_t's plus the
+	 * size of any auxiliary key data (rounded up to 8-byte alignment) plus
+	 * the size of any referred-to data (dsize).  We then round the final
+	 * size up to the chunksize for allocation.
+	 */
+	for (ksize = 0, i = 0; i < nkeys; i++)
+		ksize += P2ROUNDUP(key[i].dttk_size, sizeof(uint64_t));
+
+	/*
+	 * This should be pretty much impossible, but could happen if, say,
+	 * strange DIF specified the tuple.  Ideally, this should be an
+	 * assertion and not an error condition -- but that requires that the
+	 * chunksize calculation in dtrace_difo_chunksize() be absolutely
+	 * bullet-proof.  (That is, it must not be able to be fooled by
+	 * malicious DIF.)  Given the lack of backwards branches in DIF,
+	 * solving this would presumably not amount to solving the Halting
+	 * Problem -- but it still seems awfully hard.
+	 */
+	if (sizeof(dtrace_dynvar_t) + sizeof(dtrace_key_t) * (nkeys - 1) +
+	    ksize + dsize > chunksize) {
+		dcpu->dtdsc_drops++;
+		return NULL;
+	}
+
+	nstate = DTRACE_DSTATE_EMPTY;
+
+	do {
+retry:
+		free = dcpu->dtdsc_free;
+
+		if (free == NULL) {
+			dtrace_dynvar_t	*clean = dcpu->dtdsc_clean;
+			void		*rval;
+
+			if (clean == NULL) {
+				/*
+				 * We're out of dynamic variable space on
+				 * this CPU.  Unless we have tried all CPUs,
+				 * we'll try to allocate from a different
+				 * CPU.
+				 */
+				switch (dstate->dtds_state) {
+				case DTRACE_DSTATE_CLEAN: {
+					dtrace_dstate_state_t	*sp =
+						(dtrace_dstate_state_t *)
+							&dstate->dtds_state;
+
+					if (++cpu >= NR_CPUS)
+						cpu = 0;
+
+					if (dcpu->dtdsc_dirty != NULL &&
+					    nstate == DTRACE_DSTATE_EMPTY)
+						nstate = DTRACE_DSTATE_DIRTY;
+
+					if (dcpu->dtdsc_rinsing != NULL)
+						nstate = DTRACE_DSTATE_RINSING;
+
+					dcpu = &dstate->dtds_percpu[cpu];
+
+					if (cpu != me)
+						goto retry;
+
+					cmpxchg(sp, DTRACE_DSTATE_CLEAN,
+						nstate);
+
+					/*
+					 * To increment the correct bean
+					 * counter, take another lap.
+					 */
+					goto retry;
+				}
+
+				case DTRACE_DSTATE_DIRTY:
+					dcpu->dtdsc_dirty_drops++;
+					break;
+
+				case DTRACE_DSTATE_RINSING:
+					dcpu->dtdsc_rinsing_drops++;
+					break;
+
+				case DTRACE_DSTATE_EMPTY:
+					dcpu->dtdsc_drops++;
+					break;
+				}
+
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_DROP);
+				return NULL;
+			}
+
+			/*
+			 * The clean list appears to be non-empty.  We want to
+			 * move the clean list to the free list; we start by
+			 * moving the clean pointer aside.
+			 */
+			if (cmpxchg(&dcpu->dtdsc_clean, clean, NULL) != clean)
+				/*
+				 * We are in one of two situations:
+				 *
+				 *  (a) The clean list was switched to the
+				 *      free list by another CPU.
+				 *
+				 *  (b) The clean list was added to by the
+				 *      cleansing cyclic.
+				 *
+				 * In either of these situations, we can
+				 * just reattempt the free list allocation.
+				 */
+				goto retry;
+
+			ASSERT(clean->dtdv_hashval == DTRACE_DYNHASH_FREE);
+
+			/*
+			 * Now we'll move the clean list to the free list.
+			 * It's impossible for this to fail:  the only way
+			 * the free list can be updated is through this
+			 * code path, and only one CPU can own the clean list.
+			 * Thus, it would only be possible for this to fail if
+			 * this code were racing with dtrace_dynvar_clean().
+			 * (That is, if dtrace_dynvar_clean() updated the clean
+			 * list, and we ended up racing to update the free
+			 * list.)  This race is prevented by the dtrace_sync()
+			 * in dtrace_dynvar_clean() -- which flushes the
+			 * owners of the clean lists out before resetting
+			 * the clean lists.
+			 */
+			rval = cmpxchg(&dcpu->dtdsc_free, NULL, clean);
+			ASSERT(rval == NULL);
+
+			goto retry;
+		}
+
+		dvar = free;
+		new_free = dvar->dtdv_next;
+	} while (cmpxchg(&dcpu->dtdsc_free, free, new_free) != free);
+
+	/*
+	 * We have now allocated a new chunk.  We copy the tuple keys into the
+	 * tuple array and copy any referenced key data into the data space
+	 * following the tuple array.  As we do this, we relocate dttk_value
+	 * in the final tuple to point to the key data address in the chunk.
+	 */
+	kdata = (uintptr_t)&dvar->dtdv_tuple.dtt_key[nkeys];
+	dvar->dtdv_data = (void *)(kdata + ksize);
+	dvar->dtdv_tuple.dtt_nkeys = nkeys;
+
+	for (i = 0; i < nkeys; i++) {
+		dtrace_key_t	*dkey = &dvar->dtdv_tuple.dtt_key[i];
+		size_t		kesize = key[i].dttk_size;
+
+		if (kesize != 0) {
+			dtrace_bcopy(
+				(const void *)(uintptr_t)key[i].dttk_value,
+				(void *)kdata, kesize);
+			dkey->dttk_value = kdata;
+			kdata += P2ROUNDUP(kesize, sizeof(uint64_t));
+		} else
+			dkey->dttk_value = key[i].dttk_value;
+
+		dkey->dttk_size = kesize;
+	}
+
+	ASSERT(dvar->dtdv_hashval == DTRACE_DYNHASH_FREE);
+	dvar->dtdv_hashval = hashval;
+	dvar->dtdv_next = start;
+
+	if (cmpxchg(&hash[bucket].dtdh_chain, start, dvar) == start)
+		return dvar;
+
+	/*
+	 * The cas has failed.  Either another CPU is adding an element to
+	 * this hash chain, or another CPU is deleting an element from this
+	 * hash chain.  The simplest way to deal with both of these cases
+	 * (though not necessarily the most efficient) is to free our
+	 * allocated block and tail-call ourselves.  Note that the free is
+	 * to the dirty list and _not_ to the free list.  This is to prevent
+	 * races with allocators, above.
+	 */
+	dvar->dtdv_hashval = DTRACE_DYNHASH_FREE;
+
+	dtrace_membar_producer();
+
+	do {
+		free = dcpu->dtdsc_dirty;
+		dvar->dtdv_next = free;
+	} while (cmpxchg(&dcpu->dtdsc_dirty, free, dvar) != free);
+
+	return dtrace_dynvar(dstate, nkeys, key, dsize, op, mstate, vstate);
+}
+
+/*
+ * Return a string.  In the event that the user lacks the privilege to access
+ * arbitrary kernel memory, we copy the string out to scratch memory so that we
+ * don't fail access checking.
+ *
+ * dtrace_dif_variable() uses this routine as a helper for various
+ * builtin values such as 'execname' and 'probefunc.'
+ */
+static uintptr_t dtrace_dif_varstr(uintptr_t addr, dtrace_state_t *state,
+				   dtrace_mstate_t *mstate)
+{
+	uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+	uintptr_t	ret;
+	size_t		strsz;
+
+	/*
+	 * The easy case: this probe is allowed to read all of memory, so
+	 * we can just return this as a vanilla pointer.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return addr;
+
+	/*
+	 * This is the tougher case: we copy the string in question from
+	 * kernel memory into scratch memory and return it that way: this
+	 * ensures that we won't trip up when access checking tests the
+	 * BYREF return value.
+	 */
+	strsz = dtrace_strlen((char *)addr, size) + 1;
+
+	if (mstate->dtms_scratch_ptr + strsz >
+	    mstate->dtms_scratch_base + mstate->dtms_scratch_size) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+		return (uintptr_t)NULL;
+	}
+
+	dtrace_strcpy((const void *)addr, (void *)mstate->dtms_scratch_ptr,
+		      strsz);
+	ret = mstate->dtms_scratch_ptr;
+	mstate->dtms_scratch_ptr += strsz;
+
+	return ret;
+}
+
+/*
+ * This function implements the DIF emulator's variable lookups.  The emulator
+ * passes a reserved variable identifier and optional built-in array index.
+ *
+ * This function is annotated to be always inlined in dtrace_dif_emulate()
+ * because (1) that is the only place where it is called from, and (2) it has
+ * come to our attention that some GCC versions inline it automatically while
+ * others do not and that messes up the number of frames to skip (aframes).
+ */
+static uint64_t __always_inline dtrace_dif_variable(dtrace_mstate_t *mstate,
+						    dtrace_state_t *state,
+						    uint64_t v, uint64_t ndx)
+{
+	/*
+	 * If we're accessing one of the uncached arguments, we'll turn this
+	 * into a reference in the args array.
+	 */
+	if (v >= DIF_VAR_ARG0 && v <= DIF_VAR_ARG9) {
+		ndx = v - DIF_VAR_ARG0;
+		v = DIF_VAR_ARGS;
+	}
+
+	switch (v) {
+	case DIF_VAR_ARGS:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_ARGS);
+
+		if (ndx >= DTRACE_MSTATE_ARGS_MAX) {
+			int			aframes =
+					mstate->dtms_probe->dtpr_aframes + 1;
+			dtrace_provider_t	*pv;
+			uint64_t		val;
+
+			pv = mstate->dtms_probe->dtpr_provider;
+			if (pv->dtpv_pops.dtps_getargval != NULL)
+				val = pv->dtpv_pops.dtps_getargval(
+					pv->dtpv_arg,
+					mstate->dtms_probe->dtpr_id,
+					mstate->dtms_probe->dtpr_arg,
+					ndx, aframes);
+			else
+				val = dtrace_getarg(ndx, aframes);
+
+			/*
+			 * This is regrettably required to keep the compiler
+			 * from tail-optimizing the call to dtrace_getarg().
+			 * The condition always evaluates to true, but the
+			 * compiler has no way of figuring that out a priori.
+			 * (None of this would be necessary if the compiler
+			 * could be relied upon to _always_ tail-optimize
+			 * the call to dtrace_getarg() -- but it can't.)
+			 */
+			if (mstate->dtms_probe != NULL)
+				return val;
+
+			ASSERT(0);
+		}
+
+		return mstate->dtms_arg[ndx];
+
+	case DIF_VAR_UREGS: {
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		return dtrace_getreg(current, ndx);
+	}
+
+	case DIF_VAR_CURTHREAD:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+
+		return (uint64_t)(uintptr_t)current;
+
+	case DIF_VAR_TIMESTAMP:
+		if (!(mstate->dtms_present & DTRACE_MSTATE_TIMESTAMP)) {
+			mstate->dtms_timestamp = dtrace_gethrtime();
+			mstate->dtms_present |= DTRACE_MSTATE_TIMESTAMP;
+		}
+
+		return ktime_to_ns(mstate->dtms_timestamp);
+
+	case DIF_VAR_WALLTIMESTAMP:
+		return ktime_to_ns(dtrace_get_walltime());
+
+	case DIF_VAR_VTIMESTAMP:
+		ASSERT(dtrace_vtime_references != 0);
+
+		return ktime_to_ns(current->dtrace_vtime);
+
+	case DIF_VAR_IPL:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_IPL)) {
+			mstate->dtms_ipl = dtrace_getipl();
+			mstate->dtms_present |= DTRACE_MSTATE_IPL;
+		}
+
+		return mstate->dtms_ipl;
+
+	case DIF_VAR_EPID:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_EPID);
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_EPID);
+
+		return mstate->dtms_epid;
+
+	case DIF_VAR_ID:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+		return mstate->dtms_probe->dtpr_id;
+
+	case DIF_VAR_STACKDEPTH:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+		if (!(mstate->dtms_present & DTRACE_MSTATE_STACKDEPTH)) {
+			int	aframes = mstate->dtms_probe->dtpr_aframes + 2;
+
+			mstate->dtms_stackdepth = dtrace_getstackdepth(
+							mstate, aframes);
+			mstate->dtms_present |= DTRACE_MSTATE_STACKDEPTH;
+		}
+
+		return mstate->dtms_stackdepth;
+
+	case DIF_VAR_USTACKDEPTH:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_USTACKDEPTH)) {
+			/*
+			 * See comment in DIF_VAR_PID.
+			 */
+			if (DTRACE_ANCHORED(mstate->dtms_probe) &&
+			    in_interrupt())
+				mstate->dtms_ustackdepth = 0;
+			else
+				mstate->dtms_ustackdepth =
+					dtrace_getustackdepth();
+
+			mstate->dtms_present |= DTRACE_MSTATE_USTACKDEPTH;
+		}
+
+		return mstate->dtms_ustackdepth;
+
+	case DIF_VAR_CALLER:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_CALLER)) {
+			int	aframes = mstate->dtms_probe->dtpr_aframes + 1;
+
+			if (!DTRACE_ANCHORED(mstate->dtms_probe)) {
+				/*
+				 * If this is an unanchored probe, we are
+				 * required to go through the slow path:
+				 * dtrace_caller() only guarantees correct
+				 * results for anchored probes.
+				 */
+				uint64_t	caller[2];
+
+				dtrace_getpcstack(caller, 2, aframes,
+					(uint32_t *)(uintptr_t)
+							mstate->dtms_arg[0]);
+				mstate->dtms_caller = caller[1];
+			} else if ((mstate->dtms_caller =
+					dtrace_caller(aframes, 0)) == -1) {
+				/*
+				 * We have failed to do this the quick way;
+				 * we must resort to the slower approach of
+				 * calling dtrace_getpcstack().
+				 */
+				uint64_t	caller;
+
+				dtrace_getpcstack(&caller, 1, aframes, NULL);
+				mstate->dtms_caller = caller;
+			}
+
+			mstate->dtms_present |= DTRACE_MSTATE_CALLER;
+		}
+
+		return mstate->dtms_caller;
+
+	case DIF_VAR_UCALLER:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_UCALLER)) {
+			uint64_t	ustack[4];
+
+			/*
+			 * dtrace_getupcstack() fills in the first uint64_t with
+			 * the current PID, and the second uint64_t with the
+			 * current TGID.  The third uint64_t will be the
+			 * program counter at user-level.  The fourth uint64_t
+			 * will contain the caller, which is what we're after.
+			 */
+			ustack[3] = 0;
+			dtrace_getupcstack(ustack, 4);
+
+			mstate->dtms_ucaller = ustack[3];
+			mstate->dtms_present |= DTRACE_MSTATE_UCALLER;
+		}
+
+		return mstate->dtms_ucaller;
+
+	case DIF_VAR_PROBEPROV:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_provider->dtpv_name,
+			state, mstate);
+
+	case DIF_VAR_PROBEMOD:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_mod, state,
+			mstate);
+
+	case DIF_VAR_PROBEFUNC:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_func, state,
+			mstate);
+
+	case DIF_VAR_PROBENAME:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_name, state,
+			mstate);
+
+	case DIF_VAR_PID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 */
+		return (uint64_t)current->tgid;
+
+	case DIF_VAR_PPID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 *
+		 * Additionally, it is safe to dereference one's parent, since
+		 * it is never NULL after process birth.
+		 */
+		return (uint64_t)current->real_parent->tgid;
+
+	case DIF_VAR_TID:
+		return (uint64_t)current->pid;
+
+	case DIF_VAR_EXECNAME:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 */
+		return dtrace_dif_varstr((uintptr_t)current->comm, state,
+					 mstate);
+
+	case DIF_VAR_ZONENAME:
+		return 0;
+
+	case DIF_VAR_UID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 *
+		 * Additionally, it is safe to dereference one's own process
+		 * credential, since this is never NULL after process birth.
+		 */
+		return (uint64_t)from_kuid(current_user_ns(),
+					   current_real_cred()->uid);
+
+	case DIF_VAR_GID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 *
+		 * Additionally, it is safe to dereference one's own process
+		 * credential, since this is never NULL after process birth.
+		 */
+		return (uint64_t)from_kgid(current_user_ns(),
+					   current_real_cred()->gid);
+
+	case DIF_VAR_ERRNO: {
+		int64_t	arg0;
+
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * We need to do some magic here to get the correct semantics
+		 * for the 'errno' variable.  It can only have a non-zero value
+		 * when executing a system call, and for Linux, only after the
+		 * actual system call implementation has completed, indicating
+		 * in its return value either an error code (-2048 < errno < 0)
+		 * or a valid result.  So, the only time we can expect a valid
+		 * value in errno is during the processing of any return probe
+		 * in the syscall provider.  In all other cases, it should have
+		 * the value 0.
+		 *
+		 * So, we only look at probes that match: syscall:::return
+		 */
+		if (strncmp(mstate->dtms_probe->dtpr_provider->dtpv_name,
+			    "syscall", 7) != 0)
+			return 0;
+		if (strncmp(mstate->dtms_probe->dtpr_name, "return", 6) != 0)
+			return 0;
+
+		/*
+		 * Error number is present if arg0 lies between 0 and -2048,
+		 * exclusive.
+		 */
+		arg0 = (int64_t)mstate->dtms_arg[ndx];
+		if (arg0 < 0 && arg0 > -2048)
+			return (uint64_t)-arg0;
+
+		return 0;
+	}
+
+	case DIF_VAR_CURCPU:
+		return (uint64_t)(uintptr_t)this_cpu_info;
+
+	default:
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return 0;
+	}
+}
+
+#define DTRACE_V4MAPPED_OFFSET	(sizeof(uint32_t) * 3)
+
+/*
+ * Emulate the execution of DTrace ID subroutines invoked by the call opcode.
+ * Notice that we don't bother validating the proper number of arguments or
+ * their types in the tuple stack.  This isn't needed because all argument
+ * interpretation is safe because of our load safety -- the worst that can
+ * happen is that a bogus program can obtain bogus results.
+ */
+static void dtrace_dif_subr(uint_t subr, uint_t rd, uint64_t *regs,
+			    dtrace_key_t *tupregs, int nargs,
+			    dtrace_mstate_t *mstate, dtrace_state_t *state)
+{
+	volatile uint16_t	*flags = &this_cpu_core->cpuc_dtrace_flags;
+	volatile uintptr_t	*illval = &this_cpu_core->cpuc_dtrace_illval;
+	dtrace_vstate_t		*vstate = &state->dts_vstate;
+	struct mutex		mtx;
+
+	union {
+		rwlock_t ri;
+		uintptr_t rw;
+	} r;
+
+	dt_dbg_dif("        Subroutine %d\n", subr);
+
+	switch (subr) {
+	case DIF_SUBR_RAND:
+		regs[rd] = ktime_to_ns(dtrace_gethrtime()) * 2416 + 374441;
+		regs[rd] = do_div(regs[rd], 1771875);
+		break;
+
+	case DIF_SUBR_MUTEX_OWNED:
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate))
+			break;
+
+		dtrace_bcopy((const void *)(uintptr_t)tupregs[0].dttk_value,
+			     &mtx, sizeof(struct mutex));
+		if (*flags & CPU_DTRACE_FAULT)
+			break;
+
+		regs[rd] = mutex_owned(&mtx);
+		break;
+
+	case DIF_SUBR_MUTEX_OWNER:
+		regs[rd] = 0;
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate))
+			break;
+
+		dtrace_bcopy((const void *)(uintptr_t)tupregs[0].dttk_value,
+			     &mtx, sizeof(struct mutex));
+		if (*flags & CPU_DTRACE_FAULT)
+			break;
+
+#ifdef CONFIG_SMP
+		regs[rd] = (uintptr_t)__mutex_owner(&mtx);
+#else
+		regs[rd] = 0;
+#endif
+		break;
+
+	case DIF_SUBR_MUTEX_TYPE_ADAPTIVE:
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * On Linux, all mutexes are adaptive.
+		 */
+		regs[rd] = 1;
+		break;
+
+	case DIF_SUBR_MUTEX_TYPE_SPIN:
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * On Linux, all mutexes are adaptive.
+		 */
+		regs[rd] = 0;
+		break;
+
+	case DIF_SUBR_RW_READ_HELD: {
+		if (!dtrace_canload(tupregs[0].dttk_value, sizeof(rwlock_t),
+		    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
+		regs[rd] = !write_can_lock(&r.ri) && read_can_lock(&r.ri);
+		break;
+	}
+
+	case DIF_SUBR_RW_WRITE_HELD:
+		if (!dtrace_canload(tupregs[0].dttk_value, sizeof(rwlock_t),
+		    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
+		regs[rd] = !write_can_lock(&r.ri);
+		break;
+
+	case DIF_SUBR_RW_ISWRITER:
+		if (!dtrace_canload(tupregs[0].dttk_value, sizeof(rwlock_t),
+		    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
+		/*
+		 * On Linux there is no way to determine whether someone is
+		 * trying to acquire a write lock.
+		 */
+		regs[rd] = !write_can_lock(&r.ri);
+		break;
+
+	case DIF_SUBR_BCOPY: {
+		/*
+		 * We need to be sure that the destination is in the scratch
+		 * region -- no other region is allowed.
+		 */
+		uintptr_t	src = tupregs[0].dttk_value;
+		uintptr_t	dest = tupregs[1].dttk_value;
+		size_t		size = tupregs[2].dttk_value;
+
+		if (!dtrace_inscratch(dest, size, mstate)) {
+			*flags |= CPU_DTRACE_BADADDR;
+			*illval = regs[rd];
+			break;
+		}
+
+		if (!dtrace_canload(src, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		dtrace_bcopy((void *)src, (void *)dest, size);
+		break;
+	}
+
+	case DIF_SUBR_ALLOCA:
+	case DIF_SUBR_COPYIN: {
+		uintptr_t	dest = P2ROUNDUP(mstate->dtms_scratch_ptr, 8);
+		uint64_t	size = tupregs[
+					subr == DIF_SUBR_ALLOCA ? 0 : 1
+				       ].dttk_value;
+		size_t		scratch_size = (dest -
+						mstate->dtms_scratch_ptr) +
+					       size;
+
+		/*
+		 * This action doesn't require any credential checks since
+		 * probes will not activate in user contexts to which the
+		 * enabling user does not have permissions.
+		 */
+
+		/*
+		 * Rounding up the user allocation size could have overflowed
+		 * a large, bogus allocation (like -1ULL) to 0.
+		 */
+		if (scratch_size < size ||
+		    !DTRACE_INSCRATCH(mstate, scratch_size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (subr == DIF_SUBR_COPYIN) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			dtrace_copyin(tupregs[0].dttk_value, dest, size, flags);
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		}
+
+		mstate->dtms_scratch_ptr += scratch_size;
+		regs[rd] = dest;
+		break;
+	}
+
+	case DIF_SUBR_COPYINTO: {
+		uint64_t	size = tupregs[1].dttk_value;
+		uintptr_t	dest = tupregs[2].dttk_value;
+
+		/*
+		 * This action doesn't require any credential checks since
+		 * probes will not activate in user contexts to which the
+		 * enabling user does not have permissions.
+		 */
+		if (!dtrace_inscratch(dest, size, mstate)) {
+			*flags |= CPU_DTRACE_BADADDR;
+			*illval = regs[rd];
+			break;
+		}
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+		dtrace_copyin(tupregs[0].dttk_value, dest, size, flags);
+		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		break;
+	}
+
+	case DIF_SUBR_COPYINSTR: {
+		uintptr_t	dest = mstate->dtms_scratch_ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+
+		if (nargs > 1 && tupregs[1].dttk_value < size)
+			size = tupregs[1].dttk_value + 1;
+
+		/*
+		 * This action doesn't require any credential checks since
+		 * probes will not activate in user contexts to which the
+		 * enabling user does not have permissions.
+		 */
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+		dtrace_copyinstr(tupregs[0].dttk_value, dest, size, flags);
+		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+		((char *)dest)[size - 1] = '\0';
+		mstate->dtms_scratch_ptr += size;
+		regs[rd] = dest;
+		break;
+	}
+
+#if 0 /* FIXME */
+	case DIF_SUBR_MSGSIZE:
+	case DIF_SUBR_MSGDSIZE: {
+		uintptr_t	baddr = tupregs[0].dttk_value, daddr;
+		uintptr_t	wptr, rptr;
+		size_t		count = 0;
+		int		cont = 0;
+
+		while (baddr != NULL && !(*flags & CPU_DTRACE_FAULT)) {
+
+			if (!dtrace_canload(baddr, sizeof(mblk_t), mstate,
+			    vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+
+			wptr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_wptr));
+
+			rptr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_rptr));
+
+			if (wptr < rptr) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = tupregs[0].dttk_value;
+				break;
+			}
+
+			daddr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_datap));
+
+			baddr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_cont));
+
+			/*
+			 * We want to prevent against denial-of-service here,
+			 * so we're only going to search the list for
+			 * dtrace_msgdsize_max mblks.
+			 */
+			if (cont++ > dtrace_msgdsize_max) {
+				*flags |= CPU_DTRACE_ILLOP;
+				break;
+			}
+
+			if (subr == DIF_SUBR_MSGDSIZE) {
+				if (dtrace_load8(daddr +
+				    offsetof(dblk_t, db_type)) != M_DATA)
+					continue;
+			}
+
+			count += wptr - rptr;
+		}
+
+		if (!(*flags & CPU_DTRACE_FAULT))
+			regs[rd] = count;
+
+		break;
+	}
+#endif
+
+	case DIF_SUBR_PROGENYOF: {
+		pid_t			pid = tupregs[0].dttk_value;
+		struct task_struct	*p;
+		int			rval = 0;
+
+		for (p = current; p != NULL; p = p->real_parent) {
+			if (p->pid == pid) {
+				rval = 1;
+				break;
+			}
+
+			if (p == p->real_parent)
+				break;
+		}
+
+		regs[rd] = rval;
+		break;
+	}
+
+	case DIF_SUBR_SPECULATION:
+		regs[rd] = dtrace_speculation(state);
+		break;
+
+	case DIF_SUBR_COPYOUT: {
+		uintptr_t	kaddr = tupregs[0].dttk_value;
+		uintptr_t	uaddr = tupregs[1].dttk_value;
+		uint64_t	size = tupregs[2].dttk_value;
+
+		if (!dtrace_destructive_disallow &&
+		    dtrace_priv_proc_control(state) &&
+		    !dtrace_istoxic(kaddr, size) &&
+		    dtrace_canload(kaddr, size, mstate, vstate)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			dtrace_copyout(kaddr, uaddr, size, flags);
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		}
+		break;
+	}
+
+	case DIF_SUBR_COPYOUTSTR: {
+		uintptr_t	kaddr = tupregs[0].dttk_value;
+		uintptr_t	uaddr = tupregs[1].dttk_value;
+		uint64_t	size = tupregs[2].dttk_value;
+
+		if (!dtrace_destructive_disallow &&
+		    dtrace_priv_proc_control(state) &&
+		    !dtrace_istoxic(kaddr, size) &&
+		    dtrace_strcanload(kaddr, size, mstate, vstate)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			dtrace_copyoutstr(kaddr, uaddr, size, flags);
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		}
+		break;
+	}
+
+	case DIF_SUBR_STRLEN: {
+		size_t		sz;
+		uintptr_t	addr = (uintptr_t)tupregs[0].dttk_value;
+
+		sz = dtrace_strlen((char *)addr,
+				   state->dts_options[DTRACEOPT_STRSIZE]);
+
+		if (!dtrace_canload(addr, sz + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		regs[rd] = sz;
+
+		break;
+	}
+
+	case DIF_SUBR_STRCHR:
+	case DIF_SUBR_STRRCHR: {
+		/*
+		 * We're going to iterate over the string looking for the
+		 * specified character.  We will iterate until we have reached
+		 * the string length or we have found the character.  If this
+		 * is DIF_SUBR_STRRCHR, we will look for the last occurrence
+		 * of the specified character instead of the first.
+		 */
+		uintptr_t	saddr = tupregs[0].dttk_value;
+		uintptr_t	addr = tupregs[0].dttk_value;
+		uintptr_t	limit = addr +
+					state->dts_options[DTRACEOPT_STRSIZE];
+		char		c, target = (char)tupregs[1].dttk_value;
+
+		for (regs[rd] = 0; addr < limit; addr++) {
+			if ((c = dtrace_load8(addr)) == target) {
+				regs[rd] = addr;
+
+				if (subr == DIF_SUBR_STRCHR)
+					break;
+			}
+
+			if (c == '\0')
+				break;
+		}
+
+		if (!dtrace_canload(saddr, addr - saddr, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		break;
+	}
+
+	case DIF_SUBR_STRSTR:
+	case DIF_SUBR_INDEX:
+	case DIF_SUBR_RINDEX: {
+		/*
+		 * We're going to iterate over the string looking for the
+		 * specified string.  We will iterate until we have reached
+		 * the string length or we have found the string.  (Yes, this
+		 * is done in the most naive way possible -- but considering
+		 * that the string we're searching for is likely to be
+		 * relatively short, the complexity of Rabin-Karp or similar
+		 * hardly seems merited.)
+		 */
+		char		*addr = (char *)(uintptr_t)
+							tupregs[0].dttk_value;
+		char		*substr = (char *)(uintptr_t)
+							tupregs[1].dttk_value;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		size_t		len = dtrace_strlen(addr, size);
+		size_t		sublen = dtrace_strlen(substr, size);
+		char		*limit = addr + len, *orig = addr;
+		int		notfound = subr == DIF_SUBR_STRSTR ? 0 : -1;
+		int		inc = 1;
+
+		regs[rd] = notfound;
+
+		if (!dtrace_canload((uintptr_t)addr, len + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!dtrace_canload((uintptr_t)substr, sublen + 1, mstate,
+				    vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * strstr() and index()/rindex() have similar semantics if
+		 * both strings are the empty string: strstr() returns a
+		 * pointer to the (empty) string, and index() and rindex()
+		 * both return index 0 (regardless of any position argument).
+		 */
+		if (sublen == 0 && len == 0) {
+			if (subr == DIF_SUBR_STRSTR)
+				regs[rd] = (uintptr_t)addr;
+			else
+				regs[rd] = 0;
+			break;
+		}
+
+		if (subr != DIF_SUBR_STRSTR) {
+			if (subr == DIF_SUBR_RINDEX) {
+				limit = orig - 1;
+				addr += len;
+				inc = -1;
+			}
+
+			/*
+			 * Both index() and rindex() take an optional position
+			 * argument that denotes the starting position.
+			 */
+			if (nargs == 3) {
+				int64_t	pos = (int64_t)tupregs[2].dttk_value;
+
+				/*
+				 * If the position argument to index() is
+				 * negative, Perl implicitly clamps it at
+				 * zero.  This semantic is a little surprising
+				 * given the special meaning of negative
+				 * positions to similar Perl functions like
+				 * substr(), but it appears to reflect a
+				 * notion that index() can start from a
+				 * negative index and increment its way up to
+				 * the string.  Given this notion, Perl's
+				 * rindex() is at least self-consistent in
+				 * that it implicitly clamps positions greater
+				 * than the string length to be the string
+				 * length.  Where Perl completely loses
+				 * coherence, however, is when the specified
+				 * substring is the empty string ("").  In
+				 * this case, even if the position is
+				 * negative, rindex() returns 0 -- and even if
+				 * the position is greater than the length,
+				 * index() returns the string length.  These
+				 * semantics violate the notion that index()
+				 * should never return a value less than the
+				 * specified position and that rindex() should
+				 * never return a value greater than the
+				 * specified position.  (One assumes that
+				 * these semantics are artifacts of Perl's
+				 * implementation and not the results of
+				 * deliberate design -- it beggars belief that
+				 * even Larry Wall could desire such oddness.)
+				 * While in the abstract one would wish for
+				 * consistent position semantics across
+				 * substr(), index() and rindex() -- or at the
+				 * very least self-consistent position
+				 * semantics for index() and rindex() -- we
+				 * instead opt to keep with the extant Perl
+				 * semantics, in all their broken glory.  (Do
+				 * we have more desire to maintain Perl's
+				 * semantics than Perl does?  Probably.)
+				 */
+				if (subr == DIF_SUBR_RINDEX) {
+					if (pos < 0) {
+						if (sublen == 0)
+							regs[rd] = 0;
+						break;
+					}
+
+					if (pos > len)
+						pos = len;
+				} else {
+					if (pos < 0)
+						pos = 0;
+
+					if (pos >= len) {
+						if (sublen == 0)
+							regs[rd] = len;
+						break;
+					}
+				}
+
+				addr = orig + pos;
+			}
+		}
+
+		for (regs[rd] = notfound; addr != limit; addr += inc) {
+			if (dtrace_strncmp(addr, substr, sublen) == 0) {
+				if (subr != DIF_SUBR_STRSTR) {
+					/*
+					 * As D index() and rindex() are
+					 * modeled on Perl (and not on awk),
+					 * we return a zero-based (and not a
+					 * one-based) index.  (For you Perl
+					 * weenies: no, we're not going to add
+					 * $[ -- and shouldn't you be at a con
+					 * or something?)
+					 */
+					regs[rd] = (uintptr_t)(addr - orig);
+					break;
+				}
+
+				ASSERT(subr == DIF_SUBR_STRSTR);
+				regs[rd] = (uintptr_t)addr;
+				break;
+			}
+		}
+
+		break;
+	}
+
+	case DIF_SUBR_STRTOK: {
+		uintptr_t	addr = tupregs[0].dttk_value;
+		uintptr_t	tokaddr = tupregs[1].dttk_value;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	limit, toklimit = tokaddr + size;
+		uint8_t		c = 0, tokmap[32];	/* 256 / 8 */
+		char		*dest = (char *)mstate->dtms_scratch_ptr;
+		int		i;
+
+		/*
+		 * Check both the token buffer and (later) the input buffer,
+		 * since both could be non-scratch addresses.
+		 */
+		if (!dtrace_strcanload(tokaddr, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (addr == (uintptr_t)NULL) {
+			/*
+			 * If the address specified is NULL, we use our saved
+			 * strtok pointer from the mstate.  Note that this
+			 * means that the saved strtok pointer is _only_
+			 * valid within multiple enablings of the same probe --
+			 * it behaves like an implicit clause-local variable.
+			 */
+			addr = mstate->dtms_strtok;
+		} else {
+			/*
+			 * If the user-specified address is non-NULL we must
+			 * access check it.  This is the only time we have
+			 * a chance to do so, since this address may reside
+			 * in the string table of this clause-- future calls
+			 * (when we fetch addr from mstate->dtms_strtok)
+			 * would fail this access check.
+			 */
+			if (!dtrace_strcanload(addr, size, mstate, vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+		}
+
+		/*
+		 * First, zero the token map, and then process the token
+		 * string -- setting a bit in the map for every character
+		 * found in the token string.
+		 */
+		for (i = 0; i < sizeof(tokmap); i++)
+			tokmap[i] = 0;
+
+		for (; tokaddr < toklimit; tokaddr++) {
+			if ((c = dtrace_load8(tokaddr)) == '\0')
+				break;
+
+			ASSERT((c >> 3) < sizeof(tokmap));
+			tokmap[c >> 3] |= (1 << (c & 0x7));
+		}
+
+		for (limit = addr + size; addr < limit; addr++) {
+			/*
+			 * We're looking for a character that is _not_ contained
+			 * in the token string.
+			 */
+			if ((c = dtrace_load8(addr)) == '\0')
+				break;
+
+			if (!(tokmap[c >> 3] & (1 << (c & 0x7))))
+				break;
+		}
+
+		if (c == '\0') {
+			/*
+			 * We reached the end of the string without finding
+			 * any character that was not in the token string.
+			 * We return NULL in this case, and we set the saved
+			 * address to NULL as well.
+			 */
+			regs[rd] = 0;
+			mstate->dtms_strtok = (uintptr_t)NULL;
+			break;
+		}
+
+		/*
+		 * From here on, we're copying into the destination string.
+		 */
+		for (i = 0; addr < limit && i < size - 1; addr++) {
+			if ((c = dtrace_load8(addr)) == '\0')
+				break;
+
+			if (tokmap[c >> 3] & (1 << (c & 0x7)))
+				break;
+
+			ASSERT(i < size);
+			dest[i++] = c;
+		}
+
+		ASSERT(i < size);
+		dest[i] = '\0';
+		regs[rd] = (uintptr_t)dest;
+		mstate->dtms_scratch_ptr += size;
+		mstate->dtms_strtok = addr;
+		break;
+	}
+
+	case DIF_SUBR_SUBSTR: {
+		uintptr_t	s = tupregs[0].dttk_value;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		char		*d = (char *)mstate->dtms_scratch_ptr;
+		int64_t		index = (int64_t)tupregs[1].dttk_value;
+		int64_t		remaining = (int64_t)tupregs[2].dttk_value;
+		size_t		len = dtrace_strlen((char *)s, size);
+		int64_t		i = 0;
+
+		if (!dtrace_canload(s, len + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (nargs <= 2)
+			remaining = (int64_t)size;
+
+		if (index < 0) {
+			index += len;
+
+			if (index < 0 && index + remaining > 0) {
+				remaining += index;
+				index = 0;
+			}
+		}
+
+		if (index >= len || index < 0) {
+			remaining = 0;
+		} else if (remaining < 0) {
+			remaining += len - index;
+		} else if (index + remaining > size) {
+			remaining = size - index;
+		}
+
+		for (i = 0; i < remaining; i++) {
+			if ((d[i] = dtrace_load8(s + index + i)) == '\0')
+				break;
+		}
+
+		d[i] = '\0';
+
+		mstate->dtms_scratch_ptr += size;
+		regs[rd] = (uintptr_t)d;
+		break;
+	}
+
+	case DIF_SUBR_GETMAJOR:
+		regs[rd] = MAJOR(tupregs[0].dttk_value);
+		break;
+
+	case DIF_SUBR_GETMINOR:
+		regs[rd] = MINOR(tupregs[0].dttk_value);
+		break;
+
+#if 0 /* FIXME */
+	case DIF_SUBR_DDI_PATHNAME: {
+		/*
+		 * This one is a galactic mess.  We are going to roughly
+		 * emulate ddi_pathname(), but it's made more complicated
+		 * by the fact that we (a) want to include the minor name and
+		 * (b) must proceed iteratively instead of recursively.
+		 */
+		uintptr_t dest = mstate->dtms_scratch_ptr;
+		uint64_t size = state->dts_options[DTRACEOPT_STRSIZE];
+		char *start = (char *)dest, *end = start + size - 1;
+		uintptr_t daddr = tupregs[0].dttk_value;
+		int64_t minor = (int64_t)tupregs[1].dttk_value;
+		char *s;
+		int i, len, depth = 0;
+
+		/*
+		 * Due to all the pointer jumping we do and context we must
+		 * rely upon, we just mandate that the user must have kernel
+		 * read privileges to use this routine.
+		 */
+		if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) == 0) {
+			*flags |= CPU_DTRACE_KPRIV;
+			*illval = daddr;
+			regs[rd] = 0;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		*end = '\0';
+
+		/*
+		 * We want to have a name for the minor.  In order to do this,
+		 * we need to walk the minor list from the devinfo.  We want
+		 * to be sure that we don't infinitely walk a circular list,
+		 * so we check for circularity by sending a scout pointer
+		 * ahead two elements for every element that we iterate over;
+		 * if the list is circular, these will ultimately point to the
+		 * same element.  You may recognize this little trick as the
+		 * answer to a stupid interview question -- one that always
+		 * seems to be asked by those who had to have it laboriously
+		 * explained to them, and who can't even concisely describe
+		 * the conditions under which one would be forced to resort to
+		 * this technique.  Needless to say, those conditions are
+		 * found here -- and probably only here.  Is this the only use
+		 * of this infamous trick in shipping, production code?  If it
+		 * isn't, it probably should be...
+		 */
+		if (minor != -1) {
+			uintptr_t maddr = dtrace_loadptr(daddr +
+			    offsetof(struct dev_info, devi_minor));
+
+			uintptr_t next = offsetof(struct ddi_minor_data, next);
+			uintptr_t name = offsetof(struct ddi_minor_data,
+			    d_minor) + offsetof(struct ddi_minor, name);
+			uintptr_t dev = offsetof(struct ddi_minor_data,
+			    d_minor) + offsetof(struct ddi_minor, dev);
+			uintptr_t scout;
+
+			if (maddr != NULL)
+				scout = dtrace_loadptr(maddr + next);
+
+			while (maddr != NULL && !(*flags & CPU_DTRACE_FAULT)) {
+				uint64_t m;
+#ifdef _LP64
+				m = dtrace_load64(maddr + dev) & MAXMIN64;
+#else
+				m = dtrace_load32(maddr + dev) & MAXMIN;
+#endif
+				if (m != minor) {
+					maddr = dtrace_loadptr(maddr + next);
+
+					if (scout == NULL)
+						continue;
+
+					scout = dtrace_loadptr(scout + next);
+
+					if (scout == NULL)
+						continue;
+
+					scout = dtrace_loadptr(scout + next);
+
+					if (scout == NULL)
+						continue;
+
+					if (scout == maddr) {
+						*flags |= CPU_DTRACE_ILLOP;
+						break;
+					}
+
+					continue;
+				}
+
+				/*
+				 * We have the minor data.  Now we need to
+				 * copy the minor's name into the end of the
+				 * pathname.
+				 */
+				s = (char *)dtrace_loadptr(maddr + name);
+				len = dtrace_strlen(s, size);
+
+				if (*flags & CPU_DTRACE_FAULT)
+					break;
+
+				if (len != 0) {
+					if ((end -= (len + 1)) < start)
+						break;
+
+					*end = ':';
+				}
+
+				for (i = 1; i <= len; i++)
+					end[i] = dtrace_load8((uintptr_t)s++);
+				break;
+			}
+		}
+
+		while (daddr != NULL && !(*flags & CPU_DTRACE_FAULT)) {
+			ddi_node_state_t devi_state;
+
+			devi_state = dtrace_load32(daddr +
+			    offsetof(struct dev_info, devi_node_state));
+
+			if (*flags & CPU_DTRACE_FAULT)
+				break;
+
+			if (devi_state >= DS_INITIALIZED) {
+				s = (char *)dtrace_loadptr(daddr +
+				    offsetof(struct dev_info, devi_addr));
+				len = dtrace_strlen(s, size);
+
+				if (*flags & CPU_DTRACE_FAULT)
+					break;
+
+				if (len != 0) {
+					if ((end -= (len + 1)) < start)
+						break;
+
+					*end = '@';
+				}
+
+				for (i = 1; i <= len; i++)
+					end[i] = dtrace_load8((uintptr_t)s++);
+			}
+
+			/*
+			 * Now for the node name...
+			 */
+			s = (char *)dtrace_loadptr(daddr +
+			    offsetof(struct dev_info, devi_node_name));
+
+			daddr = dtrace_loadptr(daddr +
+			    offsetof(struct dev_info, devi_parent));
+
+			/*
+			 * If our parent is NULL (that is, if we're the root
+			 * node), we're going to use the special path
+			 * "devices".
+			 */
+			if (daddr == NULL)
+				s = "devices";
+
+			len = dtrace_strlen(s, size);
+			if (*flags & CPU_DTRACE_FAULT)
+				break;
+
+			if ((end -= (len + 1)) < start)
+				break;
+
+			for (i = 1; i <= len; i++)
+				end[i] = dtrace_load8((uintptr_t)s++);
+			*end = '/';
+
+			if (depth++ > dtrace_devdepth_max) {
+				*flags |= CPU_DTRACE_ILLOP;
+				break;
+			}
+		}
+
+		if (end < start)
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+
+		if (daddr == NULL) {
+			regs[rd] = (uintptr_t)end;
+			mstate->dtms_scratch_ptr += size;
+		}
+
+		break;
+	}
+#endif
+
+	case DIF_SUBR_STRJOIN: {
+		char		*d = (char *)mstate->dtms_scratch_ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	s1 = tupregs[0].dttk_value;
+		uintptr_t	s2 = tupregs[1].dttk_value;
+		int		i = 0;
+
+		if (!dtrace_strcanload(s1, size, mstate, vstate) ||
+		    !dtrace_strcanload(s2, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		for (;;) {
+			if (i >= size) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+
+			if ((d[i++] = dtrace_load8(s1++)) == '\0') {
+				i--;
+				break;
+			}
+		}
+
+		for (;;) {
+			if (i >= size) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+
+			if ((d[i++] = dtrace_load8(s2++)) == '\0')
+				break;
+		}
+
+		if (i < size) {
+			mstate->dtms_scratch_ptr += i;
+			regs[rd] = (uintptr_t)d;
+		}
+
+		break;
+	}
+
+	case DIF_SUBR_LLTOSTR: {
+		int64_t		i = (int64_t)tupregs[0].dttk_value;
+		int64_t		val = i < 0 ? i * -1 : i;
+		uint64_t	size = 22;	/* room for 2^64 in dec */
+		char		*end = (char *)mstate->dtms_scratch_ptr + size
+									- 1;
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * GCC on Linux introduces calls to functions that are not
+		 * linked into the kernel image, so we need to use the do_div()
+		 * function instead.  It modifies the first argument in place
+		 * (replaces it with the quotient), and returns the remainder.
+		 *
+		 * Was:
+		 *	for (*end-- = '\0'; val; val /= 10)
+		 *		*end-- = '0' + (val % 10);
+		 */
+		for (*end-- = '\0'; val; )
+			*end-- = '0' + do_div(val, 10);
+
+		if (i == 0)
+			*end-- = '0';
+
+		if (i < 0)
+			*end-- = '-';
+
+		regs[rd] = (uintptr_t)end + 1;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_HTONS:
+	case DIF_SUBR_NTOHS:
+#ifdef __BIG_ENDIAN
+		regs[rd] = (uint16_t)tupregs[0].dttk_value;
+#else
+		regs[rd] = DT_BSWAP_16((uint16_t)tupregs[0].dttk_value);
+#endif
+		break;
+
+
+	case DIF_SUBR_HTONL:
+	case DIF_SUBR_NTOHL:
+#ifdef __BIG_ENDIAN
+		regs[rd] = (uint32_t)tupregs[0].dttk_value;
+#else
+		regs[rd] = DT_BSWAP_32((uint32_t)tupregs[0].dttk_value);
+#endif
+		break;
+
+
+	case DIF_SUBR_HTONLL:
+	case DIF_SUBR_NTOHLL:
+#ifdef __BIG_ENDIAN
+		regs[rd] = (uint64_t)tupregs[0].dttk_value;
+#else
+		regs[rd] = DT_BSWAP_64((uint64_t)tupregs[0].dttk_value);
+#endif
+		break;
+
+
+	case DIF_SUBR_DIRNAME:
+	case DIF_SUBR_BASENAME: {
+		char		*dest = (char *)mstate->dtms_scratch_ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	src = tupregs[0].dttk_value;
+		int		i, j, len = dtrace_strlen((char *)src, size);
+		int		lastbase = -1, firstbase = -1, lastdir = -1;
+		int		start, end;
+
+		if (!dtrace_canload(src, len + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * The basename and dirname for a zero-length string is
+		 * defined to be "."
+		 */
+		if (len == 0) {
+			len = 1;
+			src = (uintptr_t)".";
+		}
+
+		/*
+		 * Start from the back of the string, moving back toward the
+		 * front until we see a character that isn't a slash.  That
+		 * character is the last character in the basename.
+		 */
+		for (i = len - 1; i >= 0; i--) {
+			if (dtrace_load8(src + i) != '/')
+				break;
+		}
+
+		if (i >= 0)
+			lastbase = i;
+
+		/*
+		 * Starting from the last character in the basename, move
+		 * towards the front until we find a slash.  The character
+		 * that we processed immediately before that is the first
+		 * character in the basename.
+		 */
+		for (; i >= 0; i--) {
+			if (dtrace_load8(src + i) == '/')
+				break;
+		}
+
+		if (i >= 0)
+			firstbase = i + 1;
+
+		/*
+		 * Now keep going until we find a non-slash character.  That
+		 * character is the last character in the dirname.
+		 */
+		for (; i >= 0; i--) {
+			if (dtrace_load8(src + i) != '/')
+				break;
+		}
+
+		if (i >= 0)
+			lastdir = i;
+
+		ASSERT(!(lastbase == -1 && firstbase != -1));
+		ASSERT(!(firstbase == -1 && lastdir != -1));
+
+		if (lastbase == -1) {
+			/*
+			 * We didn't find a non-slash character.  We know that
+			 * the length is non-zero, so the whole string must be
+			 * slashes.  In either the dirname or the basename
+			 * case, we return '/'.
+			 */
+			ASSERT(firstbase == -1);
+			firstbase = lastbase = lastdir = 0;
+		}
+
+		if (firstbase == -1) {
+			/*
+			 * The entire string consists only of a basename
+			 * component.  If we're looking for dirname, we need
+			 * to change our string to be just "."; if we're
+			 * looking for a basename, we'll just set the first
+			 * character of the basename to be 0.
+			 */
+			if (subr == DIF_SUBR_DIRNAME) {
+				ASSERT(lastdir == -1);
+				src = (uintptr_t)".";
+				lastdir = 0;
+			} else {
+				firstbase = 0;
+			}
+		}
+
+		if (subr == DIF_SUBR_DIRNAME) {
+			if (lastdir == -1) {
+				/*
+				 * We know that we have a slash in the name --
+				 * or lastdir would be set to 0, above.  And
+				 * because lastdir is -1, we know that this
+				 * slash must be the first character.  (That
+				 * is, the full string must be of the form
+				 * "/basename".)  In this case, the last
+				 * character of the directory name is 0.
+				 */
+				lastdir = 0;
+			}
+
+			start = 0;
+			end = lastdir;
+		} else {
+			ASSERT(subr == DIF_SUBR_BASENAME);
+			ASSERT(firstbase != -1 && lastbase != -1);
+			start = firstbase;
+			end = lastbase;
+		}
+
+		for (i = start, j = 0; i <= end && j < size - 1; i++, j++)
+			dest[j] = dtrace_load8(src + i);
+
+		dest[j] = '\0';
+		regs[rd] = (uintptr_t)dest;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_CLEANPATH: {
+		char		*dest = (char *)mstate->dtms_scratch_ptr, c;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	src = tupregs[0].dttk_value;
+		int		i = 0, j = 0;
+
+		if (!dtrace_strcanload(src, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * Move forward, loading each character.
+		 */
+		do {
+			c = dtrace_load8(src + i++);
+next:
+			if (j + 5 >= size)	/* 5 = strlen("/..c\0") */
+				break;
+
+			if (c != '/') {
+				dest[j++] = c;
+				continue;
+			}
+
+			c = dtrace_load8(src + i++);
+
+			if (c == '/') {
+				/*
+				 * We have two slashes -- we can just advance
+				 * to the next character.
+				 */
+				goto next;
+			}
+
+			if (c != '.') {
+				/*
+				 * This is not "." and it's not ".." -- we can
+				 * just store the "/" and this character and
+				 * drive on.
+				 */
+				dest[j++] = '/';
+				dest[j++] = c;
+				continue;
+			}
+
+			c = dtrace_load8(src + i++);
+
+			if (c == '/') {
+				/*
+				 * This is a "/./" component.  We're not going
+				 * to store anything in the destination buffer;
+				 * we're just going to go to the next component.
+				 */
+				goto next;
+			}
+
+			if (c != '.') {
+				/*
+				 * This is not ".." -- we can just store the
+				 * "/." and this character and continue
+				 * processing.
+				 */
+				dest[j++] = '/';
+				dest[j++] = '.';
+				dest[j++] = c;
+				continue;
+			}
+
+			c = dtrace_load8(src + i++);
+
+			if (c != '/' && c != '\0') {
+				/*
+				 * This is not ".." -- it's "..[mumble]".
+				 * We'll store the "/.." and this character
+				 * and continue processing.
+				 */
+				dest[j++] = '/';
+				dest[j++] = '.';
+				dest[j++] = '.';
+				dest[j++] = c;
+				continue;
+			}
+
+			/*
+			 * This is "/../" or "/..\0".  We need to back up
+			 * our destination pointer until we find a "/".
+			 */
+			i--;
+			while (j != 0 && dest[--j] != '/')
+				continue;
+
+			if (c == '\0')
+				dest[++j] = '/';
+		} while (c != '\0');
+
+		dest[j] = '\0';
+		regs[rd] = (uintptr_t)dest;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_LINK_NTOP: {
+		struct dtrace_hwtype_alen {
+			int hwtype;
+			size_t hwalen;
+		} hwinfo[] = {
+			{ ARPHRD_ETHER, ETH_ALEN },
+			{ ARPHRD_INFINIBAND, INFINIBAND_ALEN },
+			{ -1, 0 }
+		};
+/*
+ * Captures the maximum hardware address length among all the supported
+ * hardware types. Please update this macro when adding a new hardware type.
+ */
+#define DTRACE_MAX_HWTYPE_ALEN (ETH_ALEN > INFINIBAND_ALEN ? \
+				ETH_ALEN : INFINIBAND_ALEN)
+		uintptr_t src = tupregs[1].dttk_value;
+		int type = tupregs[0].dttk_value;
+		uint8_t hwaddr[DTRACE_MAX_HWTYPE_ALEN];
+		char *base;
+		size_t size, len;
+		int i;
+
+		for (i = 0; hwinfo[i].hwtype != -1; i++) {
+			if (type == hwinfo[i].hwtype)
+				break;
+		}
+		if (hwinfo[i].hwtype == -1) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			regs[rd] = 0;
+			break;
+		}
+		len = hwinfo[i].hwalen;
+
+		/*
+		 * Safely load the hardware address.
+		 */
+		if (!dtrace_canload(src, len, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+		dtrace_bcopy((void *)src, hwaddr, len);
+
+		/*
+		 * Check if a hardware address string will fit in scratch.
+		 * For every byte we need 3 characters (including ':').
+		 */
+		size = len * 3;
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+		base = (char *)mstate->dtms_scratch_ptr;
+
+		/*
+		 * Build the Hardware address string by working through the
+		 * address from the beginning. Given a hardware address
+		 * {0xa0, 0xaa, 0xff, 0xc, 0, 1, 2} of length 6, it will build
+		 * a0:aa:ff:0c:00:01:02.
+		 */
+		for (i = 0; i < len; i++) {
+			if (hwaddr[i] < 16) {
+				*base++ = '0';
+				*base++ = dtrace_hexdigits[hwaddr[i]];
+			} else {
+				*base++ = dtrace_hexdigits[hwaddr[i] / 16];
+				*base++ = dtrace_hexdigits[hwaddr[i] % 16];
+			}
+
+			if (i < len - 1)
+				*base++ = ':';
+		}
+		*base++ = '\0';
+		regs[rd] = mstate->dtms_scratch_ptr;
+		mstate->dtms_scratch_ptr += size;
+#undef DTRACE_MAX_HWTYPE_ALEN
+		break;
+	}
+
+	case DIF_SUBR_INET_NTOA:
+	case DIF_SUBR_INET_NTOA6:
+	case DIF_SUBR_INET_NTOP: {
+		uintptr_t src;
+		size_t	size;
+		int	af, argi, i;
+		char	*base, *end;
+
+		if (subr == DIF_SUBR_INET_NTOP) {
+			af = (int)tupregs[0].dttk_value;
+			argi = 1;
+		} else {
+			af = subr == DIF_SUBR_INET_NTOA ? AF_INET: AF_INET6;
+			argi = 0;
+		}
+
+		src = tupregs[argi].dttk_value;
+		if (af == AF_INET) {
+			ipaddr_t	ip4;
+			ipaddr_t_p	ptr4;
+			uint8_t		*ptr8, val;
+
+			/*
+			 * Safely load the IPv4 address.
+			 */
+			if (!dtrace_canload(src, 4, mstate, vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+			ip4 = dtrace_load32(src);
+
+			/*
+			 * Check an IPv4 string will fit in scratch.
+			 */
+			size = INET_ADDRSTRLEN;
+			if (!DTRACE_INSCRATCH(mstate, size)) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+			base = (char *)mstate->dtms_scratch_ptr;
+			end = (char *)mstate->dtms_scratch_ptr + size - 1;
+
+			/*
+			 * Stringify as a dotted decimal quad.
+			 */
+			*end-- = '\0';
+			ptr4 = &ip4;
+			ptr8 = (uint8_t *)ptr4;
+			for (i = 3; i >= 0; i--) {
+				val = ptr8[i];
+
+				if (val == 0) {
+					*end-- = '0';
+				} else {
+					for (; val; val /= 10) {
+						*end-- = '0' + (val % 10);
+					}
+				}
+
+				if (i > 0)
+					*end-- = '.';
+			}
+			ASSERT(end + 1 >= base);
+#if IS_ENABLED(CONFIG_IPV6)
+		} else if (af == AF_INET6) {
+			in6_addr_t	ip6;
+			int		firstzero, tryzero, numzero, v6end;
+			uint16_t	val;
+
+			/*
+			 * Stringify using RFC 1884 convention 2 - 16 bit
+			 * hexadecimal values with a zero-run compression.
+			 * Lower case hexadecimal digits are used.
+			 * 	eg, fe80::214:4fff:fe0b:76c8.
+			 * The IPv4 embedded form is returned for inet_ntop,
+			 * just the IPv4 string is returned for inet_ntoa6.
+			 */
+
+			/*
+			 * Safely load the IPv6 address.
+			 */
+			if (!dtrace_canload(src, sizeof(in6_addr_t), mstate,
+					    vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+			dtrace_bcopy((void *)src, (void *)(uintptr_t)&ip6,
+				     sizeof(in6_addr_t));
+
+			/*
+			 * Check an IPv6 string will fit in scratch.
+			 */
+			size = INET6_ADDRSTRLEN;
+			if (!DTRACE_INSCRATCH(mstate, size)) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+			base = (char *)mstate->dtms_scratch_ptr;
+			end = (char *)mstate->dtms_scratch_ptr + size - 1;
+			*end-- = '\0';
+
+			/*
+			 * Find the longest run of 16 bit zero values
+			 * for the single allowed zero compression - "::".
+			 */
+			firstzero = -1;
+			tryzero = -1;
+			numzero = 1;
+			for (i = 0; i < sizeof(in6_addr_t); i++) {
+				if (ip6.s6_addr[i] == 0 &&
+				    tryzero == -1 && i % 2 == 0) {
+					tryzero = i;
+					continue;
+				}
+
+				if (tryzero != -1 &&
+				    (ip6.s6_addr[i] != 0 ||
+				    i == sizeof(in6_addr_t) - 1)) {
+
+					if (i - tryzero <= numzero) {
+						tryzero = -1;
+						continue;
+					}
+
+					firstzero = tryzero;
+					numzero = i - i % 2 - tryzero;
+					tryzero = -1;
+
+					if (ip6.s6_addr[i] == 0 &&
+					    i == sizeof(in6_addr_t) - 1)
+						numzero += 2;
+				}
+			}
+			ASSERT(firstzero + numzero <= sizeof(in6_addr_t));
+
+			/*
+			 * Check for an IPv4 embedded address.
+			 */
+			v6end = sizeof(in6_addr_t) - 2;
+			if (ipv6_addr_type(&ip6) &
+			    (IPV6_ADDR_COMPATv4 | IPV6_ADDR_MAPPED)) {
+				for (i = sizeof(in6_addr_t) - 1;
+				    i >= DTRACE_V4MAPPED_OFFSET; i--) {
+					ASSERT(end >= base);
+
+					val = ip6.s6_addr[i];
+
+					if (val == 0) {
+						*end-- = '0';
+					} else {
+						for (; val; val /= 10) {
+							*end-- = '0' + val % 10;
+						}
+					}
+
+					if (i > DTRACE_V4MAPPED_OFFSET)
+						*end-- = '.';
+				}
+
+				if (subr == DIF_SUBR_INET_NTOA6)
+					goto inetout;
+
+				/*
+				 * Set v6end to skip the IPv4 address that
+				 * we have already stringified.
+				 */
+				v6end = 10;
+			}
+
+			/*
+			 * Build the IPv6 string by working through the
+			 * address in reverse.
+			 */
+			for (i = v6end; i >= 0; i -= 2) {
+				ASSERT(end >= base);
+
+				if (i == firstzero + numzero - 2) {
+					*end-- = ':';
+					*end-- = ':';
+					i -= numzero - 2;
+					continue;
+				}
+
+				if (i < 14 && i != firstzero - 2)
+					*end-- = ':';
+
+				val = (ip6.s6_addr[i] << 8) +
+				    ip6.s6_addr[i + 1];
+
+				if (val == 0) {
+					*end-- = '0';
+				} else {
+					for (; val; val /= 16) {
+						*end-- = \
+						    dtrace_hexdigits[val % 16];
+					}
+				}
+			}
+			ASSERT(end + 1 >= base);
+#endif
+		} else {
+			/*
+			 * The user didn't use AH_INET or AH_INET6.
+			 */
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			regs[rd] = 0;
+			break;
+		}
+
+#if IS_ENABLED(CONFIG_IPV6)
+inetout:
+#endif
+		regs[rd] = (uintptr_t)end + 1;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_D_PATH: {
+		struct path	*path = (struct path *)tupregs[0].dttk_value;
+		char		*dest = (char *)mstate->dtms_scratch_ptr;
+		char		*ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		unsigned int	fd;
+		struct files_struct
+				*files = current->files;
+		struct fdtable	*fdt;
+
+		if (!dtrace_canload((uintptr_t)path, sizeof(struct path),
+				    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (spin_is_locked(&files->file_lock) ||
+		    !spin_trylock(&files->file_lock)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		fdt = files->fdt;
+
+		/*
+		 * We (currently) limit the d_path() subroutine to paths that
+		 * relate to open files in the current task.
+		 */
+		for (fd = 0; fd < fdt->max_fds; fd++) {
+			if (fdt->fd[fd] && &fdt->fd[fd]->f_path == path)
+				break;
+		}
+
+		spin_unlock(&files->file_lock);
+
+		if (fd >= fdt->max_fds) {
+			*flags |= CPU_DTRACE_BADADDR;
+			*illval = (uintptr_t)path;
+			regs[rd] = 0;
+			break;
+		}
+
+		ptr = d_path(path, dest, size);
+		if (ptr < 0) {
+			regs[rd] = 0;
+			break;
+		}
+
+		regs[rd] = (uintptr_t)ptr;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	}
+}
+
+/*
+ * Emulate the execution of DTrace IR instructions specified by the given DIF
+ * object.  This function is deliberately void fo assertions as all of the
+ * necessary checks are handled by a call to dtrace_difo_validate().
+ */
+uint64_t dtrace_dif_emulate(dtrace_difo_t *difo, dtrace_mstate_t *mstate,
+			    dtrace_vstate_t *vstate, dtrace_state_t *state)
+{
+	const dif_instr_t	*text = difo->dtdo_buf;
+	const uint_t		textlen = difo->dtdo_len;
+	const char		*strtab = difo->dtdo_strtab;
+	const uint64_t		*inttab = difo->dtdo_inttab;
+
+	uint64_t		rval = 0;
+	dtrace_statvar_t	*svar;
+	dtrace_dstate_t		*dstate = &vstate->dtvs_dynvars;
+	dtrace_difv_t		*v;
+	volatile uint16_t	*flags = &this_cpu_core->cpuc_dtrace_flags;
+	volatile uintptr_t	*illval = &this_cpu_core->cpuc_dtrace_illval;
+
+	dtrace_key_t		tupregs[DIF_DTR_NREGS + 2];
+						/* +2 for thread and id */
+	uint64_t		regs[DIF_DIR_NREGS];
+	uint64_t		*tmp;
+
+	uint8_t			cc_n = 0, cc_z = 0, cc_v = 0, cc_c = 0;
+	int64_t			cc_r;
+	uint_t			pc = 0, id, opc = 0;
+	uint8_t			ttop = 0;
+	dif_instr_t		instr;
+	uint_t			r1, r2, rd;
+
+	dt_dbg_dif("    DIF %p emulation (text %p, %d instructions)...\n",
+		   difo, text, textlen);
+
+	/*
+	 * We stash the current DIF object into the machine state: we need it
+	 * for subsequent access checking.
+	 */
+	mstate->dtms_difo = difo;
+
+	regs[DIF_REG_R0] = 0;			/* %r0 is fixed at zero */
+
+	while (pc < textlen && !(*flags & CPU_DTRACE_FAULT)) {
+		opc = pc;
+
+		instr = text[pc++];
+		r1 = DIF_INSTR_R1(instr);
+		r2 = DIF_INSTR_R2(instr);
+		rd = DIF_INSTR_RD(instr);
+
+		dt_dbg_dif("      Executing opcode %02x (%02x, %02x, %02x)\n",
+			   DIF_INSTR_OP(instr), r1, r2, rd);
+
+		switch (DIF_INSTR_OP(instr)) {
+		case DIF_OP_OR:
+			regs[rd] = regs[r1] | regs[r2];
+			break;
+		case DIF_OP_XOR:
+			regs[rd] = regs[r1] ^ regs[r2];
+			break;
+		case DIF_OP_AND:
+			regs[rd] = regs[r1] & regs[r2];
+			break;
+		case DIF_OP_SLL:
+			regs[rd] = regs[r1] << regs[r2];
+			break;
+		case DIF_OP_SRL:
+			regs[rd] = regs[r1] >> regs[r2];
+			break;
+		case DIF_OP_SUB:
+			regs[rd] = regs[r1] - regs[r2];
+			break;
+		case DIF_OP_ADD:
+			regs[rd] = regs[r1] + regs[r2];
+			break;
+		case DIF_OP_MUL:
+			regs[rd] = regs[r1] * regs[r2];
+			break;
+		case DIF_OP_SDIV:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				int	neg = 0;
+
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = (int64_t)regs[r1] /
+				 *	      (int64_t)regs[r2];
+				 */
+				if ((int64_t)regs[r1] < 0) {
+					neg = !neg;
+					regs[r1] = -(int64_t)regs[r1];
+				}
+				if ((int64_t)regs[r2] < 0) {
+					neg = !neg;
+					regs[r2] = -(int64_t)regs[r2];
+				}
+				regs[rd] = regs[r1];
+				do_div(regs[rd], regs[r2]);
+
+				if (neg)
+					regs[rd] = -(int64_t)regs[rd];
+			}
+			break;
+
+		case DIF_OP_UDIV:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = regs[r1] / regs[r2];
+				 */
+				regs[rd] = regs[r1];
+				do_div(regs[rd], regs[r2]);
+			}
+			break;
+
+		case DIF_OP_SREM:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				int	neg = 0;
+
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = (int64_t)regs[r1] %
+				 *	      (int64_t)regs[r2];
+				 */
+				if ((int64_t)regs[r1] < 0) {
+					neg = !neg;
+					regs[r1] = -(int64_t)regs[r1];
+				}
+				if ((int64_t)regs[r2] < 0) {
+					neg = !neg;
+					regs[r2] = -(int64_t)regs[r2];
+				}
+				regs[rd] = regs[r1];
+				regs[rd] = do_div(regs[rd], regs[r2]);
+
+				if (neg)
+					regs[rd] = -(int64_t)regs[rd];
+			}
+			break;
+
+		case DIF_OP_UREM:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = regs[r1] % regs[r2];
+				 */
+				regs[rd] = regs[r1];
+				regs[rd] = do_div(regs[rd], regs[r2]);
+			}
+			break;
+
+		case DIF_OP_NOT:
+			regs[rd] = ~regs[r1];
+			break;
+		case DIF_OP_MOV:
+			regs[rd] = regs[r1];
+			break;
+		case DIF_OP_CMP:
+			cc_r = regs[r1] - regs[r2];
+			cc_n = cc_r < 0;
+			cc_z = cc_r == 0;
+			cc_v = 0;
+			cc_c = regs[r1] < regs[r2];
+			break;
+		case DIF_OP_TST:
+			cc_n = cc_v = cc_c = 0;
+			cc_z = regs[r1] == 0;
+			break;
+		case DIF_OP_BA:
+			pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BE:
+			if (cc_z)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BNE:
+			if (cc_z == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BG:
+			if ((cc_z | (cc_n ^ cc_v)) == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BGU:
+			if ((cc_c | cc_z) == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BGE:
+			if ((cc_n ^ cc_v) == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BGEU:
+			if (cc_c == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BL:
+			if (cc_n ^ cc_v)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BLU:
+			if (cc_c)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BLE:
+			if (cc_z | (cc_n ^ cc_v))
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BLEU:
+			if (cc_c | cc_z)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_RLDSB:
+#ifdef FIXME_OPENSOLARIS_BUG
+			if (!dtrace_canstore(regs[r1], 1, mstate, vstate)) {
+#else
+			if (!dtrace_canload(regs[r1], 1, mstate, vstate)) {
+#endif
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDSB:
+			regs[rd] = (int8_t)dtrace_load8(regs[r1]);
+			break;
+		case DIF_OP_RLDSH:
+			if (!dtrace_canstore(regs[r1], 2, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDSH:
+			regs[rd] = (int16_t)dtrace_load16(regs[r1]);
+			break;
+		case DIF_OP_RLDSW:
+			if (!dtrace_canstore(regs[r1], 4, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDSW:
+			regs[rd] = (int32_t)dtrace_load32(regs[r1]);
+			break;
+		case DIF_OP_RLDUB:
+			if (!dtrace_canstore(regs[r1], 1, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDUB:
+			regs[rd] = dtrace_load8(regs[r1]);
+			break;
+		case DIF_OP_RLDUH:
+			if (!dtrace_canstore(regs[r1], 2, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDUH:
+			regs[rd] = dtrace_load16(regs[r1]);
+			break;
+		case DIF_OP_RLDUW:
+			if (!dtrace_canstore(regs[r1], 4, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDUW:
+			regs[rd] = dtrace_load32(regs[r1]);
+			break;
+		case DIF_OP_RLDX:
+			if (!dtrace_canstore(regs[r1], 8, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDX:
+			regs[rd] = dtrace_load64(regs[r1]);
+			break;
+		case DIF_OP_ULDSB:
+			regs[rd] = (int8_t)dtrace_fuword8(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDSH:
+			regs[rd] = (int16_t)dtrace_fuword16(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDSW:
+			regs[rd] = (int32_t)dtrace_fuword32(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDUB:
+			regs[rd] = dtrace_fuword8((void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDUH:
+			regs[rd] = dtrace_fuword16(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDUW:
+			regs[rd] = dtrace_fuword32(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDX:
+			regs[rd] = dtrace_fuword64(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_RET:
+			rval = regs[rd];
+			pc = textlen;
+			break;
+		case DIF_OP_NOP:
+			break;
+		case DIF_OP_SETX:
+			regs[rd] = inttab[DIF_INSTR_INTEGER(instr)];
+			break;
+		case DIF_OP_SETS:
+			regs[rd] = (uint64_t)(uintptr_t)
+					(strtab + DIF_INSTR_STRING(instr));
+			break;
+		case DIF_OP_SCMP: {
+			size_t		sz = state->dts_options[
+							DTRACEOPT_STRSIZE];
+			uintptr_t	s1 = regs[r1];
+			uintptr_t	s2 = regs[r2];
+
+			if (s1 != (uintptr_t)NULL &&
+			    !dtrace_strcanload(s1, sz, mstate, vstate))
+				break;
+			if (s2 != (uintptr_t)NULL &&
+			    !dtrace_strcanload(s2, sz, mstate, vstate))
+				break;
+
+			cc_r = dtrace_strncmp((char *)s1, (char *)s2, sz);
+
+			cc_n = cc_r < 0;
+			cc_z = cc_r == 0;
+			cc_v = cc_c = 0;
+			break;
+		}
+		case DIF_OP_LDGA:
+		    regs[rd] = dtrace_dif_variable(mstate, state, r1,
+						   regs[r2]);
+			break;
+		case DIF_OP_LDGS:
+			id = DIF_INSTR_VAR(instr);
+
+			if (id >= DIF_VAR_OTHER_UBASE) {
+				uintptr_t	a;
+
+				id -= DIF_VAR_OTHER_UBASE;
+				svar = vstate->dtvs_globals[id];
+				ASSERT(svar != NULL);
+				v = &svar->dtsv_var;
+
+				if (!(v->dtdv_type.dtdt_flags & DIF_TF_BYREF)) {
+					regs[rd] = svar->dtsv_data;
+					break;
+				}
+
+				a = (uintptr_t)svar->dtsv_data;
+
+				/*
+				 * If the 0th byte is set to UINT8_MAX then
+				 * this is to be treated as a reference to a
+				 * NULL variable.
+				 */
+				if (*(uint8_t *)a == UINT8_MAX)
+					regs[rd] = 0;
+				else
+					regs[rd] = a + sizeof(uint64_t);
+
+				break;
+			}
+
+			regs[rd] = dtrace_dif_variable(mstate, state, id, 0);
+			break;
+
+		case DIF_OP_STGS:
+			id = DIF_INSTR_VAR(instr);
+
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			svar = vstate->dtvs_globals[id];
+			ASSERT(svar != NULL);
+			v = &svar->dtsv_var;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	a = (uintptr_t)svar->dtsv_data;
+
+				ASSERT(a != 0);
+				ASSERT(svar->dtsv_size != 0);
+
+				if (regs[rd] == 0) {
+					*(uint8_t *)a = UINT8_MAX;
+					break;
+				} else {
+					*(uint8_t *)a = 0;
+					a += sizeof(uint64_t);
+				}
+
+				if (!dtrace_vcanload(
+					(void *)(uintptr_t)regs[rd],
+					&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     (void *)a, &v->dtdv_type);
+				break;
+			}
+
+			svar->dtsv_data = regs[rd];
+			break;
+
+		case DIF_OP_LDTA:
+			/*
+			 * There are no DTrace built-in thread-local arrays at
+			 * present.  This opcode is saved for future work.
+			 */
+			*flags |= CPU_DTRACE_ILLOP;
+			regs[rd] = 0;
+			break;
+
+		case DIF_OP_LDLS:
+			id = DIF_INSTR_VAR(instr);
+
+			if (id < DIF_VAR_OTHER_UBASE) {
+				/*
+				 * For now, this has no meaning.
+				 */
+				regs[rd] = 0;
+				break;
+			}
+
+			id -= DIF_VAR_OTHER_UBASE;
+
+			ASSERT(id < vstate->dtvs_nlocals);
+			ASSERT(vstate->dtvs_locals != NULL);
+
+			svar = vstate->dtvs_locals[id];
+			ASSERT(svar != NULL);
+			v = &svar->dtsv_var;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	a = (uintptr_t)svar->dtsv_data;
+				size_t		sz = v->dtdv_type.dtdt_size;
+
+				sz += sizeof(uint64_t);
+				ASSERT(svar->dtsv_size == NR_CPUS * sz);
+				a += smp_processor_id() * sz;
+
+				if (*(uint8_t *)a == UINT8_MAX) {
+					/*
+					 * If the 0th byte is set to UINT8_MAX
+					 * then this is to be treated as a
+					 * reference to a NULL variable.
+					 */
+					regs[rd] = 0;
+				} else
+					regs[rd] = a + sizeof(uint64_t);
+
+				break;
+			}
+
+			ASSERT(svar->dtsv_size == NR_CPUS * sizeof(uint64_t));
+			tmp = (uint64_t *)(uintptr_t)svar->dtsv_data;
+			regs[rd] = tmp[smp_processor_id()];
+			break;
+
+		case DIF_OP_STLS:
+			id = DIF_INSTR_VAR(instr);
+
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+			ASSERT(id < vstate->dtvs_nlocals);
+
+			ASSERT(vstate->dtvs_locals != NULL);
+			svar = vstate->dtvs_locals[id];
+			ASSERT(svar != NULL);
+			v = &svar->dtsv_var;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	a = (uintptr_t)svar->dtsv_data;
+				size_t		sz = v->dtdv_type.dtdt_size;
+
+				sz += sizeof(uint64_t);
+				ASSERT(svar->dtsv_size == NR_CPUS * sz);
+				a += smp_processor_id() * sz;
+
+				if (regs[rd] == 0) {
+					*(uint8_t *)a = UINT8_MAX;
+					break;
+				} else {
+					*(uint8_t *)a = 0;
+					a += sizeof(uint64_t);
+				}
+
+				if (!dtrace_vcanload(
+						(void *)(uintptr_t)regs[rd],
+						&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     (void *)a, &v->dtdv_type);
+				break;
+			}
+
+			ASSERT(svar->dtsv_size == NR_CPUS * sizeof(uint64_t));
+			tmp = (uint64_t *)(uintptr_t)svar->dtsv_data;
+			tmp[smp_processor_id()] = regs[rd];
+			break;
+
+		case DIF_OP_LDTS: {
+			dtrace_dynvar_t	*dvar;
+			dtrace_key_t	*key;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+			v = &vstate->dtvs_tlocals[id];
+
+			key = &tupregs[DIF_DTR_NREGS];
+			key[0].dttk_value = (uint64_t)id;
+			key[0].dttk_size = 0;
+			DTRACE_TLS_THRKEY(key[1].dttk_value);
+			key[1].dttk_size = 0;
+
+			dvar = dtrace_dynvar(dstate, 2, key, sizeof(uint64_t),
+					     DTRACE_DYNVAR_NOALLOC, mstate,
+					     vstate);
+
+			if (dvar == NULL) {
+				regs[rd] = 0;
+				break;
+			}
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				regs[rd] = (uint64_t)(uintptr_t)dvar->dtdv_data;
+			else
+				regs[rd] = *((uint64_t *)dvar->dtdv_data);
+
+			break;
+		}
+
+		case DIF_OP_STTS: {
+			dtrace_dynvar_t	*dvar;
+			dtrace_key_t	*key;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			key = &tupregs[DIF_DTR_NREGS];
+			key[0].dttk_value = (uint64_t)id;
+			key[0].dttk_size = 0;
+			DTRACE_TLS_THRKEY(key[1].dttk_value);
+			key[1].dttk_size = 0;
+			v = &vstate->dtvs_tlocals[id];
+
+			dvar = dtrace_dynvar(dstate, 2, key,
+				v->dtdv_type.dtdt_size > sizeof(uint64_t)
+					?  v->dtdv_type.dtdt_size
+					: sizeof(uint64_t),
+				regs[rd]
+					? DTRACE_DYNVAR_ALLOC
+					: DTRACE_DYNVAR_DEALLOC,
+				mstate, vstate);
+
+			/*
+			 * Given that we're storing to thread-local data,
+			 * we need to flush our predicate cache.
+			 */
+			current->predcache = 0;
+
+			if (dvar == NULL)
+				break;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				if (!dtrace_vcanload(
+						(void *)(uintptr_t)regs[rd],
+						&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     dvar->dtdv_data, &v->dtdv_type);
+			} else
+				*((uint64_t *)dvar->dtdv_data) = regs[rd];
+
+			break;
+		}
+
+		case DIF_OP_SRA:
+			regs[rd] = (int64_t)regs[r1] >> regs[r2];
+			break;
+
+		case DIF_OP_CALL:
+			dtrace_dif_subr(DIF_INSTR_SUBR(instr), rd, regs,
+					tupregs, ttop, mstate, state);
+			break;
+
+		case DIF_OP_PUSHTR:
+			if (ttop == DIF_DTR_NREGS) {
+				*flags |= CPU_DTRACE_TUPOFLOW;
+				break;
+			}
+
+			if (r1 == DIF_TYPE_STRING)
+				/*
+				 * If this is a string type and the size is 0,
+				 * we'll use the system-wide default string
+				 * size.  Note that we are _not_ looking at
+				 * the value of the DTRACEOPT_STRSIZE option;
+				 * had this been set, we would expect to have
+				 * a non-zero size value in the "pushtr".
+				 */
+				tupregs[ttop].dttk_size =
+					dtrace_strlen(
+						(char *)(uintptr_t)regs[rd],
+						regs[r2]
+						    ? regs[r2]
+						    : dtrace_strsize_default
+					) + 1;
+			else
+				tupregs[ttop].dttk_size = regs[r2];
+
+			tupregs[ttop++].dttk_value = regs[rd];
+			break;
+
+		case DIF_OP_PUSHTV:
+			if (ttop == DIF_DTR_NREGS) {
+				*flags |= CPU_DTRACE_TUPOFLOW;
+				break;
+			}
+
+			tupregs[ttop].dttk_value = regs[rd];
+			tupregs[ttop++].dttk_size = 0;
+			break;
+
+		case DIF_OP_POPTS:
+			if (ttop != 0)
+				ttop--;
+			break;
+
+		case DIF_OP_FLUSHTS:
+			ttop = 0;
+			break;
+
+		case DIF_OP_LDGAA:
+		case DIF_OP_LDTAA: {
+			dtrace_dynvar_t	*dvar;
+			dtrace_key_t	*key = tupregs;
+			uint_t		nkeys = ttop;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			key[nkeys].dttk_value = (uint64_t)id;
+			key[nkeys++].dttk_size = 0;
+
+			if (DIF_INSTR_OP(instr) == DIF_OP_LDTAA) {
+				DTRACE_TLS_THRKEY(key[nkeys].dttk_value);
+				key[nkeys++].dttk_size = 0;
+				v = &vstate->dtvs_tlocals[id];
+			} else
+				v = &vstate->dtvs_globals[id]->dtsv_var;
+
+			dvar = dtrace_dynvar(dstate, nkeys, key,
+			v->dtdv_type.dtdt_size > sizeof(uint64_t) ?
+			v->dtdv_type.dtdt_size : sizeof(uint64_t),
+			DTRACE_DYNVAR_NOALLOC, mstate, vstate);
+
+			if (dvar == NULL) {
+				regs[rd] = 0;
+				break;
+			}
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				regs[rd] = (uint64_t)(uintptr_t)dvar->dtdv_data;
+			else
+				regs[rd] = *((uint64_t *)dvar->dtdv_data);
+
+			break;
+		}
+
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA: {
+			dtrace_dynvar_t	*dvar;
+			dtrace_key_t	*key = tupregs;
+			uint_t		nkeys = ttop;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			key[nkeys].dttk_value = (uint64_t)id;
+			key[nkeys++].dttk_size = 0;
+
+			if (DIF_INSTR_OP(instr) == DIF_OP_STTAA) {
+				DTRACE_TLS_THRKEY(key[nkeys].dttk_value);
+				key[nkeys++].dttk_size = 0;
+				v = &vstate->dtvs_tlocals[id];
+			} else
+				v = &vstate->dtvs_globals[id]->dtsv_var;
+
+			dvar = dtrace_dynvar(dstate, nkeys, key,
+				v->dtdv_type.dtdt_size > sizeof(uint64_t)
+					?  v->dtdv_type.dtdt_size
+					: sizeof(uint64_t),
+				regs[rd] ? DTRACE_DYNVAR_ALLOC
+					 : DTRACE_DYNVAR_DEALLOC,
+				mstate, vstate);
+
+			if (dvar == NULL)
+				break;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				if (!dtrace_vcanload(
+						(void *)(uintptr_t)regs[rd],
+						&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     dvar->dtdv_data, &v->dtdv_type);
+			} else
+				*((uint64_t *)dvar->dtdv_data) = regs[rd];
+
+			break;
+		}
+
+		case DIF_OP_ALLOCS: {
+			uintptr_t	ptr =
+					P2ROUNDUP(mstate->dtms_scratch_ptr, 8);
+			size_t		size = ptr - mstate->dtms_scratch_ptr +
+					       regs[r1];
+
+			/*
+			 * Rounding up the user allocation size could have
+			 * overflowed large, bogus allocations (like -1ULL) to
+			 * 0.
+			 */
+			if (size < regs[r1] ||
+			    !DTRACE_INSCRATCH(mstate, size)) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+
+			dtrace_bzero((void *) mstate->dtms_scratch_ptr, size);
+			mstate->dtms_scratch_ptr += size;
+			regs[rd] = ptr;
+			break;
+		}
+
+		case DIF_OP_COPYS:
+			if (!dtrace_canstore(regs[rd], regs[r2], mstate,
+					     vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (!dtrace_canload(regs[r1], regs[r2], mstate, vstate))
+				break;
+
+			dtrace_bcopy((void *)(uintptr_t)regs[r1],
+				     (void *)(uintptr_t)regs[rd],
+				     (size_t)regs[r2]);
+			break;
+
+		case DIF_OP_STB:
+			if (!dtrace_canstore(regs[rd], 1, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint8_t *)(uintptr_t)regs[rd]) = (uint8_t)regs[r1];
+			break;
+
+		case DIF_OP_STH:
+			if (!dtrace_canstore(regs[rd], 2, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (regs[rd] & 1) {
+				*flags |= CPU_DTRACE_BADALIGN;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint16_t *)(uintptr_t)regs[rd]) = (uint16_t)regs[r1];
+			break;
+
+		case DIF_OP_STW:
+			if (!dtrace_canstore(regs[rd], 4, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (regs[rd] & 3) {
+				*flags |= CPU_DTRACE_BADALIGN;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint32_t *)(uintptr_t)regs[rd]) = (uint32_t)regs[r1];
+			break;
+
+		case DIF_OP_STX:
+			if (!dtrace_canstore(regs[rd], 8, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (regs[rd] & 7) {
+				*flags |= CPU_DTRACE_BADALIGN;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint64_t *)(uintptr_t)regs[rd]) = regs[r1];
+			break;
+		}
+	}
+
+
+	if (!(*flags & CPU_DTRACE_FAULT)) {
+		dt_dbg_dif("    DIF %p completed, rval = %llx (flags %x)\n",
+			   difo, rval, *flags);
+		return rval;
+	}
+
+	dt_dbg_dif("    DIF %p emulation failed (flags %x)\n",  difo, *flags);
+
+	mstate->dtms_fltoffs = opc * sizeof(dif_instr_t);
+	mstate->dtms_present |= DTRACE_MSTATE_FLTOFFS;
+
+	return 0;
+}
diff --git a/dtrace/dtrace_dof.c b/dtrace/dtrace_dof.c
new file mode 100644
index 000000000000..365eb1c7d47d
--- /dev/null
+++ b/dtrace/dtrace_dof.c
@@ -0,0 +1,2405 @@
+/*
+ * FILE:	dtrace_dof.c
+ * DESCRIPTION:	DTrace - DOF implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+
+#include "dtrace.h"
+
+size_t			dtrace_difo_maxsize = 256 * 1024;
+dtrace_optval_t		dtrace_dof_maxsize = 256 * 1024;
+size_t			dtrace_actions_max = 16 * 1024;
+dtrace_optval_t		dtrace_helper_actions_max = 32;
+dtrace_optval_t		dtrace_helper_providers_max = 32;
+
+static int		dtrace_helpers;
+
+static uint32_t		dtrace_helptrace_next = 0;
+static uint32_t		dtrace_helptrace_nlocals;
+
+#ifdef CONFIG_DT_DEBUG
+int			dtrace_helptrace_enabled = 1;
+#else
+int			dtrace_helptrace_enabled = 0;
+#endif
+int			dtrace_helptrace_bufsize = 512 * 1024;
+char			*dtrace_helptrace_buffer;
+
+void dtrace_dof_error(dof_hdr_t *dof, const char *str)
+{
+	if (dtrace_err_verbose)
+		pr_warning("failed to process DOF: %s", str);
+	else
+		dt_dbg_dof("Failed to process DOF: %s\n", str);
+
+#ifdef DTRACE_ERRDEBUG
+	dtrace_errdebug(str);
+#endif
+}
+
+/*
+ * Create DOF out of a currently enabled state.  Right now, we only create
+ * DOF containing the run-time options -- but this could be expanded to create
+ * complete DOF representing the enabled state.
+ */
+dof_hdr_t *dtrace_dof_create(dtrace_state_t *state)
+{
+	dof_hdr_t	*dof;
+	dof_sec_t	*sec;
+	dof_optdesc_t	*opt;
+	int		i, len = sizeof(dof_hdr_t) +
+				 roundup(sizeof(dof_sec_t), sizeof(uint64_t)) +
+				 sizeof(dof_optdesc_t) * DTRACEOPT_MAX;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	dof = vmalloc(len);
+	if (dof == NULL)
+		return NULL;
+
+	dof->dofh_ident[DOF_ID_MAG0] = DOF_MAG_MAG0;
+	dof->dofh_ident[DOF_ID_MAG1] = DOF_MAG_MAG1;
+	dof->dofh_ident[DOF_ID_MAG2] = DOF_MAG_MAG2;
+	dof->dofh_ident[DOF_ID_MAG3] = DOF_MAG_MAG3;
+
+	dof->dofh_ident[DOF_ID_MODEL] = DOF_MODEL_NATIVE;
+	dof->dofh_ident[DOF_ID_ENCODING] = DOF_ENCODE_NATIVE;
+	dof->dofh_ident[DOF_ID_VERSION] = DOF_VERSION;
+	dof->dofh_ident[DOF_ID_DIFVERS] = DIF_VERSION;
+	dof->dofh_ident[DOF_ID_DIFIREG] = DIF_DIR_NREGS;
+	dof->dofh_ident[DOF_ID_DIFTREG] = DIF_DTR_NREGS;
+
+	dof->dofh_flags = 0;
+	dof->dofh_hdrsize = sizeof(dof_hdr_t);
+	dof->dofh_secsize = sizeof(dof_sec_t);
+	dof->dofh_secnum = 1;   /* only DOF_SECT_OPTDESC */
+	dof->dofh_secoff = sizeof(dof_hdr_t);
+	dof->dofh_loadsz = len;
+	dof->dofh_filesz = len;
+	dof->dofh_pad = 0;
+
+	/*
+	 * Fill in the option section header...
+	 */
+	sec = (dof_sec_t *)((uintptr_t)dof + sizeof(dof_hdr_t));
+	sec->dofs_type = DOF_SECT_OPTDESC;
+	sec->dofs_align = sizeof(uint64_t);
+	sec->dofs_flags = DOF_SECF_LOAD;
+	sec->dofs_entsize = sizeof(dof_optdesc_t);
+
+	opt = (dof_optdesc_t *)((uintptr_t)sec +
+				roundup(sizeof(dof_sec_t), sizeof(uint64_t)));
+
+	sec->dofs_offset = (uintptr_t)opt - (uintptr_t)dof;
+	sec->dofs_size = sizeof(dof_optdesc_t) * DTRACEOPT_MAX;
+
+	for (i = 0; i < DTRACEOPT_MAX; i++) {
+		opt[i].dofo_option = i;
+		opt[i].dofo_strtab = DOF_SECIDX_NONE;
+		opt[i].dofo_value = state->dts_options[i];
+	}
+
+	return dof;
+}
+
+dof_hdr_t *dtrace_dof_copyin(void __user *argp, int *errp)
+{
+	dof_hdr_t	hdr, *dof;
+
+	ASSERT(!MUTEX_HELD(&dtrace_lock));
+
+	/*
+	 * First, we're going to copyin() the sizeof(dof_hdr_t).
+	 */
+	if (copy_from_user(&hdr, argp, sizeof(hdr)) != 0) {
+		dtrace_dof_error(NULL, "failed to copyin DOF header");
+		*errp = -EFAULT;
+		return NULL;
+	}
+
+	/*
+	 * Now we'll allocate the entire DOF and copy it in -- provided
+	 * that the length isn't outrageous.
+	 */
+	if (hdr.dofh_loadsz >= dtrace_dof_maxsize) {
+		dtrace_dof_error(&hdr, "load size exceeds maximum");
+		*errp = -E2BIG;
+		return NULL;
+	}
+
+	if (hdr.dofh_loadsz < sizeof(hdr)) {
+		dtrace_dof_error(&hdr, "invalid load size");
+		*errp = -EINVAL;
+		return NULL;
+	}
+
+	dof = vmalloc(hdr.dofh_loadsz);
+	if (dof == NULL) {
+		*errp = -ENOMEM;
+		return NULL;
+	}
+
+	if (copy_from_user(dof, argp, hdr.dofh_loadsz) != 0 ||
+		dof->dofh_loadsz != hdr.dofh_loadsz) {
+		vfree(dof);
+		*errp = -EFAULT;
+		return NULL;
+	}
+
+	return dof;
+}
+
+dof_hdr_t *dtrace_dof_property(const char *name)
+{
+	uchar_t		*buf;
+	uint64_t	loadsz;
+	unsigned int	len, i;
+	dof_hdr_t	*dof;
+
+	/*
+	 * Unfortunately, array of values in .conf files are always (and
+	 * only) interpreted to be integer arrays.  We must read our DOF
+	 * as an integer array, and then squeeze it into a byte array.
+	 */
+#ifdef FIXME
+	if (ddi_prop_lookup_int_array(DDI_DEV_T_ANY, dtrace_devi, 0,
+				      (char *)name, (int **)&buf, &len) !=
+	    DDI_PROP_SUCCESS)
+		return NULL;
+#else
+	return NULL;
+#endif
+
+	for (i = 0; i < len; i++)
+		buf[i] = (uchar_t)(((int *)buf)[i]);
+
+	if (len < sizeof(dof_hdr_t)) {
+#ifdef FIXME
+		ddi_prop_free(buf);
+#endif
+		dtrace_dof_error(NULL, "truncated header");
+		return NULL;
+	}
+
+	if (len < (loadsz = ((dof_hdr_t *)buf)->dofh_loadsz)) {
+#ifdef FIXME
+		ddi_prop_free(buf);
+#endif
+		dtrace_dof_error(NULL, "truncated DOF");
+		return NULL;
+	}
+
+	if (loadsz >= dtrace_dof_maxsize) {
+#ifdef FIXME
+		ddi_prop_free(buf);
+#endif
+		dtrace_dof_error(NULL, "oversized DOF");
+		return NULL;
+	}
+
+	dof = vmalloc(loadsz);
+	if (dof == NULL) {
+		dtrace_dof_error(NULL, "out-of-memory");
+		return NULL;
+	}
+	memcpy(dof, buf, loadsz);
+#ifdef FIXME
+	ddi_prop_free(buf);
+#endif
+
+	return dof;
+}
+
+void dtrace_dof_destroy(dof_hdr_t *dof)
+{
+	vfree(dof);
+}
+
+/*
+ * Return the dof_sec_t pointer corresponding to a given section index.  If the
+ * index is not valid, dtrace_dof_error() is called and NULL is returned.  If
+ * a type other than DOF_SECT_NONE is specified, the header is checked against
+ * this type and NULL is returned if the types do not match.
+ */
+static dof_sec_t *dtrace_dof_sect(dof_hdr_t *dof, uint32_t type,
+				  dof_secidx_t i)
+{
+	dof_sec_t	*sec = (dof_sec_t *)(uintptr_t)((uintptr_t)dof +
+							dof->dofh_secoff +
+							i * dof->dofh_secsize);
+
+	if (i >= dof->dofh_secnum) {
+		dtrace_dof_error(dof, "referenced section index is invalid");
+		return NULL;
+	}
+
+	if (!(sec->dofs_flags & DOF_SECF_LOAD)) {
+		dtrace_dof_error(dof, "referenced section is not loadable");
+		return NULL;
+	}
+
+	if (type != DOF_SECT_NONE && type != sec->dofs_type) {
+		dtrace_dof_error(dof, "referenced section is the wrong type");
+		return NULL;
+	}
+
+	return sec;
+}
+
+static dtrace_probedesc_t *dtrace_dof_probedesc(dof_hdr_t *dof, dof_sec_t *sec,
+						dtrace_probedesc_t *desc)
+{
+	dof_probedesc_t	*probe;
+	dof_sec_t	*strtab;
+	uintptr_t	daddr = (uintptr_t)dof;
+	uintptr_t	str;
+	size_t		size;
+
+	if (sec->dofs_type != DOF_SECT_PROBEDESC) {
+		dtrace_dof_error(dof, "invalid probe section");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "bad alignment in probe description");
+		return NULL;
+	}
+
+	if (sec->dofs_offset + sizeof(dof_probedesc_t) > dof->dofh_loadsz) {
+		dtrace_dof_error(dof, "truncated probe description");
+		return NULL;
+	}
+
+	probe = (dof_probedesc_t *)(uintptr_t)(daddr + sec->dofs_offset);
+	strtab = dtrace_dof_sect(dof, DOF_SECT_STRTAB, probe->dofp_strtab);
+
+	if (strtab == NULL)
+		return NULL;
+
+	str = daddr + strtab->dofs_offset;
+	size = strtab->dofs_size;
+
+	if (probe->dofp_provider >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe provider");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_provider, (char *)(str + probe->dofp_provider),
+		min((size_t)DTRACE_PROVNAMELEN - 1,
+		    size - probe->dofp_provider));
+
+	if (probe->dofp_mod >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe module");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_mod, (char *)(str + probe->dofp_mod),
+		min((size_t)DTRACE_MODNAMELEN - 1, size - probe->dofp_mod));
+
+	if (probe->dofp_func >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe function");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_func, (char *)(str + probe->dofp_func),
+		min((size_t)DTRACE_FUNCNAMELEN - 1, size - probe->dofp_func));
+
+	if (probe->dofp_name >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe name");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_name, (char *)(str + probe->dofp_name),
+		min((size_t)DTRACE_NAMELEN - 1, size - probe->dofp_name));
+
+	dt_dbg_dof("      ECB Probe %s:%s:%s:%s\n",
+		   desc->dtpd_provider, desc->dtpd_mod, desc->dtpd_func,
+		   desc->dtpd_name);
+
+	return desc;
+}
+
+static dtrace_difo_t *dtrace_dof_difo(dof_hdr_t *dof, dof_sec_t *sec,
+				      dtrace_vstate_t *vstate,
+				      const cred_t *cr)
+{
+	dtrace_difo_t	*dp;
+	size_t		ttl = 0;
+	dof_difohdr_t	*dofd;
+	uintptr_t	daddr = (uintptr_t)dof;
+	size_t		max = dtrace_difo_maxsize;
+	int		i, l, n;
+
+	static const struct {
+		int section;
+		int bufoffs;
+		int lenoffs;
+		int entsize;
+		int align;
+		const char *msg;
+	} difo[] = {
+		{
+			DOF_SECT_DIF,
+			offsetof(dtrace_difo_t, dtdo_buf),
+			offsetof(dtrace_difo_t, dtdo_len),
+			sizeof(dif_instr_t),
+			sizeof(dif_instr_t),
+			"multiple DIF sections"
+		},
+		{
+			DOF_SECT_INTTAB,
+			offsetof(dtrace_difo_t, dtdo_inttab),
+			offsetof(dtrace_difo_t, dtdo_intlen),
+			sizeof(uint64_t),
+			sizeof(uint64_t),
+			"multiple integer tables"
+		},
+		{
+			DOF_SECT_STRTAB,
+			offsetof(dtrace_difo_t, dtdo_strtab),
+			offsetof(dtrace_difo_t, dtdo_strlen),
+			0,
+			sizeof(char),
+			"multiple string tables"
+		},
+		{
+			DOF_SECT_VARTAB,
+			offsetof(dtrace_difo_t, dtdo_vartab),
+			offsetof(dtrace_difo_t, dtdo_varlen),
+			sizeof(dtrace_difv_t),
+			sizeof(uint_t),
+			"multiple variable tables"
+		},
+		{
+			DOF_SECT_NONE,
+			0,
+			0,
+			0,
+			0,
+			NULL
+		}
+	};
+
+	if (sec->dofs_type != DOF_SECT_DIFOHDR) {
+		dtrace_dof_error(dof, "invalid DIFO header section");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "bad alignment in DIFO header");
+		return NULL;
+	}
+
+	if (sec->dofs_size < sizeof(dof_difohdr_t) ||
+	    sec->dofs_size % sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "bad size in DIFO header");
+		return NULL;
+	}
+
+	dofd = (dof_difohdr_t *)(uintptr_t)(daddr + sec->dofs_offset);
+	n = (sec->dofs_size - sizeof(*dofd)) / sizeof(dof_secidx_t) + 1;
+
+	dp = kzalloc(sizeof(dtrace_difo_t), GFP_KERNEL);
+	if (dp == NULL) {
+		dtrace_dof_error(dof, "out-of-memory");
+		return NULL;
+	}
+	dp->dtdo_rtype = dofd->dofd_rtype;
+
+	for (l = 0; l < n; l++) {
+		dof_sec_t	*subsec;
+		void		**bufp;
+		uint32_t	*lenp;
+
+		if ((subsec =
+		     dtrace_dof_sect(dof, DOF_SECT_NONE, dofd->dofd_links[l]))
+		    == NULL)
+			goto err; /* invalid section link */
+
+		if (ttl + subsec->dofs_size > max) {
+			dtrace_dof_error(dof, "exceeds maximum size");
+			goto err;
+		}
+
+		ttl += subsec->dofs_size;
+
+		for (i = 0; difo[i].section != DOF_SECT_NONE; i++) {
+			if (subsec->dofs_type != difo[i].section)
+				continue;
+
+			if (!(subsec->dofs_flags & DOF_SECF_LOAD)) {
+				dtrace_dof_error(dof, "section not loaded");
+				goto err;
+			}
+
+			if (subsec->dofs_align != difo[i].align) {
+				dtrace_dof_error(dof, "bad alignment");
+				goto err;
+			}
+
+			bufp = (void **)((uintptr_t)dp + difo[i].bufoffs);
+			lenp = (uint32_t *)((uintptr_t)dp + difo[i].lenoffs);
+
+			if (*bufp != NULL) {
+				dtrace_dof_error(dof, difo[i].msg);
+				goto err;
+			}
+
+			if (difo[i].entsize != subsec->dofs_entsize) {
+				dtrace_dof_error(dof, "entry size mismatch");
+				goto err;
+			}
+
+			if (subsec->dofs_entsize != 0) {
+				uint64_t	n = subsec->dofs_size;
+
+				if (do_div(n, subsec->dofs_entsize) != 0) {
+					dtrace_dof_error(dof,
+							 "corrupt entry size");
+					goto err;
+				}
+			}
+
+			*lenp = subsec->dofs_size;
+			*bufp = vmalloc(subsec->dofs_size);
+			if (*bufp == NULL) {
+				dtrace_dof_error(dof, "out-of-memory");
+				goto err;
+			}
+			memcpy(*bufp,
+			       (char *)(uintptr_t)(daddr + subsec->dofs_offset),
+			       subsec->dofs_size);
+
+			if (subsec->dofs_entsize != 0)
+				*lenp /= subsec->dofs_entsize;
+
+			break;
+		}
+
+		/*
+		 * If we encounter a loadable DIFO sub-section that is not
+		 * known to us, assume this is a broken program and fail.
+		 */
+		if (difo[i].section == DOF_SECT_NONE &&
+		    (subsec->dofs_flags & DOF_SECF_LOAD)) {
+			dtrace_dof_error(dof, "unrecognized DIFO subsection");
+			goto err;
+		}
+	}
+
+	if (dp->dtdo_buf == NULL) {
+		/*
+		 * We can't have a DIF object without DIF text.
+		 */
+		dtrace_dof_error(dof, "missing DIF text");
+		goto err;
+	}
+
+	/*
+	 * Before we validate the DIF object, run through the variable table
+	 * looking for the strings -- if any of their size are under, we'll set
+	 * their size to be the system-wide default string size.  Note that
+	 * this should _not_ happen if the "strsize" option has been set --
+	 * in this case, the compiler should have set the size to reflect the
+	 * setting of the option.
+	 */
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		dtrace_difv_t		*v = &dp->dtdo_vartab[i];
+		dtrace_diftype_t	*t = &v->dtdv_type;
+
+		if (v->dtdv_id < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		if (t->dtdt_kind == DIF_TYPE_STRING && t->dtdt_size == 0)
+			t->dtdt_size = dtrace_strsize_default;
+	}
+
+	if (dtrace_difo_validate(dp, vstate, DIF_DIR_NREGS, cr) != 0)
+		goto err;
+
+	dtrace_difo_init(dp, vstate);
+	return dp;
+
+err:
+	if (dp->dtdo_buf != NULL)
+		vfree(dp->dtdo_buf);
+	if (dp->dtdo_inttab != NULL)
+		vfree(dp->dtdo_inttab);
+	if (dp->dtdo_strtab != NULL)
+		vfree(dp->dtdo_strtab);
+	if (dp->dtdo_vartab != NULL)
+		vfree(dp->dtdo_vartab);
+
+	kfree(dp);
+
+	return NULL;
+}
+
+static dtrace_predicate_t *dtrace_dof_predicate(dof_hdr_t *dof, dof_sec_t *sec,
+						dtrace_vstate_t *vstate,
+						const cred_t *cr)
+{
+        dtrace_difo_t *dp;
+
+        if ((dp = dtrace_dof_difo(dof, sec, vstate, cr)) == NULL)
+                return NULL;
+
+        return dtrace_predicate_create(dp);
+}
+
+static dtrace_actdesc_t *dtrace_dof_actdesc(dof_hdr_t *dof, dof_sec_t *sec,
+					    dtrace_vstate_t *vstate,
+					    const cred_t *cr)
+{
+	dtrace_actdesc_t	*act, *first = NULL, *last = NULL, *next;
+	dof_actdesc_t		*desc;
+	dof_sec_t		*difosec;
+	size_t			offs;
+	uintptr_t		daddr = (uintptr_t)dof;
+	uint64_t		arg;
+	dtrace_actkind_t	kind;
+
+	if (sec->dofs_type != DOF_SECT_ACTDESC) {
+		dtrace_dof_error(dof, "invalid action section");
+		return NULL;
+	}
+
+	if (sec->dofs_offset + sizeof(dof_actdesc_t) > dof->dofh_loadsz) {
+		dtrace_dof_error(dof, "truncated action description");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(uint64_t)) {
+		dtrace_dof_error(dof, "bad alignment in action description");
+		return NULL;
+	}
+
+	if (sec->dofs_size < sec->dofs_entsize) {
+		dtrace_dof_error(dof, "section entry size exceeds total size");
+		return NULL;
+	}
+
+	if (sec->dofs_entsize != sizeof(dof_actdesc_t)) {
+		dtrace_dof_error(dof, "bad entry size in action description");
+		return NULL;
+	}
+
+	/*
+	 * Was: sec->dofs_size / sec->dofs_entsize > dtrace_actions_max
+	 * but it is safer to simply avoid the division (it requires use of
+	 * a macro in Linux to cover 64-bit division in a 32-bit kernel.
+	 */
+	if (sec->dofs_size > sec->dofs_entsize * dtrace_actions_max) {
+		dtrace_dof_error(dof, "actions exceed dtrace_actions_max");
+		return NULL;
+	}
+
+	for (offs = 0; offs < sec->dofs_size; offs += sec->dofs_entsize) {
+		desc = (dof_actdesc_t *)(daddr +
+					 (uintptr_t)sec->dofs_offset + offs);
+		kind = (dtrace_actkind_t)desc->dofa_kind;
+
+		if (DTRACEACT_ISPRINTFLIKE(kind) &&
+		    (kind != DTRACEACT_PRINTA ||
+		     desc->dofa_strtab != DOF_SECIDX_NONE)) {
+			dof_sec_t	*strtab;
+			char		*str, *fmt;
+			uint64_t	i;
+
+			/*
+			 * The printf()-like actions must have a format string.
+			 */
+			if ((strtab =
+			     dtrace_dof_sect(dof, DOF_SECT_STRTAB,
+					     desc->dofa_strtab)) == NULL)
+				goto err;
+
+			str = (char *)((uintptr_t)dof +
+				       (uintptr_t)strtab->dofs_offset);
+	
+			for (i = desc->dofa_arg; i < strtab->dofs_size; i++) {
+				if (str[i] == '\0')
+					break;
+			}
+
+			if (i >= strtab->dofs_size) {
+				dtrace_dof_error(dof, "bogus format string");
+				goto err;
+			}
+
+			if (i == desc->dofa_arg) {
+				dtrace_dof_error(dof, "empty format string");
+				goto err;
+			}
+
+			i -= desc->dofa_arg;
+			fmt = vmalloc(i + 1);
+			if (fmt == NULL) {
+				dtrace_dof_error(dof, "out-of-memory");
+				goto err;
+			}
+			memcpy(fmt, &str[desc->dofa_arg], i + 1);
+			arg = (uint64_t)(uintptr_t)fmt;
+		} else {
+			if (kind == DTRACEACT_PRINTA) {
+				ASSERT(desc->dofa_strtab == DOF_SECIDX_NONE);
+				arg = 0;
+			} else
+				arg = desc->dofa_arg;
+		}
+
+		act = dtrace_actdesc_create(kind, desc->dofa_ntuple,
+					    desc->dofa_uarg, arg);
+		if (act == NULL)
+			goto err;
+
+		if (last != NULL)
+			last->dtad_next = act;
+		else
+			first = act;
+
+		last = act;
+
+		if (desc->dofa_difo == DOF_SECIDX_NONE)
+			continue;
+
+		if ((difosec = dtrace_dof_sect(dof, DOF_SECT_DIFOHDR,
+					       desc->dofa_difo)) == NULL)
+			goto err;
+
+		act->dtad_difo = dtrace_dof_difo(dof, difosec, vstate, cr);
+
+		if (act->dtad_difo == NULL)
+			goto err;
+	}
+
+	ASSERT(first != NULL);
+	return first;
+
+err:
+	for (act = first; act != NULL; act = next) {
+		next = act->dtad_next;
+		dtrace_actdesc_release(act, vstate);
+	}
+
+	return NULL;
+}
+
+static dtrace_ecbdesc_t *dtrace_dof_ecbdesc(dof_hdr_t *dof, dof_sec_t *sec,
+					    dtrace_vstate_t *vstate,
+					    const cred_t *cr)
+{
+	dtrace_ecbdesc_t	*ep;
+	dof_ecbdesc_t		*ecb;
+	dtrace_probedesc_t	*desc;
+	dtrace_predicate_t	*pred = NULL;
+
+	if (sec->dofs_size < sizeof(dof_ecbdesc_t)) {
+		dtrace_dof_error(dof, "truncated ECB description");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(uint64_t)) {
+		dtrace_dof_error(dof, "bad alignment in ECB description");
+		return NULL;
+	}
+
+	ecb = (dof_ecbdesc_t *)((uintptr_t)dof + (uintptr_t)sec->dofs_offset);
+	sec = dtrace_dof_sect(dof, DOF_SECT_PROBEDESC, ecb->dofe_probes);
+
+	if (sec == NULL)
+		return NULL;
+
+	ep = kzalloc(sizeof(dtrace_ecbdesc_t), GFP_KERNEL);
+	if (ep == NULL)
+		return NULL;
+	ep->dted_uarg = ecb->dofe_uarg;
+	desc = &ep->dted_probe;
+
+	if (dtrace_dof_probedesc(dof, sec, desc) == NULL)
+		goto err;
+
+	if (ecb->dofe_pred != DOF_SECIDX_NONE) {
+		if ((sec = dtrace_dof_sect(dof, DOF_SECT_DIFOHDR,
+					   ecb->dofe_pred)) == NULL)
+			goto err;
+
+		if ((pred = dtrace_dof_predicate(dof, sec, vstate, cr)) == NULL)
+			goto err;
+
+		ep->dted_pred.dtpdd_predicate = pred;
+	}
+
+	if (ecb->dofe_actions != DOF_SECIDX_NONE) {
+		if ((sec = dtrace_dof_sect(dof, DOF_SECT_ACTDESC,
+					   ecb->dofe_actions)) == NULL)
+			goto err;
+
+		ep->dted_action = dtrace_dof_actdesc(dof, sec, vstate, cr);
+
+		if (ep->dted_action == NULL)
+			goto err;
+	}
+
+	return ep;
+
+err:
+	if (pred != NULL)
+		dtrace_predicate_release(pred, vstate);
+	kfree(ep);
+	return NULL;
+}
+
+/*
+ * Apply the relocations from the specified 'sec' (a DOF_SECT_URELHDR) to the
+ * specified DOF.  At present, this amounts to simply adding 'ubase' to the
+ * site of any user SETX relocations to account for load object base address.
+ * In the future, if we need other relocations, this function can be extended.
+ */
+static int dtrace_dof_relocate(dof_hdr_t *dof, dof_sec_t *sec, uint64_t ubase)
+{
+	uintptr_t	daddr = (uintptr_t)dof;
+	dof_relohdr_t	*dofr = (dof_relohdr_t *)(uintptr_t)(daddr +
+							     sec->dofs_offset);
+	dof_sec_t	*ss, *rs, *ts;
+	dof_relodesc_t	*r;
+	uint_t		i, n;
+
+	if (sec->dofs_size < sizeof(dof_relohdr_t) ||
+	    sec->dofs_align != sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "invalid relocation header");
+		return -1;
+	}
+
+	ss = dtrace_dof_sect(dof, DOF_SECT_STRTAB, dofr->dofr_strtab);
+	rs = dtrace_dof_sect(dof, DOF_SECT_RELTAB, dofr->dofr_relsec);
+	ts = dtrace_dof_sect(dof, DOF_SECT_NONE, dofr->dofr_tgtsec);
+
+	if (ss == NULL || rs == NULL || ts == NULL)
+		return -1; /* dtrace_dof_error() has been called already */
+
+	if (rs->dofs_entsize < sizeof(dof_relodesc_t) ||
+	    rs->dofs_align != sizeof(uint64_t)) {
+		dtrace_dof_error(dof, "invalid relocation section");
+		return -1;
+	}
+
+	r = (dof_relodesc_t *)(uintptr_t)(daddr + rs->dofs_offset);
+	/*
+	 * Was: n = rs->dofs_size / rs->dofs_entsize;
+	 * but on Linux we need to use a macro for the division to handle the
+	 * possible case of 64-bit division on a 32-bit kernel.
+	 */
+	n = rs->dofs_size;
+	do_div(n, rs->dofs_entsize);
+
+	for (i = 0; i < n; i++) {
+		uintptr_t	taddr = daddr + ts->dofs_offset +
+						r->dofr_offset;
+
+		switch (r->dofr_type) {
+		case DOF_RELO_NONE:
+			break;
+		case DOF_RELO_SETX:
+			if (r->dofr_offset >= ts->dofs_size ||
+			    r->dofr_offset + sizeof(uint64_t) >
+				ts->dofs_size) {
+				dtrace_dof_error(dof, "bad relocation offset");
+				return -1;
+			}
+
+			if (!IS_ALIGNED(taddr, sizeof(uint64_t))) {
+				dtrace_dof_error(dof, "misaligned setx relo");
+				return -1;
+			}
+
+			dt_dbg_dof("      Relocate 0x%llx + 0x%llx = 0x%llx\n",
+				   *(uint64_t *)taddr, ubase,
+				   *(uint64_t *)taddr + ubase);
+
+			*(uint64_t *)taddr += ubase;
+			break;
+		default:
+			dtrace_dof_error(dof, "invalid relocation type");
+			return -1;
+		}
+
+		r = (dof_relodesc_t *)((uintptr_t)r + rs->dofs_entsize);
+	}
+
+	return 0;
+}
+
+/*
+ * The dof_hdr_t passed to dtrace_dof_slurp() should be a partially validated
+ * header:  it should be at the front of a memory region that is at least
+ * sizeof(dof_hdr_t) in size -- and then at least dof_hdr.dofh_loadsz in
+ * size.  It need not be validated in any other way.
+ */
+int dtrace_dof_slurp(dof_hdr_t *dof, dtrace_vstate_t *vstate, const cred_t *cr,
+		     dtrace_enabling_t **enabp, uint64_t ubase, int noprobes)
+{
+	uint64_t		len = dof->dofh_loadsz, seclen;
+	uintptr_t		daddr = (uintptr_t)dof;
+	dtrace_ecbdesc_t	*ep;
+	dtrace_enabling_t	*enab;
+	uint_t			i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dof->dofh_loadsz >= sizeof(dof_hdr_t));
+
+	dt_dbg_dof("  DOF 0x%p Slurping...\n", dof);
+
+	dt_dbg_dof("    DOF 0x%p Validating...\n", dof);
+
+	/*
+	 * Check the DOF header identification bytes.  In addition to checking
+	 * valid settings, we also verify that unused bits/bytes are zeroed so
+	 * we can use them later without fear of regressing existing binaries.
+	 */
+	if (memcmp(&dof->dofh_ident[DOF_ID_MAG0], DOF_MAG_STRING,
+		   DOF_MAG_STRLEN) != 0) {
+		dtrace_dof_error(dof, "DOF magic string mismatch");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_MODEL] != DOF_MODEL_ILP32 &&
+	    dof->dofh_ident[DOF_ID_MODEL] != DOF_MODEL_LP64) {
+		dtrace_dof_error(dof, "DOF has invalid data model");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_ENCODING] != DOF_ENCODE_NATIVE) {
+		dtrace_dof_error(dof, "DOF encoding mismatch");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &&
+	    dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_2) {
+		dtrace_dof_error(dof, "DOF version mismatch");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_DIFVERS] != DIF_VERSION_2) {
+		dtrace_dof_error(dof, "DOF uses unsupported instruction set");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_DIFIREG] > DIF_DIR_NREGS) {
+		dtrace_dof_error(dof, "DOF uses too many integer registers");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_DIFTREG] > DIF_DTR_NREGS) {
+		dtrace_dof_error(dof, "DOF uses too many tuple registers");
+		return -1;
+	}
+
+	for (i = DOF_ID_PAD; i < DOF_ID_SIZE; i++) {
+		if (dof->dofh_ident[i] != 0) {
+			dtrace_dof_error(dof, "DOF has invalid ident byte set");                        return -1;
+		}
+	}
+
+	if (dof->dofh_flags & ~DOF_FL_VALID) {
+		dtrace_dof_error(dof, "DOF has invalid flag bits set");
+		return -1;
+	}
+
+	if (dof->dofh_secsize == 0) {
+		dtrace_dof_error(dof, "zero section header size");
+		return -1;
+	}
+
+	/*
+	 * Check that the section headers don't exceed the amount of DOF
+	 * data.  Note that we cast the section size and number of sections
+	 * to uint64_t's to prevent possible overflow in the multiplication.
+	 */
+	seclen = (uint64_t)dof->dofh_secnum * (uint64_t)dof->dofh_secsize;
+
+	if (dof->dofh_secoff > len || seclen > len ||
+	    dof->dofh_secoff + seclen > len) {
+		dtrace_dof_error(dof, "truncated section headers");
+		return -1;
+	}
+
+	if (!IS_ALIGNED(dof->dofh_secoff, sizeof(uint64_t))) {
+		dtrace_dof_error(dof, "misaligned section headers");
+		return -1;
+	}
+
+	if (!IS_ALIGNED(dof->dofh_secsize, sizeof(uint64_t))) {
+		dtrace_dof_error(dof, "misaligned section size");
+		return -1;
+	}
+
+	/*
+	 * Take an initial pass through the section headers to be sure that
+	 * the headers don't have stray offsets.  If the 'noprobes' flag is
+	 * set, do not permit sections relating to providers, probes, or args.
+	 */
+	dt_dbg_dof("    DOF 0x%p Checking section offsets...\n", dof);
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		dof_sec_t	*sec =
+				(dof_sec_t *)(daddr +
+					      (uintptr_t)dof->dofh_secoff +
+					      i * dof->dofh_secsize);
+
+		if (noprobes) {
+			switch (sec->dofs_type) {
+			case DOF_SECT_PROVIDER:
+			case DOF_SECT_PROBES:
+			case DOF_SECT_PRARGS:
+			case DOF_SECT_PROFFS:
+				dtrace_dof_error(
+					dof, "illegal sections for enabling");
+				return -1;
+			}
+		}
+
+		if (DOF_SEC_ISLOADABLE(sec->dofs_type) &&
+		    !(sec->dofs_flags & DOF_SECF_LOAD)) {
+			dtrace_dof_error(
+				dof, "loadable section with load flag unset");
+			return -1;
+		}
+
+		/*
+		 * Just ignore non-loadable sections.
+		 */
+		if (!(sec->dofs_flags & DOF_SECF_LOAD))
+			continue;
+
+		if (sec->dofs_align & (sec->dofs_align - 1)) {
+			dtrace_dof_error(dof, "bad section alignment");
+			return -1;
+		}
+
+		if (sec->dofs_offset & (sec->dofs_align - 1)) {
+			dtrace_dof_error(dof, "misaligned section");
+			return -1;
+		}
+
+		if (sec->dofs_offset > len || sec->dofs_size > len ||
+		    sec->dofs_offset + sec->dofs_size > len) {
+			dtrace_dof_error(dof, "corrupt section header");
+			return -1;
+		}
+
+		if (sec->dofs_type == DOF_SECT_STRTAB && *((char *)daddr +
+		    sec->dofs_offset + sec->dofs_size - 1) != '\0') {
+			dtrace_dof_error(dof, "non-terminating string table");
+			return -1;
+		}
+	}
+
+	/*
+	 * Take a second pass through the sections and locate and perform any
+	 * relocations that are present.  We do this after the first pass to
+	 * be sure that all sections have had their headers validated.
+	 */
+	dt_dbg_dof("    DOF 0x%p Performing relocations...\n", dof);
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		dof_sec_t	*sec =
+				(dof_sec_t *)(daddr +
+					      (uintptr_t)dof->dofh_secoff +
+					      i * dof->dofh_secsize);
+
+		/*
+		 * Skip sections that are not loadable.
+		 */
+		if (!(sec->dofs_flags & DOF_SECF_LOAD))
+			continue;
+
+		switch (sec->dofs_type) {
+		case DOF_SECT_URELHDR:
+			if (dtrace_dof_relocate(dof, sec, ubase) != 0)
+				return -1;
+			break;
+		}
+	}
+
+	dt_dbg_dof("    DOF 0x%p Processing enablings...\n", dof);
+
+	if ((enab = *enabp) == NULL)
+		enab = *enabp = dtrace_enabling_create(vstate);
+
+	if (enab == NULL) {
+		dt_dbg_dof("  DOF 0x%p Done slurping - no enablings\n", dof);
+		return -1;
+	}
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		dof_sec_t	*sec =
+				(dof_sec_t *)(daddr +
+					      (uintptr_t)dof->dofh_secoff +
+					      i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_ECBDESC)
+			continue;
+
+		if ((ep = dtrace_dof_ecbdesc(dof, sec, vstate, cr)) == NULL) {
+			dt_dbg_dof("  DOF 0x%p Done slurping - ECB problem\n",
+				   dof);
+			dtrace_enabling_destroy(enab);
+			*enabp = NULL;
+			return -1;
+		}
+
+		dtrace_enabling_add(enab, ep);
+	}
+
+	dt_dbg_dof("    DOF 0x%p Enablings processed\n", dof);
+	dt_dbg_dof("  DOF 0x%p Done slurping\n", dof);
+
+	return 0;
+}
+
+/*
+ * Process DOF for any options.  This should be called after the DOF has been
+ * processed by dtrace_dof_slurp().
+ */
+int dtrace_dof_options(dof_hdr_t *dof, dtrace_state_t *state)
+{
+	int		i, rval;
+	uint32_t	entsize;
+	size_t		offs;
+	dof_optdesc_t	*desc;
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		dof_sec_t	*sec = (dof_sec_t *)((uintptr_t)dof +
+				       (uintptr_t)dof->dofh_secoff +
+				       i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_OPTDESC)
+			continue;
+
+		if (sec->dofs_align != sizeof(uint64_t)) {
+			dtrace_dof_error(
+				dof, "bad alignment in option description");
+			return -EINVAL;
+		}
+
+		if ((entsize = sec->dofs_entsize) == 0) {
+			dtrace_dof_error(dof, "zeroed option entry size");
+			return -EINVAL;
+		}
+
+		if (entsize < sizeof(dof_optdesc_t)) {
+			dtrace_dof_error(dof, "bad option entry size");
+			return -EINVAL;
+		}
+
+		for (offs = 0; offs < sec->dofs_size; offs += entsize) {
+			desc = (dof_optdesc_t *)((uintptr_t)dof +
+						 (uintptr_t)sec->dofs_offset +
+						 offs);
+
+			if (desc->dofo_strtab != DOF_SECIDX_NONE) {
+				dtrace_dof_error(
+					dof, "non-zero option string");
+				return -EINVAL;
+			}
+
+			if (desc->dofo_value == DTRACEOPT_UNSET) {
+				dtrace_dof_error(dof, "unset option");
+				return -EINVAL;
+			}
+
+			if ((rval = dtrace_state_option(
+					state, desc->dofo_option,
+					desc->dofo_value)) != 0) {
+				dtrace_dof_error(dof, "rejected option");
+				return rval;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static dtrace_helpers_t *dtrace_helpers_create(struct task_struct *curr)
+{
+	dtrace_helpers_t	*dth;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(curr->dtrace_helpers == NULL);
+
+	dth = kzalloc(sizeof(dtrace_helpers_t), GFP_KERNEL);
+	if (dth == NULL)
+		return NULL;
+
+	dth->dthps_actions = vzalloc(sizeof(dtrace_helper_action_t *) *
+				     DTRACE_NHELPER_ACTIONS);
+	if (dth->dthps_actions == NULL) {
+		kfree(dth);
+		return NULL;
+	}
+
+	curr->dtrace_helpers = dth;
+	dtrace_helpers++;
+
+	dt_dbg_dof("  Helpers allocated for task 0x%p (%d system-wide)\n",
+		   curr, dtrace_helpers);
+
+	return dth;
+}
+
+static int dtrace_helper_validate(dtrace_helper_action_t *helper)
+{
+	int		err = 0, i;
+	dtrace_difo_t	*dp;
+
+	if ((dp = helper->dtha_predicate) != NULL)
+		err += dtrace_difo_validate_helper(dp);
+
+	for (i = 0; i < helper->dtha_nactions; i++)
+		err += dtrace_difo_validate_helper(helper->dtha_actions[i]);
+
+	return (err == 0);
+}
+
+static int dtrace_helper_provider_validate(dof_hdr_t *dof, dof_sec_t *sec)
+{
+	uintptr_t	daddr = (uintptr_t)dof;
+	dof_sec_t	*str_sec, *prb_sec, *arg_sec, *off_sec, *enoff_sec;
+	dof_provider_t	*prov;
+	dof_probe_t	*prb;
+	uint8_t		*arg;
+	char		*strtab, *typestr;
+	dof_stridx_t	typeidx;
+	size_t		typesz;
+	uint_t		 nprobes, j, k;
+
+	ASSERT(sec->dofs_type == DOF_SECT_PROVIDER);
+
+	if (sec->dofs_offset & (sizeof(uint_t) - 1)) {
+		dtrace_dof_error(dof, "misaligned section offset");
+		return -1;
+	}
+
+	/*
+	 * The section needs to be large enough to contain the DOF provider
+	 * structure appropriate for the given version.
+	 */
+	if (sec->dofs_size <
+	    ((dof->dofh_ident[DOF_ID_VERSION] == DOF_VERSION_1)
+			? offsetof(dof_provider_t, dofpv_prenoffs)
+			: sizeof(dof_provider_t))) {
+		dtrace_dof_error(dof, "provider section too small");
+		return -1;
+	}
+
+	prov = (dof_provider_t *)(uintptr_t)(daddr + sec->dofs_offset);
+	str_sec = dtrace_dof_sect(dof, DOF_SECT_STRTAB, prov->dofpv_strtab);
+	prb_sec = dtrace_dof_sect(dof, DOF_SECT_PROBES, prov->dofpv_probes);
+	arg_sec = dtrace_dof_sect(dof, DOF_SECT_PRARGS, prov->dofpv_prargs);
+	off_sec = dtrace_dof_sect(dof, DOF_SECT_PROFFS, prov->dofpv_proffs);
+
+	if (str_sec == NULL || prb_sec == NULL ||
+	    arg_sec == NULL || off_sec == NULL)
+		return -1;
+
+	enoff_sec = NULL;
+
+	if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &&
+	    prov->dofpv_prenoffs != DOF_SECT_NONE &&
+	    (enoff_sec = dtrace_dof_sect(dof, DOF_SECT_PRENOFFS,
+					 prov->dofpv_prenoffs)) == NULL)
+		return -1;
+
+	strtab = (char *)(uintptr_t)(daddr + str_sec->dofs_offset);
+
+	if (prov->dofpv_name >= str_sec->dofs_size ||
+	    strlen(strtab + prov->dofpv_name) >= DTRACE_PROVNAMELEN) {
+		dtrace_dof_error(dof, "invalid provider name");
+		return -1;
+	}
+
+	if (prb_sec->dofs_entsize == 0 ||
+	    prb_sec->dofs_entsize > prb_sec->dofs_size) {
+		dtrace_dof_error(dof, "invalid entry size");
+		return -1;
+	}
+
+	if (prb_sec->dofs_entsize & (sizeof(uintptr_t) - 1)) {
+		dtrace_dof_error(dof, "misaligned entry size");
+		return -1;
+	}
+
+	if (off_sec->dofs_entsize != sizeof(uint32_t)) {
+		dtrace_dof_error(dof, "invalid entry size");
+		return -1;
+	}
+
+	if (off_sec->dofs_offset & (sizeof(uint32_t) - 1)) {
+		dtrace_dof_error(dof, "misaligned section offset");
+		return -1;
+	}
+
+	if (arg_sec->dofs_entsize != sizeof(uint8_t)) {
+		dtrace_dof_error(dof, "invalid entry size");
+		return -1;
+	}
+
+	arg = (uint8_t *)(uintptr_t)(daddr + arg_sec->dofs_offset);
+	nprobes = prb_sec->dofs_size / prb_sec->dofs_entsize;
+
+	dt_dbg_dof("    DOF 0x%p %s::: with %d probes\n",
+		   dof, strtab + prov->dofpv_name, nprobes);
+
+	/*
+	 * Take a pass through the probes to check for errors.
+	 */
+	for (j = 0; j < nprobes; j++) {
+		prb = (dof_probe_t *)(uintptr_t)
+			(daddr + prb_sec->dofs_offset +
+			 j * prb_sec->dofs_entsize);
+
+		if (prb->dofpr_func >= str_sec->dofs_size) {
+			dtrace_dof_error(dof, "invalid function name");
+			return -1;
+		}
+
+		if (strlen(strtab + prb->dofpr_func) >= DTRACE_FUNCNAMELEN) {
+			dtrace_dof_error(dof, "function name too long");
+			return -1;
+		}
+
+		if (prb->dofpr_name >= str_sec->dofs_size ||
+		    strlen(strtab + prb->dofpr_name) >= DTRACE_NAMELEN) {
+			dtrace_dof_error(dof, "invalid probe name");
+			return -1;
+		}
+
+		/*
+		 * The offset count must not wrap the index, and the offsets
+		 * must also not overflow the section's data.
+		 */
+		if (prb->dofpr_offidx + prb->dofpr_noffs < prb->dofpr_offidx ||
+		    (prb->dofpr_offidx + prb->dofpr_noffs) *
+		    off_sec->dofs_entsize > off_sec->dofs_size) {
+			dtrace_dof_error(dof, "invalid probe offset");
+			return -1;
+		}
+
+		if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1) {
+			/*
+			 * If there's no is-enabled offset section, make sure
+			 * there aren't any is-enabled offsets. Otherwise
+			 * perform the same checks as for probe offsets
+			 * (immediately above).
+			 */
+			if (enoff_sec == NULL) {
+				if (prb->dofpr_enoffidx != 0 ||
+				    prb->dofpr_nenoffs != 0) {
+					dtrace_dof_error(dof,
+							 "is-enabled offsets "
+							 "with null section");
+					return -1;
+				}
+			} else if (prb->dofpr_enoffidx + prb->dofpr_nenoffs <
+				   prb->dofpr_enoffidx ||
+				   (prb->dofpr_enoffidx + prb->dofpr_nenoffs) *
+				   enoff_sec->dofs_entsize >
+				   enoff_sec->dofs_size) {
+				dtrace_dof_error(dof, "invalid is-enabled "
+						      "offset");
+				return -1;
+			}
+
+			if (prb->dofpr_noffs + prb->dofpr_nenoffs == 0) {
+				dtrace_dof_error(dof, "zero probe and "
+						      "is-enabled offsets");
+				return -1;
+			}
+		} else if (prb->dofpr_noffs == 0) {
+			dtrace_dof_error(dof, "zero probe offsets");
+			return -1;
+		}
+
+		if (prb->dofpr_argidx + prb->dofpr_xargc < prb->dofpr_argidx ||
+		    (prb->dofpr_argidx + prb->dofpr_xargc) *
+		    arg_sec->dofs_entsize > arg_sec->dofs_size) {
+			dtrace_dof_error(dof, "invalid args");
+			return -1;
+		}
+
+		typeidx = prb->dofpr_nargv;
+		typestr = strtab + prb->dofpr_nargv;
+		for (k = 0; k < prb->dofpr_nargc; k++) {
+			if (typeidx >= str_sec->dofs_size) {
+				dtrace_dof_error(dof, "bad native argument "
+						      "type");
+				return -1;
+			}
+
+			typesz = strlen(typestr) + 1;
+			if (typesz > DTRACE_ARGTYPELEN) {
+				dtrace_dof_error(dof, "native argument type "
+						      "too long");
+				return -1;
+			}
+
+			typeidx += typesz;
+			typestr += typesz;
+		}
+
+		typeidx = prb->dofpr_xargv;
+		typestr = strtab + prb->dofpr_xargv;
+		for (k = 0; k < prb->dofpr_xargc; k++) {
+			if (arg[prb->dofpr_argidx + k] > prb->dofpr_nargc) {
+				dtrace_dof_error(dof, "bad native argument "
+						      "index");
+				return -1;
+			}
+
+			if (typeidx >= str_sec->dofs_size) {
+				dtrace_dof_error(dof, "bad translated "
+						      "argument type");
+				return -1;
+			}
+
+			typesz = strlen(typestr) + 1;
+			if (typesz > DTRACE_ARGTYPELEN) {
+				dtrace_dof_error(dof, "translated argument "
+						      "type too long");
+				return -1;
+			}
+
+			typeidx += typesz;
+			typestr += typesz;
+		}
+
+		dt_dbg_dof("      Probe %d %s:%s:%s:%s with %d offsets, "
+			   "%d is-enabled offsets\n", j,
+			   strtab + prov->dofpv_name, "",
+			   strtab + prb->dofpr_func, strtab + prb->dofpr_name,
+			   prb->dofpr_noffs, prb->dofpr_nenoffs);
+	}
+
+	return 0;
+}
+
+static void dtrace_helper_action_destroy(dtrace_helper_action_t *helper,
+					 dtrace_vstate_t *vstate)
+{
+	int	i;
+
+	if (helper->dtha_predicate != NULL)
+		dtrace_difo_release(helper->dtha_predicate, vstate);
+
+	for (i = 0; i < helper->dtha_nactions; i++) {
+		ASSERT(helper->dtha_actions[i] != NULL);
+		dtrace_difo_release(helper->dtha_actions[i], vstate);
+	}
+
+	vfree(helper->dtha_actions);
+	kfree(helper);
+}
+
+static int dtrace_helper_action_add(int which, dtrace_ecbdesc_t *ep)
+{
+	dtrace_helpers_t	*dth;
+	dtrace_helper_action_t	*helper, *last;
+	dtrace_actdesc_t	*act;
+	dtrace_vstate_t		*vstate;
+	dtrace_predicate_t	*pred;
+	int			count = 0, nactions = 0, i;
+
+	if (which < 0 || which >= DTRACE_NHELPER_ACTIONS)
+		return -EINVAL;
+
+	dth = current->dtrace_helpers;
+	last = dth->dthps_actions[which];
+	vstate = &dth->dthps_vstate;
+
+	for (count = 0; last != NULL; last = last->dtha_next) {
+		count++;
+		if (last->dtha_next == NULL)
+			break;
+	}
+
+	/*
+	 * If we already have dtrace_helper_actions_max helper actions for this
+	 * helper action type, we'll refuse to add a new one.
+	 */
+	if (count >= dtrace_helper_actions_max)
+		return -ENOSPC;
+
+	helper = kzalloc(sizeof(dtrace_helper_action_t), GFP_KERNEL);
+	if (helper == NULL)
+		return -ENOMEM;
+
+	helper->dtha_generation = dth->dthps_generation;
+
+	if ((pred = ep->dted_pred.dtpdd_predicate) != NULL) {
+		ASSERT(pred->dtp_difo != NULL);
+		dtrace_difo_hold(pred->dtp_difo);
+		helper->dtha_predicate = pred->dtp_difo;
+	}
+
+	for (act = ep->dted_action; act != NULL; act = act->dtad_next) {
+		if (act->dtad_kind != DTRACEACT_DIFEXPR)
+			goto err;
+
+		if (act->dtad_difo == NULL)
+			goto err;
+
+		nactions++;
+	}
+
+	helper->dtha_actions = vzalloc(sizeof(dtrace_difo_t *) *
+				       (helper->dtha_nactions = nactions));
+	if (helper->dtha_actions == NULL)
+		goto err;
+
+	for (act = ep->dted_action, i = 0; act != NULL; act = act->dtad_next) {
+		dtrace_difo_hold(act->dtad_difo);
+		helper->dtha_actions[i++] = act->dtad_difo;
+	}
+
+	if (!dtrace_helper_validate(helper))
+		goto err;
+
+	if (last == NULL)
+		dth->dthps_actions[which] = helper;
+	else
+		last->dtha_next = helper;
+
+	if (vstate->dtvs_nlocals > dtrace_helptrace_nlocals) {
+		dtrace_helptrace_nlocals = vstate->dtvs_nlocals;
+		dtrace_helptrace_next = 0;
+	}
+
+	return 0;
+
+err:
+	dtrace_helper_action_destroy(helper, vstate);
+	if (helper->dtha_actions != NULL)
+		vfree(helper->dtha_actions);
+	else
+		return -ENOMEM;
+
+	return -EINVAL;
+}
+
+static int dtrace_helper_provider_add(dof_helper_t *dofhp, int gen)
+{
+	dtrace_helpers_t		*dth;
+	dtrace_helper_provider_t	*hprov, **tmp_provs;
+	uint_t				tmp_maxprovs, i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	dth = current->dtrace_helpers;
+	ASSERT(dth != NULL);
+
+	/*
+	 * If we already have dtrace_helper_providers_max helper providers,
+	 * we're refuse to add a new one.
+	 */
+	if (dth->dthps_nprovs >= dtrace_helper_providers_max)
+		return -ENOSPC;
+
+	/*
+	 * Check to make sure this isn't a duplicate.
+	 */
+	for (i = 0; i < dth->dthps_nprovs; i++) {
+		if (dofhp->dofhp_addr ==
+		    dth->dthps_provs[i]->dthp_prov.dofhp_addr)
+			return -EALREADY;
+	}
+
+	hprov = kzalloc(sizeof(dtrace_helper_provider_t), GFP_KERNEL);
+	if (hprov == NULL)
+		return -ENOMEM;
+	hprov->dthp_prov = *dofhp;
+	hprov->dthp_ref = 1;
+	hprov->dthp_generation = gen;
+
+	/*
+	 * Allocate a bigger table for helper providers if it's already full.
+	 */
+	if (dth->dthps_maxprovs == dth->dthps_nprovs) {
+		tmp_maxprovs = dth->dthps_maxprovs;
+		tmp_provs = dth->dthps_provs;
+
+		if (dth->dthps_maxprovs == 0)
+			dth->dthps_maxprovs = 2;
+		else
+			dth->dthps_maxprovs *= 2;
+
+		if (dth->dthps_maxprovs > dtrace_helper_providers_max)
+			dth->dthps_maxprovs = dtrace_helper_providers_max;
+
+		ASSERT(tmp_maxprovs < dth->dthps_maxprovs);
+
+		dth->dthps_provs = vzalloc(dth->dthps_maxprovs *
+					   sizeof(dtrace_helper_provider_t *));
+		if (dth->dthps_provs == NULL) {
+			kfree(hprov);
+			return -ENOMEM;
+		}
+
+		if (tmp_provs != NULL) {
+			memcpy(dth->dthps_provs, tmp_provs,
+			       tmp_maxprovs *
+			       sizeof(dtrace_helper_provider_t *));
+			vfree(tmp_provs);
+		}
+	}
+
+	dth->dthps_provs[dth->dthps_nprovs] = hprov;
+	dth->dthps_nprovs++;
+
+	return 0;
+}
+
+static void dtrace_helper_provider_destroy(dtrace_helper_provider_t *hprov)
+{
+	mutex_lock(&dtrace_lock);
+
+	if (--hprov->dthp_ref == 0) {
+		dof_hdr_t	*dof;
+
+		mutex_unlock(&dtrace_lock);
+
+		dof = (dof_hdr_t *)(uintptr_t)hprov->dthp_prov.dofhp_dof;
+		dtrace_dof_destroy(dof);
+		kfree(hprov);
+	} else
+		mutex_unlock(&dtrace_lock);
+}
+
+static void dtrace_dofattr2attr(dtrace_attribute_t *attr,
+				const dof_attr_t dofattr)
+{
+	attr->dtat_name = DOF_ATTR_NAME(dofattr);
+	attr->dtat_data = DOF_ATTR_DATA(dofattr);
+	attr->dtat_class = DOF_ATTR_CLASS(dofattr);
+}
+
+static void dtrace_dofprov2hprov(dtrace_helper_provdesc_t *hprov,
+				 const dof_provider_t *dofprov, char *strtab)
+{
+	hprov->dthpv_provname = strtab + dofprov->dofpv_name;
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_provider,
+			    dofprov->dofpv_provattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_mod,
+			    dofprov->dofpv_modattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_func,
+			    dofprov->dofpv_funcattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_name,
+			    dofprov->dofpv_nameattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_args,
+			    dofprov->dofpv_argsattr);
+}
+
+static void dtrace_helper_provider_remove_one(dof_helper_t *dhp,
+					      dof_sec_t *sec, pid_t pid)
+{
+	uintptr_t			daddr = (uintptr_t)dhp->dofhp_dof;
+	dof_hdr_t			*dof = (dof_hdr_t *)daddr;
+	dof_sec_t			*str_sec;
+	dof_provider_t			*prov;
+	char				*strtab;
+	dtrace_helper_provdesc_t	dhpv;
+	dtrace_meta_t			*meta = dtrace_meta_pid;
+	dtrace_mops_t			*mops = &meta->dtm_mops;
+
+	prov = (dof_provider_t *)(uintptr_t)(daddr + sec->dofs_offset);
+	str_sec = (dof_sec_t *)(uintptr_t)(daddr + dof->dofh_secoff +
+					   prov->dofpv_strtab *
+						dof->dofh_secsize);
+
+	strtab = (char *)(uintptr_t)(daddr + str_sec->dofs_offset);
+
+	/*
+	 * Create the provider.
+	 */
+	dtrace_dofprov2hprov(&dhpv, prov, strtab);
+
+	dt_dbg_dof("    Removing provider %s for PID %d\n",
+		   dhpv.dthpv_provname, pid);
+
+	mops->dtms_remove_pid(meta->dtm_arg, &dhpv, pid);
+
+	meta->dtm_count--;
+}
+
+static void dtrace_helper_provider_remove(dof_helper_t *dhp, pid_t pid)
+{
+	uintptr_t	daddr = (uintptr_t)dhp->dofhp_dof;
+	dof_hdr_t	*dof = (dof_hdr_t *)daddr;
+	int		i;
+
+	ASSERT(MUTEX_HELD(&dtrace_meta_lock));
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		dof_sec_t	*sec = (dof_sec_t *)(uintptr_t)
+				       (daddr + dof->dofh_secoff +
+					i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_PROVIDER)
+			continue;
+
+		dtrace_helper_provider_remove_one(dhp, sec, pid);
+	}
+}
+
+static void dtrace_helper_provide_one(dof_helper_t *dhp, dof_sec_t *sec,
+				      pid_t pid)
+{
+	uintptr_t			daddr = (uintptr_t)dhp->dofhp_dof;
+	dof_hdr_t			*dof = (dof_hdr_t *)daddr;
+	dof_sec_t			*str_sec, *prb_sec, *arg_sec, *off_sec,
+					*enoff_sec;
+	dof_provider_t			*prov;
+	dof_probe_t			*probe;
+	uint32_t			*off, *enoff;
+	uint8_t				*arg;
+	char				*strtab;
+	uint_t				i, nprobes;
+	dtrace_helper_provdesc_t	dhpv;
+	dtrace_helper_probedesc_t	dhpb;
+	dtrace_meta_t			*meta = dtrace_meta_pid;
+	dtrace_mops_t			*mops = &meta->dtm_mops;
+	void				*parg;
+
+	prov = (dof_provider_t *)(uintptr_t)(daddr + sec->dofs_offset);
+	str_sec = (dof_sec_t *)(uintptr_t)(daddr + dof->dofh_secoff +
+					   prov->dofpv_strtab *
+						dof->dofh_secsize);
+	prb_sec = (dof_sec_t *)(uintptr_t)(daddr + dof->dofh_secoff +
+					   prov->dofpv_probes *
+						dof->dofh_secsize);
+	arg_sec = (dof_sec_t *)(uintptr_t)(daddr + dof->dofh_secoff +
+					   prov->dofpv_prargs *
+						dof->dofh_secsize);
+	off_sec = (dof_sec_t *)(uintptr_t)(daddr + dof->dofh_secoff +
+					   prov->dofpv_proffs *
+						dof->dofh_secsize);
+
+	strtab = (char *)(uintptr_t)(daddr + str_sec->dofs_offset);
+	off = (uint32_t *)(uintptr_t)(daddr + off_sec->dofs_offset);
+	arg = (uint8_t *)(uintptr_t)(daddr + arg_sec->dofs_offset);
+	enoff = NULL;
+
+	/*
+	 * See dtrace_helper_provider_validate().
+	 */
+	if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &&
+	    prov->dofpv_prenoffs != DOF_SECT_NONE) {
+		enoff_sec = (dof_sec_t *)(uintptr_t)(daddr + dof->dofh_secoff +
+						     prov->dofpv_prenoffs *
+							dof->dofh_secsize);
+		enoff = (uint32_t *)(uintptr_t)(daddr +
+						enoff_sec->dofs_offset);
+	}
+
+	nprobes = prb_sec->dofs_size / prb_sec->dofs_entsize;
+
+	/*
+	 * Create the provider.
+	 */
+	dtrace_dofprov2hprov(&dhpv, prov, strtab);
+
+	dt_dbg_dof("    Creating provider %s for PID %d\n",
+		   strtab + prov->dofpv_name, pid);
+
+	/*
+	 * This used to just 'return;' when parg is NULL, but that causes the
+	 * cleanup code (dtrace_helper_provider_remove[_one]) to make a call
+	 * to dtms_remove_pid() for a provider that never got created.
+	 *
+	 * If we fail to provide this provider, mark it as something to ignore,
+	 * so we don't try to process it during cleanup.
+	 */
+	parg = mops->dtms_provide_pid(meta->dtm_arg, &dhpv, pid);
+	if (parg == NULL) {
+		sec->dofs_type = DOF_SECT_NONE;
+		return;
+	}
+
+	meta->dtm_count++;
+
+	/*
+	 * Create the probes.
+	 */
+	for (i = 0; i < nprobes; i++) {
+		probe = (dof_probe_t *)(uintptr_t)(daddr +
+						   prb_sec->dofs_offset +
+						   i * prb_sec->dofs_entsize);
+
+		dhpb.dthpb_mod = dhp->dofhp_mod;
+		dhpb.dthpb_func = strtab + probe->dofpr_func;
+		dhpb.dthpb_name = strtab + probe->dofpr_name;
+		dhpb.dthpb_base = probe->dofpr_addr;
+		dhpb.dthpb_offs = off + probe->dofpr_offidx;
+		dhpb.dthpb_noffs = probe->dofpr_noffs;
+
+		if (enoff != NULL) {
+			dhpb.dthpb_enoffs = enoff + probe->dofpr_enoffidx;
+			dhpb.dthpb_nenoffs = probe->dofpr_nenoffs;
+		} else {
+			dhpb.dthpb_enoffs = NULL;
+			dhpb.dthpb_nenoffs = 0;
+		}
+
+		dhpb.dthpb_args = arg + probe->dofpr_argidx;
+		dhpb.dthpb_nargc = probe->dofpr_nargc;
+		dhpb.dthpb_xargc = probe->dofpr_xargc;
+		dhpb.dthpb_ntypes = strtab + probe->dofpr_nargv;
+		dhpb.dthpb_xtypes = strtab + probe->dofpr_xargv;
+
+		dt_dbg_dof("      Creating probe %s:%s:%s:%s\n",
+			   strtab + prov->dofpv_name, "", dhpb.dthpb_func,
+			   dhpb.dthpb_name);
+
+		mops->dtms_create_probe(meta->dtm_arg, parg, &dhpb);
+	}
+}
+
+void dtrace_helper_provide(dof_helper_t *dhp, pid_t pid)
+{
+	uintptr_t	daddr = (uintptr_t)dhp->dofhp_dof;
+	dof_hdr_t	*dof = (dof_hdr_t *)daddr;
+	int		i;
+
+	ASSERT(MUTEX_HELD(&dtrace_meta_lock));
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		dof_sec_t	*sec = (dof_sec_t *)(uintptr_t)
+					(daddr + dof->dofh_secoff +
+						 i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_PROVIDER)
+			continue;
+
+		dtrace_helper_provide_one(dhp, sec, pid);
+	}
+
+	/*
+	 * We may have just created probes, so we must now rematch against any
+	 * retained enablings.  Note that this call will acquire both cpu_lock
+	 * and dtrace_lock; the fact that we are holding dtrace_meta_lock now
+	 * is what defines the ordering with respect to these three locks.
+	 */
+	dt_dbg_dof("    Re-matching against any retained enablings\n");
+	dtrace_enabling_matchall();
+}
+
+static void dtrace_helper_provider_register(struct task_struct *tsk,
+					    dtrace_helpers_t *dth,
+					    dof_helper_t *dofhp)
+{
+	ASSERT(!MUTEX_HELD(&dtrace_lock));
+
+	mutex_lock(&dtrace_meta_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (!dtrace_attached() || dtrace_meta_pid == NULL) {
+		dt_dbg_dof("    No meta provider registered -- deferred\n");
+
+		/*
+		 * If the dtrace module is loaded but not attached, or if there
+		 * isn't a meta provider registered to deal with these provider
+		 * descriptions, we need to postpone creating the actual
+		 * providers until later.
+		 */
+		if (dth->dthps_next == NULL && dth->dthps_prev == NULL &&
+		    dtrace_deferred_pid != dth) {
+			dth->dthps_deferred = 1;
+			dth->dthps_pid = tsk->pid;
+			dth->dthps_next = dtrace_deferred_pid;
+			dth->dthps_prev = NULL;
+			if (dtrace_deferred_pid != NULL)
+				dtrace_deferred_pid->dthps_prev = dth;
+			dtrace_deferred_pid = dth;
+		}
+
+		mutex_unlock(&dtrace_lock);
+	} else if (dofhp != NULL) {
+		/*
+		 * If the dtrace module is loaded and we have a particular
+		 * helper provider description, pass that off to the meta
+		 * provider.
+		 */
+		mutex_unlock(&dtrace_lock);
+
+		dtrace_helper_provide(dofhp, tsk->pid);
+	} else {
+		/*
+		 * Otherwise, just pass all the helper provider descriptions
+		 * off to the meta provider.
+		 */
+		int	i;
+
+		mutex_unlock(&dtrace_lock);
+
+		for (i = 0; i < dth->dthps_nprovs; i++) {
+			dtrace_helper_provide(&dth->dthps_provs[i]->dthp_prov,
+					      tsk->pid);
+		}
+	}
+
+	mutex_unlock(&dtrace_meta_lock);
+}
+
+int dtrace_helper_slurp(dof_hdr_t *dof, dof_helper_t *dhp)
+{
+	dtrace_helpers_t	*dth;
+	dtrace_vstate_t		*vstate;
+	dtrace_enabling_t	*enab = NULL;
+	int			i, gen, rv;
+	int			nhelpers = 0, nprovs = 0,destroy = 1;
+	uintptr_t		daddr = (uintptr_t)dof;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if ((dth = current->dtrace_helpers) == NULL)
+		dth = dtrace_helpers_create(current);
+
+	if (dth == NULL) {
+		dtrace_dof_destroy(dof);
+		return -1;
+	}
+
+	dt_dbg_dof("DOF 0x%p from helper {'%s', %p, %p}...\n",
+		   dof, dhp ? dhp->dofhp_mod : "<none>",
+			dhp ? (void *)(dhp->dofhp_addr) : NULL,
+			dhp ? (void *)(dhp->dofhp_dof) : NULL);
+
+	vstate = &dth->dthps_vstate;
+
+	if ((rv = dtrace_dof_slurp(dof, vstate, NULL, &enab,
+				   dhp != NULL ? dhp->dofhp_addr : 0,
+				   FALSE)) != 0) {
+		dtrace_dof_destroy(dof);
+		return rv;
+	}
+
+	/*
+	 * Look for helper providers and validate their descriptions.
+	 */
+	if (dhp != NULL) {
+		dt_dbg_dof("  DOF 0x%p Validating providers...\n", dof);
+
+		for (i = 0; i < dof->dofh_secnum; i++) {
+			dof_sec_t	*sec = (dof_sec_t *)(uintptr_t)
+						(daddr + dof->dofh_secoff +
+						 i * dof->dofh_secsize);
+
+			if (sec->dofs_type != DOF_SECT_PROVIDER)
+				continue;
+
+			if (dtrace_helper_provider_validate(dof, sec) != 0) {
+				dtrace_enabling_destroy(enab);
+				dtrace_dof_destroy(dof);
+				return -1;
+			}
+
+			nprovs++;
+		}
+	}
+
+	/*
+	 * Now we need to walk through the ECB descriptions in the enabling.
+	 */
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		dtrace_ecbdesc_t	*ep = enab->dten_desc[i];
+		dtrace_probedesc_t	*desc = &ep->dted_probe;
+
+		dt_dbg_dof("  ECB Desc %s:%s:%s:%s\n",
+			   desc->dtpd_provider, desc->dtpd_mod,
+			   desc->dtpd_func, desc->dtpd_name);
+		if (strcmp(desc->dtpd_provider, "dtrace") != 0)
+			continue;
+
+		if (strcmp(desc->dtpd_mod, "helper") != 0)
+			continue;
+
+		if (strcmp(desc->dtpd_func, "ustack") != 0)
+			continue;
+
+		if ((rv = dtrace_helper_action_add(DTRACE_HELPER_ACTION_USTACK,
+						   ep)) != 0) {
+			/*
+			 * Adding this helper action failed -- we are now going
+			 * to rip out the entire generation and return failure.
+			 */
+			dtrace_helper_destroygen(dth->dthps_generation);
+			dtrace_enabling_destroy(enab);
+			dtrace_dof_destroy(dof);
+			return -1;
+		}
+
+		nhelpers++;
+	}
+
+	if (nhelpers < enab->dten_ndesc)
+		dtrace_dof_error(dof, "unmatched helpers");
+
+	gen = dth->dthps_generation++;
+	dtrace_enabling_destroy(enab);
+
+	if (dhp != NULL && nprovs > 0) {
+		dt_dbg_dof("  DOF 0x%p Adding and registering providers\n",
+			   dof);
+
+		dhp->dofhp_dof = (uint64_t)(uintptr_t)dof;
+		if (dtrace_helper_provider_add(dhp, gen) == 0) {
+			mutex_unlock(&dtrace_lock);
+			dtrace_helper_provider_register(current, dth, dhp);
+			mutex_lock(&dtrace_lock);
+
+			destroy = 0;
+		}
+	}
+
+	if (destroy)
+		dtrace_dof_destroy(dof);
+
+	return gen;
+}
+
+void dtrace_helpers_destroy(struct task_struct *tsk)
+{
+	dtrace_helpers_t	*help;
+	dtrace_vstate_t		*vstate;
+	int			i;
+
+	mutex_lock(&dtrace_lock);
+
+	ASSERT(tsk->dtrace_helpers != NULL);
+	ASSERT(dtrace_helpers > 0);
+
+	dt_dbg_dof("Helper cleanup: PID %d\n", tsk->pid);
+
+	help = tsk->dtrace_helpers;
+	vstate = &help->dthps_vstate;
+
+	/*
+	 * We're now going to lose the help from this process.
+	 */
+	tsk->dtrace_helpers = NULL;
+	dtrace_sync();
+
+	/*
+	 * Destory the helper actions.
+	 */
+	for (i = 0; i < DTRACE_NHELPER_ACTIONS; i++) {
+		dtrace_helper_action_t	*h, *next;
+
+		for (h = help->dthps_actions[i]; h != NULL; h = next) {
+			next = h->dtha_next;
+			dtrace_helper_action_destroy(h, vstate);
+			h = next;
+		}
+	}
+
+	mutex_unlock(&dtrace_lock);
+
+	/*
+	 * Destroy the helper providers.
+	 */
+	if (help->dthps_maxprovs > 0) {
+		mutex_lock(&dtrace_meta_lock);
+		if (dtrace_meta_pid != NULL) {
+			ASSERT(dtrace_deferred_pid == NULL);
+
+			for (i = 0; i < help->dthps_nprovs; i++) {
+				dtrace_helper_provider_remove(
+					&help->dthps_provs[i]->dthp_prov,
+					tsk->pid);
+			}
+		} else {
+			mutex_lock(&dtrace_lock);
+			ASSERT(help->dthps_deferred == 0 ||
+			       help->dthps_next != NULL ||
+			       help->dthps_prev != NULL ||
+			       help == dtrace_deferred_pid);
+
+			/*
+			 * Remove the helper from the deferred list.
+			 */
+			if (help->dthps_next != NULL)
+				help->dthps_next->dthps_prev = help->dthps_prev;
+			if (help->dthps_prev != NULL)
+				help->dthps_prev->dthps_next = help->dthps_next;
+			if (dtrace_deferred_pid == help) {
+				dtrace_deferred_pid = help->dthps_next;
+				ASSERT(help->dthps_prev == NULL);
+			}
+
+			mutex_unlock(&dtrace_lock);
+		}
+
+		mutex_unlock(&dtrace_meta_lock);
+
+		for (i = 0; i < help->dthps_nprovs; i++)
+			dtrace_helper_provider_destroy(help->dthps_provs[i]);
+
+		vfree(help->dthps_provs);
+	}
+
+	mutex_lock(&dtrace_lock);
+
+	dtrace_vstate_fini(&help->dthps_vstate);
+	vfree(help->dthps_actions);
+	kfree(help);
+
+	--dtrace_helpers;
+	mutex_unlock(&dtrace_lock);
+}
+
+void dtrace_helpers_duplicate(struct task_struct *from, struct task_struct *to)
+{
+	dtrace_helpers_t	*help, *newhelp;
+	dtrace_helper_action_t	*helper, *new, *last;
+	dtrace_difo_t		*dp;
+	dtrace_vstate_t		*vstate;
+	int			i, j, sz, hasprovs = 0;
+
+	mutex_lock(&dtrace_lock);
+
+	ASSERT(from->dtrace_helpers != NULL);
+	ASSERT(dtrace_helpers > 0);
+
+	help = from->dtrace_helpers;
+	newhelp = dtrace_helpers_create(to);
+
+	ASSERT(to->dtrace_helpers != NULL);
+
+	newhelp->dthps_generation = help->dthps_generation;
+	vstate = &newhelp->dthps_vstate;
+
+	/*
+	 * Duplicate the helper actions.
+	 */
+	for (i = 0; i < DTRACE_NHELPER_ACTIONS; i++) {
+		if ((helper = help->dthps_actions[i]) == NULL)
+			continue;
+
+		for (last = NULL; helper != NULL; helper = helper->dtha_next) {
+			new = kzalloc(sizeof(dtrace_helper_action_t),
+				      GFP_KERNEL);
+			new->dtha_generation = helper->dtha_generation;
+
+			if ((dp = helper->dtha_predicate) != NULL) {
+				dp = dtrace_difo_duplicate(dp, vstate);
+				new->dtha_predicate = dp;
+			}
+
+			new->dtha_nactions = helper->dtha_nactions;
+			sz = sizeof(dtrace_difo_t *) * new->dtha_nactions;
+			new->dtha_actions = vmalloc(sz);
+
+			for (j = 0; j < new->dtha_nactions; j++) {
+				dtrace_difo_t	*dp = helper->dtha_actions[j];
+
+				ASSERT(dp != NULL);
+
+				dp = dtrace_difo_duplicate(dp, vstate);
+				new->dtha_actions[j] = dp;
+			}
+
+			if (last != NULL)
+				last->dtha_next = new;
+			else
+				newhelp->dthps_actions[i] = new;
+
+			last = new;
+		}
+	}
+
+	/*
+	 * Duplicate the helper providers and register them with the
+	 * DTrace framework.
+	 */
+	if (help->dthps_nprovs > 0) {
+		newhelp->dthps_nprovs = help->dthps_nprovs;
+		newhelp->dthps_maxprovs = help->dthps_nprovs;
+		newhelp->dthps_provs = vmalloc(
+					newhelp->dthps_nprovs *
+					sizeof(dtrace_helper_provider_t *));
+
+		for (i = 0; i < newhelp->dthps_nprovs; i++) {
+			newhelp->dthps_provs[i] = help->dthps_provs[i];
+			newhelp->dthps_provs[i]->dthp_ref++;
+		}
+
+		hasprovs = 1;
+	}
+
+	mutex_unlock(&dtrace_lock);
+
+	if (hasprovs)
+		dtrace_helper_provider_register(to, newhelp, NULL);
+}
+
+int dtrace_helper_destroygen(int gen)
+{
+	struct task_struct	*p = current;
+	dtrace_helpers_t	*dth = p->dtrace_helpers;
+	dtrace_vstate_t		*vstate;
+	int			i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (dth == NULL || gen > dth->dthps_generation)
+		return -EINVAL;
+
+	vstate = &dth->dthps_vstate;
+
+	for (i = 0; i < DTRACE_NHELPER_ACTIONS; i++) {
+		dtrace_helper_action_t	*last = NULL, *h, *next;
+
+		for (h = dth->dthps_actions[i]; h != NULL; h = next) {
+			next = h->dtha_next;
+
+			dt_dbg_dof("  Comparing action (agen %d vs rgen %d)\n",
+				   h->dtha_generation, gen);
+
+			if (h->dtha_generation == gen) {
+				if (last != NULL)
+					last->dtha_next = next;
+				else
+					dth->dthps_actions[i] = next;
+
+				dtrace_helper_action_destroy(h, vstate);
+			} else
+				last = h;
+		}
+	}
+
+	/*
+	 * Iterate until we've cleared out all helper providers with the given
+	 * generation number.
+	 */
+	for (;;) {
+		dtrace_helper_provider_t	*prov = NULL;
+
+		/*
+		 * Look for a helper provider with the right generation.  We
+		 * have to start back at the beginning of the list each time
+		 * because we drop dtrace_lock.  It's unlikely that we'll make
+		 * more than two passes.
+		 */
+		for (i = 0; i < dth->dthps_nprovs; i++) {
+			prov = dth->dthps_provs[i];
+
+			if (prov->dthp_generation == gen)
+				break;
+		}
+
+		/*
+		 * If there were no matches, we are done.
+		 */
+		if (i == dth->dthps_nprovs)
+			break;
+
+		dt_dbg_dof("  Found provider with gen %d\n", gen);
+
+		/*
+		 * Move the last helper provider into this slot.
+		 */
+		dth->dthps_nprovs--;
+		dth->dthps_provs[i] = dth->dthps_provs[dth->dthps_nprovs];
+		dth->dthps_provs[dth->dthps_nprovs] = NULL;
+
+		mutex_unlock(&dtrace_lock);
+
+		/*
+		 * If we have a meta provider, remove this helper provider.
+		 */
+		mutex_lock(&dtrace_meta_lock);
+
+		if (dtrace_meta_pid != NULL) {
+			ASSERT(dtrace_deferred_pid == NULL);
+
+			dtrace_helper_provider_remove(&prov->dthp_prov,
+						      p->pid);
+		}
+
+		mutex_unlock(&dtrace_meta_lock);
+
+		dtrace_helper_provider_destroy(prov);
+
+		mutex_lock(&dtrace_lock);
+	}
+
+	return 0;
+}
+
+static void dtrace_helper_trace(dtrace_helper_action_t *helper,
+				dtrace_mstate_t *mstate,
+				dtrace_vstate_t *vstate, int where)
+{
+	uint32_t		size, next, nnext, i;
+	dtrace_helptrace_t	*ent;
+	uint16_t		flags = this_cpu_core->cpuc_dtrace_flags;
+
+	if (!dtrace_helptrace_enabled)
+		return;
+
+	ASSERT(vstate->dtvs_nlocals <= dtrace_helptrace_nlocals);
+
+	/*
+	 * What would a tracing framework be without its own tracing
+	 * framework?  (Well, a hell of a lot simpler, for starters...)
+	 */
+	size = sizeof(dtrace_helptrace_t) + dtrace_helptrace_nlocals *
+	       sizeof(uint64_t) - sizeof(uint64_t);
+
+	/*
+	 * Iterate until we can allocate a slot in the trace buffer.
+	 */
+	do {
+		next = dtrace_helptrace_next;
+
+		if (next + size < dtrace_helptrace_bufsize)
+			nnext = next + size;
+		else
+			nnext = size;
+	} while (cmpxchg(&dtrace_helptrace_next, next, nnext) != next);
+
+	/*
+	 * We have our slot; fill it in.
+	*/
+	if (nnext == size)
+		next = 0;
+
+	ent = (dtrace_helptrace_t *)&dtrace_helptrace_buffer[next];
+	ent->dtht_helper = helper;
+	ent->dtht_where = where;
+	ent->dtht_nlocals = vstate->dtvs_nlocals;
+
+	ent->dtht_fltoffs = (mstate->dtms_present & DTRACE_MSTATE_FLTOFFS)
+				?  mstate->dtms_fltoffs
+				: -1;
+	ent->dtht_fault = DTRACE_FLAGS2FLT(flags);
+	ent->dtht_illval = this_cpu_core->cpuc_dtrace_illval;
+
+	for (i = 0; i < vstate->dtvs_nlocals; i++) {
+		dtrace_statvar_t	*svar;
+
+		if ((svar = vstate->dtvs_locals[i]) == NULL)
+			continue;
+
+		ASSERT(svar->dtsv_size >= NR_CPUS * sizeof(uint64_t));
+		ent->dtht_locals[i] =
+			((uint64_t *)(uintptr_t)svar->dtsv_data)[
+							smp_processor_id()];
+	}
+}
+
+uint64_t dtrace_helper(int which, dtrace_mstate_t *mstate,
+		       dtrace_state_t *state, uint64_t arg0, uint64_t arg1)
+{
+	uint16_t		*flags = &this_cpu_core->cpuc_dtrace_flags;
+	uint64_t		sarg0 = mstate->dtms_arg[0];
+	uint64_t		sarg1 = mstate->dtms_arg[1];
+	uint64_t		rval = 0;
+	dtrace_helpers_t	*helpers = current->dtrace_helpers;
+	dtrace_helper_action_t	*helper;
+	dtrace_vstate_t		*vstate;
+	dtrace_difo_t		*pred;
+	int			i, trace = dtrace_helptrace_enabled;
+
+	ASSERT(which >= 0 && which < DTRACE_NHELPER_ACTIONS);
+
+	if (helpers == NULL)
+		return 0;
+
+	if ((helper = helpers->dthps_actions[which]) == NULL)
+		return 0;
+
+	vstate = &helpers->dthps_vstate;
+	mstate->dtms_arg[0] = arg0;
+	mstate->dtms_arg[1] = arg1;
+
+	/*
+	 * Now iterate over each helper.  If its predicate evaluates to 'true',
+	 * we'll call the corresponding actions.  Note that the below calls
+	 * to dtrace_dif_emulate() may set faults in machine state.  This is
+	 * okay:  our caller (the outer dtrace_dif_emulate()) will simply plow
+	 * the stored DIF offset with its own (which is the desired behavior).
+	 * Also, note the calls to dtrace_dif_emulate() may allocate scratch
+	 * from machine state; this is okay, too.
+	 */
+	for (; helper != NULL; helper = helper->dtha_next) {
+		if ((pred = helper->dtha_predicate) != NULL) {
+			if (trace)
+				dtrace_helper_trace(helper, mstate, vstate, 0);
+
+			if (!dtrace_dif_emulate(pred, mstate, vstate, state))
+				goto next;
+
+			if (*flags & CPU_DTRACE_FAULT)
+				goto err;
+		}
+
+		for (i = 0; i < helper->dtha_nactions; i++) {
+			if (trace)
+				dtrace_helper_trace(helper, mstate, vstate,
+						    i + 1);
+
+			rval = dtrace_dif_emulate(helper->dtha_actions[i],
+						  mstate, vstate, state);
+
+			if (*flags & CPU_DTRACE_FAULT)
+				goto err;
+		}
+
+next:
+		if (trace)
+			dtrace_helper_trace(helper, mstate, vstate,
+					    DTRACE_HELPTRACE_NEXT);
+	}
+
+	if (trace)
+		dtrace_helper_trace(helper, mstate, vstate,
+				    DTRACE_HELPTRACE_DONE);
+
+	/*
+	 * Restore the arg0 that we saved upon entry.
+	 */
+	mstate->dtms_arg[0] = sarg0;
+	mstate->dtms_arg[1] = sarg1;
+
+	return rval;
+
+err:
+	if (trace)
+		dtrace_helper_trace(helper, mstate, vstate,
+				    DTRACE_HELPTRACE_ERR);
+
+	/*
+	 * Restore the arg0 that we saved upon entry.
+	 */
+	mstate->dtms_arg[0] = sarg0;
+	mstate->dtms_arg[1] = sarg1;
+
+	return 0;
+}
diff --git a/dtrace/dtrace_ecb.c b/dtrace/dtrace_ecb.c
new file mode 100644
index 000000000000..4e551a4ea318
--- /dev/null
+++ b/dtrace/dtrace_ecb.c
@@ -0,0 +1,904 @@
+/*
+ * FILE:	dtrace_ecb.c
+ * DESCRIPTION:	DTrace - ECB implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+dtrace_ecb_t	*dtrace_ecb_create_cache;
+
+static dtrace_action_t *dtrace_ecb_aggregation_create(dtrace_ecb_t *ecb,
+						      dtrace_actdesc_t *desc)
+{
+	dtrace_aggregation_t	*agg;
+	size_t			size = sizeof(uint64_t);
+	int			ntuple = desc->dtad_ntuple;
+	dtrace_action_t		*act;
+	dtrace_recdesc_t	*frec;
+	dtrace_aggid_t		aggid;
+	dtrace_state_t		*state = ecb->dte_state;
+
+	agg = kzalloc(sizeof(dtrace_aggregation_t), GFP_KERNEL);
+	if (agg == NULL)
+		return NULL;
+
+	agg->dtag_ecb = ecb;
+
+	ASSERT(DTRACEACT_ISAGG(desc->dtad_kind));
+
+	switch (desc->dtad_kind) {
+	case DTRACEAGG_MIN:
+		agg->dtag_initial = INT64_MAX;
+		agg->dtag_aggregate = dtrace_aggregate_min;
+		break;
+
+	case DTRACEAGG_MAX:
+		agg->dtag_initial = INT64_MIN;
+		agg->dtag_aggregate = dtrace_aggregate_max;
+		break;
+
+	case DTRACEAGG_COUNT:
+		agg->dtag_aggregate = dtrace_aggregate_count;
+		break;
+
+	case DTRACEAGG_QUANTIZE:
+		agg->dtag_aggregate = dtrace_aggregate_quantize;
+		size = (((sizeof(uint64_t) * NBBY) - 1) * 2 + 1) *
+		       sizeof(uint64_t);
+		break;
+
+	case DTRACEAGG_LQUANTIZE: {
+		uint16_t	step = DTRACE_LQUANTIZE_STEP(desc->dtad_arg);
+		uint16_t	levels =
+				DTRACE_LQUANTIZE_LEVELS(desc->dtad_arg);
+
+		agg->dtag_initial = desc->dtad_arg;
+		agg->dtag_aggregate = dtrace_aggregate_lquantize;
+
+		if (step == 0 || levels == 0)
+			goto err;
+
+		size = levels * sizeof(uint64_t) + 3 * sizeof(uint64_t);
+		break;
+	}
+
+	case DTRACEAGG_LLQUANTIZE: {
+		uint16_t factor = DTRACE_LLQUANTIZE_FACTOR(desc->dtad_arg);
+		uint16_t lmag = DTRACE_LLQUANTIZE_LMAG(desc->dtad_arg);
+		uint16_t hmag = DTRACE_LLQUANTIZE_HMAG(desc->dtad_arg);
+		uint16_t steps = DTRACE_LLQUANTIZE_STEPS(desc->dtad_arg);
+
+		agg->dtag_initial = desc->dtad_arg;
+		agg->dtag_aggregate = dtrace_aggregate_llquantize;
+
+		/*
+		 * 64 is the largest hmag can practically be (for the smallest
+		 * possible value of factor, 2).  libdtrace has already checked
+		 * for overflow, so if hmag > 64, we have corrupted DOF.
+		 */
+		if (factor < 2 || steps == 0 || hmag > 64)
+			goto err;
+
+		/*
+		 * The size of the buffer for an llquantize() is given by:
+		 *   (hmag-lmag+1) logarithmic ranges
+		 *   x
+		 *   (steps - steps/factor) bins per range
+		 *   x
+		 *   2 signs
+		 *   +
+		 *   two overflow bins
+		 *   +
+		 *   one underflow bin
+		 *   +
+		 *   beginning word to encode factor,lmag,hmag,steps
+		 */
+		size = ((hmag-lmag+1)*(steps-steps/factor)*2+4) * sizeof (uint64_t);
+		break;
+	}
+
+	case DTRACEAGG_AVG:
+		agg->dtag_aggregate = dtrace_aggregate_avg;
+		size = sizeof(uint64_t) * 2;
+		break;
+
+	case DTRACEAGG_STDDEV:
+		agg->dtag_aggregate = dtrace_aggregate_stddev;
+		size = sizeof(uint64_t) * 4;
+		break;
+
+	case DTRACEAGG_SUM:
+		agg->dtag_aggregate = dtrace_aggregate_sum;
+		break;
+
+	default:
+		goto err;
+	}
+
+	agg->dtag_action.dta_rec.dtrd_size = size;
+
+	if (ntuple == 0)
+		goto err;
+
+	for (act = ecb->dte_action_last; act != NULL; act = act->dta_prev) {
+		if (DTRACEACT_ISAGG(act->dta_kind))
+			break;
+
+		if (--ntuple == 0) {
+			agg->dtag_first = act;
+			goto success;
+		}
+	}
+
+	ASSERT(ntuple != 0);
+err:
+	kfree(agg);
+	return NULL;
+
+success:
+	ASSERT(ecb->dte_action_last != NULL);
+	act = ecb->dte_action_last;
+
+	if (act->dta_kind == DTRACEACT_DIFEXPR) {
+		ASSERT(act->dta_difo != NULL);
+
+		if (act->dta_difo->dtdo_rtype.dtdt_size == 0)
+			agg->dtag_hasarg = 1;
+	}
+
+	/*
+	 * Get an ID for the aggregation (add it to the idr).
+	 */
+	idr_preload(GFP_KERNEL);
+	aggid = idr_alloc_cyclic(&state->dts_agg_idr, agg, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+	if (aggid < 0) {
+		/* FIXME: need to handle this */
+	}
+
+	state->dts_naggs++;
+	agg->dtag_id = aggid;
+
+	frec = &agg->dtag_first->dta_rec;
+	if (frec->dtrd_alignment < sizeof(dtrace_aggid_t))
+		frec->dtrd_alignment = sizeof(dtrace_aggid_t);
+
+	for (act = agg->dtag_first; act != NULL; act = act->dta_next) {
+		ASSERT(!act->dta_intuple);
+
+		act->dta_intuple = 1;
+	}
+
+	return &agg->dtag_action;
+}
+
+void dtrace_ecb_aggregation_destroy(dtrace_ecb_t *ecb, dtrace_action_t *act)
+{
+	dtrace_aggregation_t	*agg = (dtrace_aggregation_t *)act;
+	dtrace_state_t		*state = ecb->dte_state;
+
+	ASSERT(DTRACEACT_ISAGG(act->dta_kind));
+
+	idr_remove(&state->dts_agg_idr, agg->dtag_id);
+	state->dts_naggs--;
+
+	kfree(agg);
+}
+
+static int dtrace_ecb_action_add(dtrace_ecb_t *ecb, dtrace_actdesc_t *desc)
+{
+	dtrace_action_t		*action, *last;
+	dtrace_difo_t		*dp = desc->dtad_difo;
+	uint32_t		size = 0, align = sizeof(uint8_t), mask;
+	uint16_t		format = 0;
+	dtrace_recdesc_t	*rec;
+	dtrace_state_t		*state = ecb->dte_state;
+	dtrace_optval_t		*opt = state->dts_options, nframes, strsize;
+	uint64_t		arg = desc->dtad_arg;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(ecb->dte_action == NULL || ecb->dte_action->dta_refcnt == 1);
+
+	if (DTRACEACT_ISAGG(desc->dtad_kind)) {
+		dtrace_action_t	*act;
+
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (act->dta_kind == DTRACEACT_COMMIT)
+				return -EINVAL;
+
+			if (act->dta_kind == DTRACEACT_SPECULATE)
+				return -EINVAL;
+		}
+
+		action = dtrace_ecb_aggregation_create(ecb, desc);
+		if (action == NULL)
+			return -EINVAL;
+	} else {
+		if (DTRACEACT_ISDESTRUCTIVE(desc->dtad_kind) ||
+		    (desc->dtad_kind == DTRACEACT_DIFEXPR &&
+		     dp != NULL && dp->dtdo_destructive))
+			state->dts_destructive = 1;
+
+		switch (desc->dtad_kind) {
+		case DTRACEACT_PRINTF:
+		case DTRACEACT_PRINTA:
+		case DTRACEACT_SYSTEM:
+		case DTRACEACT_FREOPEN:
+			if ((void *)(uintptr_t)arg == NULL) {
+				ASSERT(desc->dtad_kind == DTRACEACT_PRINTA);
+	
+				format = 0;
+			} else {
+				ASSERT((void *)(uintptr_t)arg != NULL);
+#ifdef FIXME
+				ASSERT(arg > KERNELBASE);
+#endif
+
+				format = dtrace_format_add(
+						state, (char *)(uintptr_t)arg);
+			}
+
+		case DTRACEACT_TRACEMEM:
+		case DTRACEACT_LIBACT:
+		case DTRACEACT_DIFEXPR:
+			if (dp == NULL)
+				return -EINVAL;
+
+			if ((size = dp->dtdo_rtype.dtdt_size) != 0)
+				break;
+
+			if (dp->dtdo_rtype.dtdt_kind == DIF_TYPE_STRING) {
+				if (!(dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+					return -EINVAL;
+
+				size = opt[DTRACEOPT_STRSIZE];
+			}
+
+			break;
+
+		case DTRACEACT_STACK:
+			if ((nframes = arg) == 0) {
+				nframes = opt[DTRACEOPT_STACKFRAMES];
+
+				ASSERT(nframes > 0);
+
+				arg = nframes;
+			}
+
+			size = nframes * sizeof(uint64_t);
+			break;
+
+		case DTRACEACT_JSTACK:
+			if ((strsize = DTRACE_USTACK_STRSIZE(arg)) == 0)
+				strsize = opt[DTRACEOPT_JSTACKSTRSIZE];
+
+			if ((nframes = DTRACE_USTACK_NFRAMES(arg)) == 0)
+				nframes = opt[DTRACEOPT_JSTACKFRAMES];
+
+			arg = DTRACE_USTACK_ARG(nframes, strsize);
+
+		case DTRACEACT_USTACK:
+			if (desc->dtad_kind != DTRACEACT_JSTACK &&
+			    (nframes = DTRACE_USTACK_NFRAMES(arg)) == 0) {
+				strsize = DTRACE_USTACK_STRSIZE(arg);
+				nframes = opt[DTRACEOPT_USTACKFRAMES];
+
+				ASSERT(nframes > 0);
+
+				arg = DTRACE_USTACK_ARG(nframes, strsize);
+			}
+
+			size = (nframes + 2) * sizeof(uint64_t);
+			size += DTRACE_USTACK_STRSIZE(arg);
+			size = P2ROUNDUP(size, (uint32_t)(sizeof(uintptr_t)));
+
+			break;
+
+		case DTRACEACT_SYM:
+		case DTRACEACT_MOD:
+			if (dp == NULL || ((size = dp->dtdo_rtype.dtdt_size) !=
+					   sizeof(uint64_t)) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_USYM:
+		case DTRACEACT_UMOD:
+		case DTRACEACT_UADDR:
+			if (dp == NULL ||
+			    (dp->dtdo_rtype.dtdt_size != sizeof(uint64_t)) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			size = 3 * sizeof(uint64_t);
+
+			break;
+
+		case DTRACEACT_STOP:
+		case DTRACEACT_BREAKPOINT:
+		case DTRACEACT_PANIC:
+			break;
+
+		case DTRACEACT_CHILL:
+		case DTRACEACT_DISCARD:
+		case DTRACEACT_RAISE:
+			if (dp == NULL)
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_EXIT:
+			if (dp == NULL || (size = dp->dtdo_rtype.dtdt_size) !=
+					   sizeof(int) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_SPECULATE:
+			if (ecb->dte_size > sizeof(dtrace_epid_t))
+				return -EINVAL;
+
+			if (dp == NULL)
+				return -EINVAL;
+
+			state->dts_speculates = 1;
+
+			break;
+
+		case DTRACEACT_COMMIT: {
+			dtrace_action_t	*act = ecb->dte_action;
+
+			for (; act != NULL; act = act->dta_next) {
+				if (act->dta_kind == DTRACEACT_COMMIT)
+					return -EINVAL;
+			}
+
+			if (dp == NULL)
+				return -EINVAL;
+
+			break;
+		}
+
+		default:
+			return -EINVAL;
+		}
+
+		if (size != 0 || desc->dtad_kind == DTRACEACT_SPECULATE) {
+			dtrace_action_t	*act = ecb->dte_action;
+
+			for (; act != NULL; act = act->dta_next) {
+				if (act->dta_kind == DTRACEACT_COMMIT)
+					return -EINVAL;
+			}
+		}
+
+		action = kzalloc(sizeof(dtrace_action_t), GFP_KERNEL);
+		if (action == NULL)
+			return -ENOMEM;
+
+		action->dta_rec.dtrd_size = size;
+	}
+
+	action->dta_refcnt = 1;
+	rec = &action->dta_rec;
+	size = rec->dtrd_size;
+
+	for (mask = sizeof(uint64_t) - 1; size != 0 && mask > 0; mask >>= 1) {
+		if (!(size & mask)) {
+			align = mask + 1;
+
+			break;
+		}
+	}
+
+	action->dta_kind = desc->dtad_kind;
+
+	if ((action->dta_difo = dp) != NULL)
+		dtrace_difo_hold(dp);
+
+	rec->dtrd_action = action->dta_kind;
+	rec->dtrd_arg = arg;
+	rec->dtrd_uarg = desc->dtad_uarg;
+	rec->dtrd_alignment = (uint16_t)align;
+	rec->dtrd_format = format;
+
+	if ((last = ecb->dte_action_last) != NULL) {
+		ASSERT(ecb->dte_action != NULL);
+
+		action->dta_prev = last;
+		last->dta_next = action;
+	} else {
+		ASSERT(ecb->dte_action == NULL);
+
+		ecb->dte_action = action;
+	}
+
+	ecb->dte_action_last = action;
+
+	return 0;
+}
+
+static void dtrace_ecb_action_remove(dtrace_ecb_t *ecb)
+{
+	dtrace_action_t	*act = ecb->dte_action, *next;
+	dtrace_vstate_t	*vstate = &ecb->dte_state->dts_vstate;
+	dtrace_difo_t	*dp;
+	uint16_t	format;
+
+	if (act != NULL && act->dta_refcnt > 1) {
+		ASSERT(act->dta_next == NULL || act->dta_next->dta_refcnt == 1);
+
+		act->dta_refcnt--;
+	} else {
+		for (; act != NULL; act = next) {
+			next = act->dta_next;
+			ASSERT(next != NULL || act == ecb->dte_action_last);
+			ASSERT(act->dta_refcnt == 1);
+
+			if ((format = act->dta_rec.dtrd_format) != 0)
+				dtrace_format_remove(ecb->dte_state, format);
+
+			if ((dp = act->dta_difo) != NULL)
+				dtrace_difo_release(dp, vstate);
+
+			if (DTRACEACT_ISAGG(act->dta_kind))
+				dtrace_ecb_aggregation_destroy(ecb, act);
+			else
+				kfree(act);
+		}
+	}
+
+	ecb->dte_action = NULL;
+	ecb->dte_action_last = NULL;
+	ecb->dte_size = sizeof(dtrace_epid_t);
+}
+
+/*
+ * Disable the ECB by removing it from its probe.
+ */
+void dtrace_ecb_disable(dtrace_ecb_t *ecb)
+{
+	dtrace_ecb_t	*pecb, *prev = NULL;
+	dtrace_probe_t	*probe = ecb->dte_probe;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (probe == NULL)
+		return;
+
+	for (pecb = probe->dtpr_ecb; pecb != NULL; pecb = pecb->dte_next) {
+		if (pecb == ecb)
+			break;
+
+		prev = pecb;
+	}
+
+	ASSERT(pecb != NULL);
+
+	if (prev == NULL)
+		probe->dtpr_ecb = ecb->dte_next;
+	else
+		prev->dte_next = ecb->dte_next;
+
+	if (ecb == probe->dtpr_ecb_last) {
+		ASSERT(ecb->dte_next == NULL);
+		probe->dtpr_ecb_last = prev;
+	}
+
+	/*
+	 * The ECB has been disconnected from the probe; now sync to assure
+	 * that all CPUs have seen the change before returning.
+	 */
+	dtrace_sync();
+
+	if (probe->dtpr_ecb == NULL) {
+		/*
+		 * That was the last ECB on the probe; clear the predicate
+		 * cache ID for the probe, disable it and sync one more time
+		 * to assure that we'll never hit it again.
+		 */
+		dtrace_provider_t	*prov = probe->dtpr_provider;
+
+		ASSERT(ecb->dte_next == NULL);
+		ASSERT(probe->dtpr_ecb_last == NULL);
+
+		probe->dtpr_predcache = DTRACE_CACHEIDNONE;
+		prov->dtpv_pops.dtps_disable(prov->dtpv_arg,
+					     probe->dtpr_id, probe->dtpr_arg);
+
+		dtrace_sync();
+	} else {
+		/*
+		 * There is at least one ECB remaining on the probe.  If there
+		 * is _exactly_ one, set the probe's predicate cache ID to be
+		 * the predicate cache ID of the remaining ECB.
+		 */
+		ASSERT(probe->dtpr_ecb_last != NULL);
+		ASSERT(probe->dtpr_predcache == DTRACE_CACHEIDNONE);
+
+		if (probe->dtpr_ecb == probe->dtpr_ecb_last) {
+			dtrace_predicate_t	*p =
+						probe->dtpr_ecb->dte_predicate;
+
+			ASSERT(probe->dtpr_ecb->dte_next == NULL);
+
+			if (p != NULL)
+				probe->dtpr_predcache = p->dtp_cacheid;
+		}
+
+		ecb->dte_next = NULL;
+	}
+}
+
+static dtrace_ecb_t *dtrace_ecb_add(dtrace_state_t *state,
+				    dtrace_probe_t *probe)
+{
+	dtrace_ecb_t	*ecb;
+	dtrace_epid_t	epid;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	ecb = kzalloc(sizeof(dtrace_ecb_t), GFP_KERNEL);
+	if (ecb == NULL)
+		return NULL;
+
+	ecb->dte_predicate = NULL;
+	ecb->dte_probe = probe;
+	ecb->dte_size = ecb->dte_needed = sizeof(dtrace_epid_t);
+	ecb->dte_alignment = sizeof(dtrace_epid_t);
+
+	epid = state->dts_epid++;
+
+	if (epid - 1 >= state->dts_necbs) {
+		dtrace_ecb_t	**oecbs = state->dts_ecbs, **ecbs;
+		int		necbs = state->dts_necbs << 1;
+
+		ASSERT(epid == state->dts_necbs + 1);
+
+		if (necbs == 0) {
+			ASSERT(oecbs == NULL);
+
+			necbs = 1;
+		}
+
+		ecbs = vzalloc(necbs * sizeof(*ecbs));
+		if (ecbs == NULL) {
+			kfree(ecb);
+			return NULL;
+		}
+
+		if (oecbs != NULL)
+			memcpy(ecbs, oecbs, state->dts_necbs * sizeof(*ecbs));
+
+		dtrace_membar_producer();
+
+		state->dts_ecbs = ecbs;
+
+		if (oecbs != NULL) {
+			if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+				dtrace_sync();
+
+			vfree(oecbs);
+		}
+
+		dtrace_membar_producer();
+
+		state->dts_necbs = necbs;
+	}
+
+	ecb->dte_state = state;
+
+	ASSERT(state->dts_ecbs[epid - 1] == NULL);
+
+	dtrace_membar_producer();
+
+	state->dts_ecbs[(ecb->dte_epid = epid) - 1] = ecb;
+
+	return ecb;
+}
+
+static dtrace_ecb_t *dtrace_ecb_create(dtrace_state_t *state,
+				       dtrace_probe_t *probe,
+				       dtrace_enabling_t *enab)
+{
+	dtrace_ecb_t		*ecb;
+	dtrace_predicate_t	*pred;
+	dtrace_actdesc_t	*act;
+	dtrace_provider_t	*prov;
+	dtrace_ecbdesc_t	*desc = enab->dten_current;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(state != NULL);
+
+	ecb = dtrace_ecb_add(state, probe);
+	if (ecb == NULL)
+		return NULL;
+
+	ecb->dte_uarg = desc->dted_uarg;
+
+	if ((pred = desc->dted_pred.dtpdd_predicate) != NULL) {
+		dtrace_predicate_hold(pred);
+		ecb->dte_predicate = pred;
+	}
+
+	if (probe != NULL) {
+		prov = probe->dtpr_provider;
+
+		if (!(state->dts_cred.dcr_visible & DTRACE_CRV_ALLPROC) &&
+		    (prov->dtpv_priv.dtpp_flags & DTRACE_PRIV_USER))
+			ecb->dte_cond |= DTRACE_COND_OWNER;
+
+		if (!(state->dts_cred.dcr_visible & DTRACE_CRV_KERNEL) &&
+		    (prov->dtpv_priv.dtpp_flags & DTRACE_PRIV_KERNEL))
+			ecb->dte_cond |= DTRACE_COND_USERMODE;
+	}
+
+	if (dtrace_ecb_create_cache != NULL) {
+		dtrace_ecb_t	*cached = dtrace_ecb_create_cache;
+		dtrace_action_t	*act = cached->dte_action;
+
+		if (act != NULL) {
+			ASSERT(act->dta_refcnt > 0);
+
+			act->dta_refcnt++;
+			ecb->dte_action = act;
+			ecb->dte_action_last = cached->dte_action_last;
+			ecb->dte_needed = cached->dte_needed;
+			ecb->dte_size = cached->dte_size;
+			ecb->dte_alignment = cached->dte_alignment;
+		}
+
+		return ecb;
+	}
+
+	for (act = desc->dted_action; act != NULL; act = act->dtad_next) {
+		if ((enab->dten_error = dtrace_ecb_action_add(ecb, act)) != 0) {
+			dtrace_ecb_destroy(ecb);
+			return NULL;
+		}
+	}
+
+	dtrace_ecb_resize(ecb);
+
+	return (dtrace_ecb_create_cache = ecb);
+}
+
+int dtrace_ecb_create_enable(dtrace_probe_t *probe, void *arg)
+{
+	dtrace_ecb_t		*ecb;
+	dtrace_enabling_t	*enab = arg;
+	dtrace_state_t		*state = enab->dten_vstate->dtvs_state;
+
+	ASSERT(state != NULL);
+
+	if (probe != NULL && probe->dtpr_gen < enab->dten_probegen)
+		return DTRACE_MATCH_NEXT;
+
+	if ((ecb = dtrace_ecb_create(state, probe, enab)) == NULL)
+		return DTRACE_MATCH_DONE;
+
+	if (dtrace_ecb_enable(ecb) < 0)
+		return DTRACE_MATCH_FAIL;
+
+	return DTRACE_MATCH_NEXT;
+}
+
+void dtrace_ecb_destroy(dtrace_ecb_t *ecb)
+{
+	dtrace_state_t		*state = ecb->dte_state;
+	dtrace_vstate_t		*vstate = &state->dts_vstate;
+	dtrace_predicate_t	*pred;
+	dtrace_epid_t		epid = ecb->dte_epid;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(ecb->dte_next == NULL);
+	ASSERT(ecb->dte_probe == NULL || ecb->dte_probe->dtpr_ecb != ecb);
+
+	if ((pred = ecb->dte_predicate) != NULL)
+		dtrace_predicate_release(pred, vstate);
+
+	dtrace_ecb_action_remove(ecb);
+
+	ASSERT(state->dts_ecbs[epid - 1] == ecb);
+	state->dts_ecbs[epid - 1] = NULL;
+
+	kfree(ecb);
+}
+
+void dtrace_ecb_resize(dtrace_ecb_t *ecb)
+{
+	uint32_t	maxalign = sizeof(dtrace_epid_t);
+	uint32_t	align = sizeof(uint8_t), offs, diff;
+	dtrace_action_t	*act;
+	int		wastuple = 0;
+	uint32_t	aggbase = UINT32_MAX;
+	dtrace_state_t	*state = ecb->dte_state;
+
+	/*
+	 * If we record anything, we always record the epid.  (And we always
+	 * record it first.)
+	 */
+	offs = sizeof(dtrace_epid_t);
+	ecb->dte_size = ecb->dte_needed = sizeof(dtrace_epid_t);
+
+	for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+		dtrace_recdesc_t	*rec = &act->dta_rec;
+
+		if ((align = rec->dtrd_alignment) > maxalign)
+			maxalign = align;
+
+		if (!wastuple && act->dta_intuple) {
+			/*
+			 * This is the first record in a tuple.  Align the
+			 * offset to be at offset 4 in an 8-byte aligned
+			 * block.
+			 */
+			diff = offs + sizeof(dtrace_aggid_t);
+
+			if ((diff = (diff & (sizeof(uint64_t) - 1))))
+				offs += sizeof(uint64_t) - diff;
+
+			aggbase = offs - sizeof(dtrace_aggid_t);
+			ASSERT(!(aggbase & (sizeof(uint64_t) - 1)));
+		}
+
+		if (rec->dtrd_size != 0 && (diff = (offs & (align - 1)))) {
+			/*
+			 * The current offset is not properly aligned; align it.
+			 */
+			offs += align - diff;
+		}
+
+		rec->dtrd_offset = offs;
+
+		if (offs + rec->dtrd_size > ecb->dte_needed) {
+			ecb->dte_needed = offs + rec->dtrd_size;
+
+			if (ecb->dte_needed > state->dts_needed)
+				state->dts_needed = ecb->dte_needed;
+		}
+
+		if (DTRACEACT_ISAGG(act->dta_kind)) {
+			dtrace_aggregation_t	*agg =
+						(dtrace_aggregation_t *)act;
+			dtrace_action_t		*first = agg->dtag_first,
+						*prev;
+
+			ASSERT(rec->dtrd_size != 0 && first != NULL);
+			ASSERT(wastuple);
+			ASSERT(aggbase != UINT32_MAX);
+
+			agg->dtag_base = aggbase;
+
+			while ((prev = first->dta_prev) != NULL &&
+			       DTRACEACT_ISAGG(prev->dta_kind)) {
+				agg = (dtrace_aggregation_t *)prev;
+				first = agg->dtag_first;
+			}
+
+			if (prev != NULL) {
+				offs = prev->dta_rec.dtrd_offset +
+				prev->dta_rec.dtrd_size;
+			} else
+				offs = sizeof(dtrace_epid_t);
+
+			wastuple = 0;
+		} else {
+			if (!act->dta_intuple)
+				ecb->dte_size = offs + rec->dtrd_size;
+
+			offs += rec->dtrd_size;
+		}
+
+		wastuple = act->dta_intuple;
+	}
+
+	if ((act = ecb->dte_action) != NULL &&
+	    !(act->dta_kind == DTRACEACT_SPECULATE && act->dta_next == NULL) &&
+	    ecb->dte_size == sizeof(dtrace_epid_t)) {
+		/*
+		 * If the size is still sizeof(dtrace_epid_t), then all
+		 * actions store no data; set the size to 0.
+		 */
+		ecb->dte_alignment = maxalign;
+		ecb->dte_size = 0;
+
+		/*
+		 * If the needed space is still sizeof(dtrace_epid_t), then
+		 * all actions need no additional space; set the needed
+		 * size to 0.
+		 */
+		if (ecb->dte_needed == sizeof(dtrace_epid_t))
+			ecb->dte_needed = 0;
+
+		return;
+	}
+
+	/*
+	 * Set our alignment, and make sure that the dte_size and dte_needed
+	 * are aligned to the size of an EPID.
+	 */
+	ecb->dte_alignment = maxalign;
+	ecb->dte_size = (ecb->dte_size + (sizeof(dtrace_epid_t) - 1)) &
+			~(sizeof(dtrace_epid_t) - 1);
+	ecb->dte_needed = (ecb->dte_needed + (sizeof(dtrace_epid_t) - 1)) &
+			  ~(sizeof(dtrace_epid_t) - 1);
+	ASSERT(ecb->dte_size <= ecb->dte_needed);
+}
+
+int dtrace_ecb_enable(dtrace_ecb_t *ecb)
+{
+	dtrace_probe_t	*probe = ecb->dte_probe;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(ecb->dte_next == NULL);
+
+	if (probe == NULL)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL) {
+		dtrace_provider_t	*prov = probe->dtpr_provider;
+
+		probe->dtpr_ecb = probe->dtpr_ecb_last = ecb;
+
+
+		if (ecb->dte_predicate != NULL)
+			probe->dtpr_predcache = ecb->dte_predicate->dtp_cacheid;
+
+		return prov->dtpv_pops.dtps_enable(prov->dtpv_arg,
+						   probe->dtpr_id,
+						   probe->dtpr_arg);
+	} else {
+		ASSERT(probe->dtpr_ecb_last != NULL);
+
+		probe->dtpr_ecb_last->dte_next = ecb;
+		probe->dtpr_ecb_last = ecb;
+		probe->dtpr_predcache = 0;
+
+		dtrace_sync();
+
+		return 0;
+	}
+}
+
+dtrace_ecb_t *dtrace_epid2ecb(dtrace_state_t *state, dtrace_epid_t id)
+{
+	dtrace_ecb_t *ecb;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (id == 0 || id > state->dts_necbs)
+		return NULL;
+
+	ASSERT(state->dts_necbs > 0 && state->dts_ecbs != NULL);
+	ecb = state->dts_ecbs[id - 1];
+	ASSERT(ecb == NULL || ecb->dte_epid == id);
+
+	return ecb;
+}
+
+dtrace_aggregation_t *dtrace_aggid2agg(dtrace_state_t *state,
+				       dtrace_aggid_t id)
+{
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	return idr_find(&state->dts_agg_idr, id);
+}
diff --git a/dtrace/dtrace_enable.c b/dtrace/dtrace_enable.c
new file mode 100644
index 000000000000..00da5ed0a512
--- /dev/null
+++ b/dtrace/dtrace_enable.c
@@ -0,0 +1,443 @@
+/*
+ * FILE:	dtrace_enable.c
+ * DESCRIPTION:	DTrace - probe enabling implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+size_t			dtrace_retain_max = 1024;
+dtrace_enabling_t	*dtrace_retained;
+dtrace_genid_t		dtrace_retained_gen;
+
+dtrace_enabling_t *dtrace_enabling_create(dtrace_vstate_t *vstate)
+{
+	dtrace_enabling_t	*enab;
+
+	enab = kzalloc(sizeof (dtrace_enabling_t), GFP_KERNEL);
+	if (enab == NULL)
+		return NULL;
+
+	enab->dten_vstate = vstate;
+
+	return enab;
+}
+
+void dtrace_enabling_add(dtrace_enabling_t *enab, dtrace_ecbdesc_t *ecb)
+{
+	dtrace_ecbdesc_t	**ndesc;
+	size_t			osize, nsize;
+
+	/*
+	 * We can't add to enablings after we've enabled them, or after we've
+	 * retained them.
+	 */
+	ASSERT(enab->dten_probegen == 0);
+	ASSERT(enab->dten_next == NULL && enab->dten_prev == NULL);
+
+	if (enab->dten_ndesc < enab->dten_maxdesc) {
+		enab->dten_desc[enab->dten_ndesc++] = ecb;
+		return;
+	}
+
+	osize = enab->dten_maxdesc * sizeof (dtrace_enabling_t *);
+
+	if (enab->dten_maxdesc == 0)
+		enab->dten_maxdesc = 1;
+	else
+		enab->dten_maxdesc <<= 1;
+
+	ASSERT(enab->dten_ndesc < enab->dten_maxdesc);
+
+	nsize = enab->dten_maxdesc * sizeof (dtrace_enabling_t *);
+	ndesc = vzalloc(nsize);
+	memcpy(ndesc, enab->dten_desc, osize);
+	vfree(enab->dten_desc);
+
+	enab->dten_desc = ndesc;
+	enab->dten_desc[enab->dten_ndesc++] = ecb;
+}
+
+static void dtrace_enabling_addlike(dtrace_enabling_t *enab,
+				    dtrace_ecbdesc_t *ecb,
+				    dtrace_probedesc_t *pd)
+{
+	dtrace_ecbdesc_t *new;
+	dtrace_predicate_t	*pred;
+	dtrace_actdesc_t	*act;
+
+	/*
+	 * We're going to create a new ECB description that matches the
+	 * specified ECB in every way, but has the specified probe description.
+	 */
+	new = kzalloc(sizeof (dtrace_ecbdesc_t), GFP_KERNEL);
+
+	if ((pred = ecb->dted_pred.dtpdd_predicate) != NULL)
+		dtrace_predicate_hold(pred);
+
+	for (act = ecb->dted_action; act != NULL; act = act->dtad_next)
+		dtrace_actdesc_hold(act);
+
+	new->dted_action = ecb->dted_action;
+	new->dted_pred = ecb->dted_pred;
+	new->dted_probe = *pd;
+	new->dted_uarg = ecb->dted_uarg;
+
+	dtrace_enabling_add(enab, new);
+}
+
+void dtrace_enabling_dump(dtrace_enabling_t *enab)
+{
+	int	i;
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		dtrace_probedesc_t	*desc =
+					&enab->dten_desc[i]->dted_probe;
+
+		pr_info("enabling probe %d (%s:%s:%s:%s)",
+			i, desc->dtpd_provider, desc->dtpd_mod,
+			desc->dtpd_func, desc->dtpd_name);
+	}
+}
+
+void dtrace_enabling_destroy(dtrace_enabling_t *enab)
+{
+	int			i;
+	dtrace_ecbdesc_t	*ep;
+	dtrace_vstate_t		*vstate = enab->dten_vstate;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		dtrace_actdesc_t	*act, *next;
+		dtrace_predicate_t	*pred;
+
+		ep = enab->dten_desc[i];
+
+		if ((pred = ep->dted_pred.dtpdd_predicate) != NULL)
+			dtrace_predicate_release(pred, vstate);
+
+		for (act = ep->dted_action; act != NULL; act = next) {
+			next = act->dtad_next;
+			dtrace_actdesc_release(act, vstate);
+		}
+
+		kfree(ep);
+	}
+
+	vfree(enab->dten_desc);
+
+	/*
+	 * If this was a retained enabling, decrement the dts_nretained count
+	 * and remove it from the dtrace_retained list.
+	 */
+	if (enab->dten_prev != NULL || enab->dten_next != NULL ||
+	    dtrace_retained == enab) {
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+		ASSERT(enab->dten_vstate->dtvs_state->dts_nretained > 0);
+		enab->dten_vstate->dtvs_state->dts_nretained--;
+		dtrace_retained_gen++;
+	}
+
+	if (enab->dten_prev == NULL) {
+		if (dtrace_retained == enab) {
+			dtrace_retained = enab->dten_next;
+
+			if (dtrace_retained != NULL)
+				dtrace_retained->dten_prev = NULL;
+		}
+	} else {
+		ASSERT(enab != dtrace_retained);
+		ASSERT(dtrace_retained != NULL);
+		enab->dten_prev->dten_next = enab->dten_next;
+	}
+
+	if (enab->dten_next != NULL) {
+		ASSERT(dtrace_retained != NULL);
+		enab->dten_next->dten_prev = enab->dten_prev;
+	}
+
+	kfree(enab);
+}
+
+int dtrace_enabling_retain(dtrace_enabling_t *enab)
+{
+	dtrace_state_t	*state;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(enab->dten_next == NULL && enab->dten_prev == NULL);
+	ASSERT(enab->dten_vstate != NULL);
+
+	state = enab->dten_vstate->dtvs_state;
+	ASSERT(state != NULL);
+
+	/*
+	 * We only allow each state to retain dtrace_retain_max enablings.
+	 */
+	if (state->dts_nretained >= dtrace_retain_max)
+		return -ENOSPC;
+
+	state->dts_nretained++;
+	dtrace_retained_gen++;
+
+	if (dtrace_retained == NULL) {
+		dtrace_retained = enab;
+		return 0;
+	}
+
+	enab->dten_next = dtrace_retained;
+	dtrace_retained->dten_prev = enab;
+	dtrace_retained = enab;
+
+	return 0;
+}
+
+int dtrace_enabling_replicate(dtrace_state_t *state, dtrace_probedesc_t *match,
+			      dtrace_probedesc_t *create)
+{
+	dtrace_enabling_t	*new, *enab;
+	int			found = 0, err = -ENOENT;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(strlen(match->dtpd_provider) < DTRACE_PROVNAMELEN);
+	ASSERT(strlen(match->dtpd_mod) < DTRACE_MODNAMELEN);
+	ASSERT(strlen(match->dtpd_func) < DTRACE_FUNCNAMELEN);
+	ASSERT(strlen(match->dtpd_name) < DTRACE_NAMELEN);
+
+	new = dtrace_enabling_create(&state->dts_vstate);
+	if (new == NULL)
+		return -ENOMEM;
+
+	/*
+	 * Iterate over all retained enablings, looking for enablings that
+	 * match the specified state.
+	 */
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next) {
+		int	i;
+
+		/*
+		 * dtvs_state can only be NULL for helper enablings -- and
+		 * helper enablings can't be retained.
+		 */
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state != state)
+			continue;
+
+		/*
+		 * Now iterate over each probe description; we're looking for
+		 * an exact match to the specified probe description.
+		 */
+		for (i = 0; i < enab->dten_ndesc; i++) {
+			dtrace_ecbdesc_t	*ep = enab->dten_desc[i];
+			dtrace_probedesc_t	*pd = &ep->dted_probe;
+
+			if (strcmp(pd->dtpd_provider, match->dtpd_provider))
+				continue;
+
+			if (strcmp(pd->dtpd_mod, match->dtpd_mod))
+				continue;
+
+			if (strcmp(pd->dtpd_func, match->dtpd_func))
+				continue;
+
+			if (strcmp(pd->dtpd_name, match->dtpd_name))
+				continue;
+
+			/*
+			 * We have a winning probe!  Add it to our growing
+			 * enabling.
+			 */
+			found = 1;
+			dtrace_enabling_addlike(new, ep, create);
+		}
+	}
+
+	if (!found || (err = dtrace_enabling_retain(new)) != 0) {
+		dtrace_enabling_destroy(new);
+		return err;
+	}
+
+	return 0;
+}
+
+void dtrace_enabling_retract(dtrace_state_t *state)
+{
+	dtrace_enabling_t	*enab, *next;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	/*
+	 * Iterate over all retained enablings, destroy the enablings retained
+	 * for the specified state.
+	 */
+	for (enab = dtrace_retained; enab != NULL; enab = next) {
+		next = enab->dten_next;
+
+		/*
+		 * dtvs_state can only be NULL for helper enablings, and helper
+		 * enablings can't be retained.
+		 */
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state == state) {
+			ASSERT(state->dts_nretained > 0);
+			dtrace_enabling_destroy(enab);
+		}
+	}
+
+	ASSERT(state->dts_nretained == 0);
+}
+
+int dtrace_enabling_match(dtrace_enabling_t *enab, int *nmatched)
+{
+	int	i;
+	int	total_matched = 0, matched = 0;
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		dtrace_ecbdesc_t	*ep = enab->dten_desc[i];
+
+		enab->dten_current = ep;
+		enab->dten_error = 0;
+
+		dt_dbg_enable("  Matching enabling %p[%d] for %s:%s:%s:%s\n",
+			      enab, i, ep->dted_probe.dtpd_provider,
+			      ep->dted_probe.dtpd_mod,
+			      ep->dted_probe.dtpd_func,
+			      ep->dted_probe.dtpd_name);
+
+		if ((matched = dtrace_probe_enable(&ep->dted_probe, enab))
+		    < 0) {
+			dt_dbg_enable("  Matching enabling %p[%d] failed: "
+				      "busy\n", enab, i);
+			return -EBUSY;
+		}
+
+		dt_dbg_enable("  Matching enabling %p[%d] found %d matches.\n",
+			      enab, i, matched);
+
+		total_matched += matched;
+
+		if (enab->dten_error != 0) {
+			if (nmatched == NULL)
+				pr_warning("dtrace_enabling_match() error on %p: %d\n", (void *)ep, enab->dten_error);
+
+			return enab->dten_error;
+		}
+	}
+
+	enab->dten_probegen = dtrace_probegen;
+	if (nmatched != NULL)
+		*nmatched = total_matched;
+
+	return 0;
+}
+
+void dtrace_enabling_matchall(void)
+{
+	dtrace_enabling_t	*enab;
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next)
+		(void) dtrace_enabling_match(enab, NULL);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&cpu_lock);
+}
+
+/*
+ * If an enabling is to be enabled without having matched probes (that is, if
+ * dtrace_state_go() is to be called on the underlying dtrace_state_t), the
+ * enabling must be _primed_ by creating an ECB for every ECB description.
+ * This must be done to assure that we know the number of speculations, the
+ * number of aggregations, the minimum buffer size needed, etc. before we
+ * transition out of DTRACE_ACTIVITY_INACTIVE.  To do this without actually
+ * enabling any probes, we create ECBs for every ECB decription, but with a
+ * NULL probe -- which is exactly what this function does.
+ */
+void dtrace_enabling_prime(dtrace_state_t *state)
+{
+	dtrace_enabling_t	*enab;
+	int			i;
+
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next) {
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state != state)
+			continue;
+
+		/*
+		 * We don't want to prime an enabling more than once, lest
+		 * we allow a malicious user to induce resource exhaustion.
+		 * (The ECBs that result from priming an enabling aren't
+		 * leaked -- but they also aren't deallocated until the
+		 * consumer state is destroyed.)
+		 */
+		if (enab->dten_primed)
+			continue;
+
+		for (i = 0; i < enab->dten_ndesc; i++) {
+			enab->dten_current = enab->dten_desc[i];
+			dtrace_probe_enable(NULL, enab);
+		}
+
+		enab->dten_primed = 1;
+	}
+}
+
+void dtrace_enabling_provide(dtrace_provider_t *prv)
+{
+	int		all = 0;
+	dtrace_genid_t	gen;
+
+	if (prv == NULL) {
+		all = 1;
+		prv = dtrace_provider;
+	}
+
+	do {
+		dtrace_enabling_t	*enab;
+		void			*parg = prv->dtpv_arg;
+
+retry:
+		gen = dtrace_retained_gen;
+		for (enab = dtrace_retained; enab != NULL;
+		     enab = enab->dten_next) {
+			int	i;
+
+			for (i = 0; i < enab->dten_ndesc; i++) {
+				dtrace_probedesc_t	desc;
+
+				desc = enab->dten_desc[i]->dted_probe;
+				mutex_unlock(&dtrace_lock);
+				prv->dtpv_pops.dtps_provide(parg, &desc);
+				mutex_lock(&dtrace_lock);
+
+				if (gen != dtrace_retained_gen)
+					goto retry;
+			}
+		}
+	} while (all && (prv = prv->dtpv_next) != NULL);
+
+	mutex_unlock(&dtrace_lock);
+	dtrace_probe_provide(NULL, all ? NULL : prv);
+	mutex_lock(&dtrace_lock);
+}
diff --git a/dtrace/dtrace_fmt.c b/dtrace/dtrace_fmt.c
new file mode 100644
index 000000000000..245da55bd7d1
--- /dev/null
+++ b/dtrace/dtrace_fmt.c
@@ -0,0 +1,103 @@
+/*
+ * FILE:	dtrace_fmt.c
+ * DESCRIPTION:	DTrace - format string implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+uint16_t dtrace_format_add(dtrace_state_t *state, char *str)
+{
+	char		*fmt, **new;
+	uint16_t	ndx;
+
+	fmt = dtrace_strdup(str);
+	if (fmt == NULL)
+		return 0;
+
+	for (ndx = 0; ndx < state->dts_nformats; ndx++) {
+		if (state->dts_formats[ndx] == NULL) {
+			state->dts_formats[ndx] = fmt;
+
+			return ndx + 1;
+		}
+	}
+
+	if (state->dts_nformats == UINT16_MAX) {
+		kfree(fmt);
+
+		return 0;
+	}
+
+	ndx = state->dts_nformats;
+	new = vmalloc((ndx + 1) * sizeof (char *));
+	if (new == NULL) {
+		kfree(fmt);
+		return 0;
+	}
+
+	state->dts_nformats++;
+
+	if (state->dts_formats != NULL) {
+		ASSERT(ndx != 0);
+		memcpy(new, state->dts_formats, ndx * sizeof (char *));
+		vfree(state->dts_formats);
+	}
+
+	state->dts_formats = new;
+	state->dts_formats[ndx] = fmt;
+
+	return ndx + 1;
+}
+
+void dtrace_format_remove(dtrace_state_t *state, uint16_t format)
+{
+	char	*fmt;
+
+	ASSERT(state->dts_formats != NULL);
+	ASSERT(format <= state->dts_nformats);
+	ASSERT(state->dts_formats[format - 1] != NULL);
+
+	fmt = state->dts_formats[format - 1];
+	kfree(fmt);
+	state->dts_formats[format - 1] = NULL;
+}
+
+void dtrace_format_destroy(dtrace_state_t *state)
+{
+	int	i;
+
+	if (state->dts_nformats == 0) {
+		ASSERT(state->dts_formats == NULL);
+		return;
+	}
+
+	ASSERT(state->dts_formats != NULL);
+
+	for (i = 0; i < state->dts_nformats; i++) {
+		char	*fmt = state->dts_formats[i];
+
+		if (fmt == NULL)
+			continue;
+
+		kfree(fmt);
+	}
+
+	vfree(state->dts_formats);
+	state->dts_nformats = 0;
+	state->dts_formats = NULL;
+}
diff --git a/dtrace/dtrace_hash.c b/dtrace/dtrace_hash.c
new file mode 100644
index 000000000000..09052afeda98
--- /dev/null
+++ b/dtrace/dtrace_hash.c
@@ -0,0 +1,259 @@
+/*
+ * FILE:	dtrace_hash.c
+ * DESCRIPTION:	DTrace - hash table implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+#define DTRACE_HASHSTR(hash, probe)	\
+	dtrace_hash_str(*((char **)((uintptr_t)(probe) + (hash)->dth_stroffs)))
+#define DTRACE_HASHEQ(hash, lhs, rhs)	\
+	(strcmp(*((char **)((uintptr_t)(lhs) + (hash)->dth_stroffs)), \
+		*((char **)((uintptr_t)(rhs) + (hash)->dth_stroffs))) == 0)
+
+static uint_t dtrace_hash_str(char *p)
+{
+	uint_t	g;
+	uint_t	hval = 0;
+
+	while (*p) {
+		hval = (hval << 4) + *p++;
+		if ((g = (hval & 0xf0000000)) != 0)
+			hval ^= g >> 24;
+
+		hval &= ~g;
+	}
+
+	return hval;
+}
+
+dtrace_hash_t *dtrace_hash_create(uintptr_t stroffs, uintptr_t nextoffs,
+				  uintptr_t prevoffs)
+{
+	dtrace_hash_t	*hash = kzalloc(sizeof(dtrace_hash_t), GFP_KERNEL);
+
+	if (hash == NULL)
+		return NULL;
+
+	hash->dth_stroffs = stroffs;
+	hash->dth_nextoffs = nextoffs;
+	hash->dth_prevoffs = prevoffs;
+
+	hash->dth_size = 1;
+	hash->dth_mask = hash->dth_size - 1;
+
+	hash->dth_tab = vzalloc(hash->dth_size *
+				sizeof(dtrace_hashbucket_t *));
+
+	if (hash->dth_tab == NULL) {
+		kfree(hash);
+		return NULL;
+	}
+
+	return hash;
+}
+
+void dtrace_hash_destroy(dtrace_hash_t *hash)
+{
+#ifdef DEBUG
+	int	i;
+
+	for (i = 0; i < hash->dth_size; i++)
+		ASSERT(hash->dth_tab[i] == NULL);
+#endif
+
+	if (hash == NULL)
+		return;
+
+	vfree(hash->dth_tab);
+	kfree(hash);
+}
+
+static int dtrace_hash_resize(dtrace_hash_t *hash)
+{
+	int			size = hash->dth_size, i, ndx;
+	int			new_size = hash->dth_size << 1;
+	int			new_mask = new_size - 1;
+	dtrace_hashbucket_t	**new_tab, *bucket, *next;
+
+	ASSERT((new_size & new_mask) == 0);
+
+	new_tab = vzalloc(new_size * sizeof(void *));
+	if (new_tab == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < size; i++) {
+		for (bucket = hash->dth_tab[i]; bucket != NULL;
+		     bucket = next) {
+			dtrace_probe_t *probe = bucket->dthb_chain;
+
+			ASSERT(probe != NULL);
+			ndx = DTRACE_HASHSTR(hash, probe) & new_mask;
+
+			next = bucket->dthb_next;
+			bucket->dthb_next = new_tab[ndx];
+			new_tab[ndx] = bucket;
+		}
+	}
+
+	vfree(hash->dth_tab);
+	hash->dth_tab = new_tab;
+	hash->dth_size = new_size;
+	hash->dth_mask = new_mask;
+
+	return 0;
+}
+
+int dtrace_hash_add(dtrace_hash_t *hash, dtrace_probe_t *new)
+{
+	int			hashval = DTRACE_HASHSTR(hash, new);
+	int			ndx = hashval & hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+	dtrace_probe_t		**nextp, **prevp;
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, new))
+			goto add;
+	}
+
+	if ((hash->dth_nbuckets >> 1) > hash->dth_size) {
+		int	err = 0;
+
+		if ((err = dtrace_hash_resize(hash)) != 0)
+			return err;
+
+		dtrace_hash_add(hash, new);
+		return 0;
+	}
+
+	bucket = kzalloc(sizeof(dtrace_hashbucket_t), GFP_KERNEL);
+	if (bucket == NULL)
+		return -ENOMEM;
+
+	bucket->dthb_next = hash->dth_tab[ndx];
+	hash->dth_tab[ndx] = bucket;
+	hash->dth_nbuckets++;
+
+add:
+	nextp = DTRACE_HASHNEXT(hash, new);
+
+	ASSERT(*nextp == NULL && *(DTRACE_HASHPREV(hash, new)) == NULL);
+
+	*nextp = bucket->dthb_chain;
+
+	if (bucket->dthb_chain != NULL) {
+		prevp = DTRACE_HASHPREV(hash, bucket->dthb_chain);
+
+		ASSERT(*prevp == NULL);
+
+		*prevp = new;
+	}
+
+	bucket->dthb_chain = new;
+	bucket->dthb_len++;
+
+	return 0;
+}
+
+dtrace_probe_t *dtrace_hash_lookup(dtrace_hash_t *hash,
+				   dtrace_probe_t *template)
+{
+	int			hashval = DTRACE_HASHSTR(hash, template);
+	int			ndx = hashval & hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, template))
+			return bucket->dthb_chain;
+	}
+
+	return NULL;
+}
+
+/*
+ * FIXME:
+ * It would be more accurate to calculate a lookup cost based on the number
+ * of buckets in the hash table slot, the length of the chain, and the length
+ * of the string being looked up.
+ * The hash tables can also be optimized by storing the hashval in each element
+ * rather than always performing string comparisons.
+ */
+int dtrace_hash_collisions(dtrace_hash_t *hash, dtrace_probe_t *template)
+{
+	int			hashval = DTRACE_HASHSTR(hash, template);
+	int			ndx = hashval & hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, template))
+			return bucket->dthb_len;
+	}
+
+	return 0;
+}
+
+void dtrace_hash_remove(dtrace_hash_t *hash, dtrace_probe_t *probe)
+{
+	int			ndx = DTRACE_HASHSTR(hash, probe) &
+				      hash->dth_mask;
+	dtrace_hashbucket_t	*bucket = hash->dth_tab[ndx];
+	dtrace_probe_t		**prevp = DTRACE_HASHPREV(hash, probe);
+	dtrace_probe_t		**nextp = DTRACE_HASHNEXT(hash, probe);
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, probe))
+			break;
+	}
+
+	ASSERT(bucket != NULL);
+
+	if (*prevp == NULL) {
+		if (*nextp == NULL) {
+			/*
+			 * This is the last probe in the bucket; we can remove
+			 * the bucket.
+			 */
+			dtrace_hashbucket_t	*b = hash->dth_tab[ndx];
+
+			ASSERT(bucket->dthb_chain == probe);
+			ASSERT(b != NULL);
+
+			if (b == bucket)
+				hash->dth_tab[ndx] = bucket->dthb_next;
+			else {
+				while (b->dthb_next != bucket)
+					b = b->dthb_next;
+
+				b->dthb_next = bucket->dthb_next;
+			}
+
+			ASSERT(hash->dth_nbuckets > 0);
+
+			hash->dth_nbuckets--;
+			kfree(bucket);
+
+			return;
+		}
+
+		bucket->dthb_chain = *nextp;
+	} else
+		*(DTRACE_HASHNEXT(hash, *prevp)) = *nextp;
+
+	if (*nextp != NULL)
+		*(DTRACE_HASHPREV(hash, *nextp)) = *prevp;
+}
diff --git a/dtrace/dtrace_isa.c b/dtrace/dtrace_isa.c
new file mode 100644
index 000000000000..840ffb51de6c
--- /dev/null
+++ b/dtrace/dtrace_isa.c
@@ -0,0 +1,345 @@
+/*
+ * FILE:	dtrace_isa.c
+ * DESCRIPTION:	DTrace - architecture specific code
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/hardirq.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/uaccess.h>
+#include <linux/cpumask.h>
+#include <asm/cacheflush.h>
+#include <asm/ptrace.h>
+#include <asm/stacktrace.h>
+
+#include "dtrace.h"
+
+DEFINE_MUTEX(cpu_lock);
+EXPORT_SYMBOL(cpu_lock);
+
+int dtrace_getipl(void)
+{
+	return in_interrupt();
+}
+
+void dtrace_xcall(processorid_t cpu, dtrace_xcall_t func, void *arg)
+{
+	if (cpu == DTRACE_CPUALL) {
+		smp_call_function(func, arg, 1);
+	} else
+		smp_call_function_single(cpu, func, arg, 1);
+}
+
+void dtrace_toxic_ranges(void (*func)(uintptr_t, uintptr_t))
+{
+	/* FIXME */
+}
+
+/*
+ * Note:  not called from probe context.  This function is called
+ * asynchronously (and at a regular interval) from outside of probe context
+ * by the DTrace framework to sync shared data which DTrace probe context
+ * may access without locks.
+ *
+ * Whenever the framework updates data which can be accessed from probe context,
+ * the framework then calls dtrace_sync().  dtrace_sync() guarantees all probes
+ * are using the new data before returning.
+ *
+ * See the comment in dtrace_impl.h which describes this algorithm.
+ * The cpuc_in_probe_ctxt flag is an increasing 16-bit count.  It is odd when
+ * in DTrace probe context and even when not in DTrace probe context.
+ * The upper 15 bits are a counter which are incremented when exiting DTrace
+ * probe context.  These upper 15 bits are used to detect "sample aliasing":
+ * i.e. the target CPU is not in DTrace probe context between samples but
+ * continually enters probe context just before being sampled.
+ *
+ * dtrace_sync() loops over NCPUs.  CPUs which are not in DTrace probe context
+ * (cpuc_in_probe_ctxt is even) are removed from the list.  This is repeated
+ * until there are no CPUs left in the sync list.
+ *
+ * In the rare cases where dtrace_sync() loops over all NCPUs more than
+ * dtrace_sync_sample_count times, dtrace_sync() then spins on one CPU's
+ * cpuc_in_probe_ctxt count until the count increments.  This is intended to
+ * avoid sample aliasing.
+ */
+void dtrace_sync(void)
+{
+	/*
+	 * sync_cpus is a bitmap of CPUs that need to be synced with.
+	 */
+	cpumask_t	sync_cpus;
+	uint64_t	sample_count = 0;
+	int		cpuid, sample_cpuid = 0;
+	int		outstanding;
+
+	/*
+	 * Create bitmap of CPUs that need to be synced with.
+	 */
+	cpumask_copy(&sync_cpus, cpu_online_mask);
+	outstanding = 0;
+	for_each_cpu(cpuid, &sync_cpus) {
+		++outstanding;
+
+		/*
+		 * Set a flag to let the CPU know we are syncing with it.
+		 */
+		DTRACE_SYNC_START(cpuid);
+	}
+
+	/*
+	 * The preceding stores by DTRACE_SYNC_START() must complete before
+	 * subsequent loads or stores.  No membar is needed because the
+	 * atomic-add operation in DTRACE_SYNC_START is a memory barrier on
+	 * SPARC and X86.
+	 */
+
+	while (outstanding > 0) {
+		/*
+		 * Loop over the map of CPUs that need to be synced with.
+		 */
+		for_each_cpu(cpuid, &sync_cpus) {
+			if (!DTRACE_SYNC_IN_CRITICAL(cpuid)) {
+
+				/* Clear the CPU's sync request flag */
+				DTRACE_SYNC_END(cpuid);
+
+				/*
+				 * remove cpuid from list of CPUs that
+				 * still need to be synced with.
+				 */
+				DTRACE_SYNC_DONE(cpuid, &sync_cpus);
+				--outstanding;
+			} else {
+				/*
+				 * Remember one of the outstanding CPUs to spin
+				 * on once we reach the sampling limit.
+				 */
+				sample_cpuid = cpuid;
+			}
+		}
+
+		/*
+		 * dtrace_probe may be running in sibling threads in this core.
+		 */
+		if (outstanding > 0) {
+			dtrace_safe_smt_pause();
+
+			/*
+			 * After sample_count loops, spin on one CPU's count
+			 * instead of just checking for odd/even.
+			 */
+			if (++sample_count > dtrace_sync_sample_count) {
+				uint64_t count =
+				    DTRACE_SYNC_CRITICAL_COUNT(sample_cpuid);
+
+				/*
+				 * Spin until critical section count increments.
+				 */
+				if (DTRACE_SYNC_IN_CRITICAL(sample_cpuid)) {
+					while (count ==
+					    DTRACE_SYNC_CRITICAL_COUNT(
+					    sample_cpuid)) {
+
+						dtrace_safe_smt_pause();
+					}
+				}
+
+				DTRACE_SYNC_END(sample_cpuid);
+				DTRACE_SYNC_DONE(sample_cpuid, &sync_cpus);
+				--outstanding;
+			}
+		}
+	}
+
+/*
+ * All preceding loads by DTRACE_SYNC_IN_CRITICAL() and
+ * DTRACE_SYNC_CRITICAL_COUNT() must complete before subsequent loads
+ * or stores.  No membar is needed because the atomic-add operation in
+ * DTRACE_SYNC_END() is a memory barrier on SPARC and X86.
+ */
+}
+
+/*
+ * Handle a few special cases where we store information in kernel memory that
+ * in other systems is typically found in userspace.
+ */
+static int dtrace_fake_copyin(intptr_t addr, size_t size)
+{
+	dtrace_psinfo_t	*psinfo = current->dtrace_psinfo;
+	uintptr_t	argv = (uintptr_t)psinfo->argv;
+	unsigned long	argc = psinfo->argc;
+	uintptr_t	envp = (uintptr_t)psinfo->envp;
+	unsigned long	envc = psinfo->envc;
+
+	/*
+	 * Ensure addr is within the argv array (or the envp array):
+	 * 	addr in [argv..argv + argc * sizeof(psinfo->argv[0])[
+	 * Ensure that addr + size is within the same array
+	 *	addr + size in [argv..argv * sizeof(psinfo->argv[0])]
+	 *
+	 * To guard against overflows on (addr + size) we rewrite this basic
+	 * equation:
+	 *	addr + size <= argv + argc * sizeof(psinfo->argv[0])
+	 * into:
+	 *	addr - argv <= argc * sizeof(psinfo->argv[0]) - size
+	 */
+	return (addr >= argv && addr - argv < argc * sizeof(psinfo->argv[0])
+		    && addr - argv <= argc * sizeof(psinfo->argv[0]) - size) ||
+	       (addr >= envp && addr - envp < envc * sizeof(psinfo->envp[0])
+		    && addr - envp <= envc * sizeof(psinfo->envp[0]) - size);
+}
+
+void dtrace_copyin(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		   volatile uint16_t *flags)
+{
+	if (dtrace_fake_copyin(uaddr, size)) {
+		memcpy((char *)kaddr, (char *)uaddr, size);
+		return;
+	}
+
+	dtrace_copyin_arch(uaddr, kaddr, size, flags);
+}
+
+void dtrace_copyinstr(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		      volatile uint16_t *flags)
+{
+	if (dtrace_fake_copyin(uaddr, size)) {
+		strncpy((char *)kaddr, (char *)uaddr,
+			 min(size, (size_t)PR_PSARGS_SZ));
+		return;
+	}
+
+	dtrace_copyinstr_arch(uaddr, kaddr, size, flags);
+}
+
+/*
+ * FIXME: aframes + 3 should really be aframes + 1, dtrace_stacktrace() in the
+ *	  kernel should do its own aframes + 2
+ */
+void dtrace_getpcstack(uint64_t *pcstack, int pcstack_limit, int aframes,
+		       uint32_t *intrpc)
+{
+	stacktrace_state_t	st = {
+					pcstack,
+					NULL,
+					pcstack_limit,
+					aframes + 3,
+					STACKTRACE_KERNEL
+				     };
+
+	dtrace_stacktrace(&st);
+
+	while (st.depth < st.limit)
+		pcstack[st.depth++] = 0;
+}
+EXPORT_SYMBOL(dtrace_getpcstack);
+
+/*
+ * Get user stack entries up to the pcstack_limit; return the number of entries
+ * acquired.  If pcstack is NULL, return the number of entries potentially
+ * acquirable.
+ */
+unsigned long dtrace_getufpstack(uint64_t *pcstack, uint64_t *fpstack,
+				 int pcstack_limit)
+{
+	struct task_struct	*p = current;
+	stacktrace_state_t	st;
+	unsigned long		depth;
+
+	if (pcstack) {
+		if (unlikely(pcstack_limit < 2)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			return 0;
+		}
+		*pcstack++ = (uint64_t)p->pid;
+		*pcstack++ = (uint64_t)p->tgid;
+		pcstack_limit -= 2;
+	}
+
+	st.pcs = pcstack;
+	st.fps = fpstack;
+	st.limit = pcstack_limit;
+	st.depth = 0;
+	st.flags = STACKTRACE_USER;
+
+	dtrace_stacktrace(&st);
+
+	depth = st.depth;
+	if (pcstack) {
+	        while (st.depth < st.limit) {
+			pcstack[st.depth++] = 0;
+			if (fpstack)
+				fpstack[st.depth++] = 0;
+		}
+	}
+
+	return depth;
+}
+
+void dtrace_getupcstack(uint64_t *pcstack, int pcstack_limit)
+{
+	dtrace_getufpstack(pcstack, NULL, pcstack_limit);
+}
+
+/*
+ * FIXME: aframes + 3 should really be aframes + 1, dtrace_stacktrace() in the
+ *	  kernel should do its own aframes + 2
+ */
+int dtrace_getstackdepth(dtrace_mstate_t *mstate, int aframes)
+{
+	uintptr_t		old = mstate->dtms_scratch_ptr;
+	stacktrace_state_t	st = {
+					NULL,
+					NULL,
+					0,
+					aframes + 3,
+					STACKTRACE_KERNEL
+				     };
+
+	st.pcs = (uint64_t *)ALIGN(old, 8);
+	if ((uintptr_t)st.pcs >
+	    mstate->dtms_scratch_base + mstate->dtms_scratch_size) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+		return 0;
+	}
+
+	/*
+	 * Calculate how many (64-bit) PCs we can fit in the remaining scratch
+	 * memory.
+	 */
+	st.limit = (mstate->dtms_scratch_base + mstate->dtms_scratch_size -
+		    (uintptr_t)st.pcs) >> 3;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	dtrace_stacktrace(&st);
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	mstate->dtms_scratch_ptr = old;
+
+	return st.depth;
+}
+
+int dtrace_getustackdepth(void)
+{
+	return dtrace_getufpstack(NULL, NULL, INT_MAX);
+}
+
+void dtrace_probe_error(dtrace_state_t *state, dtrace_epid_t epid, int act,
+			int fltoffs, int flags, uintptr_t addr)
+{
+	dtrace_probe(dtrace_probeid_error, (uintptr_t)state, epid, act,
+		     fltoffs, flags, addr, 0);
+}
diff --git a/dtrace/dtrace_match.c b/dtrace/dtrace_match.c
new file mode 100644
index 000000000000..e95e69cfb93f
--- /dev/null
+++ b/dtrace/dtrace_match.c
@@ -0,0 +1,336 @@
+/*
+ * FILE:	dtrace_match.c
+ * DESCRIPTION:	DTrace - probe match implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "dtrace.h"
+
+dtrace_hash_t	*dtrace_bymod;
+dtrace_hash_t	*dtrace_byfunc;
+dtrace_hash_t	*dtrace_byname;
+
+int dtrace_match_priv(const dtrace_probe_t *prp, uint32_t priv, kuid_t uid)
+{
+	if (priv != DTRACE_PRIV_ALL) {
+		uint32_t	ppriv =
+				prp->dtpr_provider->dtpv_priv.dtpp_flags;
+		uint32_t	match = priv & ppriv;
+
+		if ((priv & (DTRACE_PRIV_PROC | DTRACE_PRIV_USER |
+		    DTRACE_PRIV_KERNEL)) == 0)
+			return 0;
+
+		if (match == 0 && ppriv != 0)
+			return 0;
+
+		if (((ppriv & ~match) & DTRACE_PRIV_OWNER) != 0 &&
+		    !uid_eq(uid, make_kuid(init_user_namespace,
+			       prp->dtpr_provider->dtpv_priv.dtpp_uid)))
+			return 0;
+	}
+
+	return 1;
+}
+
+int dtrace_match_probe(const dtrace_probe_t *prp, const dtrace_probekey_t *pkp,
+		       uint32_t priv, kuid_t uid)
+{
+	dtrace_provider_t	*pvp = prp->dtpr_provider;
+	int			rv;
+
+	if (pvp->dtpv_defunct)
+		return 0;
+
+	if ((rv = pkp->dtpk_pmatch(pvp->dtpv_name, pkp->dtpk_prov, 0)) <= 0)
+		return rv;
+
+	if ((rv = pkp->dtpk_mmatch(prp->dtpr_mod, pkp->dtpk_mod, 0)) <= 0)
+		return rv;
+
+	if ((rv = pkp->dtpk_fmatch(prp->dtpr_func, pkp->dtpk_func, 0)) <= 0)
+		return rv;
+
+	if ((rv = pkp->dtpk_nmatch(prp->dtpr_name, pkp->dtpk_name, 0)) <= 0)
+		return rv;
+
+	if (dtrace_match_priv(prp, priv, uid) == 0)
+		return 0;
+
+        return rv;
+}
+
+int dtrace_match_glob(const char *s, const char *p, int depth)
+{
+	const char	*olds;
+	char		s1, c;
+	int		gs;
+
+	if (depth > DTRACE_PROBEKEY_MAXDEPTH)
+		return -1;
+
+	if (s == NULL)
+		s = "";
+
+top:
+	olds = s;
+	s1 = *s++;
+
+	if (p == NULL)
+		return 0;
+
+	if ((c = *p++) == '\0')
+		return s1 == '\0';
+
+	switch (c) {
+	case '[':
+		{
+			int	ok = 0, notflag = 0;
+			char	lc = '\0';
+
+			if (s1 == '\0')
+				return 0;
+
+			if (*p == '!') {
+				notflag = 1;
+				p++;
+			}
+
+			if ((c = *p++) == '\0')
+				return 0;
+
+			do {
+				if (c == '-' && lc != '\0' && *p != ']') {
+					if ((c = *p++) == '\0')
+						return 0;
+					if (c == '\\' && (c = *p++) == '\0')
+						return 0;
+
+					if (notflag) {
+						if (s1 < lc || s1 > c)
+							ok++;
+						else
+							return 0;
+					} else if (lc <= s1 && s1 <= c)
+						ok++;
+				} else if (c == '\\' && (c = *p++) == '\0')
+					return 0;
+
+				lc = c;
+
+				if (notflag) {
+					if (s1 != c)
+						ok++;
+					else
+						return 0;
+				} else if (s1 == c)
+					ok++;
+
+				if ((c = *p++) == '\0')
+					return 0;
+			} while (c != ']');
+
+			if (ok)
+				goto top;
+
+			return 0;
+		}
+
+	case '\\':
+		if ((c = *p++) == '\0')
+			return 0;
+
+	default:
+		if (c != s1)
+			return 0;
+
+	case '?':
+		if (s1 != '\0')
+			goto top;
+
+		return 0;
+
+	case '*':
+		while (*p == '*')
+			p++;
+
+		if (*p == '\0')
+			return 1;
+
+		for (s = olds; *s != '\0'; s++) {
+			if ((gs = dtrace_match_glob(s, p, depth + 1)) != 0)
+				return gs;
+		}
+
+		return 0;
+	}
+}
+
+int dtrace_match_string(const char *s, const char *p, int depth)
+{
+	return s != NULL && strcmp(s, p) == 0;
+}
+
+int dtrace_match_nul(const char *s, const char *p, int depth)
+{
+	return 1;
+}
+
+int dtrace_match_nonzero(const char *s, const char *p, int depth)
+{
+	return s != NULL && s[0] != '\0';
+}
+
+struct probe_match {
+	const dtrace_probekey_t *pkp;
+	uint32_t		priv;
+	kuid_t			uid;
+	int			(*matched)(dtrace_probe_t *, void *);
+	void			*arg;
+	int			nmatched;
+};
+
+static int dtrace_match_one(int id, void *p, void *data)
+{
+	struct probe_match	*pbm	= (struct probe_match *)data;
+	dtrace_probe_t		*probe	= (dtrace_probe_t *)p;
+	int			rc;
+
+	if (dtrace_match_probe(probe, pbm->pkp, pbm->priv, pbm->uid) <= 0)
+		return 0;
+
+	pbm->nmatched++;
+
+	if ((rc = (pbm->matched)(probe, pbm->arg)) != DTRACE_MATCH_NEXT) {
+		if (rc == DTRACE_MATCH_FAIL)
+			return DTRACE_MATCH_FAIL;
+	}
+
+	return 0;
+}
+
+int dtrace_match(const dtrace_probekey_t *pkp, uint32_t priv, kuid_t uid,
+		 int (*matched)(dtrace_probe_t *, void *), void *arg)
+{
+	dtrace_probe_t	template, *probe;
+	dtrace_hash_t	*hash = NULL;
+	int		len, rc, best = INT_MAX, nmatched = 0;
+
+	if (pkp->dtpk_id != DTRACE_IDNONE) {
+		if ((probe = dtrace_probe_lookup_id(pkp->dtpk_id)) != NULL &&
+		    dtrace_match_probe(probe, pkp, priv, uid) > 0) {
+			if ((*matched)(probe, arg) == DTRACE_MATCH_FAIL)
+				return DTRACE_MATCH_FAIL;
+
+			nmatched++;
+		}
+
+		return nmatched;
+	}
+
+	template.dtpr_mod = (char *)pkp->dtpk_mod;
+	template.dtpr_func = (char *)pkp->dtpk_func;
+	template.dtpr_name = (char *)pkp->dtpk_name;
+
+	if (pkp->dtpk_mmatch == &dtrace_match_string &&
+	    (len = dtrace_hash_collisions(dtrace_bymod, &template)) < best) {
+		best = len;
+		hash = dtrace_bymod;
+	}
+
+	if (pkp->dtpk_fmatch == &dtrace_match_string &&
+	    (len = dtrace_hash_collisions(dtrace_byfunc, &template)) < best) {
+		best = len;
+		hash = dtrace_byfunc;
+	}
+
+	if (pkp->dtpk_nmatch == &dtrace_match_string &&
+	    (len = dtrace_hash_collisions(dtrace_byname, &template)) < best) {
+		best = len;
+		hash = dtrace_byname;
+	}
+
+	if (hash == NULL) {
+		struct probe_match	pbm;
+
+		pbm.pkp = pkp;
+		pbm.priv = priv;
+		pbm.uid = uid;
+		pbm.matched = matched;
+		pbm.arg = arg;
+		pbm.nmatched = 0;
+
+		rc = dtrace_probe_for_each(dtrace_match_one, &pbm);
+		if (rc == DTRACE_MATCH_FAIL)
+			return DTRACE_MATCH_FAIL;
+
+		return pbm.nmatched;
+	}
+
+	for (probe = dtrace_hash_lookup(hash, &template); probe != NULL;
+	     probe = *(DTRACE_HASHNEXT(hash, probe))) {
+		if (dtrace_match_probe(probe, pkp, priv, uid) <= 0)
+			continue;
+
+		nmatched++;
+
+		if ((rc = (*matched)(probe, arg)) != DTRACE_MATCH_NEXT) {
+			if (rc == DTRACE_MATCH_FAIL)
+				return DTRACE_MATCH_FAIL;
+
+			break;
+		}
+	}
+
+	return nmatched;
+}
+
+static dtrace_probekey_f *dtrace_probekey_func(const char *p)
+{
+	char	c;
+
+	if (p == NULL || *p == '\0')
+		return &dtrace_match_nul;
+
+	while ((c = *p++) != '\0') {
+		if (c == '[' || c == '?' || c == '*' || c == '\\')
+			return &dtrace_match_glob;
+	}
+
+	return &dtrace_match_string;
+}
+
+void dtrace_probekey(const dtrace_probedesc_t *pdp, dtrace_probekey_t *pkp)
+{
+	pkp->dtpk_prov = pdp->dtpd_provider;
+	pkp->dtpk_pmatch = dtrace_probekey_func(pdp->dtpd_provider);
+
+	pkp->dtpk_mod = pdp->dtpd_mod;
+	pkp->dtpk_mmatch = dtrace_probekey_func(pdp->dtpd_mod);
+
+	pkp->dtpk_func = pdp->dtpd_func;
+	pkp->dtpk_fmatch = dtrace_probekey_func(pdp->dtpd_func);
+
+	pkp->dtpk_name = pdp->dtpd_name;
+	pkp->dtpk_nmatch = dtrace_probekey_func(pdp->dtpd_name);
+
+	pkp->dtpk_id = pdp->dtpd_id;
+
+	if (pkp->dtpk_id == DTRACE_IDNONE &&
+	    pkp->dtpk_pmatch == &dtrace_match_nul &&
+	    pkp->dtpk_mmatch == &dtrace_match_nul &&
+	    pkp->dtpk_fmatch == &dtrace_match_nul &&
+	    pkp->dtpk_nmatch == &dtrace_match_nul)
+		pkp->dtpk_fmatch = &dtrace_match_nonzero;
+}
diff --git a/dtrace/dtrace_mod.c b/dtrace/dtrace_mod.c
new file mode 100644
index 000000000000..bc9e49fa4bb4
--- /dev/null
+++ b/dtrace/dtrace_mod.c
@@ -0,0 +1,44 @@
+/*
+ * FILE:	dtrace_mod.c
+ * DESCRIPTION:	DTrace - framework kernel module
+ *
+ * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace_dev.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Dynamic Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+/*
+ * Initialize the module.
+ */
+static int __init dtrace_init(void)
+{
+	return dtrace_dev_init();
+}
+
+/*
+ * Perform cleanup before the module is removed.
+ */
+static void __exit dtrace_exit(void)
+{
+	dtrace_dev_exit();
+}
+
+module_init(dtrace_init);
+module_exit(dtrace_exit);
diff --git a/dtrace/dtrace_predicate.c b/dtrace/dtrace_predicate.c
new file mode 100644
index 000000000000..5a5e5a826359
--- /dev/null
+++ b/dtrace/dtrace_predicate.c
@@ -0,0 +1,79 @@
+/*
+ * FILE:	dtrace_predicate.c
+ * DESCRIPTION:	DTrace - predicate cache implementation
+ *
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+static dtrace_cacheid_t	dtrace_predcache_id = DTRACE_CACHEIDNONE + 1;
+
+dtrace_predicate_t *dtrace_predicate_create(dtrace_difo_t *dp)
+{
+	dtrace_predicate_t	*pred;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	pred = kzalloc(sizeof (dtrace_predicate_t), GFP_KERNEL);
+	if (pred == NULL)
+		return NULL;
+
+	pred->dtp_difo = dp;
+	pred->dtp_refcnt = 1;
+
+	if (!dtrace_difo_cacheable(dp))
+		return pred;
+
+	/*
+	 * This is only theoretically possible -- we have had 2^32 cacheable
+	 * predicates on this machine.  We cannot allow any more predicates to
+	 * become cacheable:  as unlikely as it is, there may be a thread
+	 * caching a (now stale) predicate cache ID. (N.B.: the temptation is
+	 * being successfully resisted to have this cmn_err() "Holy shit -- we
+	 * executed this code!")
+	 */
+	if (dtrace_predcache_id == DTRACE_CACHEIDNONE)
+		return pred;
+
+	pred->dtp_cacheid = dtrace_predcache_id++;
+
+	return pred;
+}
+
+void dtrace_predicate_hold(dtrace_predicate_t *pred)
+{
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(pred->dtp_difo != NULL && pred->dtp_difo->dtdo_refcnt != 0);
+	ASSERT(pred->dtp_refcnt > 0);
+
+	pred->dtp_refcnt++;
+}
+
+void dtrace_predicate_release(dtrace_predicate_t *pred,
+			      dtrace_vstate_t *vstate)
+{
+	dtrace_difo_t *dp = pred->dtp_difo;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp != NULL && dp->dtdo_refcnt != 0);
+	ASSERT(pred->dtp_refcnt > 0);
+
+	if (--pred->dtp_refcnt == 0) {
+		dtrace_difo_release(dp, vstate);
+		kfree(pred);
+	}
+}
diff --git a/dtrace/dtrace_priv.c b/dtrace/dtrace_priv.c
new file mode 100644
index 000000000000..716383511450
--- /dev/null
+++ b/dtrace/dtrace_priv.c
@@ -0,0 +1,117 @@
+/*
+ * FILE:	dtrace_priv.c
+ * DESCRIPTION:	DTrace - privilege support implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+
+#include "dtrace.h"
+
+/*
+ * This privilege check should be used by actions and subroutines to
+ * verify that the user credentials of the process that enabled the
+ * invoking ECB match the target credentials
+ */
+int dtrace_priv_proc_common_user(dtrace_state_t *state)
+{
+	const cred_t	*cr, *s_cr = state->dts_cred.dcr_cred;
+
+	/*
+	 * We should always have a non-NULL state cred here, since if cred
+	 * is null (anonymous tracing), we fast-path bypass this routine.
+	 */
+	ASSERT(s_cr != NULL);
+
+	if ((cr = current_cred()) != NULL &&
+	    uid_eq(s_cr->euid, cr->euid) &&
+	    uid_eq(s_cr->euid, cr->uid) &&
+	    uid_eq(s_cr->euid, cr->suid) &&
+	    gid_eq(s_cr->egid, cr->egid) &&
+	    gid_eq(s_cr->egid, cr->gid) &&
+	    gid_eq(s_cr->egid, cr->sgid))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * This privilege check should be used by actions and subroutines to
+ * verify that the process has not setuid or changed credentials.
+ */
+int dtrace_priv_proc_common_nocd(void)
+{
+#ifdef FIXME
+	proc_t	*proc;
+
+	if ((proc = ttoproc(curthread)) != NULL && !(proc->p_flag & SNOCD))
+		return 1;
+#endif
+
+	return 0;
+}
+
+int dtrace_priv_proc_destructive(dtrace_state_t *state)
+{
+	int	action = state->dts_cred.dcr_action;
+
+	if (((action & DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER) == 0) &&
+	    dtrace_priv_proc_common_user(state) == 0)
+		goto bad;
+
+	if (((action & DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG) == 0) &&
+	    dtrace_priv_proc_common_nocd() == 0)
+		goto bad;
+
+	return 1;
+
+bad:
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_UPRIV);
+   
+	return 0;
+}
+
+int dtrace_priv_proc_control(dtrace_state_t *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_PROC_CONTROL)
+		return 1;
+
+	if (dtrace_priv_proc_common_user(state) &&
+	    dtrace_priv_proc_common_nocd())
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_UPRIV);
+
+	return 0;
+}
+
+int dtrace_priv_proc(dtrace_state_t *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_PROC)
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_UPRIV);
+
+	return 0;
+}
+
+int dtrace_priv_kernel(dtrace_state_t *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_KERNEL)
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
+
+	return 0;
+}
diff --git a/dtrace/dtrace_probe.c b/dtrace/dtrace_probe.c
new file mode 100644
index 000000000000..2ac88e1a07c4
--- /dev/null
+++ b/dtrace/dtrace_probe.c
@@ -0,0 +1,1410 @@
+/*
+ * FILE:	dtrace_probe.c
+ * DESCRIPTION:	DTrace - probe implementation
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/hardirq.h>
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+#include <asm/cmpxchg.h>
+#include <linux/sched/signal.h>
+
+#include "dtrace.h"
+
+ktime_t				dtrace_chill_interval =
+					KTIME_INIT(1, 0);
+ktime_t				dtrace_chill_max =
+					KTIME_INIT(0,
+						   500 * (NANOSEC / MILLISEC));
+
+dtrace_genid_t			dtrace_probegen;
+struct kmem_cache		*dtrace_probe_cachep;
+
+static struct idr		dtrace_probe_idr;
+
+static struct task_struct	*dtrace_panicked;
+
+/*
+ * Free probe structure (including partially filled in ones).
+ */
+void dtrace_probe_free(dtrace_probe_t *probe)
+{
+	if (probe == NULL)
+		return;
+
+	dtrace_probe_remove_id(probe->dtpr_id);
+
+	kfree(probe->dtpr_mod);
+	kfree(probe->dtpr_func);
+	kfree(probe->dtpr_name);
+
+	kmem_cache_free(dtrace_probe_cachep, probe);
+}
+
+/*
+ * Create a new probe.
+ */
+dtrace_id_t dtrace_probe_create(dtrace_provider_id_t prov, const char *mod,
+				const char *func, const char *name,
+				int aframes, void *arg)
+{
+	dtrace_probe_t		*probe;
+	dtrace_provider_t	*provider = (dtrace_provider_t *)prov;
+	dtrace_id_t		id;
+
+	probe = kmem_cache_alloc(dtrace_probe_cachep, GFP_KERNEL);
+	if (probe == NULL)
+		goto err_probe;
+
+	/*
+	 * The idr_preload() should be called without holding locks as it may
+	 * block.  At the same time it is required to protect DTrace structures.
+	 * We can't drop it before idr_preload() and acquire after it because
+	 * we can't sleep in atomic context (until we reach idr_preload_end()).
+	 *
+	 * It is better to delay DTrace framework than traced host so the lock
+	 * is being held for the duration of idr allocation.
+	 *
+	 * When the provider is the DTrace core itself, dtrace_lock will be
+	 * held when we enter this function.
+	 */
+	if (provider == dtrace_provider) {
+		ASSERT(MUTEX_HELD(&dtrace_lock));
+	} else {
+		mutex_lock(&dtrace_lock);
+	}
+
+	idr_preload(GFP_KERNEL);
+	id = idr_alloc_cyclic(&dtrace_probe_idr, probe, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+	if (id < 0)
+		goto err_probe;
+
+	probe->dtpr_id = id;
+	probe->dtpr_ecb = NULL;
+	probe->dtpr_ecb_last = NULL;
+	probe->dtpr_arg = arg;
+	probe->dtpr_predcache = DTRACE_CACHEIDNONE;
+	probe->dtpr_aframes = aframes;
+	probe->dtpr_provider = provider;
+
+	if ((probe->dtpr_mod = dtrace_strdup(mod)) == NULL)
+		goto err_probe;
+
+	if ((probe->dtpr_func = dtrace_strdup(func)) == NULL)
+		goto err_probe;
+
+	if ((probe->dtpr_name = dtrace_strdup(name)) == NULL)
+		goto err_probe;
+
+	probe->dtpr_nextmod = probe->dtpr_prevmod = NULL;
+	probe->dtpr_nextfunc = probe->dtpr_prevfunc = NULL;
+	probe->dtpr_nextname = probe->dtpr_prevname = NULL;
+	probe->dtpr_gen = dtrace_probegen++;
+
+	if (dtrace_hash_add(dtrace_bymod, probe) != 0)
+		goto err_probe;
+
+	if (dtrace_hash_add(dtrace_byfunc, probe) != 0)
+		goto err_hash_byfunc;
+
+	if (dtrace_hash_add(dtrace_byname, probe) != 0)
+		goto err_hash_byname;
+
+	if (provider != dtrace_provider)
+		mutex_unlock(&dtrace_lock);
+
+	return id;
+
+err_hash_byname:
+	dtrace_hash_remove(dtrace_byfunc, probe);
+err_hash_byfunc:
+	dtrace_hash_remove(dtrace_bymod, probe);
+err_probe:
+	dtrace_probe_free(probe);
+	if (provider != dtrace_provider)
+		mutex_unlock(&dtrace_lock);
+	return DTRACE_IDNONE;
+}
+EXPORT_SYMBOL(dtrace_probe_create);
+
+int dtrace_probe_enable(const dtrace_probedesc_t *desc, dtrace_enabling_t *enab)
+{
+	dtrace_probekey_t	pkey;
+	uint32_t		priv;
+	kuid_t			uid;
+
+	dtrace_ecb_create_cache = NULL;
+
+	if (desc == NULL) {
+		(void) dtrace_ecb_create_enable(NULL, enab);
+
+		return 0;
+	}
+
+	dtrace_probekey(desc, &pkey);
+	dtrace_cred2priv(enab->dten_vstate->dtvs_state->dts_cred.dcr_cred,
+			 &priv, &uid);
+
+	return dtrace_match(&pkey, priv, uid, dtrace_ecb_create_enable, enab);
+}
+
+/*
+ * Return the probe argument associated with the specified probe.
+ */
+void *dtrace_probe_arg(dtrace_provider_id_t id, dtrace_id_t pid)
+{
+	dtrace_probe_t	*probe;
+	void		*rval = NULL;
+
+	mutex_lock(&dtrace_lock);
+
+	if ((probe = dtrace_probe_lookup_id(pid)) != NULL &&
+	    probe->dtpr_provider == (dtrace_provider_t *)id)
+		rval = probe->dtpr_arg;
+
+	mutex_unlock(&dtrace_lock);
+
+	return rval;
+}
+EXPORT_SYMBOL(dtrace_probe_arg);
+
+/*
+ * Copy a probe into a probe description.
+ */
+void dtrace_probe_description(const dtrace_probe_t *prp,
+			      dtrace_probedesc_t *pdp)
+{
+	memset(pdp, 0, sizeof(dtrace_probedesc_t));
+	pdp->dtpd_id = prp->dtpr_id;
+
+	strncpy(pdp->dtpd_provider, prp->dtpr_provider->dtpv_name,
+		DTRACE_PROVNAMELEN - 1);
+
+	strncpy(pdp->dtpd_mod, prp->dtpr_mod, DTRACE_MODNAMELEN - 1);
+	strncpy(pdp->dtpd_func, prp->dtpr_func, DTRACE_FUNCNAMELEN - 1);
+	strncpy(pdp->dtpd_name, prp->dtpr_name, DTRACE_NAMELEN - 1);
+}
+
+void dtrace_probe_provide(dtrace_probedesc_t *desc, dtrace_provider_t *prv)
+{
+	int		all = 0;
+
+	if (prv == NULL) {
+		all = 1;
+		prv = dtrace_provider;
+	}
+
+	do {
+		prv->dtpv_pops.dtps_provide(prv->dtpv_arg, desc);
+		dtrace_for_each_module(prv->dtpv_pops.dtps_provide_module, prv->dtpv_arg);
+	} while (all && (prv = prv->dtpv_next) != NULL);
+}
+
+/*
+ * Atomically increment a specified error counter from probe context.
+ */
+static void dtrace_error(uint32_t *counter)
+{
+	/*
+	 * Most counters stored to in probe context are per-CPU counters.
+	 * However, there are some error conditions that are sufficiently
+	 * arcane that they don't merit per-CPU storage.  If these counters
+	 * are incremented concurrently on different CPUs, scalability will be
+	 * adversely affected -- but we don't expect them to be white-hot in a
+	 * correctly constructed enabling...
+	 */
+	uint32_t	oval, nval;
+
+	do {
+		oval = *counter;
+
+		if ((nval = oval + 1) == 0) {
+			/*
+			 * If the counter would wrap, set it to 1 -- assuring
+			 * that the counter is never zero when we have seen
+			 * errors.  (The counter must be 32-bits because we
+			 * aren't guaranteed a 64-bit compare&swap operation.)
+			 * To save this code both the infamy of being fingered
+			 * by a priggish news story and the indignity of being
+			 * the target of a neo-puritan witch trial, we're
+			 * carefully avoiding any colorful description of the
+			 * likelihood of this condition -- but suffice it to
+			 * say that it is only slightly more likely than the
+			 * overflow of predicate cache IDs, as discussed in
+			 * dtrace_predicate_create().
+			 */
+			nval = 1;
+		}
+	} while (cmpxchg(counter, oval, nval) != oval);
+}
+
+static int dtrace_priv_kernel_destructive(dtrace_state_t *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_KERNEL_DESTRUCTIVE)
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
+
+	return 0;
+}
+
+static void dtrace_action_breakpoint(dtrace_ecb_t *ecb)
+{
+	dtrace_probe_t		*probe = ecb->dte_probe;
+	dtrace_provider_t	*prov = probe->dtpr_provider;
+	char			c[DTRACE_FULLNAMELEN + 80], *str;
+	char			*msg = "dtrace: breakpoint action at probe ";
+	char			*ecbmsg = " (ecb ";
+	uintptr_t		mask = (0xf << (sizeof(uintptr_t) * NBBY / 4));
+	uintptr_t		val = (uintptr_t)ecb;
+	int			shift = (sizeof(uintptr_t) * NBBY) - 4, i = 0;
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	/*
+	 * It's impossible to be taking action on the NULL probe.
+	 */
+	ASSERT(probe != NULL);
+
+	/*
+	 * This is a poor man's (destitute man's?) sprintf():  we want to
+	 * print the provider name, module name, function name and name of
+	 * the probe, along with the hex address of the ECB with the breakpoint
+	 * action -- all of which we must place in the character buffer by
+	 * hand.
+	 */
+	while (*msg != '\0')
+		c[i++] = *msg++;
+
+	for (str = prov->dtpv_name; *str != '\0'; str++)
+		c[i++] = *str;
+	c[i++] = ':';
+
+	for (str = probe->dtpr_mod; *str != '\0'; str++)
+		c[i++] = *str;
+	c[i++] = ':';
+
+	for (str = probe->dtpr_func; *str != '\0'; str++)
+		c[i++] = *str;
+	c[i++] = ':';
+
+	for (str = probe->dtpr_name; *str != '\0'; str++)
+		c[i++] = *str;
+
+	while (*ecbmsg != '\0')
+		c[i++] = *ecbmsg++;
+
+	while (shift >= 0) {
+		mask = (uintptr_t)0xf << shift;
+
+		if (val >= ((uintptr_t)1 << shift))
+			c[i++] = "0123456789abcdef"[(val & mask) >> shift];
+
+		shift -= 4;
+	}
+
+	c[i++] = ')';
+	c[i] = '\0';
+
+//	debug_enter(c); /* FIXME */
+}
+
+static void dtrace_action_panic(dtrace_ecb_t *ecb)
+{
+	dtrace_probe_t	*probe = ecb->dte_probe;
+
+	/*
+	 * It's impossible to be taking action on the NULL probe.
+	 */
+	ASSERT(probe != NULL);
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	if (dtrace_panicked != NULL)
+		return;
+
+	if (cmpxchg(&dtrace_panicked, NULL, current) != NULL)
+		return;
+
+	/*
+	 * We won the right to panic.  (We want to be sure that only one
+	 * thread calls panic() from dtrace_probe(), and that panic() is
+	 * called exactly once.)
+	 */
+	dtrace_panic(KERN_EMERG
+		     "dtrace: panic action at probe %s:%s:%s:%s (ecb %p)",
+		     probe->dtpr_provider->dtpv_name, probe->dtpr_mod,
+		     probe->dtpr_func, probe->dtpr_name, (void *)ecb);
+}
+
+static void dtrace_action_raise(uint64_t sig)
+{
+	if (dtrace_destructive_disallow)
+		return;
+
+	if (sig >= _NSIG) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return;
+	}
+
+	/*
+	 * raise() has a queue depth of 1 -- we ignore all subsequent
+	 * invocations of the raise() action.
+	 */
+	if (current->dtrace_sig == 0)
+		current->dtrace_sig = (uint8_t)sig;
+}
+
+static void dtrace_action_stop(void)
+{
+	if (dtrace_destructive_disallow)
+		return;
+
+	if (!current->dtrace_stop) {
+		current->dtrace_stop = 1;
+//		current->sig_check = 1; /* FIXME */
+//		aston(current);		/* FIXME */
+	}
+}
+
+static void dtrace_action_chill(dtrace_mstate_t *mstate, ktime_t val)
+{
+	ktime_t			now;
+	volatile uint16_t	*flags;
+	cpu_core_t		*cpu = this_cpu_core;
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	flags = (volatile uint16_t *)&cpu->cpuc_dtrace_flags;
+
+	now = dtrace_gethrtime();
+
+	if (ktime_gt(ktime_sub(now, cpu->cpu_dtrace_chillmark),
+		     dtrace_chill_interval)) {
+		/*
+		 * We need to advance the mark to current time.
+		 */
+		cpu->cpu_dtrace_chillmark = now;
+		cpu->cpu_dtrace_chilled = ktime_set(0, 0);
+	}
+
+	/*
+	 * Now check to see if the requested chill time would take us over
+	 * the maximum amount of time allowed in the chill interval.  (Or
+	 * worse, if the calculation itself induces overflow.)
+	 */
+	if (ktime_gt(ktime_add(cpu->cpu_dtrace_chilled, val),
+		     dtrace_chill_max) ||
+	    ktime_lt(ktime_add(cpu->cpu_dtrace_chilled, val),
+		     cpu->cpu_dtrace_chilled)) {
+		*flags |= CPU_DTRACE_ILLOP;
+		return;
+	}
+
+	while (ktime_lt(ktime_sub(dtrace_gethrtime(), now), val))
+		continue;
+
+	/*
+	 * Normally, we assure that the value of the variable "timestamp" does
+	 * not change within an ECB.  The presence of chill() represents an
+	 * exception from this rule, however.
+	 */
+	mstate->dtms_present &= ~DTRACE_MSTATE_TIMESTAMP;
+	cpu->cpu_dtrace_chilled = ktime_add(cpu->cpu_dtrace_chilled, val);
+}
+
+static void dtrace_action_ustack(dtrace_mstate_t *mstate,
+				 dtrace_state_t *state, uint64_t *buf,
+				 uint64_t arg)
+{
+	int		nframes = DTRACE_USTACK_NFRAMES(arg);
+	int		strsize = DTRACE_USTACK_STRSIZE(arg);
+	uint64_t	*pcs = &buf[2], *fps;
+	char		*str = (char *)&pcs[nframes];
+	int		size, offs = 0, i, j;
+	uintptr_t	old = mstate->dtms_scratch_ptr, saved;
+	uint16_t	*flags = &this_cpu_core->cpuc_dtrace_flags;
+	char		*sym;
+
+	/*
+	 * Should be taking a faster path if string space has not been
+	 * allocated.
+	 */
+	ASSERT(strsize != 0);
+
+	/*
+	 * We will first allocate some temporary space for the frame pointers.
+	 */
+	fps = (uint64_t *)P2ROUNDUP(mstate->dtms_scratch_ptr, 8);
+	size = (uintptr_t)fps - mstate->dtms_scratch_ptr +
+	       (nframes * sizeof (uint64_t));
+
+	if (!DTRACE_INSCRATCH(mstate, size)) {
+		/*
+		 * Not enough room for our frame pointers -- need to indicate
+		 * that we ran out of scratch space.
+		 */
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+		return;
+	}
+
+	mstate->dtms_scratch_ptr += size;
+	saved = mstate->dtms_scratch_ptr;
+
+	/*
+	 * Now get a stack with both program counters and frame pointers.
+	 */
+	dtrace_getufpstack(buf, fps, nframes + 2);
+
+	/*
+	 * If that faulted, we're cooked.
+	 */
+	if (*flags & CPU_DTRACE_FAULT)
+		goto out;
+
+	/*
+	 * Now we want to walk up the stack, calling the USTACK helper.  For
+	 * each iteration, we restore the scratch pointer.
+	 */
+	for (i = 0; i < nframes; i++) {
+		mstate->dtms_scratch_ptr = saved;
+
+		if (offs >= strsize)
+			break;
+
+		sym = (char *)(uintptr_t)dtrace_helper(
+						DTRACE_HELPER_ACTION_USTACK,
+						mstate, state, pcs[i], fps[i]);
+
+		/*
+		 * If we faulted while running the helper, we're going to
+		 * clear the fault and null out the corresponding string.
+		 */
+		if (*flags & CPU_DTRACE_FAULT) {
+			*flags &= ~CPU_DTRACE_FAULT;
+			str[offs++] = '\0';
+			continue;
+		}
+
+		if (sym == NULL) {
+			str[offs++] = '\0';
+			continue;
+		}
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+
+		/*
+		 * Now copy in the string that the helper returned to us.
+		 */
+		for (j = 0; offs + j < strsize; j++) {
+			if ((str[offs + j] = sym[j]) == '\0')
+			break;
+		}
+
+		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+		offs += j + 1;
+	}
+
+	/*
+	 * If we didn't have room for all of the strings, we don't abort
+	 * processing -- this needn't be a fatal error -- but we still want
+	 * to increment a counter (dts_stkstroverflows) to allow this condition
+	 * to be warned about.  (If this is from a jstack() action, it is
+	 * easily tuned via jstackstrsize.)
+	 */
+	if (offs >= strsize)
+		dtrace_error(&state->dts_stkstroverflows);
+
+	while (offs < strsize)
+		str[offs++] = '\0';
+
+out:
+	mstate->dtms_scratch_ptr = old;
+}
+
+void dtrace_probe(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
+		  uintptr_t arg2, uintptr_t arg3, uintptr_t arg4,
+		  uintptr_t arg5, uintptr_t arg6)
+{
+	processorid_t		cpuid;
+	dtrace_icookie_t	cookie;
+	dtrace_probe_t		*probe;
+	dtrace_mstate_t		mstate;
+	dtrace_ecb_t		*ecb;
+	dtrace_action_t		*act;
+	intptr_t		offs;
+	size_t			size;
+	int			onintr;
+	int			vtime;
+	volatile uint16_t	*flags;
+	ktime_t			now;
+	int			pflag = 0;
+	uint32_t		re_entry;
+
+#ifdef FIXME
+	/*
+	 * Kick out immediately if this CPU is still being born (in which case
+	 * curthread will be set to -1) or the current thread can't allow
+	 * probes in its current context.
+	 */
+	if (((uintptr_t)curthread & 1) || (curthread->t_flag & T_DONTDTRACE))
+		return;
+#endif
+
+	DTRACE_SYNC_ENTER_CRITICAL(cookie, re_entry);
+
+	/*
+	 * If preemption has already been disabled before we get here, we
+	 * accept it as a free gift.  We just need to make sure that we don't
+	 * re-enable preemption on the way out...
+	 */
+	if ((pflag = dtrace_is_preemptive()))
+		dtrace_preempt_off();
+
+	probe = dtrace_probe_lookup_id(id);
+	cpuid = smp_processor_id();
+	onintr = in_interrupt();
+
+	if (!onintr && probe->dtpr_predcache != DTRACE_CACHEIDNONE &&
+	    probe->dtpr_predcache == current->predcache) {
+		/*
+		 * We have hit in the predicate cache; we know that
+		 * this predicate would evaluate to be false.
+		 */
+		if (pflag)
+			dtrace_preempt_on();
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	if (oops_in_progress) {
+		/*
+		 * We don't trace anything if we're panicking.
+		 */
+		if (pflag)
+			dtrace_preempt_on();
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	flags = (volatile uint16_t *)&this_cpu_core->cpuc_dtrace_flags;
+
+	/*
+	 * Probe context is not re-entrant, unless we're getting called to
+	 * process an ERROR probe.
+	 */
+	if ((*flags & CPU_DTRACE_PROBE_CTX) && id != dtrace_probeid_error) {
+		dt_dbg_probe("Attempt to fire probe from within a probe " \
+			     "(ID %d, CPoID %d, U %d, pflag %d)\n", id,
+			     (int)this_cpu_core->cpu_dtrace_caller, cpuid,
+			     pflag);
+		if (pflag)
+			dtrace_preempt_on();
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	*flags |= CPU_DTRACE_PROBE_CTX;
+	this_cpu_core->cpu_dtrace_caller = id;
+
+	now = dtrace_gethrtime();
+	vtime = (dtrace_vtime_references > 0);
+
+	if (vtime && ktime_nz(current->dtrace_start))
+		current->dtrace_vtime = ktime_add(current->dtrace_vtime,
+						  ktime_sub(now, current->dtrace_start));
+
+	mstate.dtms_difo = NULL;
+	mstate.dtms_probe = probe;
+	mstate.dtms_strtok = (uintptr_t)NULL;
+	mstate.dtms_arg[0] = arg0;
+	mstate.dtms_arg[1] = arg1;
+	mstate.dtms_arg[2] = arg2;
+	mstate.dtms_arg[3] = arg3;
+	mstate.dtms_arg[4] = arg4;
+	mstate.dtms_arg[5] = arg5;
+	mstate.dtms_arg[6] = arg6;
+
+	for (ecb = probe->dtpr_ecb; ecb != NULL; ecb = ecb->dte_next) {
+		dtrace_predicate_t	*pred = ecb->dte_predicate;
+		dtrace_state_t		*state = ecb->dte_state;
+		dtrace_buffer_t		*buf = &state->dts_buffer[cpuid];
+		dtrace_buffer_t		*aggbuf = &state->dts_aggbuffer[cpuid];
+		dtrace_vstate_t		*vstate = &state->dts_vstate;
+		dtrace_provider_t	*prov = probe->dtpr_provider;
+		int			committed = 0;
+		caddr_t			tomax;
+
+		/*
+		 * A little subtlety with the following (seemingly innocuous)
+		 * declaration of the automatic 'val':  by looking at the
+		 * code, you might think that it could be declared in the
+		 * action processing loop, below.  (That is, it's only used in
+		 * the action processing loop.)  However, it must be declared
+		 * out of that scope because in the case of DIF expression
+		 * arguments to aggregating actions, one iteration of the
+		 * action loop will use the last iteration's value.
+		 */
+		uint64_t val = 0;
+
+		mstate.dtms_present = DTRACE_MSTATE_ARGS | DTRACE_MSTATE_PROBE;
+		*flags &= ~CPU_DTRACE_ERROR;
+
+		if (prov == dtrace_provider) {
+			/*
+			 * If dtrace itself is the provider of this probe,
+			 * we're only going to continue processing the ECB if
+			 * arg0 (the dtrace_state_t) is equal to the ECB's
+			 * creating state.  (This prevents disjoint consumers
+			 * from seeing one another's metaprobes.)
+			 */
+			if (arg0 != (uint64_t)(uintptr_t)state)
+				continue;
+		}
+
+		if (state->dts_activity != DTRACE_ACTIVITY_ACTIVE) {
+			/*
+			 * We're not currently active.  If our provider isn't
+			 * the dtrace pseudo provider, we're not interested.
+			 */
+			if (prov != dtrace_provider)
+				continue;
+
+			/*
+			 * Now we must further check if we are in the BEGIN
+			 * probe.  If we are, we will only continue orocessing
+			 * if we're still in WARMUP -- if one BEGIN enabling
+			 * has invoked the exit() action, we don't want to
+			 * evaluate subsequent BEGIN enablings.
+			 */
+			if (probe->dtpr_id == dtrace_probeid_begin &&
+			    state->dts_activity != DTRACE_ACTIVITY_WARMUP) {
+				ASSERT(state->dts_activity ==
+				       DTRACE_ACTIVITY_DRAINING);
+				continue;
+			}
+		}
+
+		dt_dbg_probe("Probe (ID %d EPID %d) on CPU %d...\n",
+			     id, ecb->dte_epid, cpuid);
+		if (ecb->dte_cond) {
+			/*
+			 * If the dte_cond bits indicate that this
+			 * consumer is only allowed to see user-mode firings
+			 * of this probe, call the provider's dtps_usermode()
+			 * entry point to check that the probe was fired
+			 * while in a user context. Skip this ECB if that's
+			 * not the case.
+			 */
+			if ((ecb->dte_cond & DTRACE_COND_USERMODE) &&
+			    prov->dtpv_pops.dtps_usermode(
+				prov->dtpv_arg, probe->dtpr_id, probe->dtpr_arg
+			    ) == 0) {
+				dt_dbg_probe("Probe (ID %d EPID %d) Skipped\n",
+					     id, ecb->dte_epid);
+				continue;
+			}
+
+			/*
+			 * This is more subtle than it looks. We have to be
+			 * absolutely certain that current_cred() isn't going
+			 * to change out from under us so it's only legit to
+			 * examine that structure if we're in constrained
+			 * situations. Currently, the only times we'll use this
+			 * check is if a non-super-user has enabled the
+			 * profile or syscall providers -- providers that
+			 * allow visibility of all processes. For the
+			 * profile case, the check above will ensure that
+			 * we're examining a user context.
+			 */
+			if (ecb->dte_cond & DTRACE_COND_OWNER) {
+				const cred_t	*cr;
+				const cred_t	*s_cr =
+					ecb->dte_state->dts_cred.dcr_cred;
+
+				ASSERT(s_cr != NULL);
+
+				if ((cr = current_cred()) == NULL ||
+				    !uid_eq(s_cr->euid, cr->euid) ||
+				    !uid_eq(s_cr->euid, cr->uid) ||
+				    !uid_eq(s_cr->euid, cr->suid) ||
+				    !gid_eq(s_cr->egid, cr->egid) ||
+				    !gid_eq(s_cr->egid, cr->gid) ||
+				    !gid_eq(s_cr->egid, cr->sgid)) {
+					dt_dbg_probe("Probe (ID %d EPID %d) "
+						     "Skipped\n",
+						     id, ecb->dte_epid);
+					continue;
+				}
+			}
+		}
+
+		if (ktime_gt(ktime_sub(now, state->dts_alive),
+			     dtrace_deadman_timeout)) {
+			/*
+			 * We seem to be dead.  Unless we (a) have kernel
+			 * destructive permissions (b) have expicitly enabled
+			 * destructive actions and (c) destructive actions have
+			 * not been disabled, we're going to transition into
+			 * the KILLED state, from which no further processing
+			 * on this state will be performed.
+			 */
+			if (!dtrace_priv_kernel_destructive(state) ||
+			    !state->dts_cred.dcr_destructive ||
+			    dtrace_destructive_disallow) {
+				dtrace_activity_t	*activity =
+							&state->dts_activity;
+				dtrace_activity_t	curr;
+
+				do {
+					curr = state->dts_activity;
+				} while (cmpxchg(activity, curr,
+					 DTRACE_ACTIVITY_KILLED) != curr);
+
+				dt_dbg_probe("Probe (ID %d EPID %d) Skipped\n",
+					     id, ecb->dte_epid);
+				continue;
+			}
+		}
+
+		if ((offs = dtrace_buffer_reserve(buf, ecb->dte_needed,
+						  ecb->dte_alignment, state,
+						  &mstate)) < 0) {
+			dt_dbg_probe("Probe (ID %d EPID %d) Skipped\n",
+				     id, ecb->dte_epid);
+			continue;
+		}
+
+		tomax = buf->dtb_tomax;
+		ASSERT(tomax != NULL);
+
+		if (ecb->dte_size != 0) {
+			DTRACE_STORE(uint32_t, tomax, offs, ecb->dte_epid);
+			dt_dbg_buf("    Store: %p[%ld .. %ld] <- %d [EPID] "
+				   "(from %s::%d)\n",
+				   buf, offs, offs + sizeof(uint32_t) - 1,
+				   ecb->dte_epid, __FUNCTION__, __LINE__);
+		}
+
+		mstate.dtms_epid = ecb->dte_epid;
+		mstate.dtms_present |= DTRACE_MSTATE_EPID;
+
+		if (state->dts_cred.dcr_visible & DTRACE_CRV_KERNEL)
+			mstate.dtms_access = DTRACE_ACCESS_KERNEL;
+		else
+			mstate.dtms_access = 0;
+
+		if (pred != NULL) {
+			dtrace_difo_t	*dp = pred->dtp_difo;
+			int		rval;
+
+			dt_dbg_probe("  Evaluating predicate...\n");
+
+			rval = dtrace_dif_emulate(dp, &mstate, vstate, state);
+
+			if (!(*flags & CPU_DTRACE_ERROR) && !rval) {
+				dtrace_cacheid_t	cid =
+							probe->dtpr_predcache;
+
+				if (cid != DTRACE_CACHEIDNONE && !onintr) {
+					/*
+					 * Update the predicate cache...
+					 */
+					ASSERT(cid == pred->dtp_cacheid);
+					current->predcache = cid;
+				}
+
+				dt_dbg_probe("  Predicate not met (%d)\n",
+					     rval);
+				dt_dbg_probe("Probe (ID %d EPID %d) Done\n",
+					     id, ecb->dte_epid);
+				continue;
+			}
+
+			dt_dbg_probe("  Predicate met (%d)\n", rval);
+		}
+
+		for (act = ecb->dte_action;
+		     !(*flags & CPU_DTRACE_ERROR) && act != NULL;
+		     act = act->dta_next) {
+			size_t			valoffs;
+			dtrace_difo_t		*dp;
+			dtrace_recdesc_t	*rec = &act->dta_rec;
+
+			dt_dbg_probe("  Evaluating action %p (kind %d)...\n",
+				    act, act->dta_kind);
+
+			size = rec->dtrd_size;
+			valoffs = offs + rec->dtrd_offset;
+
+			if (DTRACEACT_ISAGG(act->dta_kind)) {
+				uint64_t		v = 0xbad;
+				dtrace_aggregation_t	*agg;
+
+				agg = (dtrace_aggregation_t *)act;
+
+				if ((dp = act->dta_difo) != NULL)
+					v = dtrace_dif_emulate(dp, &mstate,
+							       vstate, state);
+
+				if (*flags & CPU_DTRACE_ERROR)
+					continue;
+
+				/*
+				 * Note that we always pass the expression
+				 * value from the previous iteration of the
+				 * action loop.  This value will only be used
+				 * if there is an expression argument to the
+				 * aggregating action, denoted by the
+				 * dtag_hasarg field.
+				 */
+				dtrace_aggregate(agg, buf, offs, aggbuf, v,
+						 val);
+				continue;
+			}
+
+			switch (act->dta_kind) {
+			case DTRACEACT_STOP:
+				if (dtrace_priv_proc_destructive(state))
+					dtrace_action_stop();
+				continue;
+
+			case DTRACEACT_BREAKPOINT:
+				if (dtrace_priv_kernel_destructive(state))
+					dtrace_action_breakpoint(ecb);
+				continue;
+
+			case DTRACEACT_PANIC:
+				if (dtrace_priv_kernel_destructive(state))
+					dtrace_action_panic(ecb);
+				continue;
+
+			case DTRACEACT_STACK:
+				if (!dtrace_priv_kernel(state))
+					continue;
+
+				dtrace_getpcstack(
+					(uint64_t *)(tomax + valoffs),
+					size / sizeof(pc_t),
+					probe->dtpr_aframes + 1,
+					DTRACE_ANCHORED(probe)
+						? NULL
+						: (uint32_t *)arg0);
+
+				continue;
+
+			case DTRACEACT_JSTACK:
+			case DTRACEACT_USTACK:
+				if (!dtrace_priv_proc(state))
+					continue;
+
+				/*
+				 * See comment in DIF_VAR_PID.
+				 */
+				if (DTRACE_ANCHORED(mstate.dtms_probe) &&
+				    in_interrupt()) {
+					int	depth = DTRACE_USTACK_NFRAMES(
+							    rec->dtrd_arg) + 2;
+
+					dtrace_bzero((void *)(tomax + valoffs),
+						     DTRACE_USTACK_STRSIZE(
+							rec->dtrd_arg) +
+						     depth * sizeof(uint64_t));
+
+					continue;
+				}
+
+				if (DTRACE_USTACK_STRSIZE(rec->dtrd_arg) != 0 &&
+				    current->dtrace_helpers != NULL) {
+					/*
+					 * This is the slow path -- we have
+					 * allocated string space, and we're
+					 * getting the stack of a process that
+					 * has helpers.  Call into a separate
+					 * routine to perform this processing.
+					 */
+					dtrace_action_ustack(
+						&mstate, state,
+						(uint64_t *)(tomax + valoffs),
+						rec->dtrd_arg);
+					continue;
+				}
+
+				dtrace_getupcstack(
+					(uint64_t *)(tomax + valoffs),
+					DTRACE_USTACK_NFRAMES(rec->dtrd_arg) +
+					2);
+				continue;
+
+			default:
+				break;
+			}
+
+			dp = act->dta_difo;
+			ASSERT(dp != NULL);
+
+			val = dtrace_dif_emulate(dp, &mstate, vstate, state);
+
+			if (*flags & CPU_DTRACE_ERROR)
+				continue;
+
+			switch (act->dta_kind) {
+			case DTRACEACT_SPECULATE:
+				ASSERT(buf == &state->dts_buffer[cpuid]);
+				buf = dtrace_speculation_buffer(state, cpuid,
+								val);
+
+				if (buf == NULL) {
+					*flags |= CPU_DTRACE_DROP;
+					continue;
+				}
+
+				offs = dtrace_buffer_reserve(buf,
+							     ecb->dte_needed,
+							     ecb->dte_alignment,
+							     state, NULL);
+
+				if (offs < 0) {
+					*flags |= CPU_DTRACE_DROP;
+					continue;
+				}
+
+				tomax = buf->dtb_tomax;
+				ASSERT(tomax != NULL);
+
+				if (ecb->dte_size != 0) {
+					DTRACE_STORE(uint32_t, tomax, offs,
+						     ecb->dte_epid);
+					dt_dbg_buf("    Store: %p[%ld .. %ld] "
+						   "<- %d [EPID] "
+						   "(from %s::%d)\n",
+						   buf, offs,
+						   offs + sizeof(uint32_t) - 1,
+						   ecb->dte_epid,
+						   __FUNCTION__, __LINE__);
+				}
+
+				continue;
+
+			case DTRACEACT_CHILL:
+				if (dtrace_priv_kernel_destructive(state))
+					dtrace_action_chill(&mstate,
+							    ns_to_ktime(val));
+
+				continue;
+
+			case DTRACEACT_RAISE:
+				if (dtrace_priv_proc_destructive(state))
+					dtrace_action_raise(val);
+
+				continue;
+
+			case DTRACEACT_COMMIT:
+				ASSERT(!committed);
+
+				/*
+				 * We need to commit our buffer state.
+				 */
+				if (ecb->dte_size) {
+					buf->dtb_offset = offs + ecb->dte_size;
+					dt_dbg_buf("  Consume: %p[%ld .. "
+						   "%lld]\n",
+						   buf, offs,
+						   buf->dtb_offset - 1);
+				}
+
+				buf = &state->dts_buffer[cpuid];
+				dtrace_speculation_commit(state, cpuid, val);
+				committed = 1;
+				continue;
+
+			case DTRACEACT_DISCARD:
+				dtrace_speculation_discard(state, cpuid, val);
+				continue;
+
+			case DTRACEACT_DIFEXPR:
+			case DTRACEACT_LIBACT:
+			case DTRACEACT_PRINTF:
+			case DTRACEACT_PRINTA:
+			case DTRACEACT_SYSTEM:
+			case DTRACEACT_FREOPEN:
+			case DTRACEACT_TRACEMEM:
+				break;
+
+			case DTRACEACT_SYM:
+			case DTRACEACT_MOD:
+				if (!dtrace_priv_kernel(state))
+					continue;
+				break;
+
+			case DTRACEACT_USYM:
+			case DTRACEACT_UMOD:
+			case DTRACEACT_UADDR: {
+				pid_t	pid = current->pid;
+				pid_t	tgid = current->tgid;
+
+				if (!dtrace_priv_proc(state))
+					continue;
+
+				DTRACE_STORE(uint64_t, tomax, valoffs,
+					     (uint64_t)pid);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %lld "
+					   "[PID] (from %s::%d)\n",
+					   buf, valoffs,
+					   valoffs + sizeof(uint64_t) - 1,
+					   (uint64_t)pid,
+					   __FUNCTION__, __LINE__);
+				DTRACE_STORE(uint64_t, tomax,
+					     valoffs + sizeof(uint64_t),
+					     (uint64_t)tgid);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %lld "
+					   "[TGID] (from %s::%d)\n",
+					   buf, valoffs + sizeof(uint64_t),
+					   valoffs + 2 * sizeof(uint64_t) - 1,
+					   (uint64_t)tgid,
+					   __FUNCTION__, __LINE__);
+				DTRACE_STORE(uint64_t, tomax,
+					     valoffs + 2 * sizeof(uint64_t),
+					     val);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %lld "
+					   "(from %s::%d)\n",
+					   buf, valoffs + 2 * sizeof(uint64_t),
+					   valoffs + 3 * sizeof(uint64_t) - 1,
+					   val, __FUNCTION__, __LINE__);
+
+				continue;
+			}
+
+			case DTRACEACT_EXIT: {
+				/*
+				 * For the exit action, we are going to attempt
+				 * to atomically set our activity to be
+				 * draining.  If this fails (either because
+				 * another CPU has beat us to the exit action,
+				 * or because our current activity is something
+				 * other than ACTIVE or WARMUP), we will
+				 * continue.  This assures that the exit action
+				 * can be successfully recorded at most once
+				 * when we're in the ACTIVE state.  If we're
+				 * encountering the exit() action while in
+				 * COOLDOWN, however, we want to honor the new
+				 * status code.  (We know that we're the only
+				 * thread in COOLDOWN, so there is no race.)
+				 */
+				dtrace_activity_t	*activity =
+							&state->dts_activity;
+				dtrace_activity_t	curr =
+							state->dts_activity;
+
+				if (curr == DTRACE_ACTIVITY_COOLDOWN)
+					break;
+
+				if (curr != DTRACE_ACTIVITY_WARMUP)
+					curr = DTRACE_ACTIVITY_ACTIVE;
+
+				if (cmpxchg(activity, curr,
+					    DTRACE_ACTIVITY_DRAINING) != curr) {
+					*flags |= CPU_DTRACE_DROP;
+					continue;
+				}
+
+				break;
+			}
+
+			default:
+				ASSERT(0);
+			}
+
+			if (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	end = valoffs + size;
+
+				if (!dtrace_vcanload((void *)(uintptr_t)val,
+						      &dp->dtdo_rtype, &mstate,
+						      vstate))
+					continue;
+
+				/*
+				 * If this is a string, we're going to only
+				 * load until we find the zero byte -- after
+				 * which we'll store zero bytes.
+				 */
+				if (dp->dtdo_rtype.dtdt_kind ==
+				    DIF_TYPE_STRING) {
+					char	c = '\0' + 1;
+					int	intuple = act->dta_intuple;
+					size_t	s;
+
+					for (s = 0; s < size; s++) {
+						if (c != '\0')
+							c = dtrace_load8(val++);
+
+						DTRACE_STORE(uint8_t, tomax,
+							     valoffs++, c);
+						dt_dbg_buf("    Store: %p[%ld]"
+							   " <- %d (from "
+							   "%s::%d)\n",
+							   buf, valoffs, c,
+							   __FUNCTION__,
+							   __LINE__);
+
+						if (c == '\0' && intuple)
+							break;
+					}
+
+					continue;
+				}
+
+				while (valoffs < end) {
+					DTRACE_STORE(uint8_t, tomax, valoffs++,
+						     dtrace_load8(val++));
+					dt_dbg_buf("    Store: %p[%ld] <- ??? "
+						   "(from %s::%d)\n",
+						   buf, valoffs,
+						   __FUNCTION__, __LINE__);
+				}
+
+				continue;
+			}
+
+			switch (size) {
+			case 0:
+				break;
+			case sizeof(uint8_t):
+				DTRACE_STORE(uint8_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld] <- %d "
+					   "(from %s::%d)\n",
+					   buf, valoffs, (uint8_t)val,
+					   __FUNCTION__, __LINE__);
+				break;
+			case sizeof(uint16_t):
+				DTRACE_STORE(uint16_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %d "
+					   "(from %s::%d)\n",
+					   buf, valoffs,
+					   valoffs + sizeof(uint16_t) - 1,
+					   (uint16_t)val,
+					   __FUNCTION__, __LINE__);
+				break;
+			case sizeof(uint32_t):
+				DTRACE_STORE(uint32_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld] <- %d "
+					   "(from %s::%d)\n",
+					   buf, valoffs,
+					   (uint32_t)val,
+					   __FUNCTION__, __LINE__);
+				break;
+			case sizeof(uint64_t):
+				DTRACE_STORE(uint64_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld] <- %lld "
+					   "(from %s::%d)\n",
+					   buf, valoffs,
+					   val,
+					   __FUNCTION__, __LINE__);
+				break;
+			default:
+				/*
+				 * Any other size should have been returned by
+				 * reference, not by value.
+				 */
+				ASSERT(0);
+				break;
+			}
+		}
+
+		if (*flags & CPU_DTRACE_DROP) {
+			dt_dbg_probe("  -> Dropped\n");
+			continue;
+		}
+
+		if (*flags & CPU_DTRACE_FAULT) {
+			int		ndx;
+			dtrace_action_t	*err;
+
+			dt_dbg_probe("  -> Failed (%x)\n", *flags);
+
+			buf->dtb_errors++;
+
+			if (probe->dtpr_id == dtrace_probeid_error) {
+				/*
+				 * There's nothing we can do -- we had an
+				 * error on the error probe.  We bump an
+				 * error counter to at least indicate that
+				 * this condition happened.
+				 */
+				dtrace_error(&state->dts_dblerrors);
+				continue;
+			}
+
+			if (vtime)
+				/*
+				 * Before recursing on dtrace_probe(), we
+				 * need to explicitly clear out our start
+				 * time to prevent it from being accumulated
+				 * into the dtrace_vtime.
+				 */
+				current->dtrace_start = ktime_set(0, 0);
+
+			/*
+			 * Iterate over the actions to figure out which action
+			 * we were processing when we experienced the error.
+			 * Note that act points _past_ the faulting action; if
+			 * act is ecb->dte_action, the fault was in the
+			 * predicate, if it's ecb->dte_action->dta_next it's
+			 * in action #1, and so on.
+			 */
+			for (err = ecb->dte_action, ndx = 0;
+			     err != act; err = err->dta_next, ndx++)
+				continue;
+
+			dtrace_probe_error(
+				state, ecb->dte_epid, ndx,
+				(mstate.dtms_present & DTRACE_MSTATE_FLTOFFS)
+					? mstate.dtms_fltoffs
+					: -1,
+				DTRACE_FLAGS2FLT(*flags),
+				this_cpu_core->cpuc_dtrace_illval);
+
+			continue;
+		}
+
+		if (!committed) {
+			buf->dtb_offset = offs + ecb->dte_size;
+			dt_dbg_buf("  Consume: %p[%ld .. %lld]\n",
+				   buf, offs, buf->dtb_offset);
+		}
+
+		dt_dbg_probe("Probe (ID %d EPID %d) Done\n",
+			     id, ecb->dte_epid);
+	}
+
+	if (vtime)
+		current->dtrace_start = dtrace_gethrtime();
+
+	/*
+	 * Only clear the flag if this is not the ERROR probe.  We know that
+	 * an ERROR probe executes from within another probe, and therefore
+	 * we need to retain the probe context flag in the flags.
+	 */
+	if (id != dtrace_probeid_error) {
+		*flags &= ~CPU_DTRACE_PROBE_CTX;
+		this_cpu_core->cpu_dtrace_caller = 0;
+	}
+
+	if (pflag)
+		dtrace_preempt_on();
+	DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+
+	if (current->dtrace_sig != 0) {
+		int	sig = current->dtrace_sig;
+
+		current->dtrace_sig = 0;
+
+		send_sig(sig, current, 0);
+	}
+}
+EXPORT_SYMBOL(dtrace_probe);
+
+int dtrace_probe_init(void)
+{
+	dtrace_id_t	id;
+
+	dtrace_probe_cachep = KMEM_CACHE(dtrace_probe, SLAB_HWCACHE_ALIGN);
+	if (dtrace_probe_cachep == NULL)
+		return -ENOMEM;
+
+	idr_init(&dtrace_probe_idr);
+
+	/*
+	 * We create a ID 0 entry as a sentinel, so we can always depend on it
+	 * being the very first entry.  This is used in functionality that runs
+	 * through the list of probes.
+	 */
+	idr_preload(GFP_KERNEL);
+	id = idr_alloc_cyclic(&dtrace_probe_idr, NULL, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+
+	return id == 0 ? 0 : -EAGAIN;
+}
+
+void dtrace_probe_exit(void)
+{
+	idr_destroy(&dtrace_probe_idr);
+	kmem_cache_destroy(dtrace_probe_cachep);
+}
+
+void dtrace_probe_remove_id(dtrace_id_t id)
+{
+	idr_remove(&dtrace_probe_idr, id);
+}
+
+dtrace_probe_t *dtrace_probe_lookup_id(dtrace_id_t id)
+{
+	return idr_find(&dtrace_probe_idr, id);
+}
+
+static int dtrace_probe_lookup_match(dtrace_probe_t *probe, void *arg)
+{
+	*((dtrace_id_t *)arg) = probe->dtpr_id;
+
+	return DTRACE_MATCH_DONE;
+}
+
+dtrace_id_t dtrace_probe_lookup(dtrace_provider_id_t prid, const char *mod,
+				const char *func, const char *name)
+{
+	dtrace_probekey_t	pkey;
+	dtrace_id_t		id;
+	int			match;
+
+	pkey.dtpk_prov = ((dtrace_provider_t *)prid)->dtpv_name;
+	pkey.dtpk_pmatch = &dtrace_match_string;
+	pkey.dtpk_mod = mod;
+	pkey.dtpk_mmatch = mod ? &dtrace_match_string : &dtrace_match_nul;
+	pkey.dtpk_func = func;
+	pkey.dtpk_fmatch = func ? &dtrace_match_string : &dtrace_match_nul;
+	pkey.dtpk_name = name;
+	pkey.dtpk_nmatch = name ? &dtrace_match_string : &dtrace_match_nul;
+	pkey.dtpk_id = DTRACE_IDNONE;
+
+	mutex_lock(&dtrace_lock);
+	match = dtrace_match(&pkey, DTRACE_PRIV_ALL,
+			     make_kuid(init_user_namespace, 0),
+			     dtrace_probe_lookup_match, &id);
+	mutex_unlock(&dtrace_lock);
+
+	ASSERT(match == 1 || match == 0);
+
+	return match ? id : 0;
+}
+EXPORT_SYMBOL(dtrace_probe_lookup);
+
+dtrace_probe_t *dtrace_probe_get_next(dtrace_id_t *idp)
+{
+	return idr_get_next(&dtrace_probe_idr, idp);
+}
+
+int dtrace_probe_for_each(int (*fn)(int id, void *p, void *data), void *data)
+{
+	return idr_for_each(&dtrace_probe_idr, fn, data);
+}
diff --git a/dtrace/dtrace_probe_ctx.c b/dtrace/dtrace_probe_ctx.c
new file mode 100644
index 000000000000..53ac64f0f66f
--- /dev/null
+++ b/dtrace/dtrace_probe_ctx.c
@@ -0,0 +1,654 @@
+/*
+ * FILE:	dtrace_probe_ctx.c
+ * DESCRIPTION:	DTrace - probe context safe functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+
+#include "dtrace.h"
+
+void dtrace_panic(const char *fmt, ...)
+{
+	va_list		alist;
+
+	va_start(alist, fmt);
+	vprintk(fmt, alist);
+	va_end(alist);
+
+	BUG();
+}
+EXPORT_SYMBOL(dtrace_panic);
+
+int dtrace_assfail(const char *a, const char *f, int l)
+{
+	dtrace_panic(KERN_EMERG "assertion failed: %s, file: %s, line: %d",
+		     a, f, l);
+
+	/*
+	 * FIXME: We can do better than this.  The OpenSolaris DTrace source
+	 * states that this cannot be optimized away.
+	 */
+	return a[(uintptr_t)f];
+}
+EXPORT_SYMBOL(dtrace_assfail);
+
+#define DT_MASK_LO	0x00000000FFFFFFFFULL
+
+static void dtrace_add_128(uint64_t *addend1, uint64_t *addend2, uint64_t *sum)
+{
+	uint64_t	result[2];
+
+	result[0] = addend1[0] + addend2[0];
+	result[1] = addend1[1] + addend2[1] +
+		    (result[0] < addend1[0] || result[0] < addend2[0] ? 1 : 0);
+
+	sum[0] = result[0];
+	sum[1] = result[1];
+}
+
+static void dtrace_shift_128(uint64_t *a, int b)
+{
+	uint64_t	mask;
+
+	if (b == 0)
+		return;
+
+	if (b < 0) {
+		b = -b;
+
+		if (b >= 64) {
+			a[0] = a[1] >> (b - 64);
+			a[1] = 0;
+		} else {
+			a[0] >>= b;
+			mask = 1LL << (64 - b);
+			mask -= 1;
+			a[0] |= ((a[1] & mask) << (64 - b));
+			a[1] >>= b;
+		}
+	} else {
+		if (b >= 64) {
+			a[1] = a[0] << (b - 64);
+			a[0] = 0;
+		} else {
+			a[1] <<= b;
+			mask = a[0] >> (64 - b);
+			a[1] |= mask;
+			a[0] <<= b;
+		}
+	}
+}
+
+static void dtrace_multiply_128(uint64_t factor1, uint64_t factor2,
+				uint64_t *product)
+{
+	uint64_t	hi1, hi2, lo1, lo2;
+	uint64_t	tmp[2];
+
+	hi1 = factor1 >> 32;
+	hi2 = factor2 >> 32;
+
+	lo1 = factor1 & DT_MASK_LO;
+	lo2 = factor2 & DT_MASK_LO;
+
+	product[0] = lo1 * lo2;
+	product[1] = hi1 * hi2;
+
+	tmp[0] = hi1 * lo2;
+	tmp[1] = 0;
+	dtrace_shift_128(tmp, 32);
+	dtrace_add_128(product, tmp, product);
+
+	tmp[0] = hi2 * lo1;
+	tmp[1] = 0;
+	dtrace_shift_128(tmp, 32);
+	dtrace_add_128(product, tmp, product);
+}
+
+void dtrace_aggregate_min(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	if ((int64_t)nval < (int64_t)*oval)
+		*oval = nval;
+}
+
+void dtrace_aggregate_max(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	if ((int64_t)nval > (int64_t)*oval)
+		*oval = nval;
+}
+
+void dtrace_aggregate_quantize(uint64_t *quanta, uint64_t nval, uint64_t incr)
+{
+	int	i, zero = DTRACE_QUANTIZE_ZEROBUCKET;
+	int64_t	val = (int64_t)nval;
+
+	if (val < 0) {
+		for (i = 0; i < zero; i++) {
+			if (val <= DTRACE_QUANTIZE_BUCKETVAL(i)) {
+				quanta[i] += incr;
+
+				return;
+			}
+		}
+	} else {
+		for (i = zero + 1; i < DTRACE_QUANTIZE_NBUCKETS; i++) {
+			if (val < DTRACE_QUANTIZE_BUCKETVAL(i)) {
+				quanta[i - 1] += incr;
+
+				return;
+			}
+		}
+
+		quanta[DTRACE_QUANTIZE_NBUCKETS - 1] += incr;
+
+		return;
+	}
+
+	ASSERT(0);
+}
+
+void dtrace_aggregate_lquantize(uint64_t *lquanta, uint64_t nval,
+				uint64_t incr)
+{
+	uint64_t	arg = *lquanta++;
+	int32_t		base = DTRACE_LQUANTIZE_BASE(arg);
+	uint16_t	step = DTRACE_LQUANTIZE_STEP(arg);
+	uint16_t	levels = DTRACE_LQUANTIZE_LEVELS(arg);
+	int64_t		val = (int64_t)nval, level;
+
+	ASSERT(step != 0);
+	ASSERT(levels != 0);
+
+	if (val < base) {
+		lquanta[0] += incr;
+
+		return;
+	}
+
+	level = (val - base) / step;
+
+	if (level < levels) {
+		lquanta[level + 1] += incr;
+
+		return;
+	}
+
+	lquanta[levels + 1] += incr;
+}
+
+static uint64_t dtrace_pow(uint64_t base, uint64_t exp)
+{
+	uint64_t p, r;
+
+	p = base;
+	r = 1;
+	while (exp > 0) {
+		if (exp & 1)
+			r *= p;
+
+		p *= p;
+		exp >>= 1;
+	}
+
+	return (r);
+}
+
+void dtrace_aggregate_llquantize(uint64_t *llquanta, uint64_t nval, uint64_t incr)
+{
+	uint64_t arg = *llquanta++;
+	int factor = DTRACE_LLQUANTIZE_FACTOR(arg);
+	int lmag = DTRACE_LLQUANTIZE_LMAG(arg);
+	int hmag = DTRACE_LLQUANTIZE_HMAG(arg);
+	int steps = DTRACE_LLQUANTIZE_STEPS(arg);
+	int i, signbit, steps_factor, mag, underflow_bin;
+	uint64_t val, bucket_max;
+
+	ASSERT(steps != 0);
+	ASSERT(factor > 1);
+
+	if (nval >> (64 - 1)) {
+		signbit = -1;
+		val = 1 + ~nval;
+	} else {
+		signbit = +1;
+		val = nval;
+	}
+
+	/*
+	 * Compute steps/factor.
+	 * Notice that while we say there are "steps" bins per logarithmic range,
+	 * steps/factor of them actually overlap with lower ranges.
+	 * E.g., if factor=10 and steps=20, for mag=2 we have the 20 bins
+	 *     0 50 100 150 200 250 300 350 ... 800 850 900 950
+	 * but the first two actually belong to lower ranges.
+	 */
+	steps_factor = steps/factor;
+
+	/* the underflow bin is in the middle */
+	underflow_bin = 1 + (hmag-lmag+1) * (steps-steps_factor);
+
+	bucket_max = dtrace_pow(factor, lmag);
+
+	/* check for "underflow" (smaller than the smallest bin) */
+	if ( val < bucket_max ) {
+		llquanta[underflow_bin] += incr;
+		return;
+	}
+
+	/* loop over the logarithmic ranges */
+	i = 0;
+	for (mag = lmag; mag <= hmag; mag++) {
+		bucket_max *= factor;
+		if (val >= bucket_max) continue;
+
+		/*
+		 * We want
+		 *     i = val * steps / bucket_max;
+		 * but val*steps could overflow.  An alternative is
+		 *     i = val / ( bucket_max/steps )
+		 * but bucket_max/steps might not divide evenly.
+		 * (Plus, we end up with an extra divide.)
+		 *
+		 * From Solaris, we inherit constraints on factor and steps
+		 * that mean bucket_max/steps divides evenly when mag>0.
+		 * Meanwhile, if mag==0, val*steps cannot overflow.
+		 * So between our two expressions for i, at least one
+		 * will work and we just have to pick which one to use.
+		 */
+		if (mag == 0) {
+			i = val * steps / bucket_max;
+		} else {
+			i = val / ( bucket_max/steps );
+		}
+
+		// shift for low indices that can never happen
+		i -= steps_factor;
+		break;
+	}
+	i = underflow_bin+signbit*((steps-steps_factor)*(mag-lmag)+i+1);
+	llquanta[i] += incr;
+}
+
+void dtrace_aggregate_avg(uint64_t *data, uint64_t nval, uint64_t arg)
+{
+	data[0]++;
+	data[1] += nval;
+}
+
+void dtrace_aggregate_stddev(uint64_t *data, uint64_t nval, uint64_t arg)
+{
+	int64_t		snval = (int64_t)nval;
+	uint64_t	tmp[2];
+
+	data[0]++;
+	data[1] += nval;
+
+	if (snval < 0)
+		snval = -snval;
+
+	dtrace_multiply_128((uint64_t)snval, (uint64_t)snval, tmp);
+	dtrace_add_128(data + 2, tmp, data + 2);
+}
+
+void dtrace_aggregate_count(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	*oval = *oval + 1;
+}
+
+void dtrace_aggregate_sum(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	*oval += nval;
+}
+
+/*
+ * DTrace Aggregation Buffers
+ *
+ * Aggregation buffers use much of the same mechanism as described above
+ * ("DTrace Buffers").  However, because an aggregation is fundamentally a
+ * hash, there exists dynamic metadata associated with an aggregation buffer
+ * that is not associated with other kinds of buffers.  This aggregation
+ * metadata is _only_ relevant for the in-kernel implementation of
+ * aggregations; it is not actually relevant to user-level consumers.  To do
+ * this, we allocate dynamic aggregation data (hash keys and hash buckets)
+ * starting below the _limit_ of the buffer, and we allocate data from the
+ * _base_ of the buffer.  When the aggregation buffer is copied out, _only_ the
+ * data is copied out; the metadata is simply discarded.  Schematically,
+ * aggregation buffers look like:
+ *
+ *      base of data buffer --->  +-------+------+-----------+-------+
+ *                                | aggid | key  | value     | aggid |
+ *                                +-------+------+-----------+-------+
+ *                                | key                              |
+ *                                +-------+-------+-----+------------+
+ *                                | value | aggid | key | value      |
+ *                                +-------+------++-----+------+-----+
+ *                                | aggid | key  | value       |     |
+ *                                +-------+------+-------------+     |
+ *                                |                ||                |
+ *                                |                ||                |
+ *                                |                \/                |
+ *                                :                                  :
+ *                                .                                  .
+ *                                .                                  .
+ *                                .                                  .
+ *                                :                                  :
+ *                                |                /\                |
+ *                                |                ||   +------------+
+ *                                |                ||   |            |
+ *                                +---------------------+            |
+ *                                | hash keys                        |
+ *                                | (dtrace_aggkey structures)       |
+ *                                |                                  |
+ *                                +----------------------------------+
+ *                                | hash buckets                     |
+ *                                | (dtrace_aggbuffer structure)     |
+ *                                |                                  |
+ *     limit of data buffer --->  +----------------------------------+
+ *
+ * As implied above, just as we assure that ECBs always store a constant
+ * amount of data, we assure that a given aggregation -- identified by its
+ * aggregation ID -- always stores data of a constant quantity and type.
+ * As with EPIDs, this allows the aggregation ID to serve as the metadata for a
+ * given record.
+ *
+ * Note that the size of the dtrace_aggkey structure must be sizeof (uintptr_t)
+ * aligned.  (If this the structure changes such that this becomes false, an
+ * assertion will fail in dtrace_aggregate().)
+ */
+#define DTRACE_AGGHASHSIZE_SLEW		17
+
+typedef struct dtrace_aggkey {
+	uint32_t dtak_hashval;			/* hash value */
+	uint32_t dtak_action:4;			/* action -- 4 bits */
+	uint32_t dtak_size:28;			/* size -- 28 bits */
+	caddr_t dtak_data;			/* data pointer */
+	struct dtrace_aggkey *dtak_next;	/* next in hash chain */
+} dtrace_aggkey_t;
+
+typedef struct dtrace_aggbuffer {
+	uintptr_t dtagb_hashsize;		/* number of buckets */
+	uintptr_t dtagb_free;			/* free list of keys */
+	dtrace_aggkey_t **dtagb_hash;		/* hash table */
+} dtrace_aggbuffer_t;
+
+#define DTRACEACT_ISSTRING(act)						      \
+	((act)->dta_kind == DTRACEACT_DIFEXPR &&			      \
+	 (act)->dta_difo->dtdo_rtype.dtdt_kind == DIF_TYPE_STRING)
+
+/*
+ * Aggregate given the tuple in the principal data buffer, and the aggregating
+ * action denoted by the specified dtrace_aggregation_t.  The aggregation
+ * buffer is specified as the buf parameter.  This routine does not return
+ * failure; if there is no space in the aggregation buffer, the data will be
+ * dropped, and a corresponding counter incremented.
+ */
+void dtrace_aggregate(dtrace_aggregation_t *agg, dtrace_buffer_t *dbuf,
+		      intptr_t offset, dtrace_buffer_t *buf, uint64_t expr,
+		      uint64_t arg)
+{
+	dtrace_recdesc_t	*rec = &agg->dtag_action.dta_rec;
+	uint32_t		i, ndx, size, fsize;
+	uint32_t		align = sizeof (uint64_t) - 1;
+	dtrace_aggbuffer_t	*agb;
+	dtrace_aggkey_t		*key;
+	uint32_t		hashval = 0, limit, isstr;
+	caddr_t			tomax, data, kdata;
+	dtrace_actkind_t	action;
+	dtrace_action_t		*act;
+	uintptr_t		offs;
+
+	if (buf == NULL)
+		return;
+
+	if (!agg->dtag_hasarg)
+		/*
+		 * Currently, only quantize(), lquantize() and llquantize()
+		 * take additional arguments, and they have the same semantics:
+		 * an increment value that defaults to 1 when not present.  If
+		 * additional aggregating actions take arguments, the setting
+		 * of the default argument value will presumably have to
+		 * become more sophisticated...
+		 */
+		arg = 1;
+
+	action = agg->dtag_action.dta_kind - DTRACEACT_AGGREGATION;
+	size = rec->dtrd_offset - agg->dtag_base;
+	fsize = size + rec->dtrd_size;
+
+	ASSERT(dbuf->dtb_tomax != NULL);
+	data = dbuf->dtb_tomax + offset + agg->dtag_base;
+
+	if ((tomax = buf->dtb_tomax) == NULL) {
+		dtrace_buffer_drop(buf);
+		return;
+	}
+
+	/*
+	 * The metastructure is always at the bottom of the buffer.
+	 */
+	agb = (dtrace_aggbuffer_t *)(tomax + buf->dtb_size -
+					     sizeof (dtrace_aggbuffer_t));
+
+	if (buf->dtb_offset == 0) {
+		/*
+		 * We just kludge up approximately 1/8th of the size to be
+		 * buckets.  If this guess ends up being routinely
+		 * off-the-mark, we may need to dynamically readjust this
+		 * based on past performance.
+		 */
+		uintptr_t	hashsize = (buf->dtb_size >> 3) /
+					   sizeof (uintptr_t);
+
+		if ((uintptr_t)agb - hashsize * sizeof (dtrace_aggkey_t *) <
+		    (uintptr_t)tomax || hashsize == 0) {
+			/*
+			 * We've been given a ludicrously small buffer;
+			 * increment our drop count and leave.
+			 */
+			dtrace_buffer_drop(buf);
+			return;
+		}
+
+		/*
+		 * And now, a pathetic attempt to try to get a an odd (or
+		 * perchance, a prime) hash size for better hash distribution.
+		 */
+		if (hashsize > (DTRACE_AGGHASHSIZE_SLEW << 3))
+			hashsize -= DTRACE_AGGHASHSIZE_SLEW;
+
+		agb->dtagb_hashsize = hashsize;
+		agb->dtagb_hash = (dtrace_aggkey_t **)((uintptr_t)agb -
+		agb->dtagb_hashsize * sizeof (dtrace_aggkey_t *));
+		agb->dtagb_free = (uintptr_t)agb->dtagb_hash;
+
+		for (i = 0; i < agb->dtagb_hashsize; i++)
+			agb->dtagb_hash[i] = NULL;
+	}
+
+	ASSERT(agg->dtag_first != NULL);
+	ASSERT(agg->dtag_first->dta_intuple);
+
+	/*
+	 * Calculate the hash value based on the key.  Note that we _don't_
+	 * include the aggid in the hashing (but we will store it as part of
+	 * the key).  The hashing algorithm is Bob Jenkins' "One-at-a-time"
+	 * algorithm: a simple, quick algorithm that has no known funnels, and
+	 * gets good distribution in practice.  The efficacy of the hashing
+	 * algorithm (and a comparison with other algorithms) may be found by
+	 * running the ::dtrace_aggstat MDB dcmd.
+	 */
+	for (act = agg->dtag_first; act->dta_intuple; act = act->dta_next) {
+		i = act->dta_rec.dtrd_offset - agg->dtag_base;
+		limit = i + act->dta_rec.dtrd_size;
+		ASSERT(limit <= size);
+		isstr = DTRACEACT_ISSTRING(act);
+
+		for (; i < limit; i++) {
+			hashval += data[i];
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			if (isstr && data[i] == '\0')
+				break;
+		}
+	}
+
+	hashval += (hashval << 3);
+	hashval ^= (hashval >> 11);
+	hashval += (hashval << 15);
+
+	/*
+	 * Yes, the divide here is expensive -- but it's generally the least
+	 * of the performance issues given the amount of data that we iterate
+	 * over to compute hash values, compare data, etc.
+	 */
+	ndx = hashval % agb->dtagb_hashsize;
+
+	for (key = agb->dtagb_hash[ndx]; key != NULL; key = key->dtak_next) {
+		ASSERT((caddr_t)key >= tomax);
+		ASSERT((caddr_t)key < tomax + buf->dtb_size);
+
+		if (hashval != key->dtak_hashval || key->dtak_size != size)
+			continue;
+
+		kdata = key->dtak_data;
+		ASSERT(kdata >= tomax && kdata < tomax + buf->dtb_size);
+
+		for (act = agg->dtag_first; act->dta_intuple;
+		     act = act->dta_next) {
+			i = act->dta_rec.dtrd_offset - agg->dtag_base;
+			limit = i + act->dta_rec.dtrd_size;
+			ASSERT(limit <= size);
+			isstr = DTRACEACT_ISSTRING(act);
+
+			for (; i < limit; i++) {
+				if (kdata[i] != data[i])
+					goto next;
+
+				if (isstr && data[i] == '\0')
+					break;
+			}
+		}
+
+		if (action != key->dtak_action) {
+			/*
+			 * We are aggregating on the same value in the same
+			 * aggregation with two different aggregating actions.
+			 * (This should have been picked up in the compiler,
+			 * so we may be dealing with errant or devious DIF.)
+			 * This is an error condition; we indicate as much,
+			 * and return.
+			 */
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			return;
+		}
+
+		/*
+		 * This is a hit:  we need to apply the aggregator to
+		 * the value at this key.
+		 */
+		dt_dbg_agg("    Aggregate [accum]: Buf %p, offs %d, act %d, "
+			   "%lld (%lld, %lld)\n",
+			   buf, size,
+			   agg->dtag_action.dta_kind - DTRACEACT_AGGREGATION,
+			   *(uint64_t *)(kdata + size), expr, arg);
+		agg->dtag_aggregate((uint64_t *)(kdata + size), expr, arg);
+		return;
+next:
+		continue;
+	}
+
+	/*
+	 * We didn't find it.  We need to allocate some zero-filled space,
+	 * link it into the hash table appropriately, and apply the aggregator
+	 * to the (zero-filled) value.
+	 */
+	offs = buf->dtb_offset;
+	while (offs & (align - 1))
+		offs += sizeof (uint32_t);
+
+	/*
+	 * If we don't have enough room to both allocate a new key _and_
+	 * its associated data, increment the drop count and return.
+	 */
+	if ((uintptr_t)tomax + offs + fsize >
+	    agb->dtagb_free - sizeof (dtrace_aggkey_t)) {
+		dtrace_buffer_drop(buf);
+		return;
+	}
+
+	ASSERT(!(sizeof (dtrace_aggkey_t) & (sizeof (uintptr_t) - 1)));
+	key = (dtrace_aggkey_t *)(agb->dtagb_free - sizeof (dtrace_aggkey_t));
+	agb->dtagb_free -= sizeof (dtrace_aggkey_t);
+
+	key->dtak_data = kdata = tomax + offs;
+	buf->dtb_offset = offs + fsize;
+
+	/*
+	 * Now copy the data across.
+	 */
+	*((dtrace_aggid_t *)kdata) = agg->dtag_id;
+
+	for (i = sizeof (dtrace_aggid_t); i < size; i++)
+		kdata[i] = data[i];
+
+	/*
+	 * Because strings are not zeroed out by default, we need to iterate
+	 * looking for actions that store strings, and we need to explicitly
+	 * pad these strings out with zeroes.
+	 */
+	for (act = agg->dtag_first; act->dta_intuple; act = act->dta_next) {
+		int	nul;
+
+		if (!DTRACEACT_ISSTRING(act))
+			continue;
+
+		i = act->dta_rec.dtrd_offset - agg->dtag_base;
+		limit = i + act->dta_rec.dtrd_size;
+		ASSERT(limit <= size);
+
+		for (nul = 0; i < limit; i++) {
+			if (nul) {
+				kdata[i] = '\0';
+				continue;
+			}
+
+			if (data[i] != '\0')
+				continue;
+
+			nul = 1;
+		}
+	}
+
+	for (i = size; i < fsize; i++)
+		kdata[i] = 0;
+
+	key->dtak_hashval = hashval;
+	key->dtak_size = size;
+	key->dtak_action = action;
+	key->dtak_next = agb->dtagb_hash[ndx];
+	agb->dtagb_hash[ndx] = key;
+
+	/*
+	 * Finally, apply the aggregator.
+	 */
+	*((uint64_t *)(key->dtak_data + size)) = agg->dtag_initial;
+	dt_dbg_agg("    Aggregate [initial]: Buf %p, offs %d, act %d, "
+	           "%lld (%lld, %lld)\n",
+	           buf, size,
+	           agg->dtag_action.dta_kind - DTRACEACT_AGGREGATION,
+	           *(uint64_t *)(key->dtak_data + size), expr, arg);
+	agg->dtag_aggregate((uint64_t *)(key->dtak_data + size), expr, arg);
+}
diff --git a/dtrace/dtrace_ptofapi.c b/dtrace/dtrace_ptofapi.c
new file mode 100644
index 000000000000..c995454baf7b
--- /dev/null
+++ b/dtrace/dtrace_ptofapi.c
@@ -0,0 +1,618 @@
+/*
+ * FILE:	dtrace_ptofapi.c
+ * DESCRIPTION:	DTrace - (meta) provider-to-framework API
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/idr.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+dtrace_provider_t	*dtrace_provider;
+dtrace_meta_t		*dtrace_meta_pid;
+dtrace_helpers_t	*dtrace_deferred_pid;
+
+DEFINE_MUTEX(dtrace_provider_lock);
+DEFINE_MUTEX(dtrace_meta_lock);
+
+/*
+ * Register the calling provider with the DTrace core.  This should generally
+ * be called by providers during module initialization.
+ */
+int dtrace_register(const char *name, const dtrace_pattr_t *pap, uint32_t priv,
+		    const cred_t *cr, const dtrace_pops_t *pops, void *arg,
+		    dtrace_provider_id_t *idp)
+{
+	dtrace_provider_t	*provider;
+
+	if (name == NULL || pap == NULL || pops == NULL || idp == NULL) {
+		pr_warning("Failed to register provider %s: invalid args\n",
+			   name ? name : "<NULL>");
+		return -EINVAL;
+	}
+
+	if (name[0] == '\0' || dtrace_badname(name)) {
+		pr_warning("Failed to register provider %s: invalid name\n",
+			   name);
+		return -EINVAL;
+	}
+
+	if ((pops->dtps_provide == NULL && pops->dtps_provide_module == NULL) ||
+	    pops->dtps_enable == NULL || pops->dtps_disable == NULL ||
+	    pops->dtps_destroy == NULL ||
+	    ((pops->dtps_resume == NULL) != (pops->dtps_suspend == NULL))) {
+		pr_warning("Failed to register provider %s: invalid ops\n",
+			   name);
+		return -EINVAL;
+	}
+
+	if (dtrace_badattr(&pap->dtpa_provider) ||
+	    dtrace_badattr(&pap->dtpa_mod) ||
+	    dtrace_badattr(&pap->dtpa_func) ||
+	    dtrace_badattr(&pap->dtpa_name) ||
+	    dtrace_badattr(&pap->dtpa_args)) {
+		pr_warning("Failed to register provider %s: invalid "
+			   "attributes\n", name);
+		return -EINVAL;
+	}
+
+	if (priv & ~DTRACE_PRIV_ALL) {
+		pr_warning("Failed to register provider %s: invalid privilege "
+			   "attributes\n", name);
+		return -EINVAL;
+	}
+
+	if ((priv & DTRACE_PRIV_KERNEL) &&
+	    (priv & (DTRACE_PRIV_USER | DTRACE_PRIV_OWNER)) &&
+	    pops->dtps_usermode == NULL) {
+		pr_warning("Failed to register provider %s: need "
+			   "dtps_usermode() op for given privilege "
+			   "attributes\n", name);
+		return -EINVAL;
+	}
+
+	provider = kzalloc(sizeof (dtrace_provider_t), GFP_KERNEL);
+	if (provider == NULL)
+		return -ENOMEM;
+	provider->dtpv_name = dtrace_strdup(name);
+	if (provider->dtpv_name == NULL) {
+		kfree(provider);
+		return -ENOMEM;
+	}
+	provider->dtpv_attr = *pap;
+	provider->dtpv_priv.dtpp_flags = priv;
+
+	if (cr != NULL) {
+		provider->dtpv_priv.dtpp_uid =
+			from_kuid(init_user_namespace, get_cred(cr)->uid);
+		put_cred(cr);
+	}
+
+	provider->dtpv_pops = *pops;
+
+	if (pops->dtps_provide == NULL) {
+		ASSERT(pops->dtps_provide_module != NULL);
+		provider->dtpv_pops.dtps_provide =
+		    (void (*)(void *, const dtrace_probedesc_t *))dtrace_nullop;
+	}
+
+	if (pops->dtps_provide_module == NULL) {
+		ASSERT(pops->dtps_provide != NULL);
+		provider->dtpv_pops.dtps_provide_module =
+		    (void (*)(void *, struct module *))dtrace_nullop;
+	}
+
+	if (pops->dtps_destroy_module == NULL) {
+		provider->dtpv_pops.dtps_destroy_module =
+		    (void (*)(void *, struct module *))dtrace_nullop;
+	}
+
+	if (pops->dtps_suspend == NULL) {
+		ASSERT(pops->dtps_resume == NULL);
+		provider->dtpv_pops.dtps_suspend =
+		    (void (*)(void *, dtrace_id_t, void *))dtrace_nullop;
+		provider->dtpv_pops.dtps_resume =
+		    (void (*)(void *, dtrace_id_t, void *))dtrace_nullop;
+	}
+
+	provider->dtpv_arg = arg;
+	*idp = (dtrace_provider_id_t)provider;
+
+	if (pops == &dtrace_provider_ops) {
+		ASSERT(MUTEX_HELD(&dtrace_provider_lock));
+		ASSERT(MUTEX_HELD(&dtrace_lock));
+		ASSERT(dtrace_anon.dta_enabling == NULL);
+
+		/*
+		 * The DTrace provider must be at the head of the provider
+		 * chain.
+		 */
+		provider->dtpv_next = dtrace_provider;
+		dtrace_provider = provider;
+
+		return 0;
+	}
+
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * If there is at least one provider registered, we'll add this new one
+	 * after the first provider.
+	 */
+	if (dtrace_provider != NULL) {
+		provider->dtpv_next = dtrace_provider->dtpv_next;
+		dtrace_provider->dtpv_next = provider;
+	} else
+		dtrace_provider = provider;
+
+	if (dtrace_retained != NULL) {
+		dtrace_enabling_provide(provider);
+
+		/*
+		 * We must now call dtrace_enabling_matchall() which needs to
+		 * acquire cpu_lock and dtrace_lock.  We therefore need to drop
+		 * our locks before calling it.
+		 */
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+		mutex_unlock(&module_mutex);
+		dtrace_enabling_matchall();
+
+		return 0;
+	}
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_register);
+
+struct unreg_state {
+	dtrace_provider_t	*prov;
+	dtrace_probe_t		*first;
+};
+
+/*
+ * Check whether the given probe is still enabled for the given provider.
+ */
+static int dtrace_unregister_check(int id, void *p, void *data)
+{
+	dtrace_probe_t		*probe = (dtrace_probe_t *)p;
+	struct unreg_state	*st = (struct unreg_state *)data;
+
+	if (probe->dtpr_provider != st->prov)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL)
+		return 0;
+
+	return -EBUSY;
+}
+
+/*
+ * Remove the given probe from the hash tables and the probe IDR, if it is
+ * associated with the given provider.  The probes are chained for further
+ * processing.
+ */
+static int dtrace_unregister_probe(int id, void *p, void *data)
+{
+	dtrace_probe_t		*probe = (dtrace_probe_t *)p;
+	struct unreg_state	*st = (struct unreg_state *)data;
+
+	if (probe->dtpr_provider != st->prov)
+		return 0;
+
+	dtrace_hash_remove(dtrace_bymod, probe);
+	dtrace_hash_remove(dtrace_byfunc, probe);
+	dtrace_hash_remove(dtrace_byname, probe);
+
+	if (st->first == NULL) {
+		st->first = probe;
+		probe->dtpr_nextmod = NULL;
+	} else {
+		probe->dtpr_nextmod = st->first;
+		st->first = probe;
+	}
+
+	return 0;
+}
+
+/*
+ * Remove the given probe from the hash tables and the probe IDR, if it is
+ * associated with the given provider and if it does not have any enablings.
+ * The probes are chained for further processing.
+ */
+static int dtrace_condense_probe(int id, void *p, void *data)
+{
+	dtrace_probe_t		*probe = (dtrace_probe_t *)p;
+	struct unreg_state	*st = (struct unreg_state *)data;
+
+	if (probe->dtpr_provider != st->prov)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL)
+		return 0;
+
+	dtrace_hash_remove(dtrace_bymod, probe);
+	dtrace_hash_remove(dtrace_byfunc, probe);
+	dtrace_hash_remove(dtrace_byname, probe);
+
+	if (st->first == NULL) {
+		st->first = probe;
+		probe->dtpr_nextmod = NULL;
+	} else {
+		probe->dtpr_nextmod = st->first;
+		st->first = probe;
+	}
+
+	return 0;
+}
+
+/*
+ * Unregister the specified provider from the DTrace core.  This should be
+ * called by provider during module cleanup.
+ *
+ * The mutex_lock is already held during this call.
+ */
+int dtrace_unregister(dtrace_provider_id_t id)
+{
+	dtrace_provider_t	*old = (dtrace_provider_t *)id;
+	dtrace_provider_t	*prev = NULL;
+	int			err, self = 0;
+	dtrace_probe_t		*probe;
+	struct unreg_state	st = {
+					old,
+					NULL
+				     };
+
+	ASSERT(MUTEX_HELD(&module_mutex));
+
+	if (old->dtpv_pops.dtps_enable ==
+	    (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop) {
+		/*
+		 * When the provider is the DTrace core itself, we're called
+		 * with locks already held.
+		 */
+		ASSERT(old == dtrace_provider);
+		ASSERT(MUTEX_HELD(&dtrace_provider_lock));
+		ASSERT(MUTEX_HELD(&dtrace_lock));
+
+		self = 1;
+
+		if (dtrace_provider->dtpv_next != NULL) {
+			/*
+			 * We cannot and should not remove the DTrace provider
+			 * if there is any other provider left.
+			 */
+			return -EBUSY;
+		}
+	} else {
+		mutex_lock(&dtrace_provider_lock);
+		mutex_lock(&dtrace_lock);
+	}
+
+	/*
+	 * If /dev/dtrace/dtrace is still held open by a process, or if there
+	 * are anonymous probes that are still enabled, we refuse to deregister
+	 * providers, unless the provider has been invalidated explicitly.
+	 */
+	if (!old->dtpv_defunct &&
+	    (dtrace_opens || (dtrace_anon.dta_state != NULL &&
+	     dtrace_anon.dta_state->dts_necbs > 0))) {
+		if (!self) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+		}
+
+		return -EBUSY;
+	}
+
+	/*
+	 * Check whether any of the probes associated with this provider are
+	 * still enabled (having at least one ECB).  If any are found, we
+	 * cannot remove this provider.
+	 */
+	st.prov = old;
+	err = dtrace_probe_for_each(dtrace_unregister_check, &st);
+	if (err < 0) {
+		if (!self) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+		}
+
+		return err;
+	}
+
+	/*
+	 * All the probes associated with this provider are disabled.  We can
+	 * safely remove these probes from the hashtables and the probe array.
+	 * We chain all the probes together for further processing.
+	 */
+	dtrace_probe_for_each(dtrace_unregister_probe, &st);
+
+	/*
+	 * The probes associated with the provider have been removed.  Ensure
+	 * synchronization on probe IDR processing.
+	 */
+	dtrace_sync();
+
+	/*
+	 * Now get rid of the actual probes.
+	 */
+	for (probe = st.first; probe != NULL; probe = st.first) {
+		int	probe_id = probe->dtpr_id;
+
+		st.first = probe->dtpr_nextmod;
+
+		old->dtpv_pops.dtps_destroy(old->dtpv_arg, probe_id,
+					    probe->dtpr_arg);
+
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kmem_cache_free(dtrace_probe_cachep, probe);
+
+		dtrace_probe_remove_id(probe_id);
+	}
+
+	if ((prev = dtrace_provider) == old) {
+		/*
+		 * We are removing the provider at the head of the chain.
+		 */
+		ASSERT(self);
+		ASSERT(old->dtpv_next == NULL);
+
+		dtrace_provider = old->dtpv_next;
+	} else {
+		while (prev != NULL && prev->dtpv_next != old)
+			prev = prev->dtpv_next;
+
+		if (prev == NULL) {
+			pr_err("Attempt to unregister non-existent DTrace "
+			       "provider %p\n", (void *)id);
+			BUG();
+		}
+
+		prev->dtpv_next = old->dtpv_next;
+	}
+
+	if (!self) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+	}
+
+	kfree(old->dtpv_name);
+	kfree(old);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_unregister);
+
+/*
+ * Invalidate the specified provider.  All subsequent probe lookups for the
+ * specified provider will fail, but the probes will not be removed.
+ */
+void dtrace_invalidate(dtrace_provider_id_t id)
+{
+	dtrace_provider_t	*pvp = (dtrace_provider_t *)id;
+
+	ASSERT(pvp->dtpv_pops.dtps_enable !=
+	       (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop);
+
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	pvp->dtpv_defunct = 1;
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+}
+EXPORT_SYMBOL(dtrace_invalidate);
+
+/*
+ * Indicate whether or not DTrace has attached.
+ */
+int dtrace_attached(void)
+{
+	/*
+	 * dtrace_provider will be non-NULL iff the DTrace driver has
+	 * attached.  (It's non-NULL because DTrace is always itself a
+	 * provider.)
+	 */
+	return dtrace_provider != NULL;
+}
+EXPORT_SYMBOL(dtrace_attached);
+
+/*
+ * Remove all the unenabled probes for the given provider.  This function is
+ * not unlike dtrace_unregister(), except that it doesn't remove the provider
+ * -- just as many of its associated probes as it can.
+ */
+int dtrace_condense(dtrace_provider_id_t id)
+{
+	dtrace_provider_t	*prov = (dtrace_provider_t *)id;
+	dtrace_probe_t		*probe;
+	struct unreg_state	st = {
+					prov,
+					NULL
+				     };
+
+	/*
+	 * Make sure this isn't the DTrace provider itself.
+	 */
+	ASSERT(prov->dtpv_pops.dtps_enable !=
+	       (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop);
+
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * Attempt to destroy the probes associated with this provider.
+	 */
+	dtrace_probe_for_each(dtrace_condense_probe, &st);
+
+	/*
+	 * The probes associated with the provider have been removed.  Ensure
+	 * synchronization on probe IDR processing.
+	 */
+	dtrace_sync();
+
+	/*
+	 * Now get rid of the actual probes.
+	 */
+	for (probe = st.first; probe != NULL; probe = st.first) {
+		int	probe_id = probe->dtpr_id;
+
+		st.first = probe->dtpr_nextmod;
+
+		prov->dtpv_pops.dtps_destroy(prov->dtpv_arg, probe_id,
+					     probe->dtpr_arg);
+
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kfree(probe);
+
+		dtrace_probe_remove_id(probe_id);
+	}
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_condense);
+
+int dtrace_meta_register(const char *name, const dtrace_mops_t *mops,
+			 void *arg, dtrace_meta_provider_id_t *idp)
+{
+	dtrace_meta_t		*meta;
+	dtrace_helpers_t	*help, *next;
+	int			i;
+
+	*idp = DTRACE_METAPROVNONE;
+
+	/*
+	 * We strictly don't need the name, but we hold onto it for
+	 * debuggability. All hail error queues!
+	 */
+	if (name == NULL) {
+		pr_warn("failed to register meta-provider: invalid name\n");
+		return -EINVAL;
+	}
+
+	if (mops == NULL ||
+	    mops->dtms_create_probe == NULL ||
+	    mops->dtms_provide_pid == NULL ||
+	    mops->dtms_remove_pid == NULL) {
+		pr_warn("failed to register meta-register %s: invalid ops\n",
+			name);
+		return -EINVAL;
+	}
+
+	meta = kzalloc(sizeof(dtrace_meta_t), GFP_KERNEL);
+	if (meta == NULL)
+		return -ENOMEM;
+	meta->dtm_mops = *mops;
+	meta->dtm_name = kmalloc(strlen(name) + 1, GFP_KERNEL);
+	if (meta->dtm_name == NULL) {
+		kfree(meta);
+		return -ENOMEM;
+	}
+	strcpy(meta->dtm_name, name);
+	meta->dtm_arg = arg;
+
+	mutex_lock(&dtrace_meta_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (dtrace_meta_pid != NULL) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_meta_lock);
+		pr_warn("failed to register meta-register %s: user-land "
+			"meta-provider exists", name);
+		kfree(meta->dtm_name);
+		kfree(meta);
+		return -EINVAL;
+	}
+
+	dtrace_meta_pid = meta;
+	*idp = (dtrace_meta_provider_id_t)meta;
+
+	/*
+	 * If there are providers and probes ready to go, pass them
+	 * off to the new meta provider now.
+	 */
+	help = dtrace_deferred_pid;
+	dtrace_deferred_pid = NULL;
+
+	mutex_unlock(&dtrace_lock);
+
+	while (help != NULL) {
+		for (i = 0; i < help->dthps_nprovs; i++) {
+			dtrace_helper_provide(&help->dthps_provs[i]->dthp_prov,
+					      help->dthps_pid);
+		}
+
+		next = help->dthps_next;
+		help->dthps_next = NULL;
+		help->dthps_prev = NULL;
+		help->dthps_deferred = 0;
+		help = next;
+	}
+
+	mutex_unlock(&dtrace_meta_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_meta_register);
+
+int dtrace_meta_unregister(dtrace_meta_provider_id_t id)
+{
+	dtrace_meta_t	**pp, *old = (dtrace_meta_t *)id;
+
+	mutex_lock(&dtrace_meta_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (old == dtrace_meta_pid) {
+		pp = &dtrace_meta_pid;
+	} else {
+		pr_err("Attempt to unregister non-existent DTrace meta-"
+		       "provider %p\n", (void *)old);
+		BUG();
+	}
+
+	if (old->dtm_count != 0) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_meta_lock);
+		return -EBUSY;
+	}
+
+	*pp = NULL;
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_meta_lock);
+
+	kfree(old->dtm_name);
+	kfree(old);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_meta_unregister);
diff --git a/dtrace/dtrace_spec.c b/dtrace/dtrace_spec.c
new file mode 100644
index 000000000000..7c1b918dd6c1
--- /dev/null
+++ b/dtrace/dtrace_spec.c
@@ -0,0 +1,435 @@
+/*
+ * FILE:	dtrace_spec.c
+ * DESCRIPTION:	DTrace - speculation implementation
+ *
+ * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/smp.h>
+#include <asm/cmpxchg.h>
+
+#include "dtrace.h"
+
+/*
+ * Given consumer state, this routine finds a speculation in the INACTIVE
+ * state and transitions it into the ACTIVE state.  If there is no speculation
+ * in the INACTIVE state, 0 is returned.  In this case, no error counter is
+ * incremented -- it is up to the caller to take appropriate action.
+ */
+int dtrace_speculation(dtrace_state_t *state)
+{
+	int				i = 0;
+	dtrace_speculation_state_t	curr;
+	uint32_t			*stat =
+					    &state->dts_speculations_unavail,
+					count;
+
+	while (i < state->dts_nspeculations) {
+		dtrace_speculation_t	*spec = &state->dts_speculations[i];
+
+		curr = spec->dtsp_state;
+
+		if (curr != DTRACESPEC_INACTIVE) {
+			if (curr == DTRACESPEC_COMMITTINGMANY ||
+			    curr == DTRACESPEC_COMMITTING ||
+			    curr == DTRACESPEC_DISCARDING)
+				stat = &state->dts_speculations_busy;
+
+			i++;
+			continue;
+		}
+
+		if (cmpxchg((uint32_t *)&spec->dtsp_state, curr,
+			    DTRACESPEC_ACTIVE) == curr)
+			return i + 1;
+	}
+
+	/*
+	 * We couldn't find a speculation.  If we found as much as a single
+	 * busy speculation buffer, we'll attribute this failure as "busy"
+	 * instead of "unavail".
+	 */
+	do {
+		count = *stat;
+	} while (cmpxchg(stat, count, count + 1) != count);
+
+	return 0;
+}
+
+/*
+ * This routine commits an active speculation.  If the specified speculation
+ * is not in a valid state to perform a commit(), this routine will silently do
+ * nothing.  The state of the specified speculation is transitioned according
+ * to the state transition diagram outlined in <sys/dtrace_impl.h>
+ */
+void dtrace_speculation_commit(dtrace_state_t *state, processorid_t cpu,
+			       dtrace_specid_t which)
+{
+	dtrace_speculation_t		*spec;
+	dtrace_buffer_t			*src, *dest;
+	uintptr_t			daddr, saddr, dlimit;
+	dtrace_speculation_state_t	curr, new = 0;
+	intptr_t			offs;
+
+	if (which == 0)
+		return;
+
+	if (which > state->dts_nspeculations) {
+		per_cpu_core(cpu)->cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
+		return;
+	}
+
+	spec = &state->dts_speculations[which - 1];
+	src = &spec->dtsp_buffer[cpu];
+	dest = &state->dts_buffer[cpu];
+
+	do {
+		curr = spec->dtsp_state;
+
+		if (curr == DTRACESPEC_COMMITTINGMANY)
+			break;
+
+		switch (curr) {
+		case DTRACESPEC_INACTIVE:
+		case DTRACESPEC_DISCARDING:
+			return;
+
+		case DTRACESPEC_COMMITTING:
+			/*
+			 * This is only possible if we are (a) commit()'ing
+			 * without having done a prior speculate() on this CPU
+			 * and (b) racing with another commit() on a different
+			 * CPU.  There's nothing to do -- we just assert that
+			 * our offset is 0.
+			 */
+			ASSERT(src->dtb_offset == 0);
+			return;
+
+		case DTRACESPEC_ACTIVE:
+			new = DTRACESPEC_COMMITTING;
+			break;
+
+		case DTRACESPEC_ACTIVEONE:
+			/*
+			 * This speculation is active on one CPU.  If our
+			 * buffer offset is non-zero, we know that the one CPU
+			 * must be us.  Otherwise, we are committing on a
+			 * different CPU from the speculate(), and we must
+			 * rely on being asynchronously cleaned.
+			 */
+			if (src->dtb_offset != 0) {
+				new = DTRACESPEC_COMMITTING;
+				break;
+			}
+			/*FALLTHROUGH*/
+
+		case DTRACESPEC_ACTIVEMANY:
+			new = DTRACESPEC_COMMITTINGMANY;
+			break;
+
+		default:
+			ASSERT(0);
+		}
+	} while (cmpxchg((uint32_t *)&spec->dtsp_state, curr, new) !=
+		 curr);
+
+	/*
+	 * We have set the state to indicate that we are committing this
+	 * speculation.  Now reserve the necessary space in the destination
+	 * buffer.
+	 */
+	offs = dtrace_buffer_reserve(dest, src->dtb_offset, sizeof (uint64_t),
+				     state, NULL);
+	if (offs < 0) {
+		dtrace_buffer_drop(dest);
+		goto out;
+	}
+
+	/*
+	 * We have the space; copy the buffer across.  (Note that this is a
+	 * highly subobtimal bcopy(); in the unlikely event that this becomes
+	 * a serious performance issue, a high-performance DTrace-specific
+	 * bcopy() should obviously be invented.)
+	 */
+	daddr = (uintptr_t)dest->dtb_tomax + offs;
+	dlimit = daddr + src->dtb_offset;
+	saddr = (uintptr_t)src->dtb_tomax;
+
+	/*
+	 * First, the aligned portion.
+	 */
+	while (dlimit - daddr >= sizeof (uint64_t)) {
+		*((uint64_t *)daddr) = *((uint64_t *)saddr);
+		*((uint64_t *)daddr) = *((uint64_t *)saddr);
+
+		daddr += sizeof (uint64_t);
+		saddr += sizeof (uint64_t);
+	}
+
+	/*
+	 * Now any left-over bit...
+	 */
+	while (dlimit - daddr)
+		*((uint8_t *)daddr++) = *((uint8_t *)saddr++);
+
+	/*
+	 * Finally, commit the reserved space in the destination buffer.
+	 */
+	dest->dtb_offset = offs + src->dtb_offset;
+
+out:
+	/*
+	 * If we're lucky enough to be the only active CPU on this speculation
+	 * buffer, we can just set the state back to DTRACESPEC_INACTIVE.
+	 */
+	if (curr == DTRACESPEC_ACTIVE ||
+	    (curr == DTRACESPEC_ACTIVEONE && new == DTRACESPEC_COMMITTING)) {
+		/*
+		 * Will cause unused warning if DEBUG is not defined.
+		 */
+		uint32_t	rval =
+				cmpxchg((uint32_t *)&spec->dtsp_state,
+					DTRACESPEC_COMMITTING,
+					DTRACESPEC_INACTIVE);
+
+		ASSERT(rval == DTRACESPEC_COMMITTING);
+		rval = 0; /* Avoid warning about unused variable if !DEBUG */
+	}
+
+	src->dtb_offset = 0;
+	src->dtb_xamot_drops += src->dtb_drops;
+	src->dtb_drops = 0;
+}
+
+/*
+ * This routine discards an active speculation.  If the specified speculation
+ * is not in a valid state to perform a discard(), this routine will silently
+ * do nothing.  The state of the specified speculation is transitioned
+ * according to the state transition diagram outlined in <sys/dtrace_impl.h>
+ */
+void dtrace_speculation_discard(dtrace_state_t *state, processorid_t cpu,
+				dtrace_specid_t which)
+{
+	dtrace_speculation_t		*spec;
+	dtrace_speculation_state_t	curr, new = 0;
+	dtrace_buffer_t			*buf;
+
+	if (which == 0)
+		return;
+
+	if (which > state->dts_nspeculations) {
+		per_cpu_core(cpu)->cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
+		return;
+	}
+
+	spec = &state->dts_speculations[which - 1];
+	buf = &spec->dtsp_buffer[cpu];
+
+	do {
+		curr = spec->dtsp_state;
+
+		switch (curr) {
+		case DTRACESPEC_INACTIVE:
+		case DTRACESPEC_COMMITTINGMANY:
+		case DTRACESPEC_COMMITTING:
+		case DTRACESPEC_DISCARDING:
+			return;
+
+		case DTRACESPEC_ACTIVE:
+		case DTRACESPEC_ACTIVEMANY:
+			new = DTRACESPEC_DISCARDING;
+			break;
+
+		case DTRACESPEC_ACTIVEONE:
+			if (buf->dtb_offset != 0)
+				new = DTRACESPEC_INACTIVE;
+			else
+				new = DTRACESPEC_DISCARDING;
+
+			break;
+
+		default:
+			ASSERT(0);
+		}
+	} while (cmpxchg((uint32_t *)&spec->dtsp_state, curr, new) != curr);
+
+	buf->dtb_offset = 0;
+	buf->dtb_drops = 0;
+}
+
+/*
+ * Note:  not called from probe context.  This function is called
+ * asynchronously from cross call context to clean any speculations that are
+ * in the COMMITTINGMANY or DISCARDING states.  These speculations may not be
+ * transitioned back to the INACTIVE state until all CPUs have cleaned the
+ * speculation.
+ */
+void dtrace_speculation_clean_here(dtrace_state_t *state)
+{
+	dtrace_icookie_t	cookie;
+	processorid_t		cpu = smp_processor_id();
+	dtrace_buffer_t		*dest = &state->dts_buffer[cpu];
+	dtrace_specid_t		i;
+	uint32_t		re_entry;
+
+	DTRACE_SYNC_ENTER_CRITICAL(cookie, re_entry);
+
+	if (dest->dtb_tomax == NULL) {
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		dtrace_speculation_t	*spec = &state->dts_speculations[i];
+		dtrace_buffer_t		*src = &spec->dtsp_buffer[cpu];
+
+		if (src->dtb_tomax == NULL)
+			continue;
+
+		if (spec->dtsp_state == DTRACESPEC_DISCARDING) {
+			src->dtb_offset = 0;
+			continue;
+		}
+
+		if (spec->dtsp_state != DTRACESPEC_COMMITTINGMANY)
+			continue;
+
+		if (src->dtb_offset == 0)
+			continue;
+
+		dtrace_speculation_commit(state, cpu, i + 1);
+	}
+
+	DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+}
+
+void dtrace_speculation_clean(dtrace_state_t *state)
+{
+	int		work = 0, rv;
+	dtrace_specid_t	i;
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		dtrace_speculation_t	*spec = &state->dts_speculations[i];
+
+		ASSERT(!spec->dtsp_cleaning);
+
+		if (spec->dtsp_state != DTRACESPEC_DISCARDING &&
+		    spec->dtsp_state != DTRACESPEC_COMMITTINGMANY)
+			continue;
+
+		work++;
+		spec->dtsp_cleaning = 1;
+	}
+
+	if (!work)
+		return;
+
+	dtrace_xcall(DTRACE_CPUALL,
+		     (dtrace_xcall_t)dtrace_speculation_clean_here, state);
+
+	/*
+	 * We now know that all CPUs have committed or discarded their
+	 * speculation buffers, as appropriate.  We can now set the state
+	 * to inactive.
+	 */
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		dtrace_speculation_t		*spec =
+						&state->dts_speculations[i];
+		dtrace_speculation_state_t	curr, new;
+
+		if (!spec->dtsp_cleaning)
+			continue;
+
+		curr= spec->dtsp_state;
+		ASSERT(curr == DTRACESPEC_DISCARDING ||
+		       curr == DTRACESPEC_COMMITTINGMANY);
+
+		new = DTRACESPEC_INACTIVE;
+
+		rv = cmpxchg((uint32_t *)&spec->dtsp_state, curr, new);
+		ASSERT(rv == curr);
+		spec->dtsp_cleaning = 0;
+	}
+}
+
+/*
+ * Called as part of a speculate() to get the speculative buffer associated
+ * with a given speculation.  Returns NULL if the specified speculation is not
+ * in an ACTIVE state.  If the speculation is in the ACTIVEONE state -- and
+ * the active CPU is not the specified CPU -- the speculation will be
+ * atomically transitioned into the ACTIVEMANY state.
+ */
+dtrace_buffer_t *dtrace_speculation_buffer(dtrace_state_t *state,
+					   processorid_t cpu,
+					   dtrace_specid_t which)
+{
+	dtrace_speculation_t		*spec;
+	dtrace_speculation_state_t	curr, new = 0;
+	dtrace_buffer_t			*buf;
+
+	if (which == 0)
+		return NULL;
+
+	if (which > state->dts_nspeculations) {
+		per_cpu_core(cpu)->cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
+		return NULL;
+	}
+
+	spec = &state->dts_speculations[which - 1];
+	buf = &spec->dtsp_buffer[cpu];
+
+	do {
+		curr = spec->dtsp_state;
+
+		switch (curr) {
+		case DTRACESPEC_INACTIVE:
+		case DTRACESPEC_COMMITTINGMANY:
+		case DTRACESPEC_DISCARDING:
+			return NULL;
+
+		case DTRACESPEC_COMMITTING:
+			ASSERT(buf->dtb_offset == 0);
+			return NULL;
+
+		case DTRACESPEC_ACTIVEONE:
+			/*
+			 * This speculation is currently active on one CPU.
+			 * Check the offset in the buffer; if it's non-zero,
+			 * that CPU must be us (and we leave the state alone).
+			 * If it's zero, assume that we're starting on a new
+			 * CPU -- and change the state to indicate that the
+			 * speculation is active on more than one CPU.
+			 */
+			if (buf->dtb_offset != 0)
+				return buf;
+
+			new = DTRACESPEC_ACTIVEMANY;
+			break;
+
+		case DTRACESPEC_ACTIVEMANY:
+			return buf;
+
+		case DTRACESPEC_ACTIVE:
+			new = DTRACESPEC_ACTIVEONE;
+			break;
+
+		default:
+			ASSERT(0);
+		}
+	} while (cmpxchg((uint32_t *)&spec->dtsp_state, curr, new) != curr);
+
+	ASSERT(new == DTRACESPEC_ACTIVEONE || new == DTRACESPEC_ACTIVEMANY);
+
+	return buf;
+}
diff --git a/dtrace/dtrace_state.c b/dtrace/dtrace_state.c
new file mode 100644
index 000000000000..a15b024c95fa
--- /dev/null
+++ b/dtrace/dtrace_state.c
@@ -0,0 +1,1067 @@
+/*
+ * FILE:	dtrace_state.c
+ * DESCRIPTION:	DTrace - consumer state implementation
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/cyclic.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+#include <linux/smp.h>
+#include <linux/vmalloc.h>
+#include <asm/cmpxchg.h>
+
+#include "dtrace.h"
+
+int			dtrace_destructive_disallow = 0;
+dtrace_optval_t		dtrace_nspec_default = 1;
+dtrace_optval_t		dtrace_specsize_default = 32 * 1024;
+dtrace_optval_t		dtrace_dstate_defsize = 1 * 1024 * 1024;
+size_t			dtrace_strsize_default = 256;
+dtrace_optval_t		dtrace_stackframes_default = 20;
+dtrace_optval_t		dtrace_ustackframes_default = 100;
+dtrace_optval_t		dtrace_cleanrate_default = 9900990;
+dtrace_optval_t		dtrace_cleanrate_min = 20000;
+dtrace_optval_t		dtrace_cleanrate_max = (uint64_t)60 * NANOSEC;
+dtrace_optval_t		dtrace_aggrate_default = NANOSEC;
+dtrace_optval_t		dtrace_switchrate_default = NANOSEC;
+dtrace_optval_t		dtrace_statusrate_default = NANOSEC;
+dtrace_optval_t		dtrace_statusrate_max = (uint64_t)10 * NANOSEC;
+dtrace_optval_t		dtrace_jstackframes_default = 50;
+dtrace_optval_t		dtrace_jstackstrsize_default = 512;
+ktime_t			dtrace_deadman_interval = KTIME_INIT(1, 0);
+ktime_t			dtrace_deadman_timeout = KTIME_INIT(10, 0);
+ktime_t			dtrace_deadman_user = KTIME_INIT(30, 0);
+uint64_t		dtrace_sync_sample_count = 100; /* Sampling before counting */
+
+dtrace_id_t		dtrace_probeid_begin;
+dtrace_id_t		dtrace_probeid_end;
+dtrace_id_t		dtrace_probeid_error;
+
+dtrace_dynvar_t		dtrace_dynhash_sink;
+
+#define DTRACE_DYNHASH_FREE		0
+#define DTRACE_DYNHASH_SINK		1
+#define DTRACE_DYNHASH_VALID		2
+
+#define DTRACE_DYNVAR_CHUNKSIZE		256
+
+static void dtrace_dynvar_clean(dtrace_dstate_t *dstate)
+{
+	dtrace_dynvar_t		*dirty;
+	dtrace_dstate_percpu_t	*dcpu;
+	int			i, work = 0;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		dcpu = &dstate->dtds_percpu[i];
+
+		ASSERT(dcpu->dtdsc_rinsing == NULL);
+
+		/*
+		 * If the dirty list is NULL, there is no dirty work to do.
+		*/
+		if (dcpu->dtdsc_dirty == NULL)
+			continue;
+
+		/*
+		 * If the clean list is non-NULL, then we're not going to do
+		 * any work for this CPU -- it means that there has not been
+		 * a dtrace_dynvar() allocation on this CPU (or from this CPU)
+		 * since the last time we cleaned house.
+		 */
+		if (dcpu->dtdsc_clean != NULL)
+			continue;
+
+		work = 1;
+
+		/*
+		 * Atomically move the dirty list aside.
+		 */
+		do {
+			dirty = dcpu->dtdsc_dirty;
+
+			/*
+			 * Before we zap the dirty list, set the rinsing list.
+			 * (This allows for a potential assertion in
+			 * dtrace_dynvar():  if a free dynamic variable appears
+			 * on a hash chain, either the dirty list or the
+			 * rinsing list for some CPU must be non-NULL.)
+			 */
+			dcpu->dtdsc_rinsing = dirty;
+			dtrace_membar_producer();
+		} while (cmpxchg(&dcpu->dtdsc_dirty, dirty, NULL) != dirty);
+	}
+
+	/*
+	 * No work to do; return.
+	 */
+	if (!work)
+		return;
+
+	dtrace_sync();
+
+	for (i = 0; i < NR_CPUS; i++) {
+		dcpu = &dstate->dtds_percpu[i];
+
+		if (dcpu->dtdsc_rinsing == NULL)
+			continue;
+
+		/*
+		 * We are now guaranteed that no hash chain contains a pointer
+		 * into this dirty list; we can make it clean.
+		 */
+		ASSERT(dcpu->dtdsc_clean == NULL);
+		dcpu->dtdsc_clean = dcpu->dtdsc_rinsing;
+		dcpu->dtdsc_rinsing = NULL;
+	}
+
+	/*
+	 * Before we actually set the state to be DTRACE_DSTATE_CLEAN, make
+	 * sure that all CPUs have seen all of the dtdsc_clean pointers.
+	 * This prevents a race whereby a CPU incorrectly decides that
+	 * the state should be something other than DTRACE_DSTATE_CLEAN
+	 * after dtrace_dynvar_clean() has completed.
+	 */
+	dtrace_sync();
+
+	dstate->dtds_state = DTRACE_DSTATE_CLEAN;
+}
+
+int dtrace_dstate_init(dtrace_dstate_t *dstate, size_t size)
+{
+	size_t		hashsize, maxper, min,
+			chunksize = dstate->dtds_chunksize;
+	void		*base, *percpu;
+	uintptr_t	limit;
+	dtrace_dynvar_t	*dvar, *next, *start;
+	int		i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dstate->dtds_base == NULL && dstate->dtds_percpu == NULL);
+
+	memset(dstate, 0, sizeof (dtrace_dstate_t));
+
+	if ((dstate->dtds_chunksize = chunksize) == 0)
+		dstate->dtds_chunksize = DTRACE_DYNVAR_CHUNKSIZE;
+
+	if (size < (min = dstate->dtds_chunksize + sizeof (dtrace_dynhash_t)))
+		size = min;
+
+	base = dtrace_vzalloc_try(size);
+	if (base == NULL)
+		return -ENOMEM;
+	percpu = kmem_cache_alloc(dtrace_state_cachep, GFP_KERNEL);
+	if (percpu == NULL) {
+		vfree(base);
+		return -ENOMEM;
+	}
+
+	dstate->dtds_size = size;
+	dstate->dtds_base = base;
+	dstate->dtds_percpu = percpu;
+	memset(dstate->dtds_percpu, 0,
+	       NR_CPUS * sizeof (dtrace_dstate_percpu_t));
+
+	hashsize = size / (dstate->dtds_chunksize + sizeof (dtrace_dynhash_t));
+
+	if (hashsize != 1 && (hashsize & 1))
+		hashsize--;
+
+	dstate->dtds_hashsize = hashsize;
+	dstate->dtds_hash = dstate->dtds_base;
+
+	/*
+	 * Set all of our hash buckets to point to the single sink, and (if
+	 * it hasn't already been set), set the sink's hash value to be the
+	 * sink sentinel value.  The sink is needed for dynamic variable
+	 * lookups to know that they have iterated over an entire, valid hash
+	 * chain.
+	 */
+	for (i = 0; i < hashsize; i++)
+		dstate->dtds_hash[i].dtdh_chain = &dtrace_dynhash_sink;
+
+	if (dtrace_dynhash_sink.dtdv_hashval != DTRACE_DYNHASH_SINK)
+		dtrace_dynhash_sink.dtdv_hashval = DTRACE_DYNHASH_SINK;
+
+	/*
+	 * Determine number of active CPUs.  Divide free list evenly among
+	 * active CPUs.
+	 */
+	start = (dtrace_dynvar_t *)((uintptr_t)base +
+				    hashsize * sizeof (dtrace_dynhash_t));
+	limit = (uintptr_t)base + size;
+
+	maxper = (limit - (uintptr_t)start) / NR_CPUS;
+	maxper = (maxper / dstate->dtds_chunksize) * dstate->dtds_chunksize;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		dstate->dtds_percpu[i].dtdsc_free = dvar = start;
+
+		/*
+		 * If we don't even have enough chunks to make it once through
+		 * NCPUs, we're just going to allocate everything to the first
+		 * CPU.  And if we're on the last CPU, we're going to allocate
+		 * whatever is left over.  In either case, we set the limit to
+		 * be the limit of the dynamic variable space.
+		 */
+		if (maxper == 0 || i == NR_CPUS - 1) {
+			limit = (uintptr_t)base + size;
+			start = NULL;
+		} else {
+			limit = (uintptr_t)start + maxper;
+			start = (dtrace_dynvar_t *)limit;
+		}
+
+		ASSERT(limit <= (uintptr_t)base + size);
+
+		for (;;) {
+			next = (dtrace_dynvar_t *)((uintptr_t)dvar +
+						   dstate->dtds_chunksize);
+
+			if ((uintptr_t)next + dstate->dtds_chunksize >= limit)
+				break;
+
+			dvar->dtdv_next = next;
+			dvar = next;
+		}
+
+		if (maxper == 0)
+			break;
+	}
+
+	return 0;
+}
+
+void dtrace_dstate_fini(dtrace_dstate_t *dstate)
+{
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (dstate->dtds_base == NULL)
+		return;
+
+	vfree(dstate->dtds_base);
+	kmem_cache_free(dtrace_state_cachep, dstate->dtds_percpu);
+}
+
+void dtrace_vstate_fini(dtrace_vstate_t *vstate)
+{
+	/*
+	 * If only there was a logical XOR operator...
+	 */
+	ASSERT((vstate->dtvs_nglobals == 0) ^ (vstate->dtvs_globals != NULL));
+
+	if (vstate->dtvs_nglobals > 0)
+		vfree(vstate->dtvs_globals);
+
+	if (vstate->dtvs_ntlocals > 0)
+		vfree(vstate->dtvs_tlocals);
+
+	ASSERT((vstate->dtvs_nlocals == 0) ^ (vstate->dtvs_locals != NULL));
+
+	if (vstate->dtvs_nlocals > 0)
+		vfree(vstate->dtvs_locals);
+}
+
+static void dtrace_state_clean(dtrace_state_t *state)
+{
+	dtrace_optval_t		*opt = state->dts_options;
+
+	if (state->dts_activity != DTRACE_ACTIVITY_ACTIVE &&
+	    state->dts_activity != DTRACE_ACTIVITY_DRAINING)
+		return;
+
+	dtrace_dynvar_clean(&state->dts_vstate.dtvs_dynvars);
+	dtrace_speculation_clean(state);
+
+	cyclic_reprogram(state->dts_cleaner, ns_to_ktime(
+						opt[DTRACEOPT_CLEANRATE]));
+}
+
+static void dtrace_state_deadman(dtrace_state_t *state)
+{
+	ktime_t			now;
+
+	dtrace_sync();
+
+	now = dtrace_gethrtime();
+	if (state != dtrace_anon.dta_state &&
+	    ktime_ge(ktime_sub(now, state->dts_laststatus),
+		     dtrace_deadman_user))
+		return;
+
+	/*
+	 * We must be sure that dts_alive never appears to be less than the
+	 * value upon entry to dtrace_state_deadman(), and because we lack a
+	 * dtrace_cas64(), we cannot store to it atomically.  We thus instead
+	 * store KTIME_MAX to it, followed by a memory barrier, followed by
+	 * the new value.  This assures that dts_alive never appears to be
+	 * less than its true value, regardless of the order in which the
+	 * stores to the underlying storage are issued.
+	 */
+	state->dts_alive = ktime_set(KTIME_SEC_MAX, 0);
+	dtrace_membar_producer();
+	state->dts_alive = now;
+}
+
+dtrace_state_t *dtrace_state_create(struct file *file)
+{
+	dtrace_state_t	*state;
+	dtrace_optval_t	*opt;
+	int		bufsize = NR_CPUS * sizeof (dtrace_buffer_t), i;
+#ifdef FIXME
+	const cred_t	*cr = file->f_cred;
+#endif
+	dtrace_aggid_t	aggid;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	state = kzalloc(sizeof (dtrace_state_t), GFP_KERNEL);
+	if (state == NULL)
+		return NULL;
+
+	state->dts_epid = DTRACE_EPIDNONE + 1;
+	state->dts_buffer = vzalloc(bufsize);
+	if (state->dts_buffer == NULL) {
+		kfree(state);
+		return NULL;
+	}
+
+	state->dts_aggbuffer = vzalloc(bufsize);
+	if (state->dts_aggbuffer == NULL) {
+		vfree(state->dts_buffer);
+		kfree(state);
+		return NULL;
+	}
+
+	idr_init(&state->dts_agg_idr);
+	state->dts_naggs = 0;
+	state->dts_cleaner = 0;
+	state->dts_deadman = 0;
+	state->dts_vstate.dtvs_state = state;
+
+	/*
+	 * Create a first entry in the aggregation IDR, so that ID 0 is used as
+	 * that gets used as meaning 'none'.
+	 */
+	idr_preload(GFP_KERNEL);
+	aggid = idr_alloc_cyclic(&state->dts_agg_idr, NULL, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+
+	ASSERT(aggid == 0);
+
+	for (i = 0; i < DTRACEOPT_MAX; i++)
+		state->dts_options[i] = DTRACEOPT_UNSET;
+
+	/*
+	 * Set the default options.
+	 */
+	opt = state->dts_options;
+	opt[DTRACEOPT_BUFPOLICY] = DTRACEOPT_BUFPOLICY_SWITCH;
+	opt[DTRACEOPT_BUFRESIZE] = DTRACEOPT_BUFRESIZE_AUTO;
+	opt[DTRACEOPT_NSPEC] = dtrace_nspec_default;
+	opt[DTRACEOPT_SPECSIZE] = dtrace_specsize_default;
+	opt[DTRACEOPT_CPU] = (dtrace_optval_t)DTRACE_CPUALL;
+	opt[DTRACEOPT_STRSIZE] = dtrace_strsize_default;
+	opt[DTRACEOPT_STACKFRAMES] = dtrace_stackframes_default;
+	opt[DTRACEOPT_USTACKFRAMES] = dtrace_ustackframes_default;
+	opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_default;
+	opt[DTRACEOPT_AGGRATE] = dtrace_aggrate_default;
+	opt[DTRACEOPT_SWITCHRATE] = dtrace_switchrate_default;
+	opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_default;
+	opt[DTRACEOPT_JSTACKFRAMES] = dtrace_jstackframes_default;
+	opt[DTRACEOPT_JSTACKSTRSIZE] = dtrace_jstackstrsize_default;
+
+	state->dts_activity = DTRACE_ACTIVITY_INACTIVE;
+
+#ifdef FIXME
+	/*
+	 * Set probe visibility and destructiveness based on user credential
+	 * information.  For actual anonymous tracing or if all privileges are
+	 * set, checks are bypassed.
+	 */
+	if (cr == NULL ||
+	    PRIV_POLICY_ONLY(cr, PRIV_ALL, FALSE)) {
+		state->dts_cred.dcr_visible = DTRACE_CRV_ALL;
+		state->dts_cred.dcr_action = DTRACE_CRA_ALL;
+	} else {
+		state->dts_cred.dcr_cred = get_cred(cr);
+
+		/*
+		 * CRA_PROC means "we have *some* privilege for dtrace" and
+		 * it unlocks the use of variables like pid, etc.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, FALSE) ||
+		    PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, FALSE))
+			state->dts_cred.dcr_action |= DTRACE_CRA_PROC;
+
+		/*
+		 * The DTRACE_USER privilege allows the use of syscall and
+		 * profile providers.  If the user also has PROC_OWNER, we
+		 * extend the scope to include additional visibility and
+		 * destructive power.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, FALSE)) {
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_visible |=
+					DTRACE_CRV_ALLPROC;
+
+			state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+
+		/*
+		 * Holding the DTRACE_KERNEL privilege also implies that
+		 * the user has the DTRACE_USER privilege from a visibility
+		 * perspective.  But without further privileges, some
+		 * destructive actions are not available.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_KERNEL, FALSE)) {
+			/*
+			 * Make all probes in all zones visible.  However,
+			 * this doesn't mean that all actions become available
+			 * to all zones.
+			 */
+			state->dts_cred.dcr_visible |= DTRACE_CRV_KERNEL |
+						       DTRACE_CRV_ALLPROC;
+			state->dts_cred.dcr_action |= DTRACE_CRA_KERNEL |
+						      DTRACE_CRA_PROC;
+
+			/*
+			 * Holding PROC_OWNER means that destructive actions
+			 * are allowed.
+			 */
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+
+		/*
+		 * Holding the DTRACE_PROC privilege gives control over the
+		 * fasttrap and pid providers.  We need to grant wider
+		 * destructive privileges in the event that the user has
+		 * PROC_OWNER .
+		*/
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, FALSE)) {
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+	}
+#else
+	state->dts_cred.dcr_visible = DTRACE_CRV_ALLPROC | DTRACE_CRV_KERNEL;
+	state->dts_cred.dcr_action = DTRACE_CRA_ALL;
+#endif
+
+	return state;
+}
+
+static int dtrace_state_buffer(dtrace_state_t *state, dtrace_buffer_t *buf,
+			       int which)
+{
+	dtrace_optval_t	*opt = state->dts_options, size;
+	processorid_t	cpu = DTRACE_CPUALL;
+	int		flags = 0, rval;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	ASSERT(which < DTRACEOPT_MAX);
+	ASSERT(state->dts_activity == DTRACE_ACTIVITY_INACTIVE ||
+	       (state == dtrace_anon.dta_state &&
+	       state->dts_activity == DTRACE_ACTIVITY_ACTIVE));
+
+	if (opt[which] == DTRACEOPT_UNSET || opt[which] == 0)
+		return 0;
+
+	if (opt[DTRACEOPT_CPU] != DTRACEOPT_UNSET)
+		cpu = opt[DTRACEOPT_CPU];
+
+	if (which == DTRACEOPT_SPECSIZE)
+		flags |= DTRACEBUF_NOSWITCH;
+
+	if (which == DTRACEOPT_BUFSIZE) {
+		if (opt[DTRACEOPT_BUFPOLICY] == DTRACEOPT_BUFPOLICY_RING)
+			flags |= DTRACEBUF_RING;
+
+		if (opt[DTRACEOPT_BUFPOLICY] == DTRACEOPT_BUFPOLICY_FILL)
+			flags |= DTRACEBUF_FILL;
+
+		if (state != dtrace_anon.dta_state ||
+		    state->dts_activity != DTRACE_ACTIVITY_ACTIVE)
+			flags |= DTRACEBUF_INACTIVE;
+	}
+
+	for (size = opt[which]; size >= sizeof (uint64_t); size >>= 1) {
+		/*
+		 * The size must be 8-byte aligned.  If the size is not 8-byte
+		 * aligned, drop it down by the difference.
+		 */
+		if (size & (sizeof (uint64_t) - 1))
+			size -= size & (sizeof (uint64_t) - 1);
+
+		if (size < state->dts_reserve) {
+			/*
+			 * Buffers always must be large enough to accommodate
+			 * their prereserved space.  We return -E2BIG instead
+			 * of ENOMEM in this case to allow for user-level
+			 * software to differentiate the cases.
+			 */
+			return -E2BIG;
+		}
+
+		rval = dtrace_buffer_alloc(buf, size, flags, cpu);
+		if (rval != -ENOMEM) {
+			opt[which] = size;
+			return rval;
+		}
+
+		if (opt[DTRACEOPT_BUFRESIZE] == DTRACEOPT_BUFRESIZE_MANUAL)
+			return rval;
+	}
+
+	return -ENOMEM;
+}
+
+static int dtrace_state_buffers(dtrace_state_t *state)
+{
+	dtrace_speculation_t	*spec = state->dts_speculations;
+	int			rval, i;
+
+	if ((rval = dtrace_state_buffer(state, state->dts_buffer,
+					DTRACEOPT_BUFSIZE)) != 0)
+		return rval;
+
+	if ((rval = dtrace_state_buffer(state, state->dts_aggbuffer,
+					DTRACEOPT_AGGSIZE)) != 0)
+		return rval;
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		if ((rval = dtrace_state_buffer(state, spec[i].dtsp_buffer,
+						DTRACEOPT_SPECSIZE)) != 0)
+			return rval;
+	}
+
+	return 0;
+}
+
+static void dtrace_state_prereserve(dtrace_state_t *state)
+{
+	dtrace_ecb_t	*ecb;
+	dtrace_probe_t	*probe;
+
+	state->dts_reserve = 0;
+
+	if (state->dts_options[DTRACEOPT_BUFPOLICY] != DTRACEOPT_BUFPOLICY_FILL)
+		return;
+
+	/*
+	 * If our buffer policy is a "fill" buffer policy, we need to set the
+	 * prereserved space to be the space required by the END probes.
+	 */
+	probe = dtrace_probe_lookup_id(dtrace_probeid_end);
+	ASSERT(probe != NULL);
+
+	for (ecb = probe->dtpr_ecb; ecb != NULL; ecb = ecb->dte_next) {
+		if (ecb->dte_state != state)
+			continue;
+
+		state->dts_reserve += ecb->dte_needed + ecb->dte_alignment;
+	}
+}
+
+int dtrace_state_go(dtrace_state_t *state, processorid_t *cpu)
+{
+	dtrace_optval_t		*opt = state->dts_options, sz, nspec;
+	dtrace_speculation_t	*spec;
+	dtrace_buffer_t		*buf;
+	cyc_handler_t		hdlr;
+	cyc_time_t		when;
+	int			rval = 0, i,
+				bufsize = NR_CPUS * sizeof (dtrace_buffer_t);
+	dtrace_icookie_t	cookie;
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * Before we can perform any checks, we must prime all of the
+	 * retained enablings that correspond to this state.
+	 */
+	dtrace_enabling_prime(state);
+
+	if (state->dts_destructive && !state->dts_cred.dcr_destructive) {
+		rval = -EACCES;
+		goto out;
+	}
+
+	dtrace_state_prereserve(state);
+
+	/*
+	 * Now we want to do is try to allocate our speculations.
+	 * We do not automatically resize the number of speculations; if
+	 * this fails, we will fail the operation.
+	 */
+	nspec = opt[DTRACEOPT_NSPEC];
+	ASSERT(nspec != DTRACEOPT_UNSET);
+
+	if (nspec > INT_MAX) {
+		rval = -ENOMEM;
+		goto out;
+	}
+
+	spec = vzalloc(nspec * sizeof(dtrace_speculation_t));
+	if (spec == NULL) {
+		rval = -ENOMEM;
+		goto out;
+	}
+
+	state->dts_speculations = spec;
+	state->dts_nspeculations = (int)nspec;
+
+	for (i = 0; i < nspec; i++) {
+		if ((buf = vzalloc(bufsize)) == NULL) {
+			rval = -ENOMEM;
+			goto err;
+		}
+
+		spec[i].dtsp_buffer = buf;
+	}
+
+	if (opt[DTRACEOPT_GRABANON] != DTRACEOPT_UNSET) {
+		if (dtrace_anon.dta_state == NULL) {
+			rval = -ENOENT;
+			goto out;
+		}
+
+		if (state->dts_necbs != 0) {
+			rval = -EALREADY;
+			goto out;
+		}
+
+		state->dts_anon = dtrace_anon_grab();
+		ASSERT(state->dts_anon != NULL);
+		state = state->dts_anon;
+
+		/*
+		 * We want "grabanon" to be set in the grabbed state, so we'll
+		 * copy that option value from the grabbing state into the
+		 * grabbed state.
+		 */
+		state->dts_options[DTRACEOPT_GRABANON] =
+						opt[DTRACEOPT_GRABANON];
+
+		*cpu = dtrace_anon.dta_beganon;
+
+		/*
+		 * If the anonymous state is active (as it almost certainly
+		 * is if the anonymous enabling ultimately matched anything),
+		 * we don't allow any further option processing -- but we
+		 * don't return failure.
+		 */
+		if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+			goto out;
+	}
+
+	if (opt[DTRACEOPT_AGGSIZE] != DTRACEOPT_UNSET &&
+	    opt[DTRACEOPT_AGGSIZE] != 0) {
+		if (state->dts_naggs == 0) {
+			/*
+			 * We're not going to create an aggregation buffer
+			 * because we don't have any ECBs that contain
+			 * aggregations -- set this option to 0.
+			 */
+			opt[DTRACEOPT_AGGSIZE] = 0;
+		} else {
+			/*
+			 * If we have an aggregation buffer, we must also have
+			 * a buffer to use as scratch.
+			 */
+			if (opt[DTRACEOPT_BUFSIZE] == DTRACEOPT_UNSET ||
+			    opt[DTRACEOPT_BUFSIZE] < state->dts_needed)
+				opt[DTRACEOPT_BUFSIZE] = state->dts_needed;
+		}
+	}
+
+	if (opt[DTRACEOPT_SPECSIZE] != DTRACEOPT_UNSET &&
+	    opt[DTRACEOPT_SPECSIZE] != 0) {
+		/*
+		 * We are not going to create speculation buffers if we do not
+		 * have any ECBs that actually speculate.
+		 */
+		if (!state->dts_speculates)
+			opt[DTRACEOPT_SPECSIZE] = 0;
+	}
+
+	/*
+	 * The bare minimum size for any buffer that we're actually going to
+	 * do anything to is sizeof (uint64_t).
+	 */
+	sz = sizeof (uint64_t);
+
+	if ((state->dts_needed != 0 && opt[DTRACEOPT_BUFSIZE] < sz) ||
+	    (state->dts_speculates && opt[DTRACEOPT_SPECSIZE] < sz) ||
+	    (state->dts_naggs != 0 && opt[DTRACEOPT_AGGSIZE] < sz)) {
+		/*
+		 * A buffer size has been explicitly set to 0 (or to a size
+		 * that will be adjusted to 0) and we need the space -- we
+		 * need to return failure.  We return -ENOSPC to differentiate
+		 * it from failing to allocate a buffer due to failure to meet
+		 * the reserve (for which we return -E2BIG).
+		 */
+		rval = -ENOSPC;
+		goto out;
+	}
+
+	if ((rval = dtrace_state_buffers(state)) != 0)
+		goto err;
+
+	if ((sz = opt[DTRACEOPT_DYNVARSIZE]) == DTRACEOPT_UNSET)
+		sz = dtrace_dstate_defsize;
+
+	do {
+		rval = dtrace_dstate_init(&state->dts_vstate.dtvs_dynvars, sz);
+
+		if (rval == 0)
+			break;
+
+		if (opt[DTRACEOPT_BUFRESIZE] == DTRACEOPT_BUFRESIZE_MANUAL)
+			goto err;
+	} while (sz >>= 1);
+
+	opt[DTRACEOPT_DYNVARSIZE] = sz;
+
+	if (rval != 0)
+		goto err;
+
+	if (opt[DTRACEOPT_STATUSRATE] > dtrace_statusrate_max)
+		opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_max;
+
+	if (opt[DTRACEOPT_CLEANRATE] == 0)
+		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_max;
+
+	if (opt[DTRACEOPT_CLEANRATE] < dtrace_cleanrate_min)
+		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_min;
+
+	if (opt[DTRACEOPT_CLEANRATE] > dtrace_cleanrate_max)
+		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_max;
+
+	hdlr.cyh_func = (cyc_func_t)dtrace_state_clean;
+	hdlr.cyh_arg = (uintptr_t)state;
+	hdlr.cyh_level = CY_LOW_LEVEL;
+
+	when.cyt_when = ktime_set(0, 0);
+	when.cyt_interval = CY_INTERVAL_INF;
+
+	state->dts_cleaner = cyclic_add(&hdlr, &when);
+	cyclic_reprogram(state->dts_cleaner, ns_to_ktime(
+						opt[DTRACEOPT_CLEANRATE]));
+
+	hdlr.cyh_func = (cyc_func_t)dtrace_state_deadman;
+	hdlr.cyh_arg = (uintptr_t)state;
+	hdlr.cyh_level = CY_LOW_LEVEL;
+
+	when.cyt_when = ktime_set(0, 0);
+	when.cyt_interval = dtrace_deadman_interval;
+
+	state->dts_alive = state->dts_laststatus = dtrace_gethrtime();
+	state->dts_deadman = cyclic_add(&hdlr, &when);
+
+	state->dts_activity = DTRACE_ACTIVITY_WARMUP;
+
+	/*
+	 * Now it's time to actually fire the BEGIN probe.  We need to disable
+	 * interrupts here both to record the CPU on which we fired the BEGIN
+	 * probe (the data from this CPU will be processed first at user
+	 * level) and to manually activate the buffer for this CPU.
+	 */
+	local_irq_save(cookie);
+	*cpu = smp_processor_id();
+//	ASSERT(state->dts_buffer[*cpu].dtb_flags & DTRACEBUF_INACTIVE);
+	state->dts_buffer[*cpu].dtb_flags &= ~DTRACEBUF_INACTIVE;
+
+	dtrace_probe(dtrace_probeid_begin, (uint64_t)(uintptr_t)state, 0, 0, 0,
+		     0, 0, 0);
+	local_irq_restore(cookie);
+
+	/*
+	 * We may have had an exit action from a BEGIN probe; only change our
+	 * state to ACTIVE if we're still in WARMUP.
+	 */
+	ASSERT(state->dts_activity == DTRACE_ACTIVITY_WARMUP ||
+	       state->dts_activity == DTRACE_ACTIVITY_DRAINING);
+
+	if (state->dts_activity == DTRACE_ACTIVITY_WARMUP)
+		state->dts_activity = DTRACE_ACTIVITY_ACTIVE;
+
+	/*
+	 * Regardless of whether or not now we're in ACTIVE or DRAINING, we
+	 * want each CPU to transition its principal buffer out of the
+	 * INACTIVE state.  Doing this assures that no CPU will suddenly begin
+	 * processing an ECB halfway down a probe's ECB chain; all CPUs will
+	 * atomically transition from processing none of a state's ECBs to
+	 * processing all of them.
+	 */
+	dtrace_xcall(DTRACE_CPUALL, (dtrace_xcall_t)dtrace_buffer_activate,
+		     state);
+	goto out;
+
+err:
+	dtrace_buffer_free(state->dts_buffer);
+	dtrace_buffer_free(state->dts_aggbuffer);
+
+	if ((nspec = state->dts_nspeculations) == 0) {
+		ASSERT(state->dts_speculations == NULL);
+		goto out;
+	}
+
+	spec = state->dts_speculations;
+	ASSERT(spec != NULL);
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		if ((buf = spec[i].dtsp_buffer) == NULL)
+			break;
+
+		dtrace_buffer_free(buf);
+		vfree(buf);
+	}
+
+	vfree(spec);
+	state->dts_nspeculations = 0;
+	state->dts_speculations = NULL;
+
+out:
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&cpu_lock);
+
+	return rval;
+}
+
+int dtrace_state_stop(dtrace_state_t *state, processorid_t *cpu)
+{
+	dtrace_icookie_t	cookie;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (state->dts_activity != DTRACE_ACTIVITY_ACTIVE &&
+	    state->dts_activity != DTRACE_ACTIVITY_DRAINING)
+		return -EINVAL;
+
+	/*
+	 * We'll set the activity to DTRACE_ACTIVITY_DRAINING, and issue a sync
+	 * to be sure that every CPU has seen it.  See below for the details
+	 * on why this is done.
+	 */
+	state->dts_activity = DTRACE_ACTIVITY_DRAINING;
+	dtrace_sync();
+
+	/*
+	 * By this point, it is impossible for any CPU to be still processing
+	 * with DTRACE_ACTIVITY_ACTIVE.  We can thus set our activity to
+	 * DTRACE_ACTIVITY_COOLDOWN and know that we're not racing with any
+	 * other CPU in dtrace_buffer_reserve().  This allows dtrace_probe()
+	 * and callees to know that the activity is DTRACE_ACTIVITY_COOLDOWN
+	 * iff we're in the END probe.
+	 */
+	state->dts_activity = DTRACE_ACTIVITY_COOLDOWN;
+	dtrace_sync();
+	ASSERT(state->dts_activity == DTRACE_ACTIVITY_COOLDOWN);
+
+	/*
+	 * Finally, we can release the reserve and call the END probe.  We
+	 * disable interrupts across calling the END probe to allow us to
+	 * return the CPU on which we actually called the END probe.  This
+	 * allows user-land to be sure that this CPU's principal buffer is
+	 * processed last.
+	 */
+	state->dts_reserve = 0;
+
+	local_irq_save(cookie);
+	*cpu = smp_processor_id();
+	dtrace_probe(dtrace_probeid_end, (uint64_t)(uintptr_t)state, 0, 0, 0,
+		     0, 0, 0);
+	local_irq_restore(cookie);
+
+	state->dts_activity = DTRACE_ACTIVITY_STOPPED;
+	dtrace_sync();
+
+	return 0;
+}
+
+int dtrace_state_option(dtrace_state_t *state, dtrace_optid_t option,
+			dtrace_optval_t val)
+{
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+		return -EBUSY;
+
+	if (option >= DTRACEOPT_MAX)
+		return -EINVAL;
+
+	if (option != DTRACEOPT_CPU && val < 0)
+		return -EINVAL;
+
+	switch (option) {
+	case DTRACEOPT_DESTRUCTIVE:
+		if (dtrace_destructive_disallow)
+			return -EACCES;
+
+		state->dts_cred.dcr_destructive = 1;
+		break;
+
+	case DTRACEOPT_BUFSIZE:
+	case DTRACEOPT_DYNVARSIZE:
+	case DTRACEOPT_AGGSIZE:
+	case DTRACEOPT_SPECSIZE:
+	case DTRACEOPT_STRSIZE:
+		if (val < 0)
+			return -EINVAL;
+
+		/*
+		 * If this is an otherwise negative value, set it to the
+		 * highest multiple of 128m less than LONG_MAX.  Technically,
+		 * we're adjusting the size without regard to the buffer
+		 * resizing policy, but in fact, this has no effect -- if we
+		 * set the buffer size to ~LONG_MAX and the buffer policy is
+		 * ultimately set to be "manual", the buffer allocation is
+		 * guaranteed to fail, if only because the allocation requires
+		 * two buffers.  (We set the the size to the highest multiple
+		 * of 128m because it ensures that the size will remain a
+		 * multiple of a megabyte when repeatedly halved -- all the
+		 * way down to 15m.)
+		 */
+		if (val >= LONG_MAX)
+			val = LONG_MAX - (1 << 27) + 1;
+	}
+
+	state->dts_options[option] = val;
+
+	return 0;
+}
+
+void dtrace_state_destroy(dtrace_state_t *state)
+{
+	dtrace_ecb_t		*ecb;
+	dtrace_vstate_t		*vstate = &state->dts_vstate;
+	int			i;
+	dtrace_speculation_t	*spec = state->dts_speculations;
+	int			nspec = state->dts_nspeculations;
+	uint32_t		match;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	/*
+	 * First, retract any retained enablings for this state.
+	 */
+	dtrace_enabling_retract(state);
+	ASSERT(state->dts_nretained == 0);
+
+	if (state->dts_activity == DTRACE_ACTIVITY_ACTIVE ||
+	    state->dts_activity == DTRACE_ACTIVITY_DRAINING) {
+		/*
+		 * We have managed to come into dtrace_state_destroy() on a
+		 * hot enabling -- almost certainly because of a disorderly
+		 * shutdown of a consumer.  (That is, a consumer that is
+		 * exiting without having called dtrace_stop().) In this case,
+		 * we're going to set our activity to be KILLED, and then
+		 * issue a sync to be sure that everyone is out of probe
+		 * context before we start blowing away ECBs.
+		 */
+		state->dts_activity = DTRACE_ACTIVITY_KILLED;
+		dtrace_sync();
+	}
+
+	/*
+	 * Release the credential hold we took in dtrace_state_create().
+	 */
+	if (state->dts_cred.dcr_cred != NULL)
+		put_cred(state->dts_cred.dcr_cred);
+
+	/*
+	 * Now we can safely disable and destroy any enabled probes.  Because
+	 * any DTRACE_PRIV_KERNEL probes may actually be slowing our progress
+	 * (especially if they're all enabled), we take two passes through the
+	 * ECBs: in the first, we disable just DTRACE_PRIV_KERNEL probes, and
+	 * in the second we disable whatever is left over.
+	*/
+	for (match = DTRACE_PRIV_KERNEL; ; match = 0) {
+		for (i = 0; i < state->dts_necbs; i++) {
+			if ((ecb = state->dts_ecbs[i]) == NULL)
+				continue;
+
+			if (match && ecb->dte_probe != NULL) {
+				dtrace_probe_t		*probe =
+							ecb->dte_probe;
+				dtrace_provider_t	*prov =
+							probe->dtpr_provider;
+
+				if (!(prov->dtpv_priv.dtpp_flags & match))
+					continue;
+			}
+
+			dtrace_ecb_disable(ecb);
+			dtrace_ecb_destroy(ecb);
+		}
+
+		if (!match)
+			break;
+	}
+
+	/*
+	 * Before we free the buffers, perform one more sync to assure that
+	 * every CPU is out of probe context.
+	 */
+	dtrace_sync();
+
+	dtrace_buffer_free(state->dts_buffer);
+	dtrace_buffer_free(state->dts_aggbuffer);
+
+	for (i = 0; i < nspec; i++)
+		dtrace_buffer_free(spec[i].dtsp_buffer);
+
+	if (state->dts_cleaner != CYCLIC_NONE)
+		cyclic_remove(state->dts_cleaner);
+
+	if (state->dts_deadman != CYCLIC_NONE)
+		cyclic_remove(state->dts_deadman);
+
+	dtrace_dstate_fini(&vstate->dtvs_dynvars);
+	dtrace_vstate_fini(vstate);
+	vfree(state->dts_ecbs);
+
+	/*
+	 * If there were aggregations allocated, they should have been cleaned
+	 * up by now, so we can get rid of the idr.
+	 */
+	idr_destroy(&state->dts_agg_idr);
+
+	vfree(state->dts_buffer);
+	vfree(state->dts_aggbuffer);
+
+	for (i = 0; i < nspec; i++)
+		vfree(spec[i].dtsp_buffer);
+
+	vfree(spec);
+
+	dtrace_format_destroy(state);
+
+	kfree(state);
+}
diff --git a/dtrace/dtrace_util.c b/dtrace/dtrace_util.c
new file mode 100644
index 000000000000..c20d7d09e3ec
--- /dev/null
+++ b/dtrace/dtrace_util.c
@@ -0,0 +1,169 @@
+/*
+ * FILE:	dtrace_util.c
+ * DESCRIPTION:	DTrace - utility functions
+ *
+ * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+
+#include "dtrace.h"
+
+int dtrace_badattr(const dtrace_attribute_t *a)
+{
+	return a->dtat_name > DTRACE_STABILITY_MAX ||
+	       a->dtat_data > DTRACE_STABILITY_MAX ||
+	       a->dtat_class > DTRACE_CLASS_MAX;
+}
+
+/*
+ * Allocate a chunk of virtual memory in kernel space, and zero it out.  This
+ * allocation might fail (which will report a backtrace in the kernel log, yet
+ * it is harmless).
+ */
+void *dtrace_vzalloc_try(unsigned long size)
+{
+	return __vmalloc(size,
+			 GFP_NOWAIT | __GFP_FS | __GFP_IO | __GFP_NOMEMALLOC |
+			 __GFP_NORETRY | __GFP_NOWARN | __GFP_ZERO,
+			 PAGE_KERNEL);
+}
+EXPORT_SYMBOL(dtrace_vzalloc_try);
+
+/*
+ * Return a duplicate copy of a string.  If the specified string is NULL, this
+ * function returs a zero-length string.
+ */
+char *dtrace_strdup(const char *str)
+{
+	return kstrdup(str ? str : "", GFP_KERNEL);
+}
+
+/*
+ * Compare two strings using safe loads.
+ */
+int dtrace_strncmp(char *s1, char *s2, size_t limit)
+{
+	uint8_t			c1, c2;
+	volatile uint16_t	*flags;
+
+	if (s1 == s2 || limit == 0)
+		return 0;
+
+	flags = (volatile uint16_t *)&this_cpu_core->cpuc_dtrace_flags;
+
+	do {
+		if (s1 == NULL)
+			c1 = '\0';
+		else
+			c1 = dtrace_load8((uintptr_t)s1++);
+
+		if (s2 == NULL)
+			c2 = '\0';
+		else
+			c2 = dtrace_load8((uintptr_t)s2++);
+
+		if (c1 != c2)
+			return (c1 - c2);
+	} while (--limit && c1 != '\0' && !(*flags & CPU_DTRACE_FAULT));
+
+	return 0;
+}
+
+/*
+ * Compute strlen(s) for a string using safe memory accesses.  The additional
+ * len parameter is used to specify a maximum length to ensure completion.
+ */
+size_t dtrace_strlen(const char *s, size_t lim)
+{
+	uint_t	len;
+
+	for (len = 0; len != lim; len++) {
+		if (dtrace_load8((uintptr_t)s++) == '\0')
+			break;
+	}
+
+	return len;
+}
+
+#define DTRACE_ISALPHA(c)	(((c) >= 'a' && (c) <= 'z') || \
+				 ((c) >= 'A' && (c) <= 'Z'))
+int dtrace_badname(const char *s)
+{
+	char	c;
+
+	if (s == NULL || (c = *s++) == '\0')
+		return 0;
+
+	if (!DTRACE_ISALPHA(c) && c != '-' && c!= '_' && c != '.')
+		return 1;
+
+	while ((c = *s++) != '\0') {
+		if (!DTRACE_ISALPHA(c) && (c < '0' || c > '9') &&
+		    c != '-' && c!= '_' && c != '.' && c != '`')
+			return 1;
+	}
+
+	return 0;
+}
+
+void dtrace_cred2priv(const cred_t *cr, uint32_t *privp, kuid_t *uidp)
+{
+#ifdef FIXME
+/*
+ * This should probably be rewritten based on capabilities in the cred_t struct.
+ */
+	uint32_t	priv;
+
+	if (cr == NULL)
+		priv = DTRACE_PRIV_ALL;
+	else {
+		const cred_t	*lcr = get_cred(cr);
+
+		if (PRIV_POLICY_ONLY(lcr, PRIV_ALL, FALSE))
+			priv = DTRACE_PRIV_ALL;
+		else {
+			*uidp = lcr->uid;
+			priv = 0;
+
+			if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_KERNEL, FALSE))
+				priv |= DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER;
+			else if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_USER,
+						  FALSE))
+				priv |= DTRACE_PRIV_USER;
+
+			if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_PROC, FALSE))
+				priv |= DTRACE_PRIV_PROC;
+			if (PRIV_POLICY_ONLY(lcr, PRIV_PROC_OWNER, FALSE))
+				priv |= DTRACE_PRIV_OWNER;
+		}
+
+		put_cred(cr);
+	}
+
+	*privp = priv;
+#else
+	*privp = DTRACE_PRIV_ALL;
+
+	if (cr != NULL) {
+		const cred_t	*lcr = get_cred(cr);
+
+		*uidp = lcr->uid;
+		put_cred(cr);
+	}
+#endif
+}
+
diff --git a/dtrace/fasttrap_dev.c b/dtrace/fasttrap_dev.c
new file mode 100644
index 000000000000..4c3524f1e9e5
--- /dev/null
+++ b/dtrace/fasttrap_dev.c
@@ -0,0 +1,1688 @@
+/*
+ * FILE:	fasttrap_dev.c
+ * DESCRIPTION:	DTrace - fasttrap provider device driver
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/atomic.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fasttrap_impl.h"
+
+#define FIX_FORCE_UNIQUE_PROVNAME_PER_PID
+
+#define FASTTRAP_MAX_DEFAULT	250000
+static uint32_t			fasttrap_max;
+static uint64_t			fasttrap_pid_count;
+static atomic_t			fasttrap_total;
+
+#define FASTTRAP_TPOINTS_DEFAULT_SIZE	0x4000
+#define FASTTRAP_PROVIDERS_DEFAULT_SIZE	0x100
+#define FASTTRAP_PROCS_DEFAULT_SIZE	0x100
+
+#define FASTTRAP_PID_NAME	"pid"
+#define FASTTRAP_ENABLE_FAIL	1
+#define FASTTRAP_ENABLE_PARTIAL	2
+
+fasttrap_hash_t			fasttrap_tpoints;
+static fasttrap_hash_t		fasttrap_provs;
+static fasttrap_hash_t		fasttrap_procs;
+
+#define FASTTRAP_PROVS_INDEX(pid, name) \
+	((fasttrap_hash_str(name) + (pid)) & fasttrap_provs.fth_mask)
+#define FASTTRAP_PROCS_INDEX(pid) ((pid) & fasttrap_procs.fth_mask)
+
+#define FASTTRAP_TPOINTS_ELEM(pid, pc) \
+	FASTTRAP_ELEM_BUCKET(&fasttrap_tpoints.fth_table[FASTTRAP_TPOINTS_INDEX(pid, pc)])
+#define FASTTRAP_PROVS_ELEM(pid, name) \
+	FASTTRAP_ELEM_BUCKET(&fasttrap_provs.fth_table[FASTTRAP_PROVS_INDEX(pid, name)])
+#define FASTTRAP_PROCS_ELEM(pid)       \
+	FASTTRAP_ELEM_BUCKET(&fasttrap_procs.fth_table[FASTTRAP_PROCS_INDEX(pid)])
+
+#define CLEANUP_NONE		0
+#define CLEANUP_SCHEDULED	1
+#define CLEANUP_DEFERRED	2
+
+DEFINE_MUTEX(fasttrap_cleanup_mtx);
+DEFINE_MUTEX(fasttrap_count_mtx);
+static uint_t			fasttrap_cleanup_state;
+static uint_t			fasttrap_cleanup_work;
+
+static struct kmem_cache	*tracepoint_cachep;
+
+/*
+ * Generation count on modifications to the global tracepoint lookup table.
+ */
+static volatile uint64_t	fasttrap_mod_gen;
+
+static void fasttrap_pid_cleanup(void);
+
+static int fasttrap_pid_probe(fasttrap_machtp_t *mtp, struct pt_regs *regs) {
+	fasttrap_tracepoint_t	*tp = container_of(mtp, fasttrap_tracepoint_t,
+						   ftt_mtp);
+	fasttrap_id_t		*id;
+	int			is_enabled = 0;
+
+	/*
+	 * Verify that this probe event is actually related to the current
+	 * task.  If not, ignore it.
+	 *
+	 * TODO: The underlying probe mechanism should register a single
+	 * 	 handler for the (inode, offset) combination.  When the handler
+	 * 	 is called, it should run through a list of fasttrap
+	 * 	 tracepoints associated with the OS-level probe, looking for
+	 * 	 one that is related to the current task.
+	 */
+	if (tp->ftt_pid != current->pid)
+		return 0;
+
+	if (atomic64_read(&tp->ftt_proc->ftpc_acount) == 0)
+		return 0;
+
+	this_cpu_core->cpu_dtrace_regs = regs;
+
+	for (id = tp->ftt_ids; id != NULL; id = id->fti_next) {
+		fasttrap_probe_t	*ftp = id->fti_probe;
+
+		if (id->fti_ptype == DTFTP_IS_ENABLED)
+			is_enabled = 1;
+		else
+			fasttrap_pid_probe_arch(ftp, regs);
+	}
+
+	this_cpu_core->cpu_dtrace_regs = NULL;
+
+	if (is_enabled)
+		fasttrap_set_enabled(regs);
+
+	return 0;
+}
+
+static void fasttrap_pid_provide(void *arg, const dtrace_probedesc_t *desc)
+{
+	/*
+	 * There are no "default" pid probes.
+	 */
+}
+
+static void fasttrap_enable_callbacks(void)
+{
+	/*
+	 * We don't have to play the RW lock game here because we're providing
+	 * something rather than taking something away -- we can be sure that
+	 * no threads have tried to follow these function pointers yet.
+	 */
+	mutex_lock(&fasttrap_count_mtx);
+	if (fasttrap_pid_count == 0) {
+		ASSERT(dtrace_tracepoint_hit == NULL);
+
+		dtrace_tracepoint_hit = &fasttrap_pid_probe;
+	}
+
+	ASSERT(dtrace_tracepoint_hit == &fasttrap_pid_probe);
+
+	fasttrap_pid_count++;
+	mutex_unlock(&fasttrap_count_mtx);
+}
+
+static void fasttrap_disable_callbacks(void)
+{
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	mutex_lock(&fasttrap_count_mtx);
+	ASSERT(fasttrap_pid_count > 0);
+	fasttrap_pid_count--;
+
+	if (fasttrap_pid_count == 0) {
+		int	cpu;
+
+		for_each_present_cpu(cpu) {
+			cpu_core_t	*cpuc = per_cpu_core(cpu);
+
+			write_lock(&cpuc->cpu_ft_lock);
+		}
+
+		dtrace_tracepoint_hit = NULL;
+
+		for_each_present_cpu(cpu) {
+			cpu_core_t	*cpuc = per_cpu_core(cpu);
+
+			write_unlock(&cpuc->cpu_ft_lock);
+		}
+	}
+
+	mutex_unlock(&fasttrap_count_mtx);
+}
+
+/*
+ * This function ensures that no threads are actively using the memory
+ * associated with probes that were formerly live.
+ */
+static void fasttrap_mod_barrier(uint64_t gen)
+{
+	int	cpu;
+
+	if (gen < fasttrap_mod_gen)
+		return;
+
+	fasttrap_mod_gen++;
+
+	for_each_present_cpu(cpu) {
+		cpu_core_t	*cpuc = per_cpu_core(cpu);
+
+		mutex_lock(&cpuc->cpuc_pid_lock);
+		mutex_unlock(&cpuc->cpuc_pid_lock);
+	}
+}
+
+static int fasttrap_tracepoint_enable(fasttrap_probe_t *probe, uint_t index)
+{
+	fasttrap_tracepoint_t	*tp, *new_tp = NULL;
+	fasttrap_bucket_t	*bucket;
+	fasttrap_id_t		*id;
+	pid_t			pid;
+	uintptr_t		pc;
+
+	ASSERT(index < probe->ftp_ntps);
+
+	pid = probe->ftp_pid;
+	pc = probe->ftp_tps[index].fit_tp->ftt_pc;
+	id = &probe->ftp_tps[index].fit_id;
+
+	ASSERT(probe->ftp_tps[index].fit_tp->ftt_pid == pid);
+
+	/*
+	 * Before we make any modifications, make sure we've imposed a barrier
+	 * on the generation in which this probe was last modified.
+	 */
+	fasttrap_mod_barrier(probe->ftp_gen);
+
+	bucket = FASTTRAP_TPOINTS_ELEM(pid, pc);
+
+	/*
+	 * If the tracepoint has already been enabled, just add our id to the
+	 * list of interested probes. This may be our second time through
+	 * this path in which case we'll have constructed the tracepoint we'd
+	 * like to install. If we can't find a match, and have an allocated
+	 * tracepoint ready to go, enable that one now.
+	 *
+	 * A tracepoint whose process is defunct is also considered defunct.
+	 */
+again:
+	mutex_lock(&bucket->ftb_mtx);
+	for (tp = bucket->ftb_data; tp != NULL; tp = tp->ftt_next) {
+		/*
+		 * Note that it's safe to access the active count on the
+		 * associated proc structure because we know that at least one
+		 * provider (this one) will still be around throughout this
+		 * operation.
+		 */
+		if (tp->ftt_pid != pid || tp->ftt_pc != pc ||
+		    atomic64_read(&tp->ftt_proc->ftpc_acount) == 0)
+			continue;
+
+		/*
+		 * Now that we've found a matching tracepoint, it would be
+		 * a decent idea to confirm that the tracepoint is still
+		 * enabled and the trap instruction hasn't been overwritten.
+		 * Since this is a little hairy, we'll punt for now.
+		 */
+
+		/*
+		 * This can't be the first interested probe. We don't have
+		 * to worry about another thread being in the midst of
+		 * deleting this tracepoint (which would be the only valid
+		 * reason for a tracepoint to have no interested probes)
+		 * since we're holding P_PR_LOCK for this process.
+		 */
+		ASSERT(tp->ftt_ids != NULL || tp->ftt_retids != NULL);
+
+		switch (id->fti_ptype) {
+		case DTFTP_ENTRY:
+		case DTFTP_OFFSETS:
+		case DTFTP_IS_ENABLED:
+			id->fti_next = tp->ftt_ids;
+			dtrace_membar_producer();
+			tp->ftt_ids = id;
+			dtrace_membar_producer();
+			break;
+
+		case DTFTP_RETURN:
+		case DTFTP_POST_OFFSETS:
+			id->fti_next = tp->ftt_retids;
+			dtrace_membar_producer();
+			tp->ftt_retids = id;
+			dtrace_membar_producer();
+			break;
+
+		default:
+			ASSERT(0);	/* FIXME */
+		}
+
+		mutex_unlock(&bucket->ftb_mtx);
+
+		if (new_tp != NULL) {
+			new_tp->ftt_ids = NULL;
+			new_tp->ftt_retids = NULL;
+		}
+
+		return 0;
+	}
+
+	/*
+	 * If we have a good tracepoint ready to go, install it now while
+	 * we have the lock held and no one can screw with us.
+	 */
+	if (new_tp != NULL) {
+		int	rc = 0;
+
+		new_tp->ftt_next = bucket->ftb_data;
+		dtrace_membar_producer();
+		bucket->ftb_data = new_tp;
+		dtrace_membar_producer();
+		mutex_unlock(&bucket->ftb_mtx);
+
+		/*
+		 * Activate the tracepoint in the ISA-specific manner.
+		 * If this fails, we need to report the failure, but
+		 * indicate that this tracepoint must still be disabled
+		 * by calling fasttrap_tracepoint_disable().
+		 */
+		rc = dtrace_tracepoint_enable(pid, pc, &new_tp->ftt_mtp);
+		if (rc != 0) {
+			pr_warn("FASTTRAP: Failed to enable tp "
+				"(PID %d, pc %lx): rc %d\n", pid, pc, rc);
+			rc = FASTTRAP_ENABLE_PARTIAL;
+		}
+
+		return rc;
+	}
+
+	mutex_unlock(&bucket->ftb_mtx);
+
+	/*
+	 * Initialize the tracepoint that's been preallocated with the probe.
+	 */
+	new_tp = probe->ftp_tps[index].fit_tp;
+
+	ASSERT(new_tp->ftt_pid == pid);
+	ASSERT(new_tp->ftt_pc == pc);
+	ASSERT(new_tp->ftt_proc == probe->ftp_prov->ftp_proc);
+	ASSERT(new_tp->ftt_ids == NULL);
+	ASSERT(new_tp->ftt_retids == NULL);
+
+	switch (id->fti_ptype) {
+	case DTFTP_ENTRY:
+	case DTFTP_OFFSETS:
+	case DTFTP_IS_ENABLED:
+		id->fti_next = NULL;
+		new_tp->ftt_ids = id;
+		break;
+
+	case DTFTP_RETURN:
+	case DTFTP_POST_OFFSETS:
+		id->fti_next = NULL;
+		new_tp->ftt_retids = id;
+		break;
+
+	default:
+		ASSERT(0);
+	}
+
+	goto again;
+}
+
+static void fasttrap_tracepoint_disable(fasttrap_probe_t *probe, uint_t index)
+{
+	fasttrap_bucket_t	*bucket;
+	fasttrap_provider_t	*prov = probe->ftp_prov;
+	fasttrap_tracepoint_t	**pp, *tp;
+	fasttrap_id_t		*id, **idp = NULL;
+	pid_t			pid;
+	uintptr_t		pc;
+
+	ASSERT(index < probe->ftp_ntps);
+
+	pid = probe->ftp_pid;
+	pc = probe->ftp_tps[index].fit_tp->ftt_pc;
+	id = &probe->ftp_tps[index].fit_id;
+
+	ASSERT(probe->ftp_tps[index].fit_tp->ftt_pid == pid);
+
+	/*
+	 * Find the tracepoint and make sure that our id is one of the
+	 * ones registered with it.
+	 */
+	bucket = FASTTRAP_TPOINTS_ELEM(pid, pc);
+	mutex_lock(&bucket->ftb_mtx);
+	for (tp = bucket->ftb_data; tp != NULL; tp = tp->ftt_next) {
+		if (tp->ftt_pid == pid && tp->ftt_pc == pc &&
+		    tp->ftt_proc == prov->ftp_proc)
+			break;
+	}
+
+	/*
+	 * If we somehow lost this tracepoint, we are in trouble.
+	 */
+	ASSERT(tp != NULL);
+
+	switch (id->fti_ptype) {
+	case DTFTP_ENTRY:
+	case DTFTP_OFFSETS:
+	case DTFTP_IS_ENABLED:
+		ASSERT(tp->ftt_ids != NULL);
+		idp = &tp->ftt_ids;
+		break;
+
+	case DTFTP_RETURN:
+	case DTFTP_POST_OFFSETS:
+		ASSERT(tp->ftt_retids != NULL);
+		idp = &tp->ftt_retids;
+		break;
+
+	default:
+		ASSERT(0);
+	}
+
+	while ((*idp)->fti_probe != probe) {
+		idp = &(*idp)->fti_next;
+		ASSERT(*idp != NULL);
+	}
+
+	id = *idp;
+	*idp = id->fti_next;
+	dtrace_membar_producer();
+
+	ASSERT(id->fti_probe == probe);
+
+	/*
+	 * If there are other registered enablings of this tracepoint, we're
+	 * all done, but if this was the last probe assocated with this
+	 * this tracepoint, we need to remove and free it.
+	 */
+	if (tp->ftt_ids != NULL || tp->ftt_retids != NULL) {
+		/*
+		 * If the current probe's tracepoint is in use, swap it
+		 * for an unused tracepoint.
+		 */
+		if (tp == probe->ftp_tps[index].fit_tp) {
+			fasttrap_probe_t	*tmp_probe;
+			fasttrap_tracepoint_t	**tmp_tp;
+			uint_t			tmp_index;
+
+			if (tp->ftt_ids != NULL) {
+				tmp_probe = tp->ftt_ids->fti_probe;
+				tmp_index = FASTTRAP_ID_INDEX(tp->ftt_ids);
+				tmp_tp = &tmp_probe->ftp_tps[tmp_index].fit_tp;
+			} else {
+				tmp_probe = tp->ftt_retids->fti_probe;
+				tmp_index = FASTTRAP_ID_INDEX(tp->ftt_retids);
+				tmp_tp = &tmp_probe->ftp_tps[tmp_index].fit_tp;
+			}
+
+			ASSERT(*tmp_tp != NULL);
+			ASSERT(*tmp_tp != probe->ftp_tps[index].fit_tp);
+			ASSERT((*tmp_tp)->ftt_ids == NULL);
+			ASSERT((*tmp_tp)->ftt_retids == NULL);
+
+			probe->ftp_tps[index].fit_tp = *tmp_tp;
+			*tmp_tp = tp;
+		}
+
+		mutex_unlock(&bucket->ftb_mtx);
+
+		/*
+		 * Tag the modified probe with the generation in which it was
+		 * changed.
+		 */
+		probe->ftp_gen = fasttrap_mod_gen;
+		return;
+	}
+
+	mutex_unlock(&bucket->ftb_mtx);
+
+	dtrace_tracepoint_disable(pid, &tp->ftt_mtp);
+
+	/*
+	 * Remove the probe from the hash table of active tracepoints.
+	 */
+	mutex_lock(&bucket->ftb_mtx);
+	pp = (fasttrap_tracepoint_t **)&bucket->ftb_data;
+	ASSERT(*pp != NULL);
+	while (*pp != tp) {
+		pp = &(*pp)->ftt_next;
+		ASSERT(*pp != NULL);
+	}
+
+	*pp = tp->ftt_next;
+	dtrace_membar_producer();
+
+	mutex_unlock(&bucket->ftb_mtx);
+
+	/*
+	 * Tag the modified probe with the generation in which it was changed.
+	 */
+	probe->ftp_gen = fasttrap_mod_gen;
+}
+
+static int fasttrap_pid_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	fasttrap_probe_t	*probe = parg;
+	int			i, rc;
+
+	ASSERT(probe != NULL);
+	ASSERT(!probe->ftp_enabled);
+	ASSERT(id == probe->ftp_id);
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	/*
+	 * Increment the count of enabled probes on this probe's provider;
+	 * the provider can't go away while the probe still exists. We
+	 * must increment this even if we aren't able to properly enable
+	 * this probe.
+	 */
+	mutex_lock(&probe->ftp_prov->ftp_mtx);
+	probe->ftp_prov->ftp_rcount++;
+	mutex_unlock(&probe->ftp_prov->ftp_mtx);
+
+	/*
+	 * If this probe's provider is retired (meaning it was valid in a
+	 * previously exec'ed incarnation of this address space), bail out. The
+	 * provider can't go away while we're in this code path.
+	 */
+	if (probe->ftp_prov->ftp_retired)
+		return 0;
+
+#ifdef FIXME
+	/*
+	 * If we can't find the process, it may be that we're in the context of
+	 * a fork in which the traced process is being born and we're copying
+	 * USDT probes. Otherwise, the process is gone so bail.
+	 */
+	if ((p = sprlock(probe->ftp_pid)) == NULL) {
+		if ((curproc->p_flag & SFORKING) == 0)
+			return 0;
+
+		mutex_enter(&pidlock);
+		p = prfind(probe->ftp_pid);
+
+		/*
+		 * Confirm that curproc is indeed forking the process in which
+		 * we're trying to enable probes.
+		 */
+		ASSERT(p != NULL);
+		ASSERT(p->p_parent == curproc);
+		ASSERT(p->p_stat == SIDL);
+
+		mutex_enter(&p->p_lock);
+		mutex_exit(&pidlock);
+
+		sprlock_proc(p);
+	}
+
+	ASSERT(!(p->p_flag & SVFORK));
+	mutex_exit(&p->p_lock);
+#endif
+
+	/*
+	 * We have to enable the trap entry point before any user threads have
+	 * the chance to execute the trap instruction we're about to place
+	 * in their process's text.
+	 */
+	fasttrap_enable_callbacks();
+
+	/*
+	 * Enable all the tracepoints and add this probe's id to each
+	 * tracepoint's list of active probes.
+	 */
+	for (i = 0; i < probe->ftp_ntps; i++) {
+		if ((rc = fasttrap_tracepoint_enable(probe, i)) != 0) {
+			/*
+			 * If enabling the tracepoint failed completely,
+			 * we don't have to disable it; if the failure
+			 * was only partial we must disable it.
+			 */
+			if (rc == FASTTRAP_ENABLE_FAIL)
+				i--;
+			else
+				ASSERT(rc == FASTTRAP_ENABLE_PARTIAL);
+
+			/*
+			 * Back up and pull out all the tracepoints we've
+			 * created so far for this probe.
+			 */
+			while (i >= 0) {
+				fasttrap_tracepoint_disable(probe, i);
+				i--;
+			}
+
+#ifdef FIXME
+			mutex_enter(&p->p_lock);
+			sprunlock(p);
+#endif
+
+			/*
+			 * Since we're not actually enabling this probe,
+			 * drop our reference on the trap table entry.
+			 */
+			fasttrap_disable_callbacks();
+			return 0;
+		}
+	}
+
+#ifdef FIXME
+	mutex_enter(&p->p_lock);
+	sprunlock(p);
+#endif
+
+	probe->ftp_enabled = 1;
+	return 0;
+}
+
+static void fasttrap_pid_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	fasttrap_probe_t	*probe = parg;
+	fasttrap_provider_t	*prov = probe->ftp_prov;
+	int			i, whack = 0;
+
+	ASSERT(id == probe->ftp_id);
+
+	mutex_lock(&prov->ftp_mtx);
+
+	/*
+	 * Disable all the associated tracepoints (for fully enabled probes).
+	 */
+	if (probe->ftp_enabled) {
+		for (i = 0; i < probe->ftp_ntps; i++)
+			fasttrap_tracepoint_disable(probe, i);
+	}
+
+	ASSERT(prov->ftp_rcount > 0);
+	prov->ftp_rcount--;
+
+	if ((prov->ftp_retired || prov->ftp_rcount == 0) && !prov->ftp_marked)
+		whack = prov->ftp_marked = 1;
+
+	mutex_unlock(&prov->ftp_mtx);
+
+	if (whack)
+		fasttrap_pid_cleanup();
+
+	if (!probe->ftp_enabled)
+		return;
+
+	probe->ftp_enabled = 0;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	fasttrap_disable_callbacks();
+}
+
+static void fasttrap_pid_getargdesc(void *arg, dtrace_id_t id, void *parg,
+				    dtrace_argdesc_t *desc)
+{
+	fasttrap_probe_t	*probe = parg;
+	char			*str;
+	int			i, ndx;
+
+	desc->dtargd_native[0] = '\0';
+	desc->dtargd_xlate[0] = '\0';
+
+	if (probe->ftp_prov->ftp_retired != 0 ||
+	    desc->dtargd_ndx >= probe->ftp_nargs) {
+		desc->dtargd_ndx = DTRACE_ARGNONE;
+		return;
+	}
+
+	ndx = (probe->ftp_argmap != NULL) ? probe->ftp_argmap[desc->dtargd_ndx]
+					  : desc->dtargd_ndx;
+
+	str = probe->ftp_ntypes;
+	for (i = 0; i < ndx; i++)
+		str += strlen(str) + 1;
+
+	ASSERT(strlen(str + 1) < sizeof(desc->dtargd_native));
+	strcpy(desc->dtargd_native, str);
+
+	if (probe->ftp_xtypes == NULL)
+		return;
+
+	str = probe->ftp_xtypes;
+	for (i = 0; i < desc->dtargd_ndx; i++)
+		str += strlen(str) + 1;
+
+	ASSERT(strlen(str + 1) < sizeof(desc->dtargd_xlate));
+	strcpy(desc->dtargd_xlate, str);
+}
+
+static void fasttrap_pid_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+	fasttrap_probe_t	*probe = parg;
+	int			i;
+
+	ASSERT(probe != NULL);
+	ASSERT(!probe->ftp_enabled);
+	ASSERT(atomic_read(&fasttrap_total) >= probe->ftp_ntps);
+
+	atomic_add(-probe->ftp_ntps, &fasttrap_total);
+
+	if (probe->ftp_gen + 1 >= fasttrap_mod_gen)
+		fasttrap_mod_barrier(probe->ftp_gen);
+
+	for (i = 0; i < probe->ftp_ntps; i++)
+		kmem_cache_free(tracepoint_cachep, probe->ftp_tps[i].fit_tp);
+
+	kfree(probe);
+}
+
+static const dtrace_pattr_t pid_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+};
+
+static dtrace_pops_t pid_pops = {
+#ifdef FIXME
+	fasttrap_pid_provide,
+	NULL,
+	NULL,
+	NULL,
+	fasttrap_pid_enable,
+	fasttrap_pid_disable,
+	NULL,
+	NULL,
+	fasttrap_pid_getargdesc,
+	fasttrap_pid_getarg,
+	NULL,
+	fasttrap_pid_destroy
+#endif
+};
+
+static dtrace_pops_t usdt_pops = {
+	.dtps_provide = fasttrap_pid_provide,
+	.dtps_provide_module = NULL,
+	.dtps_destroy_module = NULL,
+	.dtps_enable = fasttrap_pid_enable,
+	.dtps_disable = fasttrap_pid_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = fasttrap_pid_getargdesc,
+	.dtps_getargval = fasttrap_usdt_getarg,
+	.dtps_usermode = NULL,
+	.dtps_destroy = fasttrap_pid_destroy
+};
+
+static uint_t fasttrap_hash_str(const char *p)
+{
+	unsigned int	g;
+	uint_t		hval = 0;
+
+	while (*p) {
+		hval = (hval << 4) + *p++;
+		if ((g = (hval & 0xf0000000)) != 0)
+			hval ^= g >> 24;
+		hval &= ~g;
+	}
+
+	return hval;
+}
+
+static int fasttrap_uint32_cmp(const void *ap, const void *bp)
+{
+	return (*(const uint32_t *)ap - *(const uint32_t *)bp);
+}
+
+void fasttrap_meta_create_probe(void *arg, void *parg,
+				dtrace_helper_probedesc_t *dhpb)
+{
+	fasttrap_provider_t	*provider = parg;
+	fasttrap_probe_t	*pp;
+	fasttrap_tracepoint_t	*tp;
+	int			i, j;
+	uint32_t		ntps;
+
+	/*
+	 * Since the meta provider count is non-zero we don't have to worry
+	 * about this provider disappearing.
+	 */
+	ASSERT(provider->ftp_mcount > 0);
+
+	/*
+	 * The offsets must be unique.
+	 */
+	sort(dhpb->dthpb_offs, dhpb->dthpb_noffs, sizeof(uint32_t),
+	     fasttrap_uint32_cmp, NULL);
+	for (i = 1; i < dhpb->dthpb_noffs; i++) {
+		if (dhpb->dthpb_base + dhpb->dthpb_offs[i] <=
+		    dhpb->dthpb_base + dhpb->dthpb_offs[i - 1])
+			return;
+	}
+
+	sort(dhpb->dthpb_enoffs, dhpb->dthpb_nenoffs, sizeof(uint32_t),
+	     fasttrap_uint32_cmp, NULL);
+	for (i = 1; i < dhpb->dthpb_nenoffs; i++) {
+		if (dhpb->dthpb_base + dhpb->dthpb_enoffs[i] <=
+		    dhpb->dthpb_base + dhpb->dthpb_enoffs[i - 1])
+			return;
+	}
+
+	/*
+	 * Grab the creation lock to ensure consistency between calls to
+	 * dtrace_probe_lookup() and dtrace_probe_create() in the face of
+	 * other threads creating probes.
+	 */
+	mutex_lock(&provider->ftp_cmtx);
+
+	if (dtrace_probe_lookup(provider->ftp_provid, dhpb->dthpb_mod,
+				dhpb->dthpb_func, dhpb->dthpb_name) != DTRACE_IDNONE) {
+		mutex_unlock(&provider->ftp_cmtx);
+		return;
+	}
+
+	ntps = dhpb->dthpb_noffs + dhpb->dthpb_nenoffs;
+	ASSERT(ntps > 0);
+
+	pp = kzalloc(offsetof(fasttrap_probe_t, ftp_tps[ntps]), GFP_KERNEL);
+	if (pp == NULL) {
+		pr_warn("Unable to create probe %s: out of memory\n",
+			dhpb->dthpb_name);
+		mutex_unlock(&provider->ftp_cmtx);
+		return;
+	}
+
+	atomic_add(ntps, &fasttrap_total);
+	if (atomic_read(&fasttrap_total) > fasttrap_max) {
+		kfree(pp);
+		atomic_add(-ntps, &fasttrap_total);
+		mutex_unlock(&provider->ftp_cmtx);
+		return;
+	}
+
+	pp->ftp_prov = provider;
+	pp->ftp_pid = provider->ftp_pid;
+	pp->ftp_ntps = ntps;
+	pp->ftp_nargs = dhpb->dthpb_xargc;
+	pp->ftp_xtypes = dhpb->dthpb_xtypes;
+	pp->ftp_ntypes = dhpb->dthpb_ntypes;
+
+	/*
+	 * First create a tracepoint for each actual point of interest.
+	 */
+	for (i = 0; i < dhpb->dthpb_noffs; i++) {
+		tp = kmem_cache_alloc(tracepoint_cachep, GFP_KERNEL);
+		if (tp == NULL)
+			goto fail;
+
+		tp->ftt_proc = provider->ftp_proc;
+		tp->ftt_pc = dhpb->dthpb_base + dhpb->dthpb_offs[i];
+		tp->ftt_pid = provider->ftp_pid;
+		memset(&tp->ftt_mtp, 0, sizeof(fasttrap_machtp_t));
+		tp->ftt_ids = NULL;
+		tp->ftt_retids = NULL;
+		tp->ftt_next = NULL;
+
+		dt_dbg_dof("        Tracepoint at 0x%lx (0x%llx + 0x%x)\n",
+			   tp->ftt_pc, dhpb->dthpb_base, dhpb->dthpb_offs[i]);
+
+		pp->ftp_tps[i].fit_tp = tp;
+		pp->ftp_tps[i].fit_id.fti_probe = pp;
+		pp->ftp_tps[i].fit_id.fti_ptype = DTFTP_OFFSETS;
+	}
+
+	/*
+	 * Then create a tracepoint for each is-enabled point.
+	 */
+	for (j = 0; i < ntps; i++, j++) {
+		tp = kmem_cache_alloc(tracepoint_cachep, GFP_KERNEL);
+		if (tp == NULL)
+			goto fail;
+
+		tp->ftt_proc = provider->ftp_proc;
+		tp->ftt_pc = dhpb->dthpb_base + dhpb->dthpb_enoffs[j];
+		tp->ftt_pid = provider->ftp_pid;
+		memset(&tp->ftt_mtp, 0, sizeof(fasttrap_machtp_t));
+		tp->ftt_ids = NULL;
+		tp->ftt_retids = NULL;
+		tp->ftt_next = NULL;
+
+		pp->ftp_tps[i].fit_tp = tp;
+		pp->ftp_tps[i].fit_id.fti_probe = pp;
+		pp->ftp_tps[i].fit_id.fti_ptype = DTFTP_IS_ENABLED;
+	}
+
+	/*
+	 * If the arguments are shuffled around we set the argument remapping
+	 * table. Later, when the probe fires, we only remap the arguments
+	 * if the table is non-NULL.
+	 */
+	for (i = 0; i < dhpb->dthpb_xargc; i++) {
+		if (dhpb->dthpb_args[i] != i) {
+			pp->ftp_argmap = dhpb->dthpb_args;
+			break;
+		}
+	}
+
+	/*
+	 * The probe is fully constructed -- register it with DTrace.
+	 */
+	pp->ftp_id = dtrace_probe_create(provider->ftp_provid, dhpb->dthpb_mod,
+					 dhpb->dthpb_func, dhpb->dthpb_name,
+					 FASTTRAP_OFFSET_AFRAMES, pp);
+	if (pp->ftp_id == DTRACE_IDNONE)
+		goto fail;
+
+	mutex_unlock(&provider->ftp_cmtx);
+	return;
+
+fail:
+	pr_warn("Unable to create probe %s: out of memory\n",
+		dhpb->dthpb_name);
+
+	for (i = 0; i < ntps; i++)
+		kmem_cache_free(tracepoint_cachep, pp->ftp_tps[i].fit_tp);
+
+	kfree(pp);
+	atomic_add(-ntps, &fasttrap_total);
+	mutex_unlock(&provider->ftp_cmtx);
+}
+
+static void fasttrap_proc_release(fasttrap_proc_t *proc)
+{
+	fasttrap_bucket_t	*bucket;
+	fasttrap_proc_t		*fprc, **fprcp;
+	pid_t			pid = proc->ftpc_pid;
+
+	mutex_lock(&proc->ftpc_mtx);
+
+	ASSERT(proc->ftpc_rcount != 0);
+	ASSERT(atomic64_read(&proc->ftpc_acount) <= proc->ftpc_rcount);
+
+	if (--proc->ftpc_rcount != 0) {
+		mutex_unlock(&proc->ftpc_mtx);
+		return;
+	}
+
+	mutex_unlock(&proc->ftpc_mtx);
+
+	/*
+	 * There should definitely be no live providers associated with this
+	 * process at this point.
+	 */
+	ASSERT(atomic64_read(&proc->ftpc_acount) == 0);
+
+	bucket = FASTTRAP_PROCS_ELEM(pid);
+	mutex_lock(&bucket->ftb_mtx);
+
+	fprcp = (fasttrap_proc_t **)&bucket->ftb_data;
+	while ((fprc = *fprcp) != NULL) {
+		if (fprc == proc)
+			break;
+
+		fprcp = &fprc->ftpc_next;
+	}
+
+	/*
+	 * Something strange has happened if we can't find the proc.
+	 */
+	ASSERT(fprc != NULL);
+
+	*fprcp = fprc->ftpc_next;
+
+	mutex_unlock(&bucket->ftb_mtx);
+
+	kfree(fprc);
+}
+
+static void fasttrap_provider_free(fasttrap_provider_t *provider)
+{
+	pid_t			pid = provider->ftp_pid;
+
+	/*
+	 * There need to be no associated enabled probes, no consumers
+	 * creating probes, and no meta providers referencing this provider.
+	 */
+	ASSERT(provider->ftp_rcount == 0);
+	ASSERT(provider->ftp_ccount == 0);
+	ASSERT(provider->ftp_mcount == 0);
+
+	/*
+	 * If this provider hasn't been retired, we need to explicitly drop the
+	 * count of active providers on the associated process structure.
+	 */
+	if (!provider->ftp_retired) {
+		atomic64_add(-1, &provider->ftp_proc->ftpc_acount);
+		ASSERT(atomic64_read(&provider->ftp_proc->ftpc_acount) <
+		       provider->ftp_proc->ftpc_rcount);
+	}
+
+	fasttrap_proc_release(provider->ftp_proc);
+
+	kfree(provider);
+
+	unregister_pid_provider(pid);
+}
+
+static fasttrap_proc_t *fasttrap_proc_lookup(pid_t pid)
+{
+	fasttrap_bucket_t	*bucket;
+	fasttrap_proc_t		*fprc, *new_fprc;
+
+	bucket = FASTTRAP_PROCS_ELEM(pid);
+	mutex_lock(&bucket->ftb_mtx);
+
+	for (fprc = bucket->ftb_data; fprc != NULL; fprc = fprc->ftpc_next) {
+		if (fprc->ftpc_pid == pid &&
+		    atomic64_read(&fprc->ftpc_acount) != 0) {
+			mutex_lock(&fprc->ftpc_mtx);
+			mutex_unlock(&bucket->ftb_mtx);
+			fprc->ftpc_rcount++;
+			atomic64_inc(&fprc->ftpc_acount);
+			ASSERT(atomic64_read(&fprc->ftpc_acount) <=
+			       fprc->ftpc_rcount);
+			mutex_unlock(&fprc->ftpc_mtx);
+
+			return fprc;
+		}
+	}
+
+	/*
+	 * Drop the bucket lock so we don't try to perform a sleeping
+	 * allocation under it.
+	 */
+	mutex_unlock(&bucket->ftb_mtx);
+
+	new_fprc = kzalloc(sizeof(fasttrap_proc_t), GFP_KERNEL);
+	if (new_fprc == NULL)
+		return NULL;
+
+	new_fprc->ftpc_pid = pid;
+	new_fprc->ftpc_rcount = 1;
+	atomic64_set(&new_fprc->ftpc_acount, 1);
+	mutex_init(&new_fprc->ftpc_mtx);
+
+	mutex_lock(&bucket->ftb_mtx);
+
+	/*
+	 * Take another lap through the list to make sure a proc hasn't
+	 * been created for this pid while we weren't under the bucket lock.
+	 */
+	for (fprc = bucket->ftb_data; fprc != NULL; fprc = fprc->ftpc_next) {
+		if (fprc->ftpc_pid == pid &&
+		    atomic64_read(&fprc->ftpc_acount) != 0) {
+			mutex_lock(&fprc->ftpc_mtx);
+			mutex_unlock(&bucket->ftb_mtx);
+			fprc->ftpc_rcount++;
+			atomic64_inc(&fprc->ftpc_acount);
+			ASSERT(atomic64_read(&fprc->ftpc_acount) <=
+			       fprc->ftpc_rcount);
+			mutex_unlock(&fprc->ftpc_mtx);
+
+			kfree(new_fprc);
+
+			return fprc;
+		}
+	}
+
+	new_fprc->ftpc_next = bucket->ftb_data;
+	bucket->ftb_data = new_fprc;
+
+	mutex_unlock(&bucket->ftb_mtx);
+
+	return new_fprc;
+}
+
+/*
+ * Lookup a fasttrap-managed provider based on its name and associated pid.
+ * If the pattr argument is non-NULL, this function instantiates the provider
+ * if it doesn't exist otherwise it returns NULL. The provider is returned
+ * with its lock held.
+ */
+static fasttrap_provider_t *fasttrap_provider_lookup(pid_t pid,
+						     const char *name,
+						     const dtrace_pattr_t *pa)
+{
+	fasttrap_provider_t	*fp, *new_fp = NULL;
+	fasttrap_proc_t		*proc = NULL;
+	fasttrap_bucket_t	*bucket;
+	char			provname[DTRACE_PROVNAMELEN];
+	struct task_struct	*p;
+	const cred_t		*cred = NULL;
+
+	ASSERT(strlen(name) < sizeof (fp->ftp_name));
+	ASSERT(pa != NULL);
+
+	bucket = FASTTRAP_PROVS_ELEM(pid, name);
+	mutex_lock(&bucket->ftb_mtx);
+
+	/*
+	 * Take a lap through the list and return the match if we find it.
+	 */
+	for (fp = bucket->ftb_data; fp != NULL; fp = fp->ftp_next) {
+		if (fp->ftp_pid == pid && strcmp(fp->ftp_name, name) == 0 &&
+		    !fp->ftp_retired) {
+#ifdef FIX_FORCE_UNIQUE_PROVNAME_PER_PID
+			/*
+			 * We disallow multiple providers with the same name
+			 * for a given PID.
+			 */
+			mutex_unlock(&bucket->ftb_mtx);
+			return NULL;
+#else
+			mutex_lock(&fp->ftp_mtx);
+			mutex_unlock(&bucket->ftb_mtx);
+			return fp;
+#endif
+		}
+	}
+
+	/*
+	 * Drop the bucket lock so we don't try to perform a sleeping
+	 * allocation under it.
+	 */
+	mutex_unlock(&bucket->ftb_mtx);
+
+	if ((p = register_pid_provider(pid)) == NULL)
+		goto fail;
+
+	/*
+	 * Grab the credentials for this process so we have
+	 * something to pass to dtrace_register().
+	 */
+	cred = get_cred(p->cred);
+
+	if ((proc = fasttrap_proc_lookup(pid)) == NULL)
+		goto fail;
+
+	if ((new_fp = kzalloc(sizeof(fasttrap_provider_t), GFP_KERNEL)) == NULL)
+		goto fail;
+
+	new_fp->ftp_pid = pid;
+	new_fp->ftp_proc = proc;
+	mutex_init(&new_fp->ftp_mtx);
+	mutex_init(&new_fp->ftp_cmtx);
+
+	ASSERT(new_fp->ftp_proc != NULL);
+
+	mutex_lock(&bucket->ftb_mtx);
+
+	/*
+	 * Take another lap through the list to make sure a provider hasn't
+	 * been created for this pid while we weren't under the bucket lock.
+	 */
+	for (fp = bucket->ftb_data; fp != NULL; fp = fp->ftp_next) {
+		if (fp->ftp_pid == pid && strcmp(fp->ftp_name, name) == 0 &&
+		    !fp->ftp_retired) {
+			mutex_lock(&fp->ftp_mtx);
+			mutex_unlock(&bucket->ftb_mtx);
+			fasttrap_provider_free(new_fp);
+			put_cred(cred);
+			return fp;
+		}
+	}
+
+	strcpy(new_fp->ftp_name, name);
+
+	/*
+	 * Fail and return NULL if either the provider name is too long
+	 * or we fail to register this new provider with the DTrace
+	 * framework. Note that this is the only place we ever construct
+	 * the full provider name -- we keep it in pieces in the provider
+	 * structure.
+	 */
+	if (snprintf(provname, sizeof(provname), "%s%u", name, (uint_t)pid) >=
+	    sizeof(provname) ||
+	    dtrace_register(provname, pa,
+			    DTRACE_PRIV_PROC | DTRACE_PRIV_OWNER, cred,
+			    pa == &pid_attr ? &pid_pops : &usdt_pops,
+			    new_fp, &new_fp->ftp_provid) != 0) {
+		mutex_unlock(&bucket->ftb_mtx);
+		fasttrap_provider_free(new_fp);
+		put_cred(cred);
+		return NULL;
+	}
+
+	new_fp->ftp_next = bucket->ftb_data;
+	bucket->ftb_data = new_fp;
+
+	mutex_lock(&new_fp->ftp_mtx);
+	mutex_unlock(&bucket->ftb_mtx);
+
+	put_cred(cred);
+	return new_fp;
+
+fail:
+	if (proc)
+		fasttrap_proc_release(proc);
+	if (cred)
+		put_cred(cred);
+	if (p)
+		unregister_pid_provider(pid);
+
+	return NULL;
+}
+
+void *fasttrap_meta_provide(void *arg, dtrace_helper_provdesc_t *dhpv,
+			    pid_t pid)
+{
+	fasttrap_provider_t	*provider;
+
+	if (strlen(dhpv->dthpv_provname) + 10 >= sizeof (provider->ftp_name)) {
+		pr_warn("Failed to instantiate provider %s: name too long "
+			"to accomodate pid\n", dhpv->dthpv_provname);
+		return NULL;
+	}
+
+	/*
+	 * Don't let folks spoof the true pid provider.
+	 */
+	if (strcmp(dhpv->dthpv_provname, FASTTRAP_PID_NAME) == 0) {
+		pr_warn("Failed to instantiate provider %s: %s is an invalid "
+			"name\n", dhpv->dthpv_provname, FASTTRAP_PID_NAME);
+		return NULL;
+	}
+
+	/*
+	 * The highest stability class that fasttrap supports is ISA; cap
+	 * the stability of the new provider accordingly.
+	 */
+	if (dhpv->dthpv_pattr.dtpa_provider.dtat_class > DTRACE_CLASS_ISA)
+		dhpv->dthpv_pattr.dtpa_provider.dtat_class = DTRACE_CLASS_ISA;
+	if (dhpv->dthpv_pattr.dtpa_mod.dtat_class > DTRACE_CLASS_ISA)
+		dhpv->dthpv_pattr.dtpa_mod.dtat_class = DTRACE_CLASS_ISA;
+	if (dhpv->dthpv_pattr.dtpa_func.dtat_class > DTRACE_CLASS_ISA)
+		dhpv->dthpv_pattr.dtpa_func.dtat_class = DTRACE_CLASS_ISA;
+	if (dhpv->dthpv_pattr.dtpa_name.dtat_class > DTRACE_CLASS_ISA)
+		dhpv->dthpv_pattr.dtpa_name.dtat_class = DTRACE_CLASS_ISA;
+	if (dhpv->dthpv_pattr.dtpa_args.dtat_class > DTRACE_CLASS_ISA)
+		dhpv->dthpv_pattr.dtpa_args.dtat_class = DTRACE_CLASS_ISA;
+
+	provider = fasttrap_provider_lookup(pid, dhpv->dthpv_provname,
+					    &dhpv->dthpv_pattr);
+	if (provider == NULL) {
+		pr_warn("Failed to instantiate provider %s for process %u\n",
+			dhpv->dthpv_provname, (uint_t)pid);
+		return NULL;
+	}
+
+	/*
+	 * Up the meta provider count so this provider isn't removed until the
+	 * meta provider has been told to remove it.
+	 */
+	provider->ftp_mcount++;
+
+	mutex_unlock(&provider->ftp_mtx);
+
+	__module_get(THIS_MODULE);
+
+	return provider;
+}
+
+static void fasttrap_pid_cleanup_cb(struct work_struct *work)
+{
+	fasttrap_provider_t	**fpp, *fp;
+	fasttrap_bucket_t	*bucket;
+	dtrace_provider_id_t	provid;
+	int			i, later = 0;
+
+	static volatile int	in = 0;
+
+	ASSERT(in == 0);
+	in = 1;
+
+	mutex_lock(&fasttrap_cleanup_mtx);
+	if (!fasttrap_cleanup_work && fasttrap_cleanup_state == CLEANUP_NONE) {
+		mutex_unlock(&fasttrap_cleanup_mtx);
+		in = 0;
+		return;
+	}
+
+	while (fasttrap_cleanup_work) {
+		fasttrap_cleanup_work = 0;
+		mutex_unlock(&fasttrap_cleanup_mtx);
+
+		later = 0;
+
+		/*
+		 * Iterate over all the providers trying to remove the marked
+		 * ones. If a provider is marked but not retired, we just
+		 * have to take a crack at removing it -- it's no big deal if
+		 * we can't.
+		 */
+		for (i = 0; i < fasttrap_provs.fth_nent; i++) {
+			bucket = FASTTRAP_ELEM_BUCKET(&fasttrap_provs.fth_table[i]);
+			mutex_lock(&bucket->ftb_mtx);
+			fpp = (fasttrap_provider_t **)&bucket->ftb_data;
+
+			while ((fp = *fpp) != NULL) {
+				if (!fp->ftp_marked) {
+					fpp = &fp->ftp_next;
+					continue;
+				}
+
+				mutex_lock(&fp->ftp_mtx);
+
+				/*
+				 * If this provider has consumers actively
+				 * creating probes (ftp_ccount) or is a USDT
+				 * provider (ftp_mcount), we can't unregister
+				 * or even condense.
+				 */
+				if (fp->ftp_ccount != 0 ||
+				    fp->ftp_mcount != 0) {
+					mutex_unlock(&fp->ftp_mtx);
+					fp->ftp_marked = 0;
+					continue;
+				}
+
+				if (!fp->ftp_retired || fp->ftp_rcount != 0)
+					fp->ftp_marked = 0;
+
+				mutex_unlock(&fp->ftp_mtx);
+
+				/*
+				 * If we successfully unregister this
+				 * provider we can remove it from the hash
+				 * chain and free the memory. If our attempt
+				 * to unregister fails and this is a retired
+				 * provider, increment our flag to try again
+				 * pretty soon. If we've consumed more than
+				 * half of our total permitted number of
+				 * probes call dtrace_condense() to try to
+				 * clean out the unenabled probes.
+				 */
+				provid = fp->ftp_provid;
+				mutex_lock(&module_mutex);
+				if (dtrace_unregister(provid) != 0) {
+					if (atomic_read(&fasttrap_total) >
+					    fasttrap_max / 2)
+						dtrace_condense(provid);
+
+					later += fp->ftp_marked;
+					fpp = &fp->ftp_next;
+				} else {
+					*fpp = fp->ftp_next;
+					fasttrap_provider_free(fp);
+
+					module_put(THIS_MODULE); }
+				mutex_unlock(&module_mutex);
+			}
+
+			mutex_unlock(&bucket->ftb_mtx);
+		}
+
+		mutex_lock(&fasttrap_cleanup_mtx);
+	}
+
+	ASSERT(fasttrap_cleanup_state != CLEANUP_NONE);
+
+	/*
+	 * If we were unable to remove a retired provider, try again after
+	 * a second. This situation can occur in certain circumstances where
+	 * providers cannot be unregistered even though they have no probes
+	 * enabled because of an execution of dtrace -l or something similar.
+	 * If the timeout has been disabled (set to 1 because we're trying
+	 * to detach), we set fasttrap_cleanup_work to ensure that we'll
+	 * get a chance to do that work if and when the timeout is reenabled
+	 * (if detach fails).
+	 */
+	if (later > 0) {
+		if (fasttrap_cleanup_state == CLEANUP_DEFERRED)
+			fasttrap_cleanup_work = 1;
+		else {
+			struct delayed_work	*dw = container_of(
+							work,
+							struct delayed_work,
+							work);
+
+			fasttrap_cleanup_state = CLEANUP_SCHEDULED;
+			schedule_delayed_work(dw, HZ);
+		}
+	} else
+		fasttrap_cleanup_state = CLEANUP_NONE;
+
+	mutex_unlock(&fasttrap_cleanup_mtx);
+	in = 0;
+}
+
+static DECLARE_DELAYED_WORK(fasttrap_cleanup, fasttrap_pid_cleanup_cb);
+
+/*
+ * Activate the asynchronous cleanup mechanism.
+ */
+static void fasttrap_pid_cleanup(void)
+{
+        mutex_lock(&fasttrap_cleanup_mtx);
+        fasttrap_cleanup_work = 1;
+        fasttrap_cleanup_state = CLEANUP_SCHEDULED;
+	schedule_delayed_work(&fasttrap_cleanup, 3);
+        mutex_unlock(&fasttrap_cleanup_mtx);
+}
+
+void fasttrap_provider_retire(pid_t pid, const char *name, int mprov)
+{
+	fasttrap_provider_t	*fp;
+	fasttrap_bucket_t	*bucket;
+	dtrace_provider_id_t	provid;
+
+	ASSERT(strlen(name) < sizeof (fp->ftp_name));
+
+	bucket = FASTTRAP_PROVS_ELEM(pid, name);
+	mutex_lock(&bucket->ftb_mtx);
+
+	for (fp = bucket->ftb_data; fp != NULL; fp = fp->ftp_next) {
+		if (fp->ftp_pid == pid && strcmp(fp->ftp_name, name) == 0 &&
+		    !fp->ftp_retired)
+			break;
+	}
+
+	if (fp == NULL) {
+		mutex_unlock(&bucket->ftb_mtx);
+		return;
+	}
+
+	mutex_lock(&fp->ftp_mtx);
+	ASSERT(!mprov || fp->ftp_mcount > 0);
+	if (mprov && --fp->ftp_mcount != 0)  {
+		mutex_unlock(&fp->ftp_mtx);
+		mutex_unlock(&bucket->ftb_mtx);
+		return;
+	}
+
+	/*
+	 * Mark the provider to be removed in our post-processing step, mark it
+	 * retired, and drop the active count on its proc. Marking it indicates
+	 * that we should try to remove it; setting the retired flag indicates
+	 * that we're done with this provider; dropping the active count on the
+	 * proc releases our hold, and when this reaches zero (as it will
+	 * during exit or exec) the proc and associated providers become
+	 * defunct.
+	 *
+	 * We obviously need to take the bucket lock before the provider lock
+	 * to perform the lookup, but we need to drop the provider lock
+	 * before calling into the DTrace framework since we acquire the
+	 * provider lock in callbacks invoked from the DTrace framework. The
+	 * bucket lock therefore protects the integrity of the provider hash
+	 * table.
+	 */
+	atomic64_dec(&fp->ftp_proc->ftpc_acount);
+	ASSERT(atomic64_read(&fp->ftp_proc->ftpc_acount) <
+	       fp->ftp_proc->ftpc_rcount);
+
+	fp->ftp_retired = 1;
+	fp->ftp_marked = 1;
+	provid = fp->ftp_provid;
+	mutex_unlock(&fp->ftp_mtx);
+
+	/*
+	 * We don't have to worry about invalidating the same provider twice
+	 * since fasttrap_provider_lookup() will ignore provider that have
+	 * been marked as retired.
+	 */
+	dtrace_invalidate(provid);
+
+	mutex_unlock(&bucket->ftb_mtx);
+
+	fasttrap_pid_cleanup();
+}
+
+void fasttrap_meta_remove(void *arg, dtrace_helper_provdesc_t *dhpv, pid_t pid)
+{
+	/*
+	 * Clean up the USDT provider. There may be active consumers of the
+	 * provider busy adding probes, no damage will actually befall the
+	 * provider until that count has dropped to zero. This just puts
+	 * the provider on death row.
+	 */
+	fasttrap_provider_retire(pid, dhpv->dthpv_provname, 1);
+}
+
+static long fasttrap_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int fasttrap_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int fasttrap_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations fasttrap_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = fasttrap_ioctl,
+        .open   = fasttrap_open,
+        .release = fasttrap_close,
+};
+
+static struct miscdevice fasttrap_dev = {
+	.minor = DT_DEV_FASTTRAP_MINOR,
+	.name = "fasttrap",
+	.nodename = "dtrace/provider/fasttrap",
+	.fops = &fasttrap_fops,
+};
+
+static int fasttrap_init_htable(fasttrap_hash_t *fth, ulong_t nent)
+{
+	ulong_t		i;
+
+	if ((nent & (nent - 1)) == 0)
+		fth->fth_nent = nent;
+	else
+		fth->fth_nent = 1 << fls(nent);
+
+	ASSERT(fth->fth_nent > 0);
+
+	fth->fth_mask = fth->fth_nent - 1;
+	fth->fth_table = vzalloc(fth->fth_nent * sizeof(fasttrap_bucket_elem_t));
+
+	if (fth->fth_table == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < fth->fth_nent; i++)
+		mutex_init(&fth->fth_table[i].bucket.ftb_mtx);
+
+	return 0;
+}
+
+int fasttrap_dev_init(void)
+{
+	int	ret = 0;
+	ulong_t	nent;
+
+	ret = misc_register(&fasttrap_dev);
+	if (ret) {
+		pr_err("%s: Can't register misc device %d\n",
+		       fasttrap_dev.name, fasttrap_dev.minor);
+		goto fail;
+	}
+
+#ifdef FIXME
+	dtrace_fasttrap_exit_ptr = &fasttrap_exec_exit;
+	dtrace_fasttrap_exec_ptr = &fasttrap_exec_exit;
+#endif
+
+        tracepoint_cachep = KMEM_CACHE(fasttrap_tracepoint, 0);
+
+	fasttrap_max = FASTTRAP_MAX_DEFAULT;
+	atomic_set(&fasttrap_total, 0);
+
+	/*
+	 * Conjure up the tracepoints hashtable...
+	 */
+	nent = FASTTRAP_TPOINTS_DEFAULT_SIZE;
+
+	if (nent == 0 || nent > 0x1000000)
+		nent = FASTTRAP_TPOINTS_DEFAULT_SIZE;
+
+	if (fasttrap_init_htable(&fasttrap_tpoints, nent) != 0)
+		return -ENOMEM;
+
+	/*
+	 * ... and the providers hash table...
+	 */
+	nent = FASTTRAP_PROVIDERS_DEFAULT_SIZE;
+	if (fasttrap_init_htable(&fasttrap_provs, nent) != 0)
+		return -ENOMEM;
+
+	/*
+	 * ... and the procs hash table.
+	 */
+	nent = FASTTRAP_PROCS_DEFAULT_SIZE;
+	if (fasttrap_init_htable(&fasttrap_procs, nent) != 0)
+		return -ENOMEM;
+
+fail:
+	return ret;
+}
+
+void fasttrap_dev_exit(void)
+{
+	int	fail = 0;
+	ulong_t	i;
+
+	/*
+	 * Prevent any new timeouts from running by setting fasttrap_timeout
+	 * to a non-zero value, and wait for the current timeout to complete.
+	 */
+	mutex_lock(&fasttrap_cleanup_mtx);
+	fasttrap_cleanup_work = 0;
+
+	while (fasttrap_cleanup_state != CLEANUP_DEFERRED) {
+		uint_t	tmp;
+
+		tmp = fasttrap_cleanup_state;
+		fasttrap_cleanup_state = CLEANUP_DEFERRED;
+
+		if (tmp != CLEANUP_NONE) {
+			mutex_unlock(&fasttrap_cleanup_mtx);
+			flush_delayed_work(&fasttrap_cleanup);
+			mutex_lock(&fasttrap_cleanup_mtx);
+		}
+	}
+
+	fasttrap_cleanup_work = 0;
+	mutex_unlock(&fasttrap_cleanup_mtx);
+
+	/*
+	 * Iterate over all of our providers. If there's still a process
+	 * that corresponds to that pid, fail to detach.
+	 */
+	for (i = 0; i < fasttrap_provs.fth_nent; i++) {
+		fasttrap_provider_t	**fpp, *fp;
+		fasttrap_bucket_t	*bucket;
+
+		bucket = FASTTRAP_ELEM_BUCKET(&fasttrap_provs.fth_table[i]);
+		mutex_lock(&bucket->ftb_mtx);
+		fpp = (fasttrap_provider_t **)&bucket->ftb_data;
+		while ((fp = *fpp) != NULL) {
+			/*
+			 * Acquire and release the lock as a simple way of
+			 * waiting for any other consumer to finish with
+			 * this provider. A thread must first acquire the
+			 * bucket lock so there's no chance of another thread
+			 * blocking on the provider's lock.
+			 */
+			mutex_lock(&fp->ftp_mtx);
+			mutex_unlock(&fp->ftp_mtx);
+
+			mutex_lock(&module_mutex);
+			if (dtrace_unregister(fp->ftp_provid) != 0) {
+				fail = 1;
+				fpp = &fp->ftp_next;
+			} else {
+				*fpp = fp->ftp_next;
+				fasttrap_provider_free(fp);
+			}
+			mutex_unlock(&module_mutex);
+		}
+
+		mutex_unlock(&bucket->ftb_mtx);
+	}
+
+#ifdef FIXME
+	if (fail) {
+		uint_t	work;
+
+		/*
+		 * If we're failing to detach, we need to unblock timeouts
+		 * and start a new timeout if any work has accumulated while
+		 * we've been unsuccessfully trying to detach.
+		 */
+		mutex_lock(&fasttrap_cleanup_mtx);
+		fasttrap_cleanup_state = CLEANUP_NONE;
+		work = fasttrap_cleanup_work;
+		mutex_unlock(&fasttrap_cleanup_mtx);
+
+		if (work)
+			fasttrap_pid_cleanup();
+
+		dtrace_meta_register("fasttrap", &fasttrap_mops, NULL,
+				     &fasttrap_meta_id);
+
+		return (DDI_FAILURE);
+	}
+#else
+	/*
+	 * If we fail to detach, we are in lots of trouble because Linux does
+	 * not allow us to fail on a module unload.  We try to continue anyway
+	 * since triggering an OOPS at this point is even worse.
+	 */
+	if (fail)
+		pr_err("Unrecoverable error removing the fasttrap provider\n");
+#endif
+
+#ifdef DEBUG
+	mutex_lock(&fasttrap_count_mtx);
+	ASSERT(fasttrap_pid_count == 0);
+	mutex_unlock(&fasttrap_count_mtx);
+#endif
+
+	if (fasttrap_tpoints.fth_table)
+		vfree(fasttrap_tpoints.fth_table);
+	fasttrap_tpoints.fth_nent = 0;
+
+	if (fasttrap_provs.fth_table)
+		vfree(fasttrap_provs.fth_table);
+	fasttrap_provs.fth_nent = 0;
+
+	if (fasttrap_procs.fth_table)
+		vfree(fasttrap_procs.fth_table);
+	fasttrap_procs.fth_nent = 0;
+
+	kmem_cache_destroy(tracepoint_cachep);
+
+#ifdef FIXME
+	ASSERT(dtrace_fasttrap_exec_ptr == &fasttrap_exec_exit);
+	dtrace_fasttrap_exec_ptr = NULL;
+
+	ASSERT(dtrace_fasttrap_exit_ptr == &fasttrap_exec_exit);
+	dtrace_fasttrap_exit_ptr = NULL;
+#endif
+
+	misc_deregister(&fasttrap_dev);
+}
diff --git a/dtrace/fasttrap_impl.h b/dtrace/fasttrap_impl.h
new file mode 100644
index 000000000000..0972ad3a7edd
--- /dev/null
+++ b/dtrace/fasttrap_impl.h
@@ -0,0 +1,169 @@
+/*
+ * Dynamic Tracing for Linux - fasttrap provider
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _FASTTRAP_IMPL_H_
+#define _FASTTRAP_IMPL_H_
+
+#include <linux/dtrace/fasttrap.h>
+#include <dtrace/fasttrap_arch.h>
+#include <linux/cache.h>
+
+/*
+ * Fasttrap Providers, Probes and Tracepoints
+ *
+ * Each Solaris process can have multiple providers -- the pid provider as
+ * well as any number of user-level statically defined tracing (USDT)
+ * providers. Those providers are each represented by a fasttrap_provider_t.
+ * All providers for a given process have a pointer to a shared
+ * fasttrap_proc_t. The fasttrap_proc_t has two states: active or defunct.
+ * When the count of active providers goes to zero it becomes defunct; a
+ * provider drops its active count when it is removed individually or as part
+ * of a mass removal when a process exits or performs an exec.
+ *
+ * Each probe is represented by a fasttrap_probe_t which has a pointer to
+ * its associated provider as well as a list of fasttrap_id_tp_t structures
+ * which are tuples combining a fasttrap_id_t and a fasttrap_tracepoint_t.
+ * A fasttrap_tracepoint_t represents the actual point of instrumentation
+ * and it contains two lists of fasttrap_id_t structures (to be fired pre-
+ * and post-instruction emulation) that identify the probes attached to the
+ * tracepoint. Tracepoints also have a pointer to the fasttrap_proc_t for the
+ * process they trace which is used when looking up a tracepoint both when a
+ * probe fires and when enabling and disabling probes.
+ *
+ * It's important to note that probes are preallocated with the necessary
+ * number of tracepoints, but that tracepoints can be shared by probes and
+ * swapped between probes. If a probe's preallocated tracepoint is enabled
+ * (and, therefore, the associated probe is enabled), and that probe is
+ * then disabled, ownership of that tracepoint may be exchanged for an
+ * unused tracepoint belonging to another probe that was attached to the
+ * enabled tracepoint.
+ */
+typedef struct fasttrap_proc {
+	pid_t ftpc_pid;				/* process ID for this proc */
+	atomic64_t ftpc_acount;			/* count of active providers */
+	uint64_t ftpc_rcount;			/* count of extant providers */
+	struct mutex ftpc_mtx;			/* lock on all but acount */
+	struct fasttrap_proc *ftpc_next;	/* next proc in hash chain */
+} fasttrap_proc_t;
+
+typedef struct fasttrap_provider {
+	pid_t ftp_pid;				/* process ID for this prov */
+	char ftp_name[DTRACE_PROVNAMELEN];	/* prov name (w/o the pid) */
+	dtrace_provider_id_t ftp_provid;	/* DTrace provider handle */
+	uint_t ftp_marked;			/* mark for possible removal */
+	uint_t ftp_retired;			/* mark when retired */
+	struct mutex ftp_mtx;			/* provider lock */
+	struct mutex ftp_cmtx;			/* lock on creating probes */
+	uint64_t ftp_rcount;			/* enabled probes ref count */
+	uint64_t ftp_ccount;			/* consumers creating probes */
+	uint64_t ftp_mcount;			/* meta provider count */
+	fasttrap_proc_t *ftp_proc;		/* shared proc for all provs */
+	struct fasttrap_provider *ftp_next;	/* next prov in hash chain */
+} fasttrap_provider_t;
+
+typedef struct fasttrap_id		fasttrap_id_t;
+typedef struct fasttrap_probe		fasttrap_probe_t;
+typedef struct fasttrap_tracepoint	fasttrap_tracepoint_t;
+
+struct fasttrap_id {
+	fasttrap_probe_t *fti_probe;		/* referrring probe */
+	fasttrap_id_t *fti_next;		/* enabled probe list on tp */
+	fasttrap_probe_type_t fti_ptype;	/* probe type */
+};
+
+struct fasttrap_tracepoint {
+	fasttrap_proc_t *ftt_proc;		/* associated process struct */
+	uintptr_t ftt_pc;			/* address of tracepoint */
+	pid_t ftt_pid;				/* pid of tracepoint */
+	fasttrap_machtp_t ftt_mtp;		/* ISA-specific portion */
+	fasttrap_id_t *ftt_ids;			/* NULL-terminated list */
+	fasttrap_id_t *ftt_retids;		/* NULL-terminated list */
+	fasttrap_tracepoint_t *ftt_next;	/* link in global hash */
+};
+
+typedef struct fasttrap_id_tp {
+	fasttrap_id_t fit_id;
+	fasttrap_tracepoint_t *fit_tp;
+} fasttrap_id_tp_t;
+
+struct fasttrap_probe {
+	dtrace_id_t ftp_id;			/* DTrace probe identifier */
+	pid_t ftp_pid;				/* pid for this probe */
+	fasttrap_provider_t *ftp_prov;		/* this probe's provider */
+	uintptr_t ftp_faddr;			/* associated function's addr */
+	size_t ftp_fsize;			/* associated function's size */
+	uint64_t ftp_gen;			/* modification generation */
+	uint64_t ftp_ntps;			/* number of tracepoints */
+	uint8_t *ftp_argmap;			/* native to translated args */
+	uint8_t ftp_nargs;			/* translated argument count */
+	uint8_t ftp_enabled;			/* is this probe enabled */
+	char *ftp_xtypes;			/* translated types index */
+	char *ftp_ntypes;			/* native types index */
+	fasttrap_id_tp_t ftp_tps[1];		/* flexible array */
+};
+
+typedef struct fasttrap_bucket_elem {
+	union {
+		struct fasttrap_bucket {
+			struct mutex ftb_mtx;	/* bucket lock */
+			void *ftb_data;		/* data payload */
+		} bucket;
+
+		/*
+		 * Fill a cacheline, no matter how large struct mutex is.
+		 */
+		uint8_t ftb_pad[(sizeof (struct fasttrap_bucket) +
+				 L1_CACHE_BYTES - 1) & ~(L1_CACHE_BYTES - 1)];
+	};
+} fasttrap_bucket_elem_t;
+typedef struct fasttrap_bucket fasttrap_bucket_t;
+
+#define FASTTRAP_ELEM_BUCKET(elem) ((fasttrap_bucket_t *) (elem))
+
+typedef struct fasttrap_hash {
+	ulong_t fth_nent;			/* power-of-2 num. of entries */
+	ulong_t fth_mask;			/* fth_nent - 1 */
+	fasttrap_bucket_elem_t *fth_table;	/* array of buckets */
+} fasttrap_hash_t;
+
+extern fasttrap_hash_t			fasttrap_tpoints;
+
+#define	FASTTRAP_ID_INDEX(id)						      \
+	((fasttrap_id_tp_t *)(((char *)(id) -				      \
+	 offsetof(fasttrap_id_tp_t, fit_id))) -				      \
+	 &(id)->fti_probe->ftp_tps[0])
+#define FASTTRAP_TPOINTS_INDEX(pid, pc)					      \
+	(((pc) / sizeof (fasttrap_instr_t) + (pid)) &			      \
+	 fasttrap_tpoints.fth_mask)
+
+extern void fasttrap_usdt_args64_arch(fasttrap_probe_t *probe, struct pt_regs *regs,
+				      int argc, uintptr_t *argv);
+extern uint64_t fasttrap_usdt_getarg(void *arg, dtrace_id_t id, void *parg,
+				     int argno, int aframes);
+extern void fasttrap_pid_probe_arch(fasttrap_probe_t *ftp, struct pt_regs *regs);
+extern void fasttrap_set_enabled(struct pt_regs *regs);
+
+extern void fasttrap_meta_create_probe(void *, void *,
+				       dtrace_helper_probedesc_t *);
+extern void *fasttrap_meta_provide(void *, dtrace_helper_provdesc_t *, pid_t);
+extern void fasttrap_meta_remove(void *, dtrace_helper_provdesc_t *, pid_t);
+
+extern dtrace_meta_provider_id_t	fasttrap_id;
+
+extern int fasttrap_dev_init(void);
+extern void fasttrap_dev_exit(void);
+
+#endif /* _FASTTRAP_IMPL_H_ */
diff --git a/dtrace/fasttrap_mod.c b/dtrace/fasttrap_mod.c
new file mode 100644
index 000000000000..7a813eedf95c
--- /dev/null
+++ b/dtrace/fasttrap_mod.c
@@ -0,0 +1,35 @@
+/*
+ * FILE:	fasttrap_mod.c
+ * DESCRIPTION:	DTrace - fasttrap provider kernel module
+ *
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fasttrap_impl.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Fasttrap Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static dtrace_mops_t fasttrap_mops = {
+	fasttrap_meta_create_probe,
+	fasttrap_meta_provide,
+	fasttrap_meta_remove
+};
+
+DT_META_PROVIDER_MODULE(fasttrap)
diff --git a/dtrace/fbt_dev.c b/dtrace/fbt_dev.c
new file mode 100644
index 000000000000..20e723b0501c
--- /dev/null
+++ b/dtrace/fbt_dev.c
@@ -0,0 +1,289 @@
+/*
+ * FILE:	fbt_dev.c
+ * DESCRIPTION:	DTrace - FBT provider device driver
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/kallsyms.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/dtrace_fbt.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fbt_impl.h"
+
+#define FBT_PROBETAB_SIZE	0x8000		/* 32k entries -- 128K total */
+
+fbt_probe_t		**fbt_probetab;
+int			fbt_probetab_size = FBT_PROBETAB_SIZE;
+int			fbt_probetab_mask;
+
+static void *fbt_provide_probe(struct module *mp, char *func, int type, int
+			       stype, asm_instr_t *addr, uintptr_t off,
+			       void *pfbt, void *arg)
+{
+	fbt_probe_t	*fbp;
+	fbt_probe_t	*prev;
+	int		*skipped = arg;
+
+	switch (type) {
+	case FBT_ENTRY:
+		fbp = kzalloc(sizeof(fbt_probe_t), GFP_KERNEL);
+		fbp->fbp_name = kstrdup(func, GFP_KERNEL);
+		if (fbp->fbp_name == NULL)
+			goto err_probe;
+
+		fbp->fbp_id = dtrace_probe_create(fbt_id, mp->name, func,
+						  "entry", FBT_AFRAMES, fbp);
+		if (fbp->fbp_id == DTRACE_IDNONE)
+			goto err_name;
+
+		fbp->fbp_module = mp;
+		fbp->fbp_loadcnt = 1; /* FIXME */
+		fbp->fbp_primary = 1; /* FIXME */
+		fbp->fbp_roffset = off;
+		fbp->fbp_patchpoint = addr;
+		fbt_provide_probe_arch(fbp, type, stype);
+
+		fbp->fbp_hashnext = fbt_probetab[FBT_ADDR2NDX(fbp->fbp_patchpoint)];
+		fbt_probetab[FBT_ADDR2NDX(fbp->fbp_patchpoint)] = fbp;
+
+		PDATA(mp)->fbt_probe_cnt++;
+
+		return fbp;
+	case FBT_RETURN:
+
+		/* Check if we are able to patch this return probe. */
+		if (!fbt_can_patch_return_arch(addr))
+			return pfbt;
+
+		fbp = kzalloc(sizeof(fbt_probe_t), GFP_KERNEL);
+		fbp->fbp_name = kstrdup(func, GFP_KERNEL);
+		if (fbp->fbp_name == NULL)
+			goto err_probe;
+
+		prev = (fbt_probe_t *)pfbt;
+		if (prev != NULL) {
+			prev->fbp_next = fbp;
+			fbp->fbp_id = prev->fbp_id;
+		} else {
+			fbp->fbp_id = dtrace_probe_create(fbt_id, mp->name,
+							  func, "return",
+							  FBT_AFRAMES, fbp);
+			if (fbp->fbp_id == DTRACE_IDNONE)
+				goto err_name;
+		}
+
+		fbp->fbp_module = mp;
+		fbp->fbp_loadcnt = 1; /* FIXME */
+		fbp->fbp_primary = 1; /* FIXME */
+		fbp->fbp_roffset = off;
+		fbp->fbp_patchpoint = addr;
+		fbt_provide_probe_arch(fbp, type, stype);
+
+		fbp->fbp_hashnext = fbt_probetab[FBT_ADDR2NDX(fbp->fbp_patchpoint)];
+		fbt_probetab[FBT_ADDR2NDX(fbp->fbp_patchpoint)] = fbp;
+
+		PDATA(mp)->fbt_probe_cnt++;
+
+		return fbp;
+	default:
+		printk(KERN_INFO "FBT: Invalid probe type %d (%d) for %s\n",
+		       type, stype, func);
+
+		return NULL;
+	}
+
+err_name:
+	kfree(fbp->fbp_name);
+err_probe:
+	kfree(fbp);
+	(*skipped)++;
+
+	return NULL;
+}
+
+void fbt_provide_module(void *arg, struct module *mp)
+{
+	struct module_use	*use;
+	int			probes_skipped = 0;
+
+	/* If module setup has failed then do not provide anything. */
+	if (PDATA(mp) == NULL)
+		return;
+
+	/*
+	 * Nothing to do if the module FBT probes were already created.
+	 */
+	if (PDATA(mp)->fbt_probe_cnt != 0)
+		return;
+
+	/*
+	 * Do not try to instrument DTrace itself and its modules:
+	 *      - dtrace module
+	 *      - all modules depending on dtrace
+	 */
+	if (!strncmp(mp->name, "dtrace", 7))
+		return;
+
+	list_for_each_entry(use, &mp->target_list, target_list) {
+		if (!strncmp(use->target->name, "dtrace", 7))
+			return;
+	}
+
+	/*
+	 * Provide probes.
+	 */
+	if (!fbt_provide_module_arch(arg, mp))
+		return;
+
+	dtrace_fbt_init((fbt_add_probe_fn)fbt_provide_probe, mp,
+			&probes_skipped);
+
+	if (probes_skipped != 0)
+		pr_warn("fbt: Failed to provide %d probes in %s (out of memory)\n",
+			probes_skipped, mp->name);
+}
+
+int fbt_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	fbt_probe_t	*fbp = parg;
+	fbt_probe_t	*curr;
+
+	/*
+	 * Ensure that we have a reference to the module.
+	 */
+	if (!try_module_get(fbp->fbp_module))
+		return -EAGAIN;
+
+	/*
+	 * If at least one other enabled probe exists for this module, drop the
+	 * reference we took above, because we only need one to prevent the
+	 * module from being unloaded.
+	 */
+	PDATA(fbp->fbp_module)->enabled_cnt++;
+	if (PDATA(fbp->fbp_module)->enabled_cnt > 1)
+		module_put(fbp->fbp_module);
+
+	for (curr = fbp; curr != NULL; curr = curr->fbp_next)
+		fbt_enable_arch(curr, id, arg);
+
+	return 0;
+}
+
+void fbt_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	fbt_probe_t	*fbp = parg;
+	fbt_probe_t	*curr;
+
+	for (curr = fbp; curr != NULL; curr = curr->fbp_next)
+		fbt_disable_arch(curr, id, arg);
+
+	/*
+	 * If we are disabling a probe, we know it was enabled, and therefore
+	 * we know that we have a reference on the module to prevent it from
+	 * being unloaded.  If we disable the last probe on the module, we can
+	 * drop the reference.
+	 */
+	PDATA(fbp->fbp_module)->enabled_cnt--;
+	if (PDATA(fbp->fbp_module)->enabled_cnt == 0)
+		module_put(fbp->fbp_module);
+}
+
+void fbt_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+	fbt_probe_t	*fbp = parg;
+	fbt_probe_t	*hbp, *lst, *nxt;
+	int		ndx;
+	struct module	*mp = fbp->fbp_module;
+
+	do {
+		nxt = fbp->fbp_next;
+
+		ndx = FBT_ADDR2NDX(fbp->fbp_patchpoint);
+		lst = NULL;
+		hbp = fbt_probetab[ndx];
+
+		while (hbp != fbp) {
+			ASSERT(hbp != NULL);
+
+			lst = hbp;
+			hbp = hbp->fbp_hashnext;
+		}
+
+		if (lst != NULL)
+			lst->fbp_hashnext = fbp->fbp_hashnext;
+		else
+			fbt_probetab[ndx] = fbp->fbp_hashnext;
+
+		kfree(fbp->fbp_name);
+		kfree(fbp);
+
+		PDATA(mp)->fbt_probe_cnt--;
+
+		fbp = nxt;
+	} while (fbp != NULL);
+}
+
+static long fbt_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int fbt_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int fbt_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations fbt_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = fbt_ioctl,
+        .open   = fbt_open,
+        .release = fbt_close,
+};
+
+static struct miscdevice fbt_dev = {
+	.minor = DT_DEV_FBT_MINOR,
+	.name = "fbt",
+	.nodename = "dtrace/provider/fbt",
+	.fops = &fbt_fops,
+};
+
+int fbt_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&fbt_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       fbt_dev.name, fbt_dev.minor);
+
+	return fbt_dev_init_arch();
+}
+
+void fbt_dev_exit(void)
+{
+	fbt_dev_exit_arch();
+
+	misc_deregister(&fbt_dev);
+}
diff --git a/dtrace/fbt_impl.h b/dtrace/fbt_impl.h
new file mode 100644
index 000000000000..bad55cfaff59
--- /dev/null
+++ b/dtrace/fbt_impl.h
@@ -0,0 +1,51 @@
+/*
+ * Dynamic Tracing for Linux - Function Boundary Tracing provider
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _FBT_H_
+#define _FBT_H_
+
+#include <asm/dtrace_arch.h>
+#include <dtrace/fbt_arch.h>
+
+#define FBT_ADDR2NDX(addr)	((((uintptr_t)(addr)) >> 4) & \
+					fbt_probetab_mask)
+
+extern fbt_probe_t		**fbt_probetab;
+extern int			fbt_probetab_size;
+extern int			fbt_probetab_mask;
+
+extern void fbt_provide_probe_arch(fbt_probe_t *, int, int);
+extern void fbt_enable_arch(fbt_probe_t *, dtrace_id_t, void *);
+extern void fbt_disable_arch(fbt_probe_t *, dtrace_id_t, void *);
+extern int fbt_can_patch_return_arch(asm_instr_t *);
+
+extern int fbt_provide_module_arch(void *, struct module *);
+extern void fbt_provide_module(void *, struct module *);
+extern void fbt_destroy_module(void *, struct module *);
+extern int fbt_enable(void *, dtrace_id_t, void *);
+extern void fbt_disable(void *, dtrace_id_t, void *);
+extern uint64_t fbt_getarg(void *, dtrace_id_t, void *, int, int);
+extern void fbt_destroy(void *, dtrace_id_t, void *);
+
+extern dtrace_provider_id_t	fbt_id;
+
+extern int fbt_dev_init_arch(void);
+extern void fbt_dev_exit_arch(void);
+
+extern int fbt_dev_init(void);
+extern void fbt_dev_exit(void);
+
+#endif /* _FBT_H_ */
diff --git a/dtrace/fbt_mod.c b/dtrace/fbt_mod.c
new file mode 100644
index 000000000000..7b17146202ac
--- /dev/null
+++ b/dtrace/fbt_mod.c
@@ -0,0 +1,55 @@
+/*
+ * FILE:	fbt_mod.c
+ * DESCRIPTION:	DTrace - FBT provider kernel module
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "fbt_impl.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Function Boundary Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static const dtrace_pattr_t fbt_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pops_t fbt_pops = {
+	.dtps_provide = NULL,
+	.dtps_provide_module = fbt_provide_module,
+	.dtps_destroy_module = fbt_destroy_module,
+	.dtps_enable = fbt_enable,
+	.dtps_disable = fbt_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = NULL,
+#ifdef CONFIG_X86_64
+	.dtps_getargval = fbt_getarg,
+#else
+	.dtps_getargval = NULL,
+#endif
+	.dtps_usermode = NULL,
+	.dtps_destroy = fbt_destroy
+};
+
+DT_PROVIDER_MODULE(fbt, DTRACE_PRIV_KERNEL)
diff --git a/dtrace/profile.h b/dtrace/profile.h
new file mode 100644
index 000000000000..9b98ab7adc46
--- /dev/null
+++ b/dtrace/profile.h
@@ -0,0 +1,31 @@
+/*
+ * Dynamic Tracing for Linux - profile provider
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _PROFILE_H_
+#define _PROFILE_H_
+
+extern void profile_provide(void *, const dtrace_probedesc_t *);
+extern int profile_enable(void *, dtrace_id_t, void *);
+extern void profile_disable(void *, dtrace_id_t, void *);
+extern int profile_usermode(void *, dtrace_id_t, void *);
+extern void profile_destroy(void *, dtrace_id_t, void *);
+
+extern dtrace_provider_id_t	profile_id;
+
+extern int profile_dev_init(void);
+extern void profile_dev_exit(void);
+
+#endif /* _PROFILE_H_ */
diff --git a/dtrace/profile_dev.c b/dtrace/profile_dev.c
new file mode 100644
index 000000000000..1b15dacd189b
--- /dev/null
+++ b/dtrace/profile_dev.c
@@ -0,0 +1,487 @@
+/*
+ * FILE:	profile_dev.c
+ * DESCRIPTION:	DTrace - profile provider device driver
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/fs.h>
+#include <linux/ktime.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <asm/irq_regs.h>
+#include <asm/ptrace.h>
+
+#include <linux/hardirq.h>
+#include <linux/profile.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "profile.h"
+
+#define PROF_NAMELEN		15
+#define PROF_PROFILE		0
+#define PROF_TICK		1
+#define PROF_PREFIX_PROFILE	"profile-"
+#define PROF_PREFIX_TICK	"tick-"
+
+typedef struct profile_probe {
+	char		prof_name[PROF_NAMELEN];
+	dtrace_id_t	prof_id;
+	int		prof_kind;
+	ktime_t		prof_interval;
+	cyclic_id_t	prof_cyclic;
+} profile_probe_t;
+
+typedef struct profile_probe_percpu {
+	ktime_t		profc_expected;
+	ktime_t		profc_interval;
+	profile_probe_t	*profc_probe;
+} profile_probe_percpu_t;
+
+static ktime_t	profile_interval_min = KTIME_INIT(0, NANOSEC / 5000);
+static int	profile_aframes = 0;
+
+static int	profile_rates[] = {
+				    97, 199, 499, 997, 1999,
+				    4001, 4999, 0, 0, 0,
+				    0, 0, 0, 0, 0,
+				    0, 0, 0, 0, 0,
+				  };
+static int	profile_ticks[] = {
+				    1, 10, 100, 500, 1000,
+				    5000, 0, 0, 0, 0,
+				    0, 0, 0, 0, 0,
+				  };
+
+/*
+ * profile_max defines the upper bound on the number of profile probes that
+ * can exist (this is to prevent malicious or clumsy users from exhausing
+ * system resources by creating a slew of profile probes). At mod load time,
+ * this gets its value from PROFILE_MAX_DEFAULT or profile-max-probes if it's
+ * present as module parameter.
+ * FIXME: module parameter yet to be implemented.
+ */
+#define PROFILE_MAX_DEFAULT	1000	/* default max. number of probes */
+
+static int	profile_max;		/* maximum number of profile probes */
+static atomic_t	profile_total;		/* current number of profile probes */
+
+static void profile_tick_fn(uintptr_t arg)
+{
+	profile_probe_t	*prof = (profile_probe_t *)arg;
+	unsigned long	pc = 0, upc = 0;
+	struct pt_regs	*regs = get_irq_regs();
+
+	/*
+	 * If regs == NULL, then we were called from from softirq context which
+	 * also means that we didn't actually interrupt any processing (kernel
+	 * or user space).
+	 * If regs != NULL, then we did actually get called from hardirq
+	 * because the timer interrupt did really interrupt something that was
+	 * going on on the CPU (could be user mode or kernel mode).
+	 */
+	if (regs == NULL) {
+		uint64_t	stack[8];
+
+		dtrace_getpcstack(stack, 8, 0, NULL);
+		pc = stack[7];
+	} else if (user_mode(regs))
+		upc = instruction_pointer(regs);
+	else
+		pc = instruction_pointer(regs);
+
+	dtrace_probe(prof->prof_id, pc, upc, 0, 0, 0, 0, 0);
+}
+
+static void profile_prof_fn(uintptr_t arg)
+{
+	profile_probe_percpu_t	*pcpu = (profile_probe_percpu_t *)arg;
+	profile_probe_t		*prof = pcpu->profc_probe;
+	ktime_t			late;
+	struct pt_regs		*regs = get_irq_regs();
+	unsigned long		pc = 0, upc = 0;
+
+	late = ktime_sub(dtrace_gethrtime(), pcpu->profc_expected);
+	pcpu->profc_expected = ktime_add(pcpu->profc_expected,
+					 pcpu->profc_interval);
+
+	/*
+	 * If regs == NULL, then we were called from from softirq context which
+	 * also means that we didn't actually interrupt any processing (kernel
+	 * or user space).
+	 * If regs != NULL, then we did actually get called from hardirq
+	 * because the timer interrupt did really interrupt something that was
+	 * going on on the CPU (could be user mode or kernel mode).
+	 */
+	if (regs == NULL) {
+		uint64_t	stack[8];
+
+		dtrace_getpcstack(stack, 8, 0, NULL);
+		pc = stack[7];
+	} else if (user_mode(regs))
+		upc = instruction_pointer(regs);
+	else
+		pc = instruction_pointer(regs);
+
+	dtrace_probe(prof->prof_id, pc, upc, ktime_to_ns(late), 0, 0, 0, 0);
+}
+
+static void profile_online(void *arg, processorid_t cpu, cyc_handler_t *hdlr,
+			   cyc_time_t *when)
+{
+	profile_probe_t		*prof = arg;
+	profile_probe_percpu_t	*pcpu;
+
+	pcpu = kzalloc(sizeof(profile_probe_percpu_t), GFP_KERNEL);
+	pcpu->profc_probe = prof;
+
+	hdlr->cyh_func = profile_prof_fn;
+	hdlr->cyh_arg = (uintptr_t)pcpu;
+	hdlr->cyh_level = CY_HIGH_LEVEL;
+
+	when->cyt_interval = prof->prof_interval;
+	when->cyt_when = ktime_add(dtrace_gethrtime(), when->cyt_interval);
+
+	pcpu->profc_expected = when->cyt_when;
+	pcpu->profc_interval = when->cyt_interval;
+}
+
+static void profile_offline(void *arg, processorid_t cpu, void *oarg)
+{
+	profile_probe_percpu_t	*pcpu = oarg;
+
+	if (pcpu->profc_probe == arg) {
+		kfree(pcpu);
+		return;
+	}
+
+	WARN_ONCE(1, "%s: called with mismatched probe info (%p vs %p)"
+		  " - leaking %lu bytes\n", __func__, pcpu->profc_probe, arg,
+		  sizeof(profile_probe_percpu_t));
+
+}
+
+static void profile_create(ktime_t interval, const char *name, int kind)
+{
+	profile_probe_t	*prof;
+	int		nr_frames = 0; /* FIXME */
+
+	if (profile_aframes)
+		nr_frames = profile_aframes;
+
+	if (ktime_lt(interval, profile_interval_min))
+		return;
+
+	if (dtrace_probe_lookup(profile_id, NULL, NULL, name) != 0)
+		return;
+
+	prof = kzalloc(sizeof(profile_probe_t), GFP_KERNEL);
+	if (prof == NULL) {
+		pr_warn("Unable to create probe %s: out of memory\n", name);
+		return;
+	}
+
+	atomic_inc(&profile_total);
+	if (atomic_read(&profile_total) > profile_max)
+		goto errout;
+
+	strcpy(prof->prof_name, name);
+	prof->prof_interval = interval;
+	prof->prof_cyclic = CYCLIC_NONE;
+	prof->prof_kind = kind;
+	prof->prof_id = dtrace_probe_create(profile_id, NULL, NULL, name,
+					    nr_frames, prof);
+
+	if (prof->prof_id == DTRACE_IDNONE) {
+		pr_warn("Unable to create probe %s: out of memory\n", name);
+		goto errout;
+	}
+
+	return;
+
+errout:
+	kfree(prof);
+	atomic_dec(&profile_total);
+	return;
+}
+
+void profile_provide(void *arg, const dtrace_probedesc_t *desc)
+{
+	int		i, j, rate, kind;
+	long		val = 0, mult = 1, mult_s = 0, mult_ns = 0, len;
+	ktime_t		interval;
+	const char	*name, *suffix = NULL;
+	const struct {
+			char	*prefix;
+			int	kind;
+	} types[] = {
+			{ PROF_PREFIX_PROFILE, PROF_PROFILE },
+			{ PROF_PREFIX_TICK, PROF_TICK },
+			{ NULL, 0 },
+		    };
+
+	const struct {
+			char	*name;
+			long	mult_s;
+			long	mult_ns;
+	} suffixes[] = {
+			{ "ns",		0, 1 },
+			{ "nsec",	0, 1 },
+			{ "us",		0, NANOSEC / MICROSEC },
+			{ "usec",	0, NANOSEC / MICROSEC },
+			{ "ms",		0, NANOSEC / MILLISEC },
+			{ "msec",	0, NANOSEC / MILLISEC },
+			{ "s",		1, 0 },
+			{ "sec",	1, 0 },
+			{ "m",		60, 0 },
+			{ "min",	60, 0 },
+			{ "h",		60 * 60, 0 },
+			{ "hour",	60 * 60, 0 },
+			{ "d",		24 * 60 * 60, 0 },
+			{ "day",	24 * 60 * 60, 0 },
+			{ "hz",		0, 0 },
+			{ NULL, },
+		       };
+
+	if (desc == NULL) {
+		char	n[PROF_NAMELEN];
+
+		/*
+		 * If no description was provided, provide all of our probes.
+		 */
+		for (i = 0; i < sizeof(profile_rates) / sizeof(int); i++) {
+			if ((rate = profile_rates[i]) == 0)
+				continue;
+
+			snprintf(n, PROF_NAMELEN, "%s%d",
+				 PROF_PREFIX_PROFILE, rate);
+			profile_create(ktime_set(0, NANOSEC / rate),
+				       n, PROF_PROFILE);
+		}
+
+		for (i = 0; i < sizeof(profile_ticks) / sizeof(int); i++) {
+			if ((rate = profile_ticks[i]) == 0)
+				continue;
+
+			snprintf(n, PROF_NAMELEN, "%s%d",
+				 PROF_PREFIX_TICK, rate);
+			profile_create(ktime_set(0, NANOSEC / rate),
+				       n, PROF_TICK);
+		}
+
+		return;
+	}
+
+	name = desc->dtpd_name;
+
+	for (i = 0; types[i].prefix != NULL; i++) {
+		len = strlen(types[i].prefix);
+
+		if (strncmp(name, types[i].prefix, len) != 0)
+			continue;
+
+		break;
+	}
+
+	if (types[i].prefix == NULL)
+		return;
+
+	kind = types[i].kind;
+
+	/*
+	 * We need to start before any time suffix.
+	 */
+	for (j = strlen(name); j >= len; j--) {
+		if (name[j] >= '0' && name[j] <= '9')
+			break;
+
+		suffix = &name[j];
+	}
+
+	if (suffix == NULL) {
+		WARN_ONCE(1, "%s: missing time suffix in %s\n", __func__, name);
+		return;
+	}
+
+	/*
+	 * Now determine the numerical value present in the probe name.
+	 */
+	for (; j >= len; j--) {
+		if (name[j] < '0' || name[j] > '9')
+			return;
+
+		val += (name[j] - '0') * mult;
+		mult *= 10;
+	}
+
+	if (val == 0)
+		return;
+
+	/*
+	 * Look up the suffix to determine the multiplier.
+	 */
+	for (i = 0; suffixes[i].name != NULL; i++) {
+		if (strcasecmp(suffixes[i].name, suffix) == 0) {
+			mult_s = suffixes[i].mult_s;
+			mult_ns = suffixes[i].mult_ns;
+			break;
+		}
+	}
+
+	if (suffixes[i].name == NULL && *suffix != '\0')
+		return;
+
+	if (mult_s == 0 && mult_ns == 0) {
+		/*
+		 * The default is frequency (per-second).
+		 */
+		interval = ns_to_ktime((int64_t)NANOSEC / val);
+	} else {
+		long	sec;
+		long	nsec = val * mult_ns;
+
+		sec = nsec / NANOSEC;
+		nsec %= NANOSEC;
+
+		interval = ktime_set(val * mult_s + sec, nsec);
+	}
+
+
+	profile_create(interval, name, kind);
+}
+
+int profile_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	profile_probe_t		*prof = parg;
+	cyc_time_t		when;
+
+	if (!ktime_nz(prof->prof_interval)) {
+		WARN_ONCE(1, "%s: trying to enable 0-interval probe %s\n",
+			  __func__, prof->prof_name);
+		return 1;
+	}
+	if (!MUTEX_HELD(&cpu_lock)) {
+		WARN_ONCE(1, "%s: not holding cpu_lock\n", __func__);
+		return 1;
+	}
+
+	if (prof->prof_kind == PROF_TICK) {
+		cyc_handler_t		hdlr;
+
+		hdlr.cyh_func = profile_tick_fn;
+		hdlr.cyh_arg = (uintptr_t)prof;
+		hdlr.cyh_level = CY_HIGH_LEVEL;
+
+		when.cyt_interval = prof->prof_interval;
+		when.cyt_when = ktime_set(0, 0);
+
+		prof->prof_cyclic = cyclic_add(&hdlr, &when);
+	} else if (prof->prof_kind == PROF_PROFILE) {
+		cyc_omni_handler_t	omni;
+
+		omni.cyo_online = profile_online;
+		omni.cyo_offline = profile_offline;
+		omni.cyo_arg = prof;
+
+		prof->prof_cyclic = cyclic_add_omni(&omni);
+	} else
+		pr_warn_once("%s: Invalid profile type %d\n",
+			      __func__, prof->prof_kind);
+
+	return 0;
+}
+
+void profile_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	profile_probe_t	*prof = parg;
+
+	if (prof->prof_cyclic == CYCLIC_NONE) {
+		WARN_ONCE(1, "%s: trying to disable probe %s without cyclic\n",
+			  __func__, prof->prof_name);
+		return;
+	}
+	if (!MUTEX_HELD(&cpu_lock)) {
+		WARN_ONCE(1, "%s: not holding cpu_lock\n", __func__);
+		return;
+	}
+
+	cyclic_remove(prof->prof_cyclic);
+	prof->prof_cyclic = CYCLIC_NONE;
+}
+
+int profile_usermode(void *arg, dtrace_id_t id, void *parg)
+{
+	return 1; /* FIXME */
+}
+
+void profile_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+	profile_probe_t	*prof = parg;
+
+	if (prof->prof_cyclic == CYCLIC_NONE) {
+		kfree(prof);
+
+		if (atomic_read(&profile_total) >= 1) {
+			atomic_dec(&profile_total);
+			return;
+		}
+
+		WARN_ONCE(1, "%s: profile_total refcount is 0!\n", __func__);
+	}
+
+	WARN_ONCE(1, "%s: %s still assigned to cyclic\n",
+		  __func__, prof->prof_name);
+}
+
+static int profile_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int profile_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations profile_fops = {
+	.owner  = THIS_MODULE,
+        .open   = profile_open,
+        .release = profile_close,
+};
+
+static struct miscdevice profile_dev = {
+	.minor = DT_DEV_PROFILE_MINOR,
+	.name = "profile",
+	.nodename = "dtrace/provider/profile",
+	.fops = &profile_fops,
+};
+
+int profile_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&profile_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       profile_dev.name, profile_dev.minor);
+
+	profile_max = PROFILE_MAX_DEFAULT;
+
+	return ret;
+}
+
+void profile_dev_exit(void)
+{
+	misc_deregister(&profile_dev);
+}
diff --git a/dtrace/profile_mod.c b/dtrace/profile_mod.c
new file mode 100644
index 000000000000..d366b1ad9520
--- /dev/null
+++ b/dtrace/profile_mod.c
@@ -0,0 +1,51 @@
+/*
+ * FILE:	profile_mod.c
+ * DESCRIPTION:	DTrace - Profile provider kernel module
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "profile.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Profile Interrupt Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static const dtrace_pattr_t profile_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+};
+
+static dtrace_pops_t profile_pops = {
+	.dtps_provide = profile_provide,
+	.dtps_provide_module = NULL,
+	.dtps_destroy_module = NULL,
+	.dtps_enable = profile_enable,
+	.dtps_disable = profile_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = NULL,
+	.dtps_getargval = NULL,
+	.dtps_usermode = profile_usermode,
+	.dtps_destroy = profile_destroy,
+};
+
+DT_PROVIDER_MODULE(profile, DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER)
diff --git a/dtrace/sdt_dev.c b/dtrace/sdt_dev.c
new file mode 100644
index 000000000000..ac972c4311b5
--- /dev/null
+++ b/dtrace/sdt_dev.c
@@ -0,0 +1,562 @@
+/*
+ * FILE:	sdt_dev.c
+ * DESCRIPTION:	DTrace - SDT provider device driver
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/sdt.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "sdt_impl.h"
+
+#define SDT_PROBETAB_SIZE	0x1000		/* 4k entries -- 16K total */
+
+sdt_probe_t		**sdt_probetab;
+int			sdt_probetab_size;
+int			sdt_probetab_mask;
+
+/*
+ * Return, in newly-allocated space, a version of the passed-in type which has
+ * been cleaned up suitably for CTF: leading and trailing spaces (if any)
+ * removed, and optionally a trailing argument removed as well.
+ *
+ * Type strings look like either
+ *
+ * type (for SDT, as in function prototypes), or
+ *
+ * type argname (for perf: as in function declarations).
+ *
+ * Translator components ": (foo, foo)", if any, have been removed by this
+ * stage.
+ */
+static char *cleanup_type(const char *type, int arg_strip)
+{
+	const char *cleaned;
+	const char *p;
+
+	cleaned = type + strspn(type, " \t");
+	for (p = cleaned + strlen(cleaned) - 1; p > cleaned &&
+		     isspace(*p); p--);
+	if (arg_strip) {
+		for (; p > cleaned && (isalnum(*p) || *p == '_'); p--);
+		for (; p > cleaned && isspace(*p); p--);
+	}
+	p++;
+
+	return kstrndup(cleaned, p - cleaned, GFP_KERNEL);
+}
+
+/*
+ * Set up the args lists, extracting them from their sdpd entry and parsing them
+ * into an sdt_argdesc array for each probe.
+ */
+static sdt_argdesc_t *sdt_setup_args(sdt_probedesc_t *sdpd, size_t *sdp_nargdesc)
+{
+	sdt_argdesc_t *args;
+	char *argstr;
+	char *p;
+	int arg_strip = 0;
+	char *next_arg = NULL;
+	size_t arg = 0, sarg = 0, i;
+
+	*sdp_nargdesc = 0;
+
+	if ((sdpd->sdpd_args == NULL) || (sdpd->sdpd_args[0] == '\0'))
+		return NULL;
+
+	/*
+	 * Take a copy of the string so we can mutate it without causing trouble
+	 * on module reload.
+	 */
+ 	argstr = kstrdup(sdpd->sdpd_args, GFP_KERNEL);
+	if (argstr == NULL)
+		goto oom;
+
+	/*
+	 * Handle the common case of a trailing comma before we allocate space,
+	 * and elide it.
+	 */
+	p = argstr + strlen(argstr) - 1;
+	if (p[0] == ',' && p[1] == '\0')
+		*p = '\0';
+
+	/*
+	 * This works for counting the number of args even though translator
+	 * strings can contain commas, because each comma denotes a new probe
+	 * argument.  It may overcount in the case of elided arguments
+	 * ("foo : ,"): we compensate for that further down, and ignore the tiny
+	 * memory leak that results.
+	 */
+	for (p = argstr; p != NULL; p = strchr(p + 1, ','))
+		(*sdp_nargdesc)++;
+
+	args = kzalloc(*sdp_nargdesc * sizeof (struct sdt_argdesc),
+		GFP_KERNEL);
+	if (args == NULL)
+		goto oom_argstr;
+
+	/*
+	 * We need to transform each arg (stripping off a terminal argument
+	 * name) if this is a perf probe.
+	 */
+	if (strncmp(sdpd->sdpd_name, "__perf_", strlen("__perf_")) == 0)
+		arg_strip = 1;
+
+	next_arg = argstr;
+	do {
+		char *tok;
+		char *xlator = NULL, *p;
+		char *native;
+		int parens = 0;
+		int empty_xlation;
+
+		/*
+		 * Find the end of this arg, and figure out if it has any
+		 * translators.  Clean up the type of the arg (or native type,
+		 * if this is a translated type).
+		 */
+		tok = next_arg;
+		next_arg = NULL;
+		p = strpbrk(tok, "():,");
+		while (p && !next_arg) {
+			switch(*p) {
+			case '(': parens++;
+				break;
+			case ')': if (parens > 0)
+					parens--;
+				break;
+			case ':': *p = '\0';
+				xlator = p + 1;
+				break;
+			case ',': if (parens == 0) {
+					*p = '\0';
+					next_arg = p + 1;
+				}
+				break;
+			}
+			p = strpbrk(p + 1, "():,");
+		}
+
+		native = cleanup_type(tok, arg_strip);
+		if (native == NULL) {
+			args[arg].sda_native = args[arg].sda_xlate = NULL;
+			goto full_oom;
+		}
+
+		/*
+		 * Special case: perf's DECLARE_TRACE_NOARGS passes a single arg
+		 * 'void'. Spot and skip it.
+		 */
+		if (!xlator && arg_strip && strcmp(native, "void") == 0) {
+			kfree(native);
+			(*sdp_nargdesc)--;
+			sarg++;
+			continue;
+		}
+
+		/*
+		 * No translator: straight mapping.
+		 */
+		if (xlator == NULL) {
+			ASSERT(arg < *sdp_nargdesc);
+			args[arg].sda_mapping = sarg;
+			args[arg].sda_native = native;
+			args[arg].sda_xlate = NULL;
+			arg++;
+			sarg++;
+			continue;
+		}
+
+		/*
+		 * If this is a perf probe, warn: translations cannot exist for
+		 * these, and have no defined format yet in any case.  We can
+		 * struggle on by assuming they look like SDT translations.
+		 */
+		if (arg_strip)
+			pr_warn("Perf probe %s has at least one SDT translation, "
+				"which should be impossible.", sdpd->sdpd_name);
+
+		/*
+		 * Zero or more translations.  (If there are zero, i.e. a pair
+		 * of empty parentheses or a colon with nothing after it, we
+		 * have to decrement the nargdesc.)
+		 */
+
+		empty_xlation = 1;
+		while ((p = strsep(&xlator, "(,)")) != NULL) {
+			/*
+			 * Skip the empty space before the ( or after the ).
+			 */
+			if (strspn(p, " \t") == strlen(p))
+				continue;
+
+			ASSERT(arg < *sdp_nargdesc);
+
+			empty_xlation = 0;
+			args[arg].sda_mapping = sarg;
+			args[arg].sda_native = kstrdup(native, GFP_KERNEL);
+			args[arg].sda_xlate = cleanup_type(p, 0);
+			if ((args[arg].sda_native == NULL) ||
+			    (args[arg].sda_xlate == NULL)) {
+				pr_warn("Unable to create argdesc list for "
+					"probe %s: out of memory\n",
+					sdpd->sdpd_name);
+				kfree(native);
+				goto full_oom;
+			}
+			arg++;
+		}
+		if (empty_xlation)
+			(*sdp_nargdesc)--;
+
+		kfree(native);
+		sarg++;
+	} while (next_arg != NULL);
+
+	kfree(argstr);
+	return args;
+
+full_oom:
+	for (i = 0; i < arg; i++) {
+		kfree(args[i].sda_native);
+		kfree(args[i].sda_xlate);
+	}
+	kfree(args);
+oom_argstr:
+	kfree(argstr);
+oom:
+	*sdp_nargdesc = 0;
+	pr_warn("Unable to create argdesc list for probe %s: "
+		"out of memory\n", sdpd->sdpd_name);
+	return NULL;
+}
+
+void sdt_provide_module(void *arg, struct module *mp)
+{
+	char			*modname = mp->name;
+	dtrace_mprovider_t	*prov;
+	sdt_probedesc_t		*sdpd;
+	sdt_probe_t		*sdp, *prv;
+	int			idx, len;
+	int			probes_skipped = 0;
+
+	/* If module setup has failed then do not provide anything. */
+	if (PDATA(mp) == NULL)
+		return;
+
+	/*
+	 * Nothing to do if the module SDT probes were already created.
+	 */
+	if (PDATA(mp)->sdt_probe_cnt != 0)
+		return;
+
+	/*
+	 * Nothing to do if there are no SDT probes.
+	 */
+	if (mp->sdt_probec == 0)
+		return;
+
+	/*
+	 * Nothing if arch specific module setup fails.
+	 */
+	if (!sdt_provide_module_arch(NULL, mp))
+		return;
+
+	/*
+	 * Do not provide any probes unless all SDT providers have been created
+	 * for this meta-provider.
+	 */
+	for (prov = sdt_providers; prov->dtmp_name != NULL; prov++) {
+		if (prov->dtmp_id == DTRACE_PROVNONE)
+			return;
+	}
+
+	for (idx = 0, sdpd = mp->sdt_probes; idx < mp->sdt_probec;
+	     idx++, sdpd++) {
+		char			*name = sdpd->sdpd_name, *nname;
+		int			i, j;
+		dtrace_mprovider_t	*prov;
+		dtrace_id_t		id;
+		sdt_probe_type_t	ptype;
+
+		if (name[0] == '?') {
+			ptype = SDTPT_IS_ENABLED;
+			name++;
+		} else
+			ptype = SDTPT_OFFSETS;
+
+		for (prov = sdt_providers; prov->dtmp_pref != NULL; prov++) {
+			char	*prefix = prov->dtmp_pref;
+			int	len = strlen(prefix);
+
+			if (strncmp(name, prefix, len) == 0) {
+				name += len;
+				break;
+			}
+		}
+
+		nname = kmalloc(len = strlen(name) + 1, GFP_KERNEL);
+		if (nname == NULL) {
+			probes_skipped++;
+			continue;
+		}
+
+		for (i = j = 0; name[j] != '\0'; i++) {
+			if (name[j] == '_' && name[j + 1] == '_') {
+				nname[i] = '-';
+				j += 2;
+			} else
+				nname[i] = name[j++];
+		}
+
+		nname[i] = '\0';
+
+		sdp = kzalloc(sizeof(sdt_probe_t), GFP_KERNEL);
+		if (sdp == NULL) {
+			probes_skipped++;
+			continue;
+		}
+
+		sdp->sdp_loadcnt = 1; /* FIXME */
+		sdp->sdp_module = mp;
+		sdp->sdp_name = nname;
+		sdp->sdp_namelen = len;
+		sdp->sdp_provider = prov;
+		sdp->sdp_ptype = ptype;
+
+		sdp->sdp_argdesc = sdt_setup_args(sdpd, &sdp->sdp_nargdesc);
+
+		if ((id = dtrace_probe_lookup(prov->dtmp_id, modname,
+					      sdpd->sdpd_func, nname)) !=
+				DTRACE_IDNONE) {
+			prv = dtrace_probe_arg(prov->dtmp_id, id);
+			ASSERT(prv != NULL);
+
+			sdp->sdp_next = prv->sdp_next;
+			sdp->sdp_id = id;
+			prv->sdp_next = sdp;
+		} else {
+			sdp->sdp_id = dtrace_probe_create(prov->dtmp_id,
+							  modname,
+							  sdpd->sdpd_func,
+							  nname, SDT_AFRAMES,
+							  sdp);
+
+			/*
+			 * If we failed to create the probe just skip it.
+			 */
+			if (sdp->sdp_id == DTRACE_IDNONE) {
+				kfree(sdp);
+				probes_skipped++;
+				continue;
+			}
+
+			PDATA(mp)->sdt_probe_cnt++;
+		}
+
+		sdp->sdp_patchpoint = (asm_instr_t *)sdpd->sdpd_offset;
+
+		sdt_provide_probe_arch(sdp, mp, idx);
+
+		sdp->sdp_hashnext = sdt_probetab[
+					SDT_ADDR2NDX(sdp->sdp_patchpoint)];
+		sdt_probetab[SDT_ADDR2NDX(sdp->sdp_patchpoint)] = sdp;
+	}
+
+	if (probes_skipped != 0)
+		pr_warn("sdt: Failed to provide %d probes in %s (out of memory)\n",
+			probes_skipped, mp->name);
+}
+
+int sdt_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	sdt_probe_t	*sdp = parg;
+	sdt_probe_t	*curr;
+
+	/*
+	 * Ensure that we have a reference to the module.
+	 */
+	if (!try_module_get(sdp->sdp_module))
+		return -EAGAIN;
+
+	/*
+	 * If at least one other enabled probe exists for this module, drop the
+	 * reference we took above, because we only need one to prevent the
+	 * module from being unloaded.
+	 */
+	PDATA(sdp->sdp_module)->enabled_cnt++;
+	if (PDATA(sdp->sdp_module)->enabled_cnt > 1)
+		module_put(sdp->sdp_module);
+
+	for (curr = sdp; curr != NULL; curr = curr->sdp_next)
+		sdt_enable_arch(curr, id, arg);
+
+	return 0;
+}
+
+void sdt_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	sdt_probe_t	*sdp = parg;
+	sdt_probe_t	*curr;
+
+	for (curr = sdp; curr != NULL; curr = curr->sdp_next)
+		sdt_disable_arch(curr, id, arg);
+
+	/*
+	 * If we are disabling a probe, we know it was enabled, and therefore
+	 * we know that we have a reference on the module to prevent it from
+	 * being unloaded.  If we disable the last probe on the module, we can
+	 * drop the reference.
+	 */
+	PDATA(sdp->sdp_module)->enabled_cnt--;
+	if (PDATA(sdp->sdp_module)->enabled_cnt == 0)
+		module_put(sdp->sdp_module);
+}
+
+void sdt_getargdesc(void *arg, dtrace_id_t id, void *parg,
+		    dtrace_argdesc_t *desc)
+{
+	sdt_probe_t	*sdp = parg;
+
+	desc->dtargd_native[0] = '\0';
+	desc->dtargd_xlate[0] = '\0';
+
+	while ((sdp->sdp_ptype == SDTPT_IS_ENABLED) &&
+	       (sdp->sdp_next != NULL))
+		sdp = sdp->sdp_next;
+
+	if (sdp->sdp_nargdesc <= desc->dtargd_ndx) {
+		desc->dtargd_ndx = DTRACE_ARGNONE;
+		return;
+	}
+
+	if (sdp->sdp_argdesc[desc->dtargd_ndx].sda_native != NULL)
+		strlcpy(desc->dtargd_native,
+			sdp->sdp_argdesc[desc->dtargd_ndx].sda_native,
+			sizeof(desc->dtargd_native));
+
+	if (sdp->sdp_argdesc[desc->dtargd_ndx].sda_xlate != NULL)
+		strlcpy(desc->dtargd_xlate,
+			sdp->sdp_argdesc[desc->dtargd_ndx].sda_xlate,
+			sizeof(desc->dtargd_xlate));
+
+	desc->dtargd_mapping = sdp->sdp_argdesc[desc->dtargd_ndx].sda_mapping;
+}
+
+void sdt_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+	sdt_probe_t	*sdp = parg;
+
+	PDATA(sdp->sdp_module)->sdt_probe_cnt--;
+
+	while (sdp != NULL) {
+		sdt_probe_t	*old = sdp, *last, *hash;
+		int		ndx;
+		size_t		i;
+
+		ndx = SDT_ADDR2NDX(sdp->sdp_patchpoint);
+		last = NULL;
+		hash = sdt_probetab[ndx];
+
+		while (hash != sdp) {
+			ASSERT(hash != NULL);
+			last = hash;
+			hash = hash->sdp_hashnext;
+		}
+
+		if (last != NULL)
+			last->sdp_hashnext = sdp->sdp_hashnext;
+		else
+			sdt_probetab[ndx] = sdp->sdp_hashnext;
+
+		for (i = 0; i < sdp->sdp_nargdesc; i++) {
+			kfree(sdp->sdp_argdesc[i].sda_native);
+			kfree(sdp->sdp_argdesc[i].sda_xlate);
+		}
+		kfree(sdp->sdp_argdesc);
+		kfree(sdp->sdp_name);
+		sdp = sdp->sdp_next;
+		kfree(old);
+	}
+}
+
+static long sdt_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int sdt_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int sdt_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations sdt_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = sdt_ioctl,
+        .open   = sdt_open,
+        .release = sdt_close,
+};
+
+static struct miscdevice sdt_dev = {
+	.minor = DT_DEV_SDT_MINOR,
+	.name = "sdt",
+	.nodename = "dtrace/provider/sdt",
+	.fops = &sdt_fops,
+};
+
+int sdt_dev_init(void)
+{
+	int ret = 0;
+
+	ret = misc_register(&sdt_dev);
+	if (ret) {
+		pr_err("%s: Can't register misc device %d\n",
+		       sdt_dev.name, sdt_dev.minor);
+		return ret;
+	}
+
+	if (sdt_probetab_size == 0)
+		sdt_probetab_size = SDT_PROBETAB_SIZE;
+
+	sdt_probetab_mask = sdt_probetab_size - 1;
+	sdt_probetab = vzalloc(sdt_probetab_size * sizeof(sdt_probe_t *));
+	if (sdt_probetab == NULL)
+		return -ENOMEM;
+
+	sdt_dev_init_arch();
+
+	return ret;
+}
+
+void sdt_dev_exit(void)
+{
+	sdt_dev_exit_arch();
+
+	vfree(sdt_probetab);
+
+	misc_deregister(&sdt_dev);
+}
diff --git a/dtrace/sdt_impl.h b/dtrace/sdt_impl.h
new file mode 100644
index 000000000000..e58c2e767d53
--- /dev/null
+++ b/dtrace/sdt_impl.h
@@ -0,0 +1,85 @@
+/*
+ * Dynamic Tracing for Linux - Statically Defined Tracing provider
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SDT_IMPL_H_
+#define _SDT_IMPL_H_
+
+#include <linux/sdt.h>
+#include <asm/dtrace_arch.h>
+#include <dtrace/sdt_arch.h>
+
+extern struct module		*dtrace_kmod;
+
+struct sdt_argdesc;
+
+typedef enum fasttrap_probe_type {
+        SDTPT_NONE = 0,
+        SDTPT_OFFSETS,
+        SDTPT_IS_ENABLED
+} sdt_probe_type_t;
+
+typedef struct sdt_probe {
+	dtrace_mprovider_t	*sdp_provider;	/* provider */
+	char			*sdp_name;	/* name of probe */
+	int			sdp_namelen;	/* length of allocated name */
+	dtrace_id_t		sdp_id;		/* probe ID */
+	struct module		*sdp_module;	/* modctl for module */
+	int			sdp_loadcnt;	/* load count for module */
+	int			sdp_primary;	/* non-zero if primary mod */
+	sdt_probe_type_t	sdp_ptype;	/* probe type */
+	asm_instr_t		*sdp_patchpoint;/* patch point */
+	asm_instr_t		sdp_patchval;	/* instruction to patch */
+	asm_instr_t		sdp_savedval;	/* saved instruction value */
+	struct sdt_argdesc	*sdp_argdesc;	/* arguments for this probe */
+	size_t			sdp_nargdesc;	/* number of arguments */
+	struct sdt_probe	*sdp_next;	/* next probe */
+	struct sdt_probe	*sdp_hashnext;	/* next on hash */
+} sdt_probe_t;
+
+typedef struct sdt_argdesc {
+	int			sda_mapping;
+	char			*sda_native;
+	char			*sda_xlate;
+} sdt_argdesc_t;
+
+extern dtrace_mprovider_t	sdt_providers[];
+extern sdt_probe_t		**sdt_probetab;
+extern int			sdt_probetab_size;
+extern int			sdt_probetab_mask;
+
+#define SDT_ADDR2NDX(addr)	((((uintptr_t)(addr)) >> 4) & \
+					sdt_probetab_mask)
+
+extern void sdt_provide_probe_arch(sdt_probe_t *, struct module *, int);
+extern int sdt_provide_module_arch(void *, struct module *);
+extern void sdt_enable_arch(sdt_probe_t *, dtrace_id_t, void *);
+extern void sdt_disable_arch(sdt_probe_t *, dtrace_id_t, void *);
+
+extern void sdt_provide_module(void *, struct module *);
+extern void sdt_destroy_module(void *, struct module *);
+extern int sdt_enable(void *, dtrace_id_t, void *);
+extern void sdt_disable(void *, dtrace_id_t, void *);
+extern void sdt_getargdesc(void *, dtrace_id_t, void *, dtrace_argdesc_t *);
+extern uint64_t sdt_getarg(void *, dtrace_id_t, void *, int, int);
+extern void sdt_destroy(void *, dtrace_id_t, void *);
+
+extern int sdt_dev_init(void);
+extern void sdt_dev_exit(void);
+
+extern int sdt_dev_init_arch(void);
+extern void sdt_dev_exit_arch(void);
+
+#endif /* _SDT_IMPL_H_ */
diff --git a/dtrace/sdt_mod.c b/dtrace/sdt_mod.c
new file mode 100644
index 000000000000..ff3f09f4047d
--- /dev/null
+++ b/dtrace/sdt_mod.c
@@ -0,0 +1,153 @@
+/*
+ * FILE:	sdt_mod.c
+ * DESCRIPTION:	DTrace - SDT provider kernel module
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "sdt_impl.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Profile Interrupt Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static dtrace_pattr_t vtrace_attr = {
+{ DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t info_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t fc_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t fpu_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_CPU },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t fsinfo_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t stab_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t sdt_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t xpv_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_PLATFORM },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_PLATFORM },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_PLATFORM },
+};
+
+static dtrace_pattr_t iscsi_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pattr_t perf_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pops_t sdt_pops = {
+	.dtps_provide = NULL,
+	.dtps_provide_module = sdt_provide_module,
+	.dtps_destroy_module = sdt_destroy_module,
+	.dtps_enable = sdt_enable,
+	.dtps_disable = sdt_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = sdt_getargdesc,
+#ifdef CONFIG_X86_64
+	.dtps_getargval = sdt_getarg,
+#else
+	.dtps_getargval = NULL,
+#endif
+	.dtps_usermode = NULL,
+	.dtps_destroy = sdt_destroy,
+};
+
+dtrace_mprovider_t sdt_providers[] = {
+  { "vtrace", "__vtrace_", &vtrace_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "sysinfo", "__cpu_sysinfo_", &info_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "vminfo", "__cpu_vminfo_", &info_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "fpuinfo", "__fpuinfo_", &fpu_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "sched", "__sched_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "proc", "__proc_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "io", "__io_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "ip", "__ip_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "lockstat", "__lockstat_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "tcp", "__tcp_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "udp", "__udp_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "mib", "__mib_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "fsinfo", "__fsinfo_", &fsinfo_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "iscsi", "__iscsi_", &iscsi_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "nfsv3", "__nfsv3_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "nfsv4", "__nfsv4_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "xpv", "__xpv_", &xpv_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "fc", "__fc_", &fc_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "srp", "__srp_", &fc_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "sysevent", "__sysevent_", &stab_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "perf", "__perf_", &perf_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { "sdt", NULL, &sdt_attr, DTRACE_PRIV_KERNEL, &sdt_pops, 0 },
+  { NULL }
+};
+
+DT_MULTI_PROVIDER_MODULE(sdt, sdt_providers)
diff --git a/dtrace/systrace.h b/dtrace/systrace.h
new file mode 100644
index 000000000000..111009b2cbcf
--- /dev/null
+++ b/dtrace/systrace.h
@@ -0,0 +1,32 @@
+/*
+ * Dynamic Tracing for Linux - syscall tracing provider
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SYSTRACE_H_
+#define _SYSTRACE_H_
+
+#include "dtrace.h"
+
+extern void systrace_provide(void *, const dtrace_probedesc_t *);
+extern int systrace_enable(void *arg, dtrace_id_t, void *);
+extern void systrace_disable(void *arg, dtrace_id_t, void *);
+extern void systrace_destroy(void *, dtrace_id_t, void *);
+
+extern dtrace_provider_id_t	syscall_id;
+
+extern int syscall_dev_init(void);
+extern void syscall_dev_exit(void);
+
+#endif /* _SYSTRACE_H_ */
diff --git a/dtrace/systrace_dev.c b/dtrace/systrace_dev.c
new file mode 100644
index 000000000000..1ebcf938696f
--- /dev/null
+++ b/dtrace/systrace_dev.c
@@ -0,0 +1,219 @@
+/*
+ * FILE:	systrace_dev.c
+ * DESCRIPTION:	DTrace - systrace provider device driver
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_syscall.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <asm/unistd.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "systrace.h"
+
+#define SYSTRACE_ARTIFICIAL_FRAMES	1
+
+#define SYSTRACE_SHIFT			16
+#define SYSTRACE_ENTRY(id)		((1 << SYSTRACE_SHIFT) | (id))
+#define SYSTRACE_RETURN(id)		(id)
+#define SYSTRACE_SYSNUM(x)		((int)(x) & ((1 << SYSTRACE_SHIFT) - 1))
+#define SYSTRACE_ISENTRY(x)		((int)(x) >> SYSTRACE_SHIFT)
+
+#if ((1 << SYSTRACE_SHIFT) <= NR_syscalls)
+# error 1 << SYSTRACE_SHIFT must exceed number of system calls
+#endif
+
+static systrace_info_t	*systrace_info = NULL;
+
+void systrace_provide(void *arg, const dtrace_probedesc_t *desc)
+{
+	int	failed_count = 0;
+	int	i;
+
+	ASSERT(systrace_info != NULL);
+
+	if (desc != NULL)
+		return;
+
+	for (i = 0; i < NR_syscalls; i++) {
+		const char		*nm = systrace_info->sysent[i].name;
+		dtrace_id_t		id;
+		int			sz;
+
+		if (nm == NULL)
+			continue;
+
+		if (systrace_info->sysent[i].stsy_underlying == NULL)
+			continue;
+
+		sz = strlen(nm);
+		if (sz > 4 && memcmp(nm, "sys_", 4) == 0)
+			nm += 4;
+		else if (sz > 5 && memcmp(nm, "stub_", 5) == 0)
+			nm += 5;
+
+		id = dtrace_probe_lookup(syscall_id, dtrace_kmod->name, nm, "entry");
+		if (id == DTRACE_IDNONE) {
+			id = dtrace_probe_create(syscall_id, dtrace_kmod->name, nm,
+						"entry", SYSTRACE_ARTIFICIAL_FRAMES,
+						(void *)((uintptr_t)SYSTRACE_ENTRY(i)));
+			if (id == DTRACE_IDNONE)
+				failed_count++;
+
+			systrace_info->sysent[i].stsy_entry = DTRACE_IDNONE;
+		}
+
+		id = dtrace_probe_lookup(syscall_id, dtrace_kmod->name, nm, "return");
+		if (id == DTRACE_IDNONE) {
+			id = dtrace_probe_create(syscall_id, dtrace_kmod->name, nm,
+						 "return", SYSTRACE_ARTIFICIAL_FRAMES,
+						 (void *)((uintptr_t)SYSTRACE_RETURN(i)));
+			if (id == DTRACE_IDNONE)
+				failed_count++;
+
+			systrace_info->sysent[i].stsy_return = DTRACE_IDNONE;
+		}
+	}
+
+	if (failed_count > 0)
+		pr_warn("systrace: Failed to provide %d probes (out of memory)\n", failed_count);
+}
+
+static dt_sys_call_t get_intercept(int sysnum)
+{
+	switch (sysnum) {
+	default:
+		return systrace_info->syscall;
+#define DTRACE_SYSCALL_STUB(t, n) \
+	case __NR_##n: \
+		return systrace_info->stubs[SCE_##t];
+#include <asm/dtrace_syscall.h>
+#undef DTRACE_SYSCALL_STUB
+	}
+}
+
+int systrace_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	int			sysnum = SYSTRACE_SYSNUM((uintptr_t)parg);
+	dtrace_syscalls_t	*sc = &systrace_info->sysent[sysnum];
+	int			enabled = sc->stsy_entry != DTRACE_IDNONE ||
+					  sc->stsy_return != DTRACE_IDNONE;
+	dt_sys_call_t		intercept = get_intercept(sysnum);
+
+	if (!enabled) {
+		if (cmpxchg(sc->stsy_tblent, sc->stsy_underlying,
+			    intercept) != sc->stsy_underlying)
+			return 1;
+	} else
+		ASSERT(*sc->stsy_tblent == intercept);
+
+	if (SYSTRACE_ISENTRY((uintptr_t)parg))
+		sc->stsy_entry = id;
+	else
+		sc->stsy_return = id;
+
+	return 0;
+}
+
+void systrace_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	int			sysnum = SYSTRACE_SYSNUM((uintptr_t)parg);
+	dtrace_syscalls_t	*sc = &systrace_info->sysent[sysnum];
+	int			enabled =
+				(sc->stsy_entry != DTRACE_IDNONE ? 1 : 0) +
+				(sc->stsy_return != DTRACE_IDNONE ? 1 : 0);
+	dt_sys_call_t		intercept = get_intercept(sysnum);
+
+	/*
+	 * Every syscall can have 2 probes associated with it.  We need to keep
+	 * the interceptor in place until the last probe is getting disabled.
+	 */
+	if (enabled == 1)
+		(void)cmpxchg(sc->stsy_tblent, intercept, sc->stsy_underlying);
+
+	if (SYSTRACE_ISENTRY((uintptr_t)parg))
+		sc->stsy_entry = DTRACE_IDNONE;
+	else
+		sc->stsy_return = DTRACE_IDNONE;
+}
+
+void systrace_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+	int	sysnum = SYSTRACE_SYSNUM((uintptr_t)parg);
+
+	/*
+	 * Nothing to be done here - just ensure our probe has been disabled.
+	 */
+	if (SYSTRACE_ISENTRY((uintptr_t)parg))
+		ASSERT(systrace_info->sysent[sysnum].stsy_entry ==
+		       DTRACE_IDNONE);
+	else
+		ASSERT(systrace_info->sysent[sysnum].stsy_return ==
+		       DTRACE_IDNONE);
+}
+
+static long systrace_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EAGAIN;
+}
+
+static int systrace_open(struct inode *inode, struct file *file)
+{
+	return -EAGAIN;
+}
+
+static int systrace_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations systrace_fops = {
+	.owner  = THIS_MODULE,
+        .unlocked_ioctl = systrace_ioctl,
+        .open   = systrace_open,
+        .release = systrace_close,
+};
+
+static struct miscdevice systrace_dev = {
+	.minor = DT_DEV_SYSTRACE_MINOR,
+	.name = "systrace",
+	.nodename = "dtrace/provider/systrace",
+	.fops = &systrace_fops,
+};
+
+int syscall_dev_init(void)
+{
+	int	ret = 0;
+
+	systrace_info = dtrace_syscalls_init();
+
+	ret = misc_register(&systrace_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       systrace_dev.name, systrace_dev.minor);
+
+	*(systrace_info->probep) = (dtrace_systrace_probe_t)dtrace_probe;
+
+	return ret;
+}
+
+void syscall_dev_exit(void)
+{
+	*(systrace_info->probep) = systrace_info->stub;
+
+	misc_deregister(&systrace_dev);
+}
diff --git a/dtrace/systrace_mod.c b/dtrace/systrace_mod.c
new file mode 100644
index 000000000000..25c7975e4b97
--- /dev/null
+++ b/dtrace/systrace_mod.c
@@ -0,0 +1,51 @@
+/*
+ * FILE:	systrace_mod.c
+ * DESCRIPTION:	DTrace - systrace provider kernel module
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "systrace.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("System Call Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static const dtrace_pattr_t syscall_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static dtrace_pops_t syscall_pops = {
+	.dtps_provide = systrace_provide,
+	.dtps_provide_module = NULL,
+	.dtps_destroy_module = NULL,
+	.dtps_enable = systrace_enable,
+	.dtps_disable = systrace_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = NULL,
+	.dtps_getargval = NULL,
+	.dtps_usermode = NULL,
+	.dtps_destroy = systrace_destroy
+};
+
+DT_PROVIDER_MODULE(syscall, DTRACE_PRIV_USER)
diff --git a/fs/Makefile b/fs/Makefile
index ef772f1eaff8..caf85cbacbb0 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_SIGNALFD)		+= signalfd.o
 obj-$(CONFIG_TIMERFD)		+= timerfd.o
 obj-$(CONFIG_EVENTFD)		+= eventfd.o
 obj-$(CONFIG_USERFAULTFD)	+= userfaultfd.o
+obj-$(CONFIG_WAITFD)		+= waitfd.o
 obj-$(CONFIG_AIO)               += aio.o
 obj-$(CONFIG_FS_DAX)		+= dax.o
 obj-$(CONFIG_FS_ENCRYPTION)	+= crypto/
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 2fabd19cdeea..9cf0945d5189 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -162,6 +162,9 @@ struct epitem {
 	/* Number of active wait queue attached to poll operations */
 	int nwait;
 
+	/* fd always raises this fixed event. */
+	unsigned long fixed_event;
+
 	/* List containing poll wait queues */
 	struct list_head pwqlist;
 
@@ -913,7 +916,7 @@ static int ep_read_events_proc(struct eventpoll *ep, struct list_head *head,
 }
 
 static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,
-				 poll_table *pt);
+				 poll_table *pt, unsigned long fixed_event);
 
 struct readyevents_arg {
 	struct eventpoll *ep;
@@ -1225,6 +1228,13 @@ static int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, v
 	if (!(epi->event.events & EPOLLEXCLUSIVE))
 		ewake = 1;
 
+	/*
+	 * If this fd type has a hardwired event which should override the key
+	 * (e.g. if it is waiting on a non-file waitqueue), jam it in here.
+	 */
+	if (epi->fixed_event)
+		key = (void *)epi->fixed_event;
+
 	if ((unsigned long)key & POLLFREE) {
 		/*
 		 * If we race with ep_remove_wait_queue() it can miss
@@ -1249,11 +1259,17 @@ static int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, v
  * target file wakeup lists.
  */
 static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,
-				 poll_table *pt)
+				 poll_table *pt, unsigned long fixed_event)
 {
 	struct epitem *epi = ep_item_from_epqueue(pt);
 	struct eppoll_entry *pwq;
 
+	if (fixed_event & !(epi->event.events & fixed_event))
+		return;
+
+	if (fixed_event)
+		epi->fixed_event = fixed_event;
+
 	if (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {
 		init_waitqueue_func_entry(&pwq->wait, ep_poll_callback);
 		pwq->whead = whead;
@@ -1452,6 +1468,7 @@ static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
 	ep_set_ffd(&epi->ffd, tfile, fd);
 	epi->event = *event;
 	epi->nwait = 0;
+	epi->fixed_event = 0;
 	epi->next = EP_UNACTIVE_PTR;
 	if (epi->event.events & EPOLLWAKEUP) {
 		error = ep_create_wakeup_source(epi);
@@ -2325,7 +2342,6 @@ static int __init eventpoll_init(void)
 	 * We can have many thousands of epitems, so prevent this from
 	 * using an extra cache line on 64-bit (and smaller) CPUs
 	 */
-	BUILD_BUG_ON(sizeof(void *) <= 8 && sizeof(struct epitem) > 128);
 
 	/* Allocates slab cache used to allocate "struct epitem" items */
 	epi_cache = kmem_cache_create("eventpoll_epi", sizeof(struct epitem),
diff --git a/fs/exec.c b/fs/exec.c
index acec119fcc31..34801d032752 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -62,6 +62,8 @@
 #include <linux/oom.h>
 #include <linux/compat.h>
 #include <linux/vmalloc.h>
+#include <linux/sdt.h>
+#include <linux/dtrace_os.h>
 
 #include <linux/uaccess.h>
 #include <asm/mmu_context.h>
@@ -1739,6 +1741,7 @@ static int do_execveat_common(int fd, struct filename *filename,
 	current->in_execve = 1;
 
 	file = do_open_execat(fd, filename, flags);
+	DTRACE_PROC(exec, char *, filename->name);
 	retval = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out_unmark;
@@ -1805,6 +1808,11 @@ static int do_execveat_common(int fd, struct filename *filename,
 		goto out;
 
 	/* execve succeeded */
+#ifdef CONFIG_DTRACE
+	dtrace_task_cleanup(current);	/* get rid of probes from old ... */
+	dtrace_task_reinit(current);	/* ... be ready for probes from new */
+	dtrace_psinfo_alloc(current);	/* install new psinfo object */
+#endif
 	current->fs->in_exec = 0;
 	current->in_execve = 0;
 	membarrier_execve(current);
@@ -1815,6 +1823,8 @@ static int do_execveat_common(int fd, struct filename *filename,
 	putname(filename);
 	if (displaced)
 		put_files_struct(displaced);
+
+	DTRACE_PROC(exec__success);
 	return retval;
 
 out:
@@ -1836,6 +1846,7 @@ static int do_execveat_common(int fd, struct filename *filename,
 		reset_files_struct(displaced);
 out_ret:
 	putname(filename);
+	DTRACE_PROC(exec__failure, int, retval);
 	return retval;
 }
 
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index f9a4a5524bd5..6d5fb63b10d3 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -9,6 +9,7 @@
 #include <linux/crc32.h>
 #include <linux/nfs_page.h>
 #include <linux/wait_bit.h>
+#include <linux/sdt.h>
 
 #define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
 
@@ -776,3 +777,16 @@ static inline void nfs_context_set_write_error(struct nfs_open_context *ctx, int
 	smp_wmb();
 	set_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);
 }
+
+#define	DTRACE_IO_NFS(name, rw, size, inode)			\
+	if (DTRACE_IO_ENABLED(name)) {				\
+		struct bio bio __maybe_unused = {		\
+			.bi_opf = rw,				\
+			.bi_flags = (1 << BIO_USER_MAPPED),	\
+			.bi_iter.bi_size = size,		\
+			.bi_iter.bi_sector = NFS_FILEID(inode),	\
+		};						\
+		DTRACE_IO(name, struct bio * : (bufinfo_t *,	\
+			  devinfo_t *), &bio,			\
+			  struct file * : fileinfo_t *, NULL);	\
+}
diff --git a/fs/nfs/read.c b/fs/nfs/read.c
index 48d7277c60a9..79387e139bd5 100644
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@ -199,6 +199,8 @@ static void nfs_initiate_read(struct nfs_pgio_header *hdr,
 	struct inode *inode = hdr->inode;
 	int swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;
 
+	DTRACE_IO_NFS(start, REQ_OP_READ, hdr->args.count, hdr->inode);
+
 	task_setup_data->flags |= swap_flags;
 	rpc_ops->read_setup(hdr, msg);
 	trace_nfs_initiate_read(inode, hdr->io_start, hdr->good_bytes);
@@ -230,6 +232,7 @@ static int nfs_readpage_done(struct rpc_task *task,
 			     struct inode *inode)
 {
 	int status = NFS_PROTO(inode)->read_done(task, hdr);
+	DTRACE_IO_NFS(done, REQ_OP_READ, hdr->res.count, hdr->inode);
 	if (status != 0)
 		return status;
 
diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 76da415be39a..6741299286a6 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -1379,6 +1379,8 @@ static void nfs_initiate_write(struct nfs_pgio_header *hdr,
 	trace_nfs_initiate_write(hdr->inode, hdr->io_start, hdr->good_bytes,
 				 hdr->args.stable);
 
+	DTRACE_IO_NFS(start, REQ_OP_WRITE, hdr->args.count, hdr->inode);
+
 	nfs4_state_protect_write(NFS_SERVER(hdr->inode)->nfs_client,
 				 &task_setup_data->rpc_client, msg, hdr);
 }
@@ -1533,6 +1535,7 @@ static int nfs_writeback_done(struct rpc_task *task,
 	 * depend on tighter cache coherency when writing.
 	 */
 	status = NFS_PROTO(inode)->write_done(task, hdr);
+	DTRACE_IO_NFS(done, REQ_OP_WRITE, hdr->res.count, hdr->inode);
 	if (status != 0)
 		return status;
 
diff --git a/fs/select.c b/fs/select.c
index 063067e606ca..c2b1d263906c 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -116,7 +116,7 @@ struct poll_table_page {
  * poll table.
  */
 static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,
-		       poll_table *p);
+		       poll_table *p, unsigned long fixed_event);
 
 void poll_initwait(struct poll_wqueues *pwq)
 {
@@ -212,22 +212,38 @@ static int pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key
 	struct poll_table_entry *entry;
 
 	entry = container_of(wait, struct poll_table_entry, wait);
+
+	/*
+	 * If this fd type has a hardwired key which should override the key
+	 * (e.g. if it is waiting on a non-file waitqueue), jam it in here.
+	 */
+	if (entry->fixed_key)
+		key = (void *)entry->fixed_key;
+
 	if (key && !((unsigned long)key & entry->key))
 		return 0;
+
 	return __pollwake(wait, mode, sync, key);
 }
 
 /* Add a new entry */
 static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,
-				poll_table *p)
+				poll_table *p, unsigned long fixed_event)
 {
 	struct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);
-	struct poll_table_entry *entry = poll_get_entry(pwq);
+	struct poll_table_entry *entry;
+
+	if (fixed_event && !(p->_key & fixed_event))
+		return;
+
+	entry = poll_get_entry(pwq);
 	if (!entry)
 		return;
+
 	entry->filp = get_file(filp);
 	entry->wait_address = wait_address;
-	entry->key = p->_key;
+ 	entry->key = p->_key;
+	entry->fixed_key = fixed_event;
 	init_waitqueue_func_entry(&entry->wait, pollwake);
 	entry->wait.private = pwq;
 	add_wait_queue(wait_address, &entry->wait);
diff --git a/fs/waitfd.c b/fs/waitfd.c
new file mode 100644
index 000000000000..0d3defd544fc
--- /dev/null
+++ b/fs/waitfd.c
@@ -0,0 +1,128 @@
+/*
+ *  fs/waitfd.c
+ *
+ *  Copyright (C) 2008  Red Hat, Casey Dahlin <cdahlin@redhat.com>
+ *
+ *  Largely derived from fs/signalfd.c
+ */
+
+#include <linux/file.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/list.h>
+#include <linux/anon_inodes.h>
+#include <linux/syscalls.h>
+
+long kernel_wait4(pid_t upid, int __user *stat_addr,
+	      int options, struct rusage __user *ru);
+
+struct waitfd_ctx {
+	int	options;
+	pid_t	upid;
+};
+
+static int waitfd_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
+static unsigned int waitfd_poll(struct file *file, poll_table *wait)
+{
+	struct waitfd_ctx *ctx = file->private_data;
+	long value;
+
+	poll_wait_fixed(file, &current->signal->wait_chldexit, wait,
+		POLLIN);
+
+	value = kernel_wait4(ctx->upid, NULL, ctx->options | WNOHANG | WNOWAIT,
+			 NULL);
+	if (value > 0 || value == -ECHILD)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+/*
+ * Returns a multiple of the size of a stat_addr, or a negative error code. The
+ * "count" parameter must be at least sizeof(int).
+ */
+static ssize_t waitfd_read(struct file *file, char __user *buf, size_t count,
+			     loff_t *ppos)
+{
+	struct waitfd_ctx *ctx = file->private_data;
+	int __user *stat_addr = (int *)buf;
+	int flags = ctx->options;
+	ssize_t ret, total = 0;
+
+	count /= sizeof(int);
+	if (!count)
+		return -EINVAL;
+
+	if (file->f_flags & O_NONBLOCK)
+		flags |= WNOHANG;
+
+	do {
+		ret = kernel_wait4(ctx->upid, stat_addr, flags, NULL);
+		if (ret == 0)
+			ret = -EAGAIN;
+		if (ret == -ECHILD)
+			ret = 0;
+		if (ret <= 0)
+			break;
+
+		stat_addr++;
+		total += sizeof(int);
+	} while (--count);
+
+	return total ? total : ret;
+}
+
+static const struct file_operations waitfd_fops = {
+	.release	= waitfd_release,
+	.poll		= waitfd_poll,
+	.read		= waitfd_read,
+	.llseek		= noop_llseek,
+};
+ 
+SYSCALL_DEFINE4(waitfd, int __maybe_unused, which, pid_t, upid, int, options,
+		int __maybe_unused, flags)
+{
+	int ufd;
+	struct waitfd_ctx *ctx;
+
+	/*
+	 * Options validation from kernel_wait4(), minus WNOWAIT, which is only used
+	 * by our polling implementation.  If WEXITED or WSTOPPED are provided,
+	 * silently remove them (for backward compatibility with older callers).
+	 */
+	options &= ~(WEXITED | WSTOPPED);
+	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
+			__WNOTHREAD|__WCLONE|__WALL))
+		return -EINVAL;
+
+	ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->options = options;
+	ctx->upid = upid;
+
+	ufd = anon_inode_getfd("[waitfd]", &waitfd_fops, ctx,
+			       O_RDWR | flags | ((options & WNOHANG) ?
+						 O_NONBLOCK | 0 : 0));
+	/*
+	 * Use the fd's nonblocking state from now on, since that can change.
+	 */
+	ctx->options &= ~WNOHANG;
+
+	if (ufd < 0)
+		kfree(ctx);
+
+	return ufd;
+}
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 16f93d7356b7..391c9f0235cd 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -58,6 +58,20 @@ static kmem_zone_t *xfs_buf_zone;
 #define xb_to_gfp(flags) \
 	((((flags) & XBF_READ_AHEAD) ? __GFP_NORETRY : GFP_NOFS) | __GFP_NOWARN)
 
+#define	DTRACE_IO_XFS_WAIT(name, bp, is_write)				\
+	if (DTRACE_IO_ENABLED(name)) {					\
+		struct bio bio __maybe_unused = {			\
+			.bi_iter.bi_sector = (bp)->b_bn,		\
+			.bi_iter.bi_size = (bp)->b_length,		\
+			.bi_opf = is_write ?				\
+				REQ_OP_WRITE : REQ_OP_READ,		\
+			.bi_disk = (bp)->b_target->bt_bdev->bd_disk,	\
+			.bi_partno = (bp)->b_target->bt_bdev->bd_partno,\
+		};							\
+		DTRACE_IO(name, struct bio * : (bufinfo_t *,		\
+			  devinfo_t *), &bio,				\
+			  struct file * : fileinfo_t *, NULL);		\
+	}
 
 static inline int
 xfs_buf_is_vmapped(
@@ -1484,6 +1498,7 @@ xfs_buf_submit_wait(
 	struct xfs_buf	*bp)
 {
 	int		error;
+	bool		is_write = bp->b_flags & XBF_WRITE;
 
 	trace_xfs_buf_submit_wait(bp, _RET_IP_);
 
@@ -1527,7 +1542,9 @@ xfs_buf_submit_wait(
 
 	/* wait for completion before gathering the error from the buffer */
 	trace_xfs_buf_iowait(bp, _RET_IP_);
+	DTRACE_IO_XFS_WAIT(wait__start, bp, is_write);
 	wait_for_completion(&bp->b_iowait);
+	DTRACE_IO_XFS_WAIT(wait__done, bp, is_write);
 	trace_xfs_buf_iowait_done(bp, _RET_IP_);
 	error = bp->b_error;
 
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index 353f52fdc35e..e41a97953e32 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -136,6 +136,20 @@
 #define KPROBE_BLACKLIST()
 #endif
 
+#ifdef CONFIG_DTRACE
+#define DTRACE_SDT_NAMES()	. = ALIGN(8);					\
+				VMLINUX_SYMBOL(__start_dtrace_sdt_names) = .;	\
+				*(_dtrace_sdt_names)				\
+				VMLINUX_SYMBOL(__stop_dtrace_sdt_names) = .;
+#define DTRACE_SDT_ARGS()	. = ALIGN(8);					\
+				VMLINUX_SYMBOL(__start_dtrace_sdt_args) = .;	\
+				*(_dtrace_sdt_args)				\
+				VMLINUX_SYMBOL(__stop_dtrace_sdt_args) = .;
+#else
+#define DTRACE_SDT_NAMES()
+#define DTRACE_SDT_ARGS()
+#endif
+
 #ifdef CONFIG_EVENT_TRACING
 #define FTRACE_EVENTS()	. = ALIGN(8);					\
 			VMLINUX_SYMBOL(__start_ftrace_events) = .;	\
@@ -561,6 +575,8 @@
 	FTRACE_EVENTS()							\
 	TRACE_SYSCALLS()						\
 	KPROBE_BLACKLIST()						\
+	DTRACE_SDT_NAMES()						\
+	DTRACE_SDT_ARGS()						\
 	MEM_DISCARD(init.rodata)					\
 	CLK_OF_TABLES()							\
 	RESERVEDMEM_OF_TABLES()						\
diff --git a/include/dtrace/dtrace_impl.h b/include/dtrace/dtrace_impl.h
new file mode 100644
index 000000000000..d61b6537d96e
--- /dev/null
+++ b/include/dtrace/dtrace_impl.h
@@ -0,0 +1,1206 @@
+/*
+ * Dynamic Tracing for Linux - Implementation
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_IMPL_H
+#define _LINUX_DTRACE_IMPL_H
+
+#include <linux/cyclic.h>
+#include <linux/idr.h>
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/dif.h>
+#include <linux/dtrace/difo_defines.h>
+#include <linux/dtrace/metadesc.h>
+#include <linux/dtrace/stability.h>
+#include <linux/dtrace/helpers.h>
+#include <dtrace/types.h>
+#include <dtrace/provider.h>
+#include <dtrace/dtrace_impl_defines.h>
+
+typedef struct dtrace_provider {
+	dtrace_pattr_t dtpv_attr;
+	dtrace_ppriv_t dtpv_priv;
+	dtrace_pops_t dtpv_pops;
+	char *dtpv_name;
+	void *dtpv_arg;
+	uint_t dtpv_defunct;
+	struct dtrace_provider *dtpv_next;
+} dtrace_provider_t;
+
+typedef struct dtrace_predicate {
+	struct dtrace_difo *dtp_difo;
+	dtrace_cacheid_t dtp_cacheid;
+	int dtp_refcnt;
+} dtrace_predicate_t;
+
+typedef struct dtrace_statvar {
+	uint64_t dtsv_data;
+	size_t dtsv_size;
+	int dtsv_refcnt;
+	dtrace_difv_t dtsv_var;
+} dtrace_statvar_t;
+
+typedef struct dtrace_action {
+	dtrace_actkind_t dta_kind;
+	uint16_t dta_intuple;
+	uint32_t dta_refcnt;
+	dtrace_difo_t *dta_difo;
+	dtrace_recdesc_t dta_rec;
+	struct dtrace_action *dta_prev;
+	struct dtrace_action *dta_next;
+} dtrace_action_t;
+
+struct dtrace_ecb;
+typedef struct dtrace_ecb	dtrace_ecb_t;
+
+typedef struct dtrace_probe {
+	dtrace_id_t dtpr_id;
+	dtrace_ecb_t *dtpr_ecb;
+	dtrace_ecb_t *dtpr_ecb_last;
+	void *dtpr_arg;
+	dtrace_cacheid_t dtpr_predcache;
+	int dtpr_aframes;
+	dtrace_provider_t *dtpr_provider;
+	char *dtpr_mod;
+	char *dtpr_func;
+	char *dtpr_name;
+	struct dtrace_probe *dtpr_nextmod;
+	struct dtrace_probe *dtpr_prevmod;
+	struct dtrace_probe *dtpr_nextfunc;
+	struct dtrace_probe *dtpr_prevfunc;
+	struct dtrace_probe *dtpr_nextname;
+	struct dtrace_probe *dtpr_prevname;
+	dtrace_genid_t dtpr_gen;
+} dtrace_probe_t;
+
+struct dtrace_state;
+typedef struct dtrace_state	dtrace_state_t;
+
+struct dtrace_ecb {
+	dtrace_epid_t dte_epid;
+	uint32_t dte_alignment;
+	size_t dte_needed;
+	size_t dte_size;
+	dtrace_predicate_t *dte_predicate;
+	dtrace_action_t *dte_action;
+	struct dtrace_ecb *dte_next;
+	dtrace_state_t *dte_state;
+	uint32_t dte_cond;
+	dtrace_probe_t *dte_probe;
+	dtrace_action_t *dte_action_last;
+	uint64_t dte_uarg;
+};
+
+typedef struct dtrace_key {
+	uint64_t dttk_value;
+	uint64_t dttk_size;
+} dtrace_key_t;
+
+typedef struct dtrace_tuple {
+	uint32_t dtt_nkeys;
+	uint32_t dtt_pad;
+	dtrace_key_t dtt_key[1];
+} dtrace_tuple_t;
+
+typedef struct dtrace_dynvar {
+	uint64_t dtdv_hashval;
+	struct dtrace_dynvar *dtdv_next;
+	void *dtdv_data;
+	dtrace_tuple_t dtdv_tuple;
+} dtrace_dynvar_t;
+
+typedef struct dtrace_dstate_percpu {
+	dtrace_dynvar_t *dtdsc_free;
+	dtrace_dynvar_t *dtdsc_dirty;
+	dtrace_dynvar_t *dtdsc_rinsing;
+	dtrace_dynvar_t *dtdsc_clean;
+	uint64_t dtdsc_drops;
+	uint64_t dtdsc_dirty_drops;
+	uint64_t dtdsc_rinsing_drops;
+#ifdef CONFIG_64BIT
+	uint64_t dtdsc_pad;
+#else
+	uint64_t dtdsc_pad[2];
+#endif
+} dtrace_dstate_percpu_t;
+
+typedef struct dtrace_dynhash {
+	dtrace_dynvar_t *dtdh_chain;
+	uintptr_t dtdh_lock;
+#ifdef CONFIG_64BIT
+	uintptr_t dtdh_pad[6];
+#else
+	uintptr_t dtdh_pad[14];
+#endif
+} dtrace_dynhash_t;
+
+typedef struct dtrace_dstate {
+	void *dtds_base;
+	size_t dtds_size;
+	size_t dtds_hashsize;
+	size_t dtds_chunksize;
+	dtrace_dynhash_t *dtds_hash;
+	dtrace_dstate_state_t dtds_state;
+	dtrace_dstate_percpu_t *dtds_percpu;
+} dtrace_dstate_t;
+
+typedef struct dtrace_vstate {
+	dtrace_state_t *dtvs_state;
+	dtrace_statvar_t **dtvs_globals;
+	int dtvs_nglobals;
+	dtrace_difv_t *dtvs_tlocals;
+	int dtvs_ntlocals;
+	dtrace_statvar_t **dtvs_locals;
+	int dtvs_nlocals;
+	dtrace_dstate_t dtvs_dynvars;
+} dtrace_vstate_t;
+
+/*
+ * DTrace Machine State
+ *
+ * In the process of processing a fired probe, DTrace needs to track and/or
+ * cache some per-CPU state associated with that particular firing.  This is
+ * state that is always discarded after the probe firing has completed, and
+ * much of it is not specific to any DTrace consumer, remaining valid across
+ * all ECBs.  This state is tracked in the dtrace_mstate structure.
+ */
+
+typedef struct dtrace_mstate {
+	uintptr_t dtms_scratch_base;
+	uintptr_t dtms_scratch_ptr;
+	size_t dtms_scratch_size;
+	uint32_t dtms_present;
+	uint64_t dtms_arg[7];
+	dtrace_epid_t dtms_epid;
+	ktime_t dtms_timestamp;
+	int dtms_stackdepth;
+	int dtms_ustackdepth;
+	struct dtrace_probe *dtms_probe;
+	uintptr_t dtms_caller;
+	uint64_t dtms_ucaller;
+	int dtms_ipl;
+	int dtms_fltoffs;
+	uintptr_t dtms_strtok;
+	uint32_t dtms_access;
+	dtrace_difo_t *dtms_difo;
+} dtrace_mstate_t;
+
+typedef struct dtrace_buffer {
+	uint64_t dtb_offset;
+	uint64_t dtb_size;
+	uint32_t dtb_flags;
+	uint32_t dtb_drops;
+	caddr_t dtb_tomax;
+	caddr_t dtb_xamot;
+	uint32_t dtb_xamot_flags;
+	uint32_t dtb_xamot_drops;
+	uint64_t dtb_xamot_offset;
+	uint32_t dtb_errors;
+	uint32_t dtb_xamot_errors;
+#ifndef CONFIG_64BIT
+	uint64_t dtb_pad1;
+#endif
+} dtrace_buffer_t;
+
+typedef struct dtrace_speculation {
+	dtrace_speculation_state_t dtsp_state;
+	int dtsp_cleaning;
+	dtrace_buffer_t *dtsp_buffer;
+} dtrace_speculation_t;
+
+typedef struct dtrace_aggregation {
+	dtrace_action_t dtag_action;
+	dtrace_aggid_t dtag_id;
+	dtrace_ecb_t *dtag_ecb;
+	dtrace_action_t *dtag_first;
+	uint32_t dtag_base;
+	uint8_t dtag_hasarg;
+	uint64_t dtag_initial;
+	void (*dtag_aggregate)(uint64_t *, uint64_t, uint64_t);
+} dtrace_aggregation_t;
+
+typedef struct dtrace_cred {
+	const cred_t *dcr_cred;
+	uint8_t dcr_destructive;
+	uint8_t dcr_visible;
+	uint16_t dcr_action;
+} dtrace_cred_t;
+
+struct dtrace_state {
+	dev_t dts_dev;
+	int dts_necbs;
+	dtrace_ecb_t **dts_ecbs;
+	dtrace_epid_t dts_epid;
+	size_t dts_needed;
+	struct dtrace_state *dts_anon;
+	dtrace_activity_t dts_activity;
+	dtrace_vstate_t dts_vstate;
+	dtrace_buffer_t *dts_buffer;
+	dtrace_buffer_t *dts_aggbuffer;
+	dtrace_speculation_t *dts_speculations;
+	int dts_nspeculations;
+	struct idr dts_agg_idr;
+	int dts_naggs;
+	uint64_t dts_errors;
+	uint32_t dts_speculations_busy;
+	uint32_t dts_speculations_unavail;
+	uint32_t dts_stkstroverflows;
+	uint32_t dts_dblerrors;
+	uint32_t dts_reserve;
+	cyclic_id_t dts_cleaner;
+	cyclic_id_t dts_deadman;
+	ktime_t dts_laststatus;
+	ktime_t dts_alive;
+	char dts_speculates;
+	char dts_destructive;
+	int dts_nformats;
+	char **dts_formats;
+	dtrace_optval_t dts_options[DTRACEOPT_MAX];
+	dtrace_cred_t dts_cred;
+	size_t dts_nretained;
+};
+
+typedef struct dtrace_enabling {
+	dtrace_ecbdesc_t **dten_desc;
+	int dten_ndesc;
+	int dten_maxdesc;
+	dtrace_vstate_t *dten_vstate;
+	dtrace_genid_t dten_probegen;
+	dtrace_ecbdesc_t *dten_current;
+	int dten_error;
+	int dten_primed;
+	struct dtrace_enabling *dten_prev;
+	struct dtrace_enabling *dten_next;
+} dtrace_enabling_t;
+
+typedef int dtrace_probekey_f(const char *, const char *, int);
+
+typedef struct dtrace_probekey {
+	const char *dtpk_prov;
+	dtrace_probekey_f *dtpk_pmatch;
+	const char *dtpk_mod;
+	dtrace_probekey_f *dtpk_mmatch;
+	const char *dtpk_func;
+	dtrace_probekey_f *dtpk_fmatch;
+	const char *dtpk_name;
+	dtrace_probekey_f *dtpk_nmatch;
+	dtrace_id_t dtpk_id;
+} dtrace_probekey_t;
+
+typedef struct dtrace_hashbucket {
+	struct dtrace_hashbucket *dthb_next;
+	dtrace_probe_t *dthb_chain;
+	int dthb_len;
+} dtrace_hashbucket_t;
+
+typedef struct dtrace_hash {
+	dtrace_hashbucket_t **dth_tab;
+	int dth_size;
+	int dth_mask;
+	int dth_nbuckets;
+	uintptr_t dth_nextoffs;
+	uintptr_t dth_prevoffs;
+	uintptr_t dth_stroffs;
+} dtrace_hash_t;
+
+/*
+ * DTrace supports safe loads from probe context; if the address turns out to
+ * be invalid, a bit will be set by the kernel indicating that DTrace
+ * encountered a memory error, and DTrace will propagate the error to the user
+ * accordingly.  However, there may exist some regions of memory in which an
+ * arbitrary load can change system state, and from which it is impossible to
+ * recover from such a load after it has been attempted.  Examples of this may
+ * include memory in which programmable I/O registers are mapped (for which a
+ * read may have some implications for the device) or (in the specific case of
+ * UltraSPARC-I and -II) the virtual address hole.  The platform is required
+ * to make DTrace aware of these toxic ranges; DTrace will then check that
+ * target addresses are not in a toxic range before attempting to issue a
+ * safe load.
+ */
+typedef struct dtrace_toxrange {
+	uintptr_t dtt_base;
+	uintptr_t dtt_limit;
+} dtrace_toxrange_t;
+
+/*
+ * DTrace Helper Implementation
+ *
+ * A description of the helper architecture may be found in <linux/dtrace.h>.
+ * Each process contains a pointer to its helpers in its dtrace_helpers
+ * member.  This is a pointer to a dtrace_helpers structure, which contains an
+ * array of pointers to dtrace_helper structures, helper variable state (shared
+ * among a process's helpers) and a generation count.  (The generation count is
+ * used to provide an identifier when a helper is added so that it may be
+ * subsequently removed.)  The dtrace_helper structure is self-explanatory,
+ * containing pointers to the objects needed to execute the helper.  Note that
+ * helpers are _duplicated_ across fork(2), and destroyed on exec(2).  No more
+ * than dtrace_helpers_max are allowed per-process.
+ */
+typedef struct dtrace_helper_action {
+	int dtha_generation;			/* helper action generation */
+	int dtha_nactions;			/* number of actions */
+	dtrace_difo_t *dtha_predicate;		/* helper action predicate */
+	dtrace_difo_t **dtha_actions;		/* array of actions */
+	struct dtrace_helper_action *dtha_next;	/* next helper action */
+} dtrace_helper_action_t;
+
+typedef struct dtrace_helper_provider {
+	int dthp_generation;			/* helper provider generation */
+	uint32_t dthp_ref;			/* reference count */
+	dof_helper_t dthp_prov;			/* DOF w/ provider and probes */
+} dtrace_helper_provider_t;
+
+typedef struct dtrace_helpers {
+	dtrace_helper_action_t **dthps_actions;	/* array of helper actions */
+	dtrace_vstate_t dthps_vstate;	/* helper action var. state */
+	dtrace_helper_provider_t **dthps_provs;	/* array of providers */
+	uint_t dthps_nprovs;			/* count of providers */
+	uint_t dthps_maxprovs;			/* provider array size */
+	int dthps_generation;			/* current generation */
+	pid_t dthps_pid;			/* pid of associated proc */
+	int dthps_deferred;			/* helper in deferred list */
+	struct dtrace_helpers *dthps_next;	/* next pointer */
+	struct dtrace_helpers *dthps_prev;	/* prev pointer */
+} dtrace_helpers_t;
+
+/*
+ * DTrace Helper Action Tracing
+ *
+ * Debugging helper actions can be arduous.  To ease the development and
+ * debugging of helpers, DTrace contains a tracing-framework-within-a-tracing-
+ * framework: helper tracing.  If dtrace_helptrace_enabled is non-zero (which
+ * it is by default on DEBUG kernels), all helper activity will be traced to a
+ * global, in-kernel ring buffer.  Each entry includes a pointer to the specific
+ * helper, the location within the helper, and a trace of all local variables.
+ * The ring buffer may be displayed in a human-readable format with the
+ * ::dtrace_helptrace mdb(1) dcmd.
+ */
+typedef struct dtrace_helptrace {
+	dtrace_helper_action_t  *dtht_helper;	/* helper action */
+	int dtht_where;				/* where in helper action */
+	int dtht_nlocals;			/* number of locals */
+	int dtht_fault;				/* type of fault (if any) */
+	int dtht_fltoffs;			/* DIF offset */
+	uint64_t dtht_illval;			/* faulting value */
+	uint64_t dtht_locals[1];		/* local variables */
+} dtrace_helptrace_t;
+
+extern struct mutex		dtrace_lock;
+extern struct mutex		dtrace_provider_lock;
+extern struct mutex		dtrace_meta_lock;
+
+extern dtrace_genid_t		dtrace_probegen;
+extern struct kmem_cache	*dtrace_probe_cachep;
+
+extern dtrace_pops_t		dtrace_provider_ops;
+
+extern int			dtrace_opens;
+extern int			dtrace_err_verbose;
+
+extern dtrace_toxrange_t	*dtrace_toxrange;
+extern int			dtrace_toxranges;
+
+extern void dtrace_nullop(void);
+extern int dtrace_enable_nullop(void);
+extern int dtrace_istoxic(uintptr_t, size_t);
+
+/*
+ * DTrace Probe Context Functions
+ */
+
+extern void dtrace_panic(const char *, ...);
+extern int dtrace_assfail(const char *, const char *, int);
+extern void dtrace_aggregate_min(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_max(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_quantize(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_lquantize(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_llquantize(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_avg(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_stddev(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_count(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate_sum(uint64_t *, uint64_t, uint64_t);
+extern void dtrace_aggregate(dtrace_aggregation_t *, dtrace_buffer_t *,
+			     intptr_t, dtrace_buffer_t *, uint64_t, uint64_t);
+
+/*
+ * DTrace Probe Hashing Functions
+ */
+
+extern dtrace_hash_t *dtrace_hash_create(uintptr_t, uintptr_t, uintptr_t);
+extern void dtrace_hash_destroy(dtrace_hash_t *);
+extern int dtrace_hash_add(dtrace_hash_t *, dtrace_probe_t *);
+extern dtrace_probe_t *dtrace_hash_lookup(dtrace_hash_t *, dtrace_probe_t *);
+extern int dtrace_hash_collisions(dtrace_hash_t *, dtrace_probe_t *);
+extern void dtrace_hash_remove(dtrace_hash_t *, dtrace_probe_t *);
+
+/*
+ * DTrace Speculation Functions
+ */
+extern int dtrace_speculation(dtrace_state_t *);
+extern void dtrace_speculation_commit(dtrace_state_t *, processorid_t,
+				      dtrace_specid_t);
+extern void dtrace_speculation_discard(dtrace_state_t *, processorid_t,
+				       dtrace_specid_t);
+extern void dtrace_speculation_clean(dtrace_state_t *);
+extern dtrace_buffer_t *dtrace_speculation_buffer(dtrace_state_t *,
+                                           processorid_t, dtrace_specid_t);
+
+/*
+ * DTrace Non-Probe Context Utility Functions
+ */
+
+/*
+ * DTrace Matching Functions
+ */
+extern dtrace_hash_t		*dtrace_bymod;
+extern dtrace_hash_t		*dtrace_byfunc;
+extern dtrace_hash_t		*dtrace_byname;
+
+extern int dtrace_match_priv(const dtrace_probe_t *, uint32_t, kuid_t);
+extern int dtrace_match_probe(const dtrace_probe_t *,
+			      const dtrace_probekey_t *, uint32_t, kuid_t);
+extern int dtrace_match_glob(const char *, const char *, int);
+extern int dtrace_match_string(const char *, const char *, int);
+extern int dtrace_match_nul(const char *, const char *, int);
+extern int dtrace_match_nonzero(const char *, const char *, int);
+extern int dtrace_match(const dtrace_probekey_t *, uint32_t, kuid_t,
+			int (*matched)(dtrace_probe_t *, void *), void *);
+extern void dtrace_probekey(const dtrace_probedesc_t *, dtrace_probekey_t *);
+
+/*
+ * DTrace Provider-to-Framework API Functions
+ */
+
+extern dtrace_provider_t	*dtrace_provider;
+extern dtrace_meta_t		*dtrace_meta_pid;
+extern dtrace_helpers_t		*dtrace_deferred_pid;
+
+/*
+ * DTrace Privilege Check Functions
+ */
+extern int dtrace_priv_proc_destructive(dtrace_state_t *);
+extern int dtrace_priv_proc_control(dtrace_state_t *);
+extern int dtrace_priv_proc(dtrace_state_t *);
+extern int dtrace_priv_kernel(dtrace_state_t *);
+
+/*
+ * DTrace Probe Management Functions
+ */
+
+extern int dtrace_probe_enable(const dtrace_probedesc_t *,
+			       dtrace_enabling_t *);
+extern void dtrace_probe_description(const dtrace_probe_t *,
+				     dtrace_probedesc_t *);
+extern void dtrace_probe_provide(dtrace_probedesc_t *, dtrace_provider_t *);
+extern int dtrace_probe_init(void);
+extern void dtrace_probe_exit(void);
+extern void dtrace_probe_remove_id(dtrace_id_t);
+extern dtrace_probe_t *dtrace_probe_lookup_id(dtrace_id_t);
+extern dtrace_probe_t *dtrace_probe_get_next(dtrace_id_t *);
+extern int dtrace_probe_for_each(int (*)(int, void *, void *), void *);
+
+/*
+ * DTrace Kernel Hooks
+ */
+extern void (*dtrace_modload)(struct module *);
+extern void (*dtrace_modunload)(struct module *);
+
+extern uint8_t dtrace_load8(uintptr_t);
+extern uint16_t dtrace_load16(uintptr_t);
+extern uint32_t dtrace_load32(uintptr_t);
+extern uint64_t dtrace_load64(uintptr_t);
+
+extern void dtrace_bzero(void *, size_t);
+
+extern int dtrace_vcanload(void *, dtrace_diftype_t *, dtrace_mstate_t *,
+			   dtrace_vstate_t *);
+
+extern int dtrace_difo_validate(dtrace_difo_t *, dtrace_vstate_t *, uint_t,
+				const cred_t *);
+extern int dtrace_difo_validate_helper(dtrace_difo_t *);
+extern int dtrace_difo_cacheable(dtrace_difo_t *);
+extern void dtrace_difo_hold(dtrace_difo_t *);
+extern void dtrace_difo_init(dtrace_difo_t *, dtrace_vstate_t *);
+extern dtrace_difo_t * dtrace_difo_duplicate(dtrace_difo_t *,
+					     dtrace_vstate_t *);
+extern void dtrace_difo_release(dtrace_difo_t *, dtrace_vstate_t *);
+
+extern uint64_t			dtrace_vtime_references;
+
+extern uint64_t dtrace_dif_emulate(dtrace_difo_t *, dtrace_mstate_t *,
+				   dtrace_vstate_t *, dtrace_state_t *);
+
+/*
+ * DTrace Format Functions
+ */
+extern uint16_t dtrace_format_add(dtrace_state_t *, char *);
+extern void dtrace_format_remove(dtrace_state_t *, uint16_t);
+extern void dtrace_format_destroy(dtrace_state_t *);
+
+/*
+ * DTrace Predicate Functions
+ */
+extern dtrace_predicate_t *dtrace_predicate_create(dtrace_difo_t *);
+extern void dtrace_predicate_hold(dtrace_predicate_t *);
+extern void dtrace_predicate_release(dtrace_predicate_t *, dtrace_vstate_t *);
+
+/*
+ * DTrace Action Description Functions
+ */
+extern dtrace_actdesc_t *dtrace_actdesc_create(dtrace_actkind_t, uint32_t,
+					       uint64_t, uint64_t);
+extern void dtrace_actdesc_hold(dtrace_actdesc_t *);
+extern void dtrace_actdesc_release(dtrace_actdesc_t *, dtrace_vstate_t *);
+
+/*
+ * DTrace Helper Functions
+ */
+extern void dtrace_helpers_destroy(struct task_struct *);
+extern void dtrace_helpers_duplicate(struct task_struct *,
+				     struct task_struct *);
+extern uint64_t dtrace_helper(int, dtrace_mstate_t *, dtrace_state_t *,
+			      uint64_t, uint64_t);
+
+/*
+ * DTrace ECB Functions
+ */
+extern dtrace_ecb_t		*dtrace_ecb_create_cache;
+
+extern int dtrace_ecb_create_enable(dtrace_probe_t *, void *);
+extern void dtrace_ecb_disable(dtrace_ecb_t *);
+extern void dtrace_ecb_destroy(dtrace_ecb_t *);
+extern void dtrace_ecb_resize(dtrace_ecb_t *);
+extern int dtrace_ecb_enable(dtrace_ecb_t *);
+extern dtrace_ecb_t *dtrace_epid2ecb(dtrace_state_t *, dtrace_epid_t);
+extern dtrace_aggregation_t *dtrace_aggid2agg(dtrace_state_t *,
+					      dtrace_aggid_t);
+
+/*
+ * DTrace Buffer Functions
+ *
+ * DTrace Buffers
+ *
+ * Principal buffers, aggregation buffers, and speculative buffers are all
+ * managed with the dtrace_buffer structure.  By default, this structure
+ * includes twin data buffers -- dtb_tomax and dtb_xamot -- that serve as the
+ * active and passive buffers, respectively.  For speculative buffers,
+ * dtb_xamot will be NULL; for "ring" and "fill" buffers, dtb_xamot will point
+ * to a scratch buffer.  For all buffer types, the dtrace_buffer structure is
+ * always allocated on a per-CPU basis; a single dtrace_buffer structure is
+ * never shared among CPUs.  (That is, there is never true sharing of the
+ * dtrace_buffer structure; to prevent false sharing of the structure, it must
+ * always be aligned to the coherence granularity -- generally 64 bytes.)
+ *
+ * One of the critical design decisions of DTrace is that a given ECB always
+ * stores the same quantity and type of data.  This is done to assure that the
+ * only metadata required for an ECB's traced data is the EPID.  That is, from
+ * the EPID, the consumer can determine the data layout.  (The data buffer
+ * layout is shown schematically below.)  By assuring that one can determine
+ * data layout from the EPID, the metadata stream can be separated from the
+ * data stream -- simplifying the data stream enormously.
+ *
+ *      base of data buffer --->  +------+--------------------+------+
+ *                                | EPID | data               | EPID |
+ *                                +------+--------+------+----+------+
+ *                                | data          | EPID | data      |
+ *                                +---------------+------+-----------+
+ *                                | data, cont.                      |
+ *                                +------+--------------------+------+
+ *                                | EPID | data               |      |
+ *                                +------+--------------------+      |
+ *                                |                ||                |
+ *                                |                ||                |
+ *                                |                \/                |
+ *                                :                                  :
+ *                                .                                  .
+ *                                .                                  .
+ *                                .                                  .
+ *                                :                                  :
+ *                                |                                  |
+ *     limit of data buffer --->  +----------------------------------+
+ *
+ * When evaluating an ECB, dtrace_probe() determines if the ECB's needs of the
+ * principal buffer (both scratch and payload) exceed the available space.  If
+ * the ECB's needs exceed available space (and if the principal buffer policy
+ * is the default "switch" policy), the ECB is dropped, the buffer's drop count
+ * is incremented, and processing advances to the next ECB.  If the ECB's needs
+ * can be met with the available space, the ECB is processed, but the offset in
+ * the principal buffer is only advanced if the ECB completes processing
+ * without error.
+ *
+ * When a buffer is to be switched (either because the buffer is the principal
+ * buffer with a "switch" policy or because it is an aggregation buffer), a
+ * cross call is issued to the CPU associated with the buffer.  In the cross
+ * call context, interrupts are disabled, and the active and the inactive
+ * buffers are atomically switched.  This involves switching the data pointers,
+ * copying the various state fields (offset, drops, errors, etc.) into their
+ * inactive equivalents, and clearing the state fields.  Because interrupts are
+ * disabled during this procedure, the switch is guaranteed to appear atomic to
+ * dtrace_probe().
+ *
+ * DTrace Ring Buffering
+ *
+ * To process a ring buffer correctly, one must know the oldest valid record.
+ * Processing starts at the oldest record in the buffer and continues until
+ * the end of the buffer is reached.  Processing then resumes starting with
+ * the record stored at offset 0 in the buffer, and continues until the
+ * youngest record is processed.  If trace records are of a fixed-length,
+ * determining the oldest record is trivial:
+ *
+ *   - If the ring buffer has not wrapped, the oldest record is the record
+ *     stored at offset 0.
+ *
+ *   - If the ring buffer has wrapped, the oldest record is the record stored
+ *     at the current offset.
+ *
+ * With variable length records, however, just knowing the current offset
+ * doesn't suffice for determining the oldest valid record:  assuming that one
+ * allows for arbitrary data, one has no way of searching forward from the
+ * current offset to find the oldest valid record.  (That is, one has no way
+ * of separating data from metadata.) It would be possible to simply refuse to
+ * process any data in the ring buffer between the current offset and the
+ * limit, but this leaves (potentially) an enormous amount of otherwise valid
+ * data unprocessed.
+ *
+ * To effect ring buffering, we track two offsets in the buffer:  the current
+ * offset and the _wrapped_ offset.  If a request is made to reserve some
+ * amount of data, and the buffer has wrapped, the wrapped offset is
+ * incremented until the wrapped offset minus the current offset is greater
+ * than or equal to the reserve request.  This is done by repeatedly looking
+ * up the ECB corresponding to the EPID at the current wrapped offset, and
+ * incrementing the wrapped offset by the size of the data payload
+ * corresponding to that ECB.  If this offset is greater than or equal to the
+ * limit of the data buffer, the wrapped offset is set to 0.  Thus, the
+ * current offset effectively "chases" the wrapped offset around the buffer.
+ * Schematically:
+ *
+ *      base of data buffer --->  +------+--------------------+------+
+ *                                | EPID | data               | EPID |
+ *                                +------+--------+------+----+------+
+ *                                | data          | EPID | data      |
+ *                                +---------------+------+-----------+
+ *                                | data, cont.                      |
+ *                                +------+---------------------------+
+ *                                | EPID | data                      |
+ *           current offset --->  +------+---------------------------+
+ *                                | invalid data                     |
+ *           wrapped offset --->  +------+--------------------+------+
+ *                                | EPID | data               | EPID |
+ *                                +------+--------+------+----+------+
+ *                                | data          | EPID | data      |
+ *                                +---------------+------+-----------+
+ *                                :                                  :
+ *                                .                                  .
+ *                                .        ... valid data ...        .
+ *                                .                                  .
+ *                                :                                  :
+ *                                +------+-------------+------+------+
+ *                                | EPID | data        | EPID | data |
+ *                                +------+------------++------+------+
+ *                                | data, cont.       | leftover     |
+ *     limit of data buffer --->  +-------------------+--------------+
+ *
+ * If the amount of requested buffer space exceeds the amount of space
+ * available between the current offset and the end of the buffer:
+ *
+ *  (1)  all words in the data buffer between the current offset and the limit
+ *       of the data buffer (marked "leftover", above) are set to
+ *       DTRACE_EPIDNONE
+ *
+ *  (2)  the wrapped offset is set to zero
+ *
+ *  (3)  the iteration process described above occurs until the wrapped offset
+ *       is greater than the amount of desired space.
+ *
+ * The wrapped offset is implemented by (re-)using the inactive offset.
+ * In a "switch" buffer policy, the inactive offset stores the offset in
+ * the inactive buffer; in a "ring" buffer policy, it stores the wrapped
+ * offset.
+ *
+ * DTrace Scratch Buffering
+ *
+ * Some ECBs may wish to allocate dynamically-sized temporary scratch memory.
+ * To accommodate such requests easily, scratch memory may be allocated in
+ * the buffer beyond the current offset plus the needed memory of the current
+ * ECB.  If there isn't sufficient room in the buffer for the requested amount
+ * of scratch space, the allocation fails and an error is generated.  Scratch
+ * memory is tracked in the dtrace_mstate_t and is automatically freed when
+ * the ECB ceases processing.  Note that ring buffers cannot allocate their
+ * scratch from the principal buffer -- lest they needlessly overwrite older,
+ * valid data.  Ring buffers therefore have their own dedicated scratch buffer
+ * from which scratch is allocated.
+ */
+
+extern void dtrace_buffer_switch(dtrace_buffer_t *);
+extern void dtrace_buffer_activate(dtrace_state_t *);
+extern int dtrace_buffer_alloc(dtrace_buffer_t *, size_t, int, processorid_t);
+extern void dtrace_buffer_drop(dtrace_buffer_t *);
+extern intptr_t dtrace_buffer_reserve(dtrace_buffer_t *, size_t, size_t,
+				      dtrace_state_t *, dtrace_mstate_t *);
+extern void dtrace_buffer_polish(dtrace_buffer_t *);
+extern void dtrace_buffer_free(dtrace_buffer_t *);
+
+/*
+ * DTrace framework/probe data synchronization
+ * -------------------------------------------
+ *
+ * The dtrace_sync() facility is used to synchronize global DTrace framework
+ * data with DTrace probe context.  The framework updates data and then calls
+ * dtrace_sync().  dtrace_sync() loops until it observes all CPUs have been out
+ * of probe context at least once.  This ensures all consumers are using the
+ * updated data.
+ *
+ * DTrace probes have several requirements.  First DTrace probe context cannot
+ * block.  DTrace probes execute with interrupts disabled.  Locks cannot be
+ * acquired in DTrace probe context.  A second requirement is that DTrace
+ * probes need to be as high performance as possible to minimize the effect of
+ * enabled probes.
+ *
+ * DTrace framework data changes have their own requirements.  DTrace data
+ * changes/syncs are extremely infrequent compared to DTrace probe firings.
+ * Probes can be in commonly executed code.  A good trade-off is to favor
+ * DTrace probe context performance over DTrace sync performance.
+ *
+ * To meet the above requirements, the DTrace data synchronization algorithm
+ * is lock-less.  The DTrace probe path is wait-free.  The DTrace probe path
+ * is memory-barrier-free in the common case to minimize probe effect.
+ * dtrace_probe has been made membar free in the common case by adding a read
+ * in dtrace_probe and adding an additional write and membar to dtrace_sync().
+ *
+ * A simple algorithm is to have dtrace_probe set a flag for its CPU when
+ * entering DTrace probe context and clear the flag when it exits DTrace probe
+ * context.  A producer of DTrace framework data checks the flag to detect and
+ * synchronize with probe context.  Unfortunately memory ordering issues
+ * complicate the implementation.  Memory barriers are required in probe
+ * context for this simple approach to work.
+ *
+ * A simple implementation to sync with one CPU that works with any memory
+ * ordering model is:
+ *
+ * DTrace probe:
+ *    1. CPU->in_probe_context = B_TRUE;
+ *    2. dtrace_membar_enter()// membar #StoreLoad|#StoreStore
+ *    3. access framework shared data// critical section
+ *    4. dtrace_membar_exit()// membar #LoadStore|#StoreStore
+ *    5. CPU->in_probe_context = B_FALSE;
+ *
+ * DTrace framework dtrace_sync:
+ *    0. update framework shared data
+ *    1. dtrace_membar_enter()// membar #StoreLoad|#StoreStore
+ *    2. while (CPU->in_probe_context == B_TRUE)
+ *    3.     spin
+ *    4. dtrace_membar_exit()// membar #LoadStore|#StoreStore
+ *    5. produce shared dtrace data
+ *
+ * A note on memory ordering
+ * -------------------------
+ *
+ * dtrace_membar_enter() guarantees later loads cannot complete before earlier
+ * stores, and it guarantees later stores cannot complete before earlier stores.
+ * dtrace_membar_enter() is, in SPARC parlance, a membar #StoreLoad|#StoreStore.
+ *
+ * dtrace_membar_exit() guarantees later stores cannot complete before earlier
+ * loads, and it guarantees later stores cannot complete before earlier stores.
+ * dtrace_membar_exit() is, in SPARC parlance, a membar #LoadStore|#StoreStore.
+ *
+ * Please see the SPARC and Intel processor guides on memory ordering.
+ * All sun4v and Fujitsu processors are TSO (Total Store Order).  Modern
+ * supported Intel and AMD processors have similar load and store ordering
+ * to SPARC.  All processors currently supported by Solaris have these memory
+ * ordering properties:
+ * 1) Loads are ordered with respect to earlier loads.
+ * 2) Stores are ordered with respect to earlier stores.
+ * 3a) SPARC Atomic load-store behaves as if it were followed by a
+ *     MEMBAR #LoadLoad, #LoadStore, and #StoreStore.
+ * 3b) X86 Atomic operations serialize load and store.
+ * 4) Stores cannot bypass earlier loads.
+ *
+ * The above implementation details allow the membars to be simplified thus:
+ * A) dtrace_membar_enter() can be reduced to "membar #StoreLoad" on sparc.
+ *    See property number 4 above.
+ *    Since dtrace_membar_enter() is an atomic operation on x86, it cannot be
+ *    reduced further.
+ * B) dtrace_membar_exit() becomes a NOP on both SPARC and x86.
+ *    See properties 2 and 4.
+ *
+ *
+ * Elimination of membar #StoreLoad from dtrace probe context
+ * ----------------------------------------------------------
+ *
+ * Furthermore it is possible to eliminate all memory barriers from the common
+ * dtrace_probe() entry case.  The only membar needed in dtrace_probe is there
+ * to prevent Loads of global DTrace framework data from passing the Store to
+ * the "in_probe_context" flag (i.e. the dtrace_membar_enter()).
+ * A Load at the beginning of the algorithm is also ordered with these later
+ * Loads and Stores: the membar #StoreLoad can be replaced with a early Load of
+ * a "sync_request" flag and a conditional branch on the flag value.
+ *
+ * dtrace_sync() first Stores to the "sync_request" flag, and dtrace_probe()
+ * starts by Loading the flag.  This Load in dtrace_probe() of "sync_request"
+ * is ordered with its later Store to the "in_probe_context" flag and
+ * dtrace_probe's later Loads of DTrace framework data.  dtrace_probe() only
+ * needs a membar #StoreLoad iff the "sync_request" flag is set.
+ *
+ * Optimized Synchronization Algorithm
+ * -----------------------------------
+ *
+ * DTrace probe:
+ * +  1a. request_flag = CPU->sync_request		// Load
+ *    1b. CPU->in_probe_context = B_TRUE		// Store
+ * +  2.  if request_flag > 0
+ *            dtrace_membar_enter()			// membar #StoreLoad
+ *    3. access framework shared data			// critical section
+ * -
+ *    5. CPU->in_probe_context = B_FALSE		// Store
+ *
+ * DTrace framework dtrace_sync:
+ * +  1a. atomically add 1 to CPU->sync_request		// Store and
+ *    1b. dtrace_membar_enter()				// membar #StoreLoad
+ *    2.  while (CPU->in_probe_context == B_TRUE)	// Load
+ *    3.      spin
+ * +  4a. atomically subtract 1 from CPU->sync_request	// Load + Store
+ * -
+ *    5.  produce shared dtrace data
+ *
+ * This algorithm has been proven correct by analysis of all interleaving
+ * scenarios of the above operations with the hardware memory ordering
+ * described above.
+ *
+ * The Load and store of the flag pair is very inexpensive.  The cacheline with
+ * the flag pair is never accessed by a different CPU except by dtrace_sync.
+ * dtrace_sync is very uncommon compared to typical probe firings.  The removal
+ * of membars from DTrace probe context at the expense of a Load and Store and
+ * a conditional branch is a good performance win.
+ *
+ * As implemented there is one pair of flags per CPU.  The flags are in one
+ * cacheline; they could be split into two cachelines if dtrace_sync was more
+ * common.  dtrace_sync loops over all NCPU sets of flags.  dtrace_sync lazily
+ * only does one dtrace_membar_enter() (step 1b) after setting all NCPU
+ * sync_request flags.
+ *
+ * Sample aliasing could cause dtrace_sync() to always sample a CPU's
+ * in_probe_context flag when the CPU is in probe context even if the CPU
+ * left and returned to probe context one or more times since the last sample.
+ * cpuc_in_probe_ctxt is implemented as an even/odd counter instead of a
+ * boolean flag.  cpuc_in_probe_ctxt is odd when in probe context and even
+ * when not in probe context.  Probe context increments cpuc_in_probe_ctxt when
+ * entering and exiting.  dtrace_probe() handles re-entry by not increment the
+ * counter for re-enterant entry and exit.
+ */
+
+/*
+ * dtrace_membar_exit() is a NOP on current SPARC and X86 hardware.
+ * It is defined as an inline asm statement to prevent the C optimizer from
+ * moving C statements around the membar.
+ */
+#define	dtrace_membar_exit()						\
+	__asm__ __volatile__("" ::: "memory")
+
+/*
+ * dtrace_membar_enter() does not need an explicit membar #StoreStore because
+ * modern SPARC hardware is TSO: stores are ordered with other stores.
+ */
+#define	dtrace_membar_enter()						\
+	mb();
+
+#define	dtrace_safe_smt_pause()						\
+	cpu_relax();
+
+/*
+ * Used by dtrace_probe() to flag entry to the the critical section.
+ * dtrace_probe() context may be consuming DTrace framework data.
+ *
+ * cpuc_in_probe_ctxt is odd when in probe context and even when not in
+ * probe context.  The flag must not be incremented when re-entering from
+ * probe context.
+ */
+#define	DTRACE_SYNC_ENTER_CRITICAL(cookie, re_entry)			\
+{									\
+	uint64_t	requests;					\
+	uint64_t	count;						\
+									\
+	local_irq_save(cookie);						\
+									\
+	requests = atomic64_read(&this_cpu_core->cpuc_sync_requests);	\
+									\
+	/* Increment flag iff it is even */				\
+	count = atomic64_read(&this_cpu_core->cpuc_in_probe_ctx);	\
+	re_entry = count & 0x1;						\
+	atomic64_set(&this_cpu_core->cpuc_in_probe_ctx, count | 0x1);	\
+	ASSERT(DTRACE_SYNC_IN_CRITICAL(smp_processor_id()));		\
+									\
+	/*								\
+	 * Later Loads are ordered with respect to the Load of		\
+	 * cpuc_sync_requests.  The Load is also guaranteed to complete	\
+	 * before the store to cpuc_in_probe_ctxt.  Thus a member_enter	\
+	 * is only needed when requests is not 0.  This is very		\
+	 * uncommon.							\
+	 */								\
+	if (requests > 0) {						\
+		dtrace_membar_enter();					\
+	}								\
+}
+
+/*
+ * Used by dtrace_probe() to flag exit from the critical section.
+ * dtrace_probe context is no longer using DTrace framework data.
+ */
+#define	DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry)			\
+{									\
+	dtrace_membar_exit();						\
+	ASSERT((re_entry | 0x1) ==  0x1);				\
+									\
+	/*								\
+	 * flag must not be incremented when returning to probe context.\
+	 */								\
+	atomic64_add(~re_entry & 0x1, &this_cpu_core->cpuc_in_probe_ctx); \
+	ASSERT(re_entry ==						\
+	    (atomic64_read(&this_cpu_core->cpuc_in_probe_ctx) & 0x1));	\
+	local_irq_restore(cookie);					\
+}
+
+/*
+ * Used by dtrace_sync to inform dtrace_probe it needs to synchronize with
+ * dtrace_sync.  dtrace_probe consumes the cpuc_sync_requests flag to determine
+ * if it needs a membar_enter.  Not called from probe context.
+ *
+ * cpuc_sync_requests must be updated atomically by dtrace_sync because there
+ * may be multiple dtrace_sync operations executing at the same time.
+ * cpuc_sync_requests is a simple count of the number of concurrent
+ * dtrace_sync requests.
+ */
+#define	DTRACE_SYNC_START(cpuid)					\
+{									\
+	atomic64_add(1, &(per_cpu_core(cpuid))->cpuc_sync_requests);	\
+	ASSERT(atomic64_read(&per_cpu_core(cpuid)->cpuc_sync_requests) > 0);	\
+}
+
+/*
+ * Used by dtrace_sync to flag dtrace_probe that it no longer needs to
+ * synchronize with dtrace_sync.  Not called from probe context.
+ */
+#define	DTRACE_SYNC_END(cpuid)						\
+{									\
+	atomic64_add(-1, &(per_cpu_core(cpuid))->cpuc_sync_requests);	\
+	ASSERT(atomic64_read(&per_cpu_core(cpuid)->cpuc_sync_requests) >= 0);	\
+}
+
+/*
+ * The next two macros are used by dtrace_sync to check if the target CPU is in
+ * DTrace probe context.  cpuc_in_probe_ctxt is a monotonically increasing
+ * count which dtrace_probe() increments when entering and exiting probe
+ * context.  The flag is odd when in probe context, and even when not in probe
+ * context.
+ */
+#define	DTRACE_SYNC_IN_CRITICAL(cpuid)					\
+	(atomic64_read(&per_cpu_core(cpuid)->cpuc_in_probe_ctx) & 0x1)
+
+/*
+ * Used to check if the target CPU left and then entered probe context again.
+ */
+#define	DTRACE_SYNC_CRITICAL_COUNT(cpuid)				\
+	(atomic64_read(&per_cpu_core(cpuid)->cpuc_in_probe_ctx))
+
+/*
+ * The next three macros are bitmap operations used by dtrace_sync to keep track
+ * of which CPUs it still needs to synchronize with.
+ */
+#define	DTRACE_SYNC_OUTSTANDING(cpuid, bitmap)				\
+	(cpumask_test_cpu(cpuid, bitmap) == 1)
+
+#define	DTRACE_SYNC_NEEDED(cpuid, bitmap)				\
+	cpumask_set_cpu(cpuid, bitmap)
+
+#define	DTRACE_SYNC_DONE(cpuid, bitmap)					\
+	cpumask_clear_cpu(cpuid, bitmap)
+
+extern uint64_t dtrace_sync_sample_count;
+extern void dtrace_sync(void);
+
+/*
+ * DTrace Enabling Functions
+ */
+extern dtrace_enabling_t	*dtrace_retained;
+extern dtrace_genid_t		dtrace_retained_gen;
+
+extern dtrace_enabling_t *dtrace_enabling_create(dtrace_vstate_t *);
+extern void dtrace_enabling_add(dtrace_enabling_t *, dtrace_ecbdesc_t *);
+extern void dtrace_enabling_dump(dtrace_enabling_t *);
+extern void dtrace_enabling_destroy(dtrace_enabling_t *);
+extern int dtrace_enabling_retain(dtrace_enabling_t *);
+extern int dtrace_enabling_replicate(dtrace_state_t *, dtrace_probedesc_t *,
+				     dtrace_probedesc_t *);
+extern void dtrace_enabling_retract(dtrace_state_t *);
+extern int dtrace_enabling_match(dtrace_enabling_t *, int *);
+extern void dtrace_enabling_matchall(void);
+extern void dtrace_enabling_prime(dtrace_state_t *);
+extern void dtrace_enabling_provide(dtrace_provider_t *);
+
+/*
+ * DOF functions
+ */
+extern void dtrace_dof_error(dof_hdr_t *, const char *);
+extern dof_hdr_t *dtrace_dof_create(dtrace_state_t *);
+extern dof_hdr_t *dtrace_dof_copyin(void __user *, int *);
+extern dof_hdr_t *dtrace_dof_property(const char *);
+extern void dtrace_dof_destroy(dof_hdr_t *);
+extern int dtrace_dof_slurp(dof_hdr_t *, dtrace_vstate_t *, const cred_t *,
+			    dtrace_enabling_t **, uint64_t, int);
+extern int dtrace_dof_options(dof_hdr_t *, dtrace_state_t *);
+extern void dtrace_helper_provide(dof_helper_t *dhp, pid_t pid);
+extern int dtrace_helper_slurp(dof_hdr_t *, dof_helper_t *);
+extern int dtrace_helper_destroygen(int);
+
+/*
+ * DTrace Anonymous Enabling Functions
+ */
+typedef struct dtrace_anon {
+	dtrace_state_t *dta_state;
+	dtrace_enabling_t *dta_enabling;
+	processorid_t dta_beganon;
+} dtrace_anon_t;
+
+extern dtrace_anon_t		dtrace_anon;
+
+extern dtrace_state_t *dtrace_anon_grab(void);
+extern void dtrace_anon_property(void);
+
+/*
+ * DTrace Consumer State Functions
+ */
+extern struct kmem_cache	*dtrace_state_cachep;
+extern size_t			dtrace_strsize_default;
+
+extern ktime_t			dtrace_deadman_timeout;
+extern int			dtrace_destructive_disallow;
+
+extern dtrace_id_t		dtrace_probeid_begin;
+extern dtrace_id_t		dtrace_probeid_end;
+extern dtrace_id_t		dtrace_probeid_error;
+
+extern dtrace_dynvar_t		dtrace_dynhash_sink;
+
+extern struct user_namespace	*init_user_namespace;
+
+extern int dtrace_dstate_init(dtrace_dstate_t *, size_t);
+extern void dtrace_dstate_fini(dtrace_dstate_t *);
+extern void dtrace_vstate_fini(dtrace_vstate_t *);
+extern dtrace_state_t *dtrace_state_create(struct file *);
+extern int dtrace_state_go(dtrace_state_t *, processorid_t *);
+extern int dtrace_state_stop(dtrace_state_t *, processorid_t *);
+extern int dtrace_state_option(dtrace_state_t *, dtrace_optid_t,
+			       dtrace_optval_t);
+extern void dtrace_state_destroy(dtrace_state_t *);
+
+/*
+ * DTrace Utility Functions
+ */
+extern void *dtrace_vzalloc(unsigned long);
+extern void *dtrace_vzalloc_try(unsigned long);
+extern char *dtrace_strdup(const char *);
+extern int dtrace_strncmp(char *, char *, size_t);
+extern size_t dtrace_strlen(const char *, size_t);
+extern int dtrace_badattr(const dtrace_attribute_t *);
+extern int dtrace_badname(const char *);
+extern void dtrace_cred2priv(const cred_t *, uint32_t *, kuid_t *);
+
+extern void ctf_forceload(void);
+
+#define dtrace_membar_producer()	smp_wmb()
+#define dtrace_membar_consumer()	smp_rmb()
+
+typedef unsigned long	dtrace_icookie_t;
+
+extern struct mutex	cpu_lock;
+
+extern void dtrace_toxic_ranges(void (*)(uintptr_t, uintptr_t));
+extern void dtrace_vpanic(const char *, va_list);
+extern int dtrace_getipl(void);
+
+extern dtrace_icookie_t dtrace_interrupt_disable(void);
+extern void dtrace_interrupt_enable(dtrace_icookie_t);
+
+typedef void 		(*dtrace_xcall_t)(void *);
+
+extern void dtrace_xcall(processorid_t, dtrace_xcall_t, void *);
+
+extern uintptr_t dtrace_fulword(void *);
+extern uint8_t dtrace_fuword8(void *);
+extern uint16_t dtrace_fuword16(void *);
+extern uint32_t dtrace_fuword32(void *);
+extern uint64_t dtrace_fuword64(void *);
+
+extern void dtrace_probe_error(dtrace_state_t *, dtrace_epid_t, int, int, int,
+			       uintptr_t);
+
+extern void dtrace_getpcstack(uint64_t *, int, int, uint32_t *);
+extern void dtrace_getupcstack(uint64_t *, int);
+extern unsigned long dtrace_getufpstack(uint64_t *, uint64_t *, int);
+extern uintptr_t dtrace_getfp(void);
+extern uint64_t dtrace_getarg(int, int);
+extern int dtrace_getstackdepth(dtrace_mstate_t *, int);
+extern int dtrace_getustackdepth(void);
+extern ulong_t dtrace_getreg(struct task_struct *, uint_t);
+extern void dtrace_copyin(uintptr_t, uintptr_t, size_t,
+			  volatile uint16_t *);
+extern void dtrace_copyout(uintptr_t, uintptr_t, size_t,
+			   volatile uint16_t *);
+extern void dtrace_copyinstr(uintptr_t, uintptr_t, size_t,
+			     volatile uint16_t *);
+extern void dtrace_copyoutstr(uintptr_t, uintptr_t, size_t,
+			      volatile uint16_t *);
+
+/*
+ * Plaforms that support a fast path to obtain the caller implement the
+ * dtrace_caller() function.
+ *
+ * The first argument is the number of frames that should be skipped when
+ * looking for a caller address.  The 2nd argument is a dummy argument that
+ * is necessary for SPARC.
+ *
+ * On x86 this is effectively a NOP.
+ *
+ * On SPARC it is possible to retrieve the caller address from the register
+ * windows without flushing them to the stack.  This involves performing
+ * explicit rotation of the register windows.  Modification of the windowing
+ * mechanism state alters all %i, %o, and %l registers so we are can only use
+ * %g registers to store temporary data.
+ *
+ * On Linux a lot of %g registers are already allocated for specific purpose.
+ * Saving temporaries to the stack would be a violation of the fast path code
+ * logic. Therefore, the function prototype declares a 2nd argument that serves
+ * as a temporary value.  A compiler will not expect that the value in %o1
+ * will survive the call and therefore dtrace_caller() can use %o1 as a
+ * temporary registe.
+ */
+extern uintptr_t dtrace_caller(int, int);
+
+extern void dtrace_copyin_arch(uintptr_t, uintptr_t, size_t,
+			       volatile uint16_t *);
+extern void dtrace_copyinstr_arch(uintptr_t, uintptr_t, size_t,
+				  volatile uint16_t *);
+
+extern void pdata_init(dtrace_module_t *, struct module *);
+extern void pdata_cleanup(dtrace_module_t *, struct module *);
+
+extern void debug_enter(char *);
+
+#endif /* _LINUX_DTRACE_IMPL_H */
diff --git a/include/dtrace/dtrace_impl_defines.h b/include/dtrace/dtrace_impl_defines.h
new file mode 100644
index 000000000000..9c6823fa46f2
--- /dev/null
+++ b/include/dtrace/dtrace_impl_defines.h
@@ -0,0 +1,190 @@
+/*
+ * Dynamic Tracing for Linux - Implementation Defines
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_IMPL_DEFINES_H
+#define _LINUX_DTRACE_IMPL_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/preempt.h>
+#include <asm/ptrace.h>
+
+typedef typeof(instruction_pointer((struct pt_regs *)0))	pc_t;
+
+typedef enum dtrace_activity {
+	DTRACE_ACTIVITY_INACTIVE = 0,
+	DTRACE_ACTIVITY_WARMUP,
+	DTRACE_ACTIVITY_ACTIVE,
+	DTRACE_ACTIVITY_DRAINING,
+	DTRACE_ACTIVITY_COOLDOWN,
+	DTRACE_ACTIVITY_STOPPED,
+	DTRACE_ACTIVITY_KILLED
+} dtrace_activity_t;
+
+typedef enum dtrace_dstate_state {
+	DTRACE_DSTATE_CLEAN = 0,
+	DTRACE_DSTATE_EMPTY,
+	DTRACE_DSTATE_DIRTY,
+	DTRACE_DSTATE_RINSING
+} dtrace_dstate_state_t;
+
+typedef enum dtrace_dynvar_op {
+	DTRACE_DYNVAR_ALLOC,
+	DTRACE_DYNVAR_NOALLOC,
+	DTRACE_DYNVAR_DEALLOC
+} dtrace_dynvar_op_t;
+
+#define DTRACE_MSTATE_ARGS		0x00000001
+#define DTRACE_MSTATE_PROBE		0x00000002
+#define DTRACE_MSTATE_EPID		0x00000004
+#define DTRACE_MSTATE_TIMESTAMP		0x00000008
+#define DTRACE_MSTATE_STACKDEPTH	0x00000010
+#define DTRACE_MSTATE_CALLER		0x00000020
+#define DTRACE_MSTATE_IPL		0x00000040
+#define DTRACE_MSTATE_FLTOFFS		0x00000080
+#define DTRACE_MSTATE_USTACKDEPTH	0x00000100
+#define DTRACE_MSTATE_UCALLER		0x00000200
+
+#define DTRACE_PROBEKEY_MAXDEPTH	8
+
+typedef enum dtrace_speculation_state {
+	DTRACESPEC_INACTIVE = 0,
+	DTRACESPEC_ACTIVE,
+	DTRACESPEC_ACTIVEONE,
+	DTRACESPEC_ACTIVEMANY,
+	DTRACESPEC_COMMITTING,
+	DTRACESPEC_COMMITTINGMANY,
+	DTRACESPEC_DISCARDING
+} dtrace_speculation_state_t;
+
+#define DTRACE_HELPER_ACTION_USTACK	0
+#define DTRACE_NHELPER_ACTIONS		1
+
+#define DTRACE_HELPTRACE_NEXT	(-1)
+#define DTRACE_HELPTRACE_DONE	(-2)
+#define DTRACE_HELPTRACE_ERR	(-3)
+
+#undef ASSERT
+#ifdef CONFIG_DT_DEBUG
+# define ASSERT(x)	((void)((x) || dtrace_assfail(#x, __FILE__, __LINE__)))
+#else
+# define ASSERT(x)	((void)0)
+#endif
+
+/*
+ * DTrace Probe Hashing
+ */
+
+#define DTRACE_HASHNEXT(hash, probe)					\
+	(dtrace_probe_t **)((uintptr_t)(probe) + (hash)->dth_nextoffs)
+#define DTRACE_HASHPREV(hash, probe)	\
+	(dtrace_probe_t **)((uintptr_t)(probe) + (hash)->dth_prevoffs)
+
+/*
+ * DTrace Probe Management
+ */
+#define DTRACE_ANCHORED(probe)	((probe)->dtpr_func[0] != '\0')
+#define DTRACE_FLAGS2FLT(flags)						\
+	(((flags) & CPU_DTRACE_BADADDR) ? DTRACEFLT_BADADDR :		\
+	 ((flags) & CPU_DTRACE_ILLOP) ? DTRACEFLT_ILLOP :		\
+	 ((flags) & CPU_DTRACE_DIVZERO) ? DTRACEFLT_DIVZERO :		\
+	 ((flags) & CPU_DTRACE_KPRIV) ? DTRACEFLT_KPRIV :		\
+	 ((flags) & CPU_DTRACE_UPRIV) ? DTRACEFLT_UPRIV :		\
+	 ((flags) & CPU_DTRACE_TUPOFLOW) ?  DTRACEFLT_TUPOFLOW :	\
+	 ((flags) & CPU_DTRACE_BADALIGN) ?  DTRACEFLT_BADALIGN :	\
+	 ((flags) & CPU_DTRACE_NOSCRATCH) ?  DTRACEFLT_NOSCRATCH :	\
+	 ((flags) & CPU_DTRACE_BADSTACK) ?  DTRACEFLT_BADSTACK :	\
+	 DTRACEFLT_UNKNOWN)
+
+/*
+ * Test whether alloc_sz bytes will fit in the scratch region.  We isolate
+ * alloc_sz on the righthand side of the comparison in order to avoid overflow
+ * or underflow in the comparison with it.  This is simpler than the INRANGE
+ * check above, because we know that the dtms_scratch_ptr is valid in the
+ * range.  Allocations of size zero are allowed.
+ */
+#define DTRACE_INSCRATCH(mstate, alloc_sz) \
+	((mstate)->dtms_scratch_base + (mstate)->dtms_scratch_size - \
+	 (mstate)->dtms_scratch_ptr >= (alloc_sz))
+
+/*
+ * Buffering.
+ */
+
+#define DTRACEBUF_RING		0x0001		/* bufpolicy set to "ring" */
+#define DTRACEBUF_FILL		0x0002		/* bufpolicy set to "fill" */
+#define DTRACEBUF_NOSWITCH	0x0004		/* do not switch buffer */
+#define DTRACEBUF_WRAPPED	0x0008		/* ring buffer has wrapped */
+#define DTRACEBUF_DROPPED	0x0010		/* drops occurred */
+#define DTRACEBUF_ERROR		0x0020		/* errors occurred */
+#define DTRACEBUF_FULL		0x0040		/* "fill" buffer is full */
+#define DTRACEBUF_CONSUMED	0x0080		/* buffer has been consumed */
+#define DTRACEBUF_INACTIVE	0x0100		/* buffer is not yet active */
+
+#define DTRACE_STORE(type, tomax, offset, what) \
+	do { \
+	*((type *)((uintptr_t)(tomax) + (uintptr_t)(offset))) = (type)(what); \
+	} while (0)
+
+#define KERNELBASE	(uintptr_t)_text
+
+#ifdef CONFIG_DT_DEBUG_MUTEX
+# define real_mutex_lock(x)		mutex_lock(x)
+# define real_mutex_unlock(x)		mutex_unlock(x)
+
+# define mutex_lock(x)		do {					      \
+				    printk(KERN_DEBUG			      \
+					   "mutex_lock(%s) at %s::%d "	      \
+					   " for %p (PID %d)\n",	      \
+					   __stringify(x),		      \
+					   __FILE__, __LINE__, current,	      \
+					   current ? current->pid : -1);      \
+				    real_mutex_lock(x);			      \
+				} while (0)
+# define mutex_unlock(x)	do {					      \
+				    printk(KERN_DEBUG			      \
+					   "mutex_unlock(%s) at %s::%d"	      \
+					   " for %p (PID %d)\n",	      \
+					   __stringify(x),		      \
+					   __FILE__, __LINE__, current,	      \
+					   current ? current->pid : -1);      \
+				    real_mutex_unlock(x);		      \
+				} while (0)
+#endif
+
+#define MUTEX_HELD(lock)	mutex_owned(lock)
+
+#if defined(CONFIG_PREEMPT_VOLUNTARY)
+# define dtrace_is_preemptive()	(preempt_count() == 0)
+# define dtrace_preempt_off()	preempt_disable()
+# define dtrace_preempt_on()	preempt_enable()
+#elif defined(CONFIG_PREEMPT)
+# define dtrace_is_preemptive()	(preempt_count() == 0)
+# define dtrace_preempt_off()	preempt_disable()
+# define dtrace_preempt_on()	preempt_enable_no_resched()
+#elif defined(CONFIG_PREEMPT_NONE)
+# define dtrace_is_preemptive() (0)
+# define dtrace_preempt_off()
+# define dtrace_preempt_on()
+#endif
+
+#define PDATA(mp)		((dtrace_module_t *)mp->pdata)
+
+#endif /* _LINUX_DTRACE_IMPL_DEFINES_H */
diff --git a/include/dtrace/provider.h b/include/dtrace/provider.h
new file mode 100644
index 000000000000..9c87e540e991
--- /dev/null
+++ b/include/dtrace/provider.h
@@ -0,0 +1,950 @@
+/*
+ * Dynamic Tracing for Linux - Provider API
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _DTRACE_PROVIDER_H
+#define _DTRACE_PROVIDER_H
+
+/*
+ * The following functions are implemented by the DTrace framework and are
+ * used to implement separate in-kernel DTrace providers.
+ *
+ * The provider API has two halves:  the API that the providers consume from
+ * DTrace, and the API that providers make available to DTrace.
+ *
+ * 1 Framework-to-Provider API
+ *
+ * 1.1  Overview
+ *
+ * The Framework-to-Provider API is represented by the dtrace_pops structure
+ * that the provider passes to the framework when registering itself.  This
+ * structure consists of the following members:
+ *
+ *   dtps_provide()          <-- Provide all probes, all modules
+ *   dtps_provide_module()   <-- Provide all probes in specified module
+ *   dtps_enable()           <-- Enable specified probe
+ *   dtps_disable()          <-- Disable specified probe
+ *   dtps_suspend()          <-- Suspend specified probe
+ *   dtps_resume()           <-- Resume specified probe
+ *   dtps_getargdesc()       <-- Get the argument description for args[X]
+ *   dtps_getargval()        <-- Get the value for an argX or args[X] variable
+ *   dtps_usermode()         <-- Find out if the probe was fired in user mode
+ *   dtps_destroy()          <-- Destroy all state associated with this probe
+ *   dtps_destroy_module()   <-- Destroy per-module data
+ *
+ * 1.2  void dtps_provide(void *arg, const dtrace_probedesc_t *spec)
+ *
+ * 1.2.1  Overview
+ *
+ *   Called to indicate that the provider should provide all probes.  If the
+ *   specified description is non-NULL, dtps_provide() is being called because
+ *   no probe matched a specified probe -- if the provider has the ability to
+ *   create custom probes, it may wish to create a probe that matches the
+ *   specified description.
+ *
+ * 1.2.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is a pointer to a probe description that the provider may
+ *   wish to consider when creating custom probes.  The provider is expected to
+ *   call back into the DTrace framework via dtrace_probe_create() to create
+ *   any necessary probes.  dtps_provide() may be called even if the provider
+ *   has made available all probes; the provider should check the return value
+ *   of dtrace_probe_create() to handle this case.  Note that the provider need
+ *   not implement both dtps_provide() and dtps_provide_module(); see
+ *   "Arguments and Notes" for dtrace_register(), below.
+ *
+ * 1.2.3  Return value
+ *
+ *   None.
+ *
+ * 1.2.4  Caller's context
+ *
+ *   dtps_provide() is typically called from open() or ioctl() context, but may
+ *   be called from other contexts as well.  The DTrace framework is locked in
+ *   such a way that providers may not register or unregister.  This means that
+ *   the provider may not call any DTrace API that affects its registration with
+ *   the framework, including dtrace_register(), dtrace_unregister(),
+ *   dtrace_invalidate(), and dtrace_condense().  However, the context is such
+ *   that the provider may (and indeed, is expected to) call probe-related
+ *   DTrace routines, including dtrace_probe_create(), dtrace_probe_lookup(),
+ *   and dtrace_probe_arg().
+ *
+ * 1.3  void dtps_provide_module(void *arg, struct modctl *mp)
+ *
+ * 1.3.1  Overview
+ *
+ *   Called to indicate that the provider should provide all probes in the
+ *   specified module.
+ *
+ * 1.3.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is a pointer to a modctl structure that indicates the
+ *   module for which probes should be created.
+ *
+ * 1.3.3  Return value
+ *
+ *   None.
+ *
+ * 1.3.4  Caller's context
+ *
+ *   dtps_provide_module() may be called from open() or ioctl() context, but
+ *   may also be called from a module loading context.  mod_lock is held, and
+ *   the DTrace framework is locked in such a way that providers may not
+ *   register or unregister.  This means that the provider may not call any
+ *   DTrace API that affects its registration with the framework, including
+ *   dtrace_register(), dtrace_unregister(), dtrace_invalidate(), and
+ *   dtrace_condense().  However, the context is such that the provider may (and
+ *   indeed, is expected to) call probe-related DTrace routines, including
+ *   dtrace_probe_create(), dtrace_probe_lookup(), and dtrace_probe_arg().  Note
+ *   that the provider need not implement both dtps_provide() and
+ *   dtps_provide_module(); see "Arguments and Notes" for dtrace_register(),
+ *   below.
+ *
+ * 1.4  int dtps_enable(void *arg, dtrace_id_t id, void *parg)
+ *
+ * 1.4.1  Overview
+ *
+ *   Called to enable the specified probe.
+ *
+ * 1.4.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is the identifier of the probe to be enabled.  The third
+ *   argument is the probe argument as passed to dtrace_probe_create().
+ *   dtps_enable() will be called when a probe transitions from not being
+ *   enabled at all to having one or more ECB.  The number of ECBs associated
+ *   with the probe may change without subsequent calls into the provider.
+ *   When the number of ECBs drops to zero, the provider will be explicitly
+ *   told to disable the probe via dtps_disable().  dtrace_probe() should never
+ *   be called for a probe identifier that hasn't been explicitly enabled via
+ *   dtps_enable().
+ *
+ * 1.4.3  Return value
+ *
+ *   On success, dtps_enable() should return 0. On failure, -1 should be
+ *   returned.
+ *
+ * 1.4.4  Caller's context
+ *
+ *   The DTrace framework is locked in such a way that it may not be called
+ *   back into at all.  cpu_lock is held.  mod_lock is not held and may not
+ *   be acquired.
+ *
+ * 1.5  void dtps_disable(void *arg, dtrace_id_t id, void *parg)
+ *
+ * 1.5.1  Overview
+ *
+ *   Called to disable the specified probe.
+ *
+ * 1.5.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is the identifier of the probe to be disabled.  The third
+ *   argument is the probe argument as passed to dtrace_probe_create().
+ *   dtps_disable() will be called when a probe transitions from being enabled
+ *   to having zero ECBs.  dtrace_probe() should never be called for a probe
+ *   identifier that has been explicitly enabled via dtps_disable().
+ *
+ * 1.5.3  Return value
+ *
+ *   None.
+ *
+ * 1.5.4  Caller's context
+ *
+ *   The DTrace framework is locked in such a way that it may not be called
+ *   back into at all.  cpu_lock is held.  mod_lock is not held and may not
+ *   be acquired.
+ *
+ * 1.6  void dtps_suspend(void *arg, dtrace_id_t id, void *parg)
+ *
+ * 1.6.1  Overview
+ *
+ *   Called to suspend the specified enabled probe.  This entry point is for
+ *   providers that may need to suspend some or all of their probes when CPUs
+ *   are being powered on or when the boot monitor is being entered for a
+ *   prolonged period of time.
+ *
+ * 1.6.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is the identifier of the probe to be suspended.  The
+ *   third argument is the probe argument as passed to dtrace_probe_create().
+ *   dtps_suspend will only be called on an enabled probe.  Providers that
+ *   provide a dtps_suspend entry point will want to take roughly the action
+ *   that it takes for dtps_disable.
+ *
+ * 1.6.3  Return value
+ *
+ *   None.
+ *
+ * 1.6.4  Caller's context
+ *
+ *   Interrupts are disabled.  The DTrace framework is in a state such that the
+ *   specified probe cannot be disabled or destroyed for the duration of
+ *   dtps_suspend().  As interrupts are disabled, the provider is afforded
+ *   little latitude; the provider is expected to do no more than a store to
+ *   memory.
+ *
+ * 1.7  void dtps_resume(void *arg, dtrace_id_t id, void *parg)
+ *
+ * 1.7.1  Overview
+ *
+ *   Called to resume the specified enabled probe.  This entry point is for
+ *   providers that may need to resume some or all of their probes after the
+ *   completion of an event that induced a call to dtps_suspend().
+ *
+ * 1.7.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is the identifier of the probe to be resumed.  The
+ *   third argument is the probe argument as passed to dtrace_probe_create().
+ *   dtps_resume will only be called on an enabled probe.  Providers that
+ *   provide a dtps_resume entry point will want to take roughly the action
+ *   that it takes for dtps_enable.
+ *
+ * 1.7.3  Return value
+ *
+ *   None.
+ *
+ * 1.7.4  Caller's context
+ *
+ *   Interrupts are disabled.  The DTrace framework is in a state such that the
+ *   specified probe cannot be disabled or destroyed for the duration of
+ *   dtps_resume().  As interrupts are disabled, the provider is afforded
+ *   little latitude; the provider is expected to do no more than a store to
+ *   memory.
+ *
+ * 1.8  void dtps_getargdesc(void *arg, dtrace_id_t id, void *parg,
+ *           dtrace_argdesc_t *desc)
+ *
+ * 1.8.1  Overview
+ *
+ *   Called to retrieve the argument description for an args[X] variable.
+ *
+ * 1.8.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register(). The
+ *   second argument is the identifier of the current probe. The third
+ *   argument is the probe argument as passed to dtrace_probe_create(). The
+ *   fourth argument is a pointer to the argument description.  This
+ *   description is both an input and output parameter:  it contains the
+ *   index of the desired argument in the dtargd_ndx field, and expects
+ *   the other fields to be filled in upon return.  If there is no argument
+ *   corresponding to the specified index, the dtargd_ndx field should be set
+ *   to DTRACE_ARGNONE.
+ *
+ * 1.8.3  Return value
+ *
+ *   None.  The dtargd_ndx, dtargd_native, dtargd_xlate and dtargd_mapping
+ *   members of the dtrace_argdesc_t structure are all output values.
+ *
+ * 1.8.4  Caller's context
+ *
+ *   dtps_getargdesc() is called from ioctl() context. mod_lock is held, and
+ *   the DTrace framework is locked in such a way that providers may not
+ *   register or unregister.  This means that the provider may not call any
+ *   DTrace API that affects its registration with the framework, including
+ *   dtrace_register(), dtrace_unregister(), dtrace_invalidate(), and
+ *   dtrace_condense().
+ *
+ * 1.9  uint64_t dtps_getargval(void *arg, dtrace_id_t id, void *parg,
+ *               int argno, int aframes)
+ *
+ * 1.9.1  Overview
+ *
+ *   Called to retrieve a value for an argX or args[X] variable.
+ *
+ * 1.9.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register(). The
+ *   second argument is the identifier of the current probe. The third
+ *   argument is the probe argument as passed to dtrace_probe_create(). The
+ *   fourth argument is the number of the argument (the X in the example in
+ *   1.9.1). The fifth argument is the number of stack frames that were used
+ *   to get from the actual place in the code that fired the probe to
+ *   dtrace_probe() itself, the so-called artificial frames. This argument may
+ *   be used to descend an appropriate number of frames to find the correct
+ *   values. If this entry point is left NULL, the dtrace_getarg() built-in
+ *   function is used.
+ *
+ * 1.9.3  Return value
+ *
+ *   The value of the argument.
+ *
+ * 1.9.4  Caller's context
+ *
+ *   This is called from within dtrace_probe() meaning that interrupts
+ *   are disabled. No locks should be taken within this entry point.
+ *
+ * 1.10  int dtps_usermode(void *arg, dtrace_id_t id, void *parg)
+ *
+ * 1.10.1  Overview
+ *
+ *   Called to determine if the probe was fired in a user context.
+ *
+ * 1.10.2  Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register(). The
+ *   second argument is the identifier of the current probe. The third
+ *   argument is the probe argument as passed to dtrace_probe_create().  This
+ *   entry point must not be left NULL for providers whose probes allow for
+ *   mixed mode tracing, that is to say those probes that can fire during
+ *   kernel- _or_ user-mode execution
+ *
+ * 1.10.3  Return value
+ *
+ *   A boolean value.
+ *
+ * 1.10.4  Caller's context
+ *
+ *   This is called from within dtrace_probe() meaning that interrupts
+ *   are disabled. No locks should be taken within this entry point.
+ *
+ * 1.11 void dtps_destroy(void *arg, dtrace_id_t id, void *parg)
+ *
+ * 1.11.1 Overview
+ *
+ *   Called to destroy the specified probe.
+ *
+ * 1.11.2 Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register().  The
+ *   second argument is the identifier of the probe to be destroyed.  The third
+ *   argument is the probe argument as passed to dtrace_probe_create().  The
+ *   provider should free all state associated with the probe.  The framework
+ *   guarantees that dtps_destroy() is only called for probes that have either
+ *   been disabled via dtps_disable() or were never enabled via dtps_enable().
+ *   Once dtps_disable() has been called for a probe, no further call will be
+ *   made specifying the probe.
+ *
+ * 1.11.3 Return value
+ *
+ *   None.
+ *
+ * 1.11.4 Caller's context
+ *
+ *   The DTrace framework is locked in such a way that it may not be called
+ *   back into at all.  mod_lock is held.  cpu_lock is not held, and may not be
+ *   acquired.
+ *
+ * 1.12 void dtps_destroy_module(void *arg, struct modctl *mp)
+ *
+ * 1.12.1 Overview
+ *
+ *   Called to notify provider that it can remove any per-module data.
+ *
+ * 1.12.2 Arguments and notes
+ *
+ *   The first argument is the cookie as passed to dtrace_register(). The
+ *   second argument is a pointer to a struct module structure that points to
+ *   the module for which data may be cleared.
+ *
+ * 1.12.3 Return value
+ *
+ *   None.
+ *
+ *
+ * 2 Provider-to-Framework API
+ *
+ * 2.1  Overview
+ *
+ * The Provider-to-Framework API provides the mechanism for the provider to
+ * register itself with the DTrace framework, to create probes, to lookup
+ * probes and (most importantly) to fire probes.  The Provider-to-Framework
+ * consists of:
+ *
+ *   dtrace_register()       <-- Register a provider with the DTrace framework
+ *   dtrace_unregister()     <-- Remove a provider's DTrace registration
+ *   dtrace_meta_register()  <-- Register a metaprovider with the DTrace framework
+ *   dtrace_meta_unregister()<-- Remove a metaprovider's DTrace registration
+ *   dtrace_invalidate()     <-- Invalidate the specified provider
+ *   dtrace_condense()       <-- Remove a provider's unenabled probes
+ *   dtrace_attached()       <-- Indicates whether or not DTrace has attached
+ *   dtrace_probe_create()   <-- Create a DTrace probe
+ *   dtrace_probe_lookup()   <-- Lookup a DTrace probe based on its name
+ *   dtrace_probe_arg()      <-- Return the probe argument for a specific probe
+ *   dtrace_probe()          <-- Fire the specified probe
+ *
+ * 2.2  int dtrace_register(const char *name, const dtrace_pattr_t *pap,
+ *          uint32_t priv, cred_t *cr, const dtrace_pops_t *pops, void *arg,
+ *          dtrace_provider_id_t *idp)
+ *
+ * 2.2.1  Overview
+ *
+ *   dtrace_register() registers the calling provider with the DTrace
+ *   framework.  It should generally be called by DTrace providers in their
+ *   attach(9E) entry point.
+ *
+ * 2.2.2  Arguments and Notes
+ *
+ *   The first argument is the name of the provider.  The second argument is a
+ *   pointer to the stability attributes for the provider.  The third argument
+ *   is the privilege flags for the provider, and must be some combination of:
+ *
+ *     DTRACE_PRIV_NONE     <= All users may enable probes from this provider
+ *
+ *     DTRACE_PRIV_PROC     <= Any user with privilege of PRIV_DTRACE_PROC may
+ *                             enable probes from this provider
+ *
+ *     DTRACE_PRIV_USER     <= Any user with privilege of PRIV_DTRACE_USER may
+ *                             enable probes from this provider
+ *
+ *     DTRACE_PRIV_KERNEL   <= Any user with privilege of PRIV_DTRACE_KERNEL
+ *                             may enable probes from this provider
+ *
+ *     DTRACE_PRIV_OWNER    <= This flag places an additional constraint on
+ *                             the privilege requirements above. These probes
+ *                             require either (a) a user ID matching the user
+ *                             ID of the cred passed in the fourth argument
+ *                             or (b) the PRIV_PROC_OWNER privilege.
+ *
+ *   Note that these flags designate the _visibility_ of the probes, not
+ *   the conditions under which they may or may not fire.
+ *
+ *   The fourth argument is the credential that is associated with the provider.
+ *   This argument should be NULL if the privilege flags don't include
+ *   DTRACE_PRIV_OWNER. If non-NULL, the framework stashes the uid represented
+ *   by this credential for use at probe-time, in implicit predicates. These
+ *   limit visibility of the probes to users which have sufficient privilege to
+ *   access them.
+ *
+ *   The fifth argument is a DTrace provider operations vector, which provides
+ *   the implementation for the Framework-to-Provider API.  (See Section 1,
+ *   above.)  This must be non-NULL, and each member must be non-NULL.  The
+ *   exceptions to this are (1) the dtps_provide() and dtps_provide_module()
+ *   members (if the provider so desires, _one_ of these members may be left
+ *   NULL -- denoting that the provider only implements the other) and (2)
+ *   the dtps_suspend() and dtps_resume() members, which must either both be
+ *   NULL or both be non-NULL.
+ *
+ *   The sixth argument is a cookie to be specified as the first argument for
+ *   each function in the Framework-to-Provider API.  This argument may have
+ *   any value.
+ *
+ *   The final argument is a pointer to dtrace_provider_id_t.  If
+ *   dtrace_register() successfully completes, the provider identifier will be
+ *   stored in the memory pointed to be this argument.  This argument must be
+ *   non-NULL.
+ *
+ * 2.2.3  Return value
+ *
+ *   On success, dtrace_register() returns 0 and stores the new provider's
+ *   identifier into the memory pointed to by the idp argument.  On failure,
+ *   dtrace_register() returns an errno:
+ *
+ *     EINVAL   The arguments passed to dtrace_register() were somehow invalid.
+ *              This may because a parameter that must be non-NULL was NULL,
+ *              because the name was invalid (either empty or an illegal
+ *              provider name) or because the attributes were invalid.
+ *
+ *   No other failure code is returned.
+ *
+ * 2.2.4  Caller's context
+ *
+ *   dtrace_register() may induce calls to dtrace_provide(); the provider must
+ *   hold no locks across dtrace_register() that may also be acquired by
+ *   dtrace_provide().  cpu_lock and mod_lock must not be held.
+ *
+ * 2.3  int dtrace_unregister(dtrace_provider_t id)
+ *
+ * 2.3.1  Overview
+ *
+ *   Unregisters the specified provider from the DTrace framework.  It should
+ *   generally be called by DTrace providers in their detach(9E) entry point.
+ *
+ * 2.3.2  Arguments and Notes
+ *
+ *   The only argument is the provider identifier, as returned from a
+ *   successful call to dtrace_register().  As a result of calling
+ *   dtrace_unregister(), the DTrace framework will call back into the provider
+ *   via the dtps_destroy() entry point.  Once dtrace_unregister() successfully
+ *   completes, however, the DTrace framework will no longer make calls through
+ *   the Framework-to-Provider API.
+ *
+ * 2.3.3  Return value
+ *
+ *   On success, dtrace_unregister returns 0.  On failure, dtrace_unregister()
+ *   returns an errno:
+ *
+ *     EBUSY    There are currently processes that have the DTrace pseudodevice
+ *              open, or there exists an anonymous enabling that hasn't yet
+ *              been claimed.
+ *
+ *   No other failure code is returned.
+ *
+ * 2.3.4  Caller's context
+ *
+ *   Because a call to dtrace_unregister() may induce calls through the
+ *   Framework-to-Provider API, the caller may not hold any lock across
+ *   dtrace_register() that is also acquired in any of the Framework-to-
+ *   Provider API functions.  Additionally, mod_lock may not be held.
+ *
+ * 2.4  void dtrace_invalidate(dtrace_provider_id_t id)
+ *
+ * 2.4.1  Overview
+ *
+ *   Invalidates the specified provider.  All subsequent probe lookups for the
+ *   specified provider will fail, but its probes will not be removed.
+ *
+ * 2.4.2  Arguments and note
+ *
+ *   The only argument is the provider identifier, as returned from a
+ *   successful call to dtrace_register().  In general, a provider's probes
+ *   always remain valid; dtrace_invalidate() is a mechanism for invalidating
+ *   an entire provider, regardless of whether or not probes are enabled or
+ *   not.  Note that dtrace_invalidate() will _not_ prevent already enabled
+ *   probes from firing -- it will merely prevent any new enablings of the
+ *   provider's probes.
+ *
+ * 2.5 int dtrace_condense(dtrace_provider_id_t id)
+ *
+ * 2.5.1  Overview
+ *
+ *   Removes all the unenabled probes for the given provider. This function is
+ *   not unlike dtrace_unregister(), except that it doesn't remove the
+ *   provider just as many of its associated probes as it can.
+ *
+ * 2.5.2  Arguments and Notes
+ *
+ *   As with dtrace_unregister(), the sole argument is the provider identifier
+ *   as returned from a successful call to dtrace_register().  As a result of
+ *   calling dtrace_condense(), the DTrace framework will call back into the
+ *   given provider's dtps_destroy() entry point for each of the provider's
+ *   unenabled probes.
+ *
+ * 2.5.3  Return value
+ *
+ *   Currently, dtrace_condense() always returns 0.  However, consumers of this
+ *   function should check the return value as appropriate; its behavior may
+ *   change in the future.
+ *
+ * 2.5.4  Caller's context
+ *
+ *   As with dtrace_unregister(), the caller may not hold any lock across
+ *   dtrace_condense() that is also acquired in the provider's entry points.
+ *   Also, mod_lock may not be held.
+ *
+ * 2.6 int dtrace_attached()
+ *
+ * 2.6.1  Overview
+ *
+ *   Indicates whether or not DTrace has attached.
+ *
+ * 2.6.2  Arguments and Notes
+ *
+ *   For most providers, DTrace makes initial contact beyond registration.
+ *   That is, once a provider has registered with DTrace, it waits to hear
+ *   from DTrace to create probes.  However, some providers may wish to
+ *   proactively create probes without first being told by DTrace to do so.
+ *   If providers wish to do this, they must first call dtrace_attached() to
+ *   determine if DTrace itself has attached.  If dtrace_attached() returns 0,
+ *   the provider must not make any other Provider-to-Framework API call.
+ *
+ * 2.6.3  Return value
+ *
+ *   dtrace_attached() returns 1 if DTrace has attached, 0 otherwise.
+ *
+ * 2.7  int dtrace_probe_create(dtrace_provider_t id, const char *mod,
+ *	    const char *func, const char *name, int aframes, void *arg)
+ *
+ * 2.7.1  Overview
+ *
+ *   Creates a probe with specified module name, function name, and name.
+ *
+ * 2.7.2  Arguments and Notes
+ *
+ *   The first argument is the provider identifier, as returned from a
+ *   successful call to dtrace_register().  The second, third, and fourth
+ *   arguments are the module name, function name, and probe name,
+ *   respectively.  Of these, module name and function name may both be NULL
+ *   (in which case the probe is considered to be unanchored), or they may both
+ *   be non-NULL.  The name must be non-NULL, and must point to a non-empty
+ *   string.
+ *
+ *   The fifth argument is the number of artificial stack frames that will be
+ *   found on the stack when dtrace_probe() is called for the new probe.  These
+ *   artificial frames will be automatically be pruned should the stack() or
+ *   stackdepth() functions be called as part of one of the probe's ECBs.  If
+ *   the parameter doesn't add an artificial frame, this parameter should be
+ *   zero.
+ *
+ *   The final argument is a probe argument that will be passed back to the
+ *   provider when a probe-specific operation is called.  (e.g., via
+ *   dtps_enable(), dtps_disable(), etc.)
+ *
+ *   Note that it is up to the provider to be sure that the probe that it
+ *   creates does not already exist -- if the provider is unsure of the probe's
+ *   existence, it should assure its absence with dtrace_probe_lookup() before
+ *   calling dtrace_probe_create().
+ *
+ * 2.7.3  Return value
+ *
+ *   dtrace_probe_create() always succeeds, and always returns the identifier
+ *   of the newly-created probe.
+ *
+ * 2.7.4  Caller's context
+ *
+ *   While dtrace_probe_create() is generally expected to be called from
+ *   dtps_provide() and/or dtps_provide_module(), it may be called from other
+ *   non-DTrace contexts.  Neither cpu_lock nor mod_lock may be held.
+ *
+ * 2.8  dtrace_id_t dtrace_probe_lookup(dtrace_provider_t id, const char *mod,
+ *	    const char *func, const char *name)
+ *
+ * 2.8.1  Overview
+ *
+ *   Looks up a probe based on provdider and one or more of module name,
+ *   function name and probe name.
+ *
+ * 2.8.2  Arguments and Notes
+ *
+ *   The first argument is the provider identifier, as returned from a
+ *   successful call to dtrace_register().  The second, third, and fourth
+ *   arguments are the module name, function name, and probe name,
+ *   respectively.  Any of these may be NULL; dtrace_probe_lookup() will return
+ *   the identifier of the first probe that is provided by the specified
+ *   provider and matches all of the non-NULL matching criteria.
+ *   dtrace_probe_lookup() is generally used by a provider to be check the
+ *   existence of a probe before creating it with dtrace_probe_create().
+ *
+ * 2.8.3  Return value
+ *
+ *   If the probe exists, returns its identifier.  If the probe does not exist,
+ *   return DTRACE_IDNONE.
+ *
+ * 2.8.4  Caller's context
+ *
+ *   While dtrace_probe_lookup() is generally expected to be called from
+ *   dtps_provide() and/or dtps_provide_module(), it may also be called from
+ *   other non-DTrace contexts.  Neither cpu_lock nor mod_lock may be held.
+ *
+ * 2.9  void *dtrace_probe_arg(dtrace_provider_t id, dtrace_id_t probe)
+ *
+ * 2.9.1  Overview
+ *
+ *   Returns the probe argument associated with the specified probe.
+ *
+ * 2.9.2  Arguments and Notes
+ *
+ *   The first argument is the provider identifier, as returned from a
+ *   successful call to dtrace_register().  The second argument is a probe
+ *   identifier, as returned from dtrace_probe_lookup() or
+ *   dtrace_probe_create().  This is useful if a probe has multiple
+ *   provider-specific components to it:  the provider can create the probe
+ *   once with provider-specific state, and then add to the state by looking
+ *   up the probe based on probe identifier.
+ *
+ * 2.9.3  Return value
+ *
+ *   Returns the argument associated with the specified probe.  If the
+ *   specified probe does not exist, or if the specified probe is not provided
+ *   by the specified provider, NULL is returned.
+ *
+ * 2.9.4  Caller's context
+ *
+ *   While dtrace_probe_arg() is generally expected to be called from
+ *   dtps_provide() and/or dtps_provide_module(), it may also be called from
+ *   other non-DTrace contexts.  Neither cpu_lock nor mod_lock may be held.
+ *
+ * 2.10  void dtrace_probe(dtrace_id_t probe, uintptr_t arg0, uintptr_t arg1,
+ *		uintptr_t arg2, uintptr_t arg3, uintptr_t arg4)
+ *
+ * 2.10.1  Overview
+ *
+ *   The epicenter of DTrace:  fires the specified probes with the specified
+ *   arguments.
+ *
+ * 2.10.2  Arguments and Notes
+ *
+ *   The first argument is a probe identifier as returned by
+ *   dtrace_probe_create() or dtrace_probe_lookup().  The second through sixth
+ *   arguments are the values to which the D variables "arg0" through "arg4"
+ *   will be mapped.
+ *
+ *   dtrace_probe() should be called whenever the specified probe has fired --
+ *   however the provider defines it.
+ *
+ * 2.10.3  Return value
+ *
+ *   None.
+ *
+ * 2.10.4  Caller's context
+ *
+ *   dtrace_probe() may be called in virtually any context:  kernel, user,
+ *   interrupt, high-level interrupt, with arbitrary adaptive locks held, with
+ *   dispatcher locks held, with interrupts disabled, etc.  The only latitude
+ *   that must be afforded to DTrace is the ability to make calls within
+ *   itself (and to its in-kernel subroutines) and the ability to access
+ *   arbitrary (but mapped) memory.  On some platforms, this constrains
+ *   context.  For example, on UltraSPARC, dtrace_probe() cannot be called
+ *   from any context in which TL is greater than zero.  dtrace_probe() may
+ *   also not be called from any routine which may be called by dtrace_probe()
+ *   -- which includes functions in the DTrace framework and some in-kernel
+ *   DTrace subroutines.  All such functions "dtrace_"; providers that
+ *   instrument the kernel arbitrarily should be sure to not instrument these
+ *   routines.
+ */
+
+#include <dtrace/types.h>
+#include <linux/module.h>
+#include <linux/dtrace/enabling_defines.h>
+#include <linux/dtrace/arg_defines.h>
+#include <dtrace/provider_defines.h>
+#include <linux/dtrace/stability.h>
+
+typedef struct dtrace_pops {
+	void (*dtps_provide)(void *, const struct dtrace_probedesc *);
+	void (*dtps_provide_module)(void *, struct module *);
+	int (*dtps_enable)(void *, dtrace_id_t, void *);
+	void (*dtps_disable)(void *, dtrace_id_t, void *);
+	void (*dtps_suspend)(void *, dtrace_id_t, void *);
+	void (*dtps_resume)(void *, dtrace_id_t, void *);
+	void (*dtps_getargdesc)(void *, dtrace_id_t, void *,
+				struct dtrace_argdesc *);
+	uint64_t (*dtps_getargval)(void *, dtrace_id_t, void *, int, int);
+	int (*dtps_usermode)(void *, dtrace_id_t, void *);
+	void (*dtps_destroy)(void *, dtrace_id_t, void *);
+	void (*dtps_destroy_module)(void *, struct module *);
+} dtrace_pops_t;
+
+typedef struct dtrace_helper_probedesc {
+	char *dthpb_mod;
+	char *dthpb_func;
+	char *dthpb_name;
+	uint64_t dthpb_base;
+	uint32_t *dthpb_offs;
+	uint32_t *dthpb_enoffs;
+	uint32_t dthpb_noffs;
+	uint32_t dthpb_nenoffs;
+	uint8_t *dthpb_args;
+	uint8_t dthpb_xargc;
+	uint8_t dthpb_nargc;
+	char *dthpb_xtypes;
+	char *dthpb_ntypes;
+} dtrace_helper_probedesc_t;
+
+typedef struct dtrace_helper_provdesc {
+	char *dthpv_provname;
+	struct dtrace_pattr dthpv_pattr;
+} dtrace_helper_provdesc_t;
+
+typedef struct dtrace_mops {
+	void (*dtms_create_probe)(void *, void *, dtrace_helper_probedesc_t *);
+	void *(*dtms_provide_pid)(void *, dtrace_helper_provdesc_t *, pid_t);
+	void (*dtms_remove_pid)(void *, dtrace_helper_provdesc_t *, pid_t);
+} dtrace_mops_t;
+
+/*
+ * DTrace Provider-to-Framework API Functions
+ */
+
+typedef struct dtrace_meta {
+	dtrace_mops_t dtm_mops;
+	char *dtm_name;
+	void *dtm_arg;
+	uint64_t dtm_count;
+} dtrace_meta_t;
+
+typedef struct dtrace_mprovider {
+	char			*dtmp_name;
+	char			*dtmp_pref;
+	dtrace_pattr_t		*dtmp_attr;
+	uint32_t		dtmp_priv;
+	dtrace_pops_t		*dtmp_pops;
+	dtrace_provider_id_t	dtmp_id;
+} dtrace_mprovider_t;
+
+typedef struct dtrace_pmod {
+	struct module		*mod;
+	struct list_head	list;
+} dtrace_pmod_t;
+
+extern int dtrace_register(const char *, const dtrace_pattr_t *, uint32_t,
+			   const cred_t *, const dtrace_pops_t *, void *,
+			   dtrace_provider_id_t *);
+extern int dtrace_unregister(dtrace_provider_id_t);
+extern void dtrace_invalidate(dtrace_provider_id_t);
+extern int dtrace_condense(dtrace_provider_id_t);
+extern int dtrace_attached(void);
+
+extern int dtrace_meta_register(const char *, const dtrace_mops_t *, void *,
+				dtrace_meta_provider_id_t *);
+extern int dtrace_meta_unregister(dtrace_meta_provider_id_t);
+
+extern dtrace_id_t dtrace_probe_create(dtrace_provider_id_t, const char *,
+				       const char *, const char *, int,
+				       void *);
+extern void *dtrace_probe_arg(dtrace_provider_id_t, dtrace_id_t);
+extern dtrace_id_t dtrace_probe_lookup(dtrace_provider_id_t, const char *,
+				       const char *, const char *);
+extern void dtrace_probe(dtrace_id_t, uintptr_t, uintptr_t, uintptr_t,
+			 uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+
+/*
+ * Provider creation.
+ */
+
+#define DT_PROVIDER_MODULE(name, priv)					\
+  dtrace_provider_id_t	name##_id;					\
+									\
+  static int name##_prov_exit(void)					\
+  {									\
+	  return (dtrace_unregister(name##_id) == 0);			\
+  }									\
+									\
+  static int __init name##_init(void)					\
+  {									\
+	int	ret = -ENOMEM;						\
+	dtrace_module_t *pdata = THIS_MODULE->pdata;			\
+									\
+	if (pdata == NULL)						\
+		goto failed;						\
+									\
+	ret = name##_dev_init();					\
+	if (ret)							\
+		goto failed;						\
+									\
+	ret = dtrace_register(__stringify(name), &name##_attr, priv,	\
+			      NULL, &name##_pops, NULL, &name##_id);	\
+	if (ret)							\
+		goto failed;						\
+									\
+	pdata->prov_exit = name##_prov_exit;				\
+									\
+	return 0;							\
+									\
+  failed:								\
+	return ret;							\
+  }									\
+									\
+  static void __exit name##_exit(void)					\
+  {									\
+	name##_dev_exit();						\
+  }									\
+									\
+  module_init(name##_init);						\
+  module_exit(name##_exit);
+
+#define DT_META_PROVIDER_MODULE(name)					\
+  dtrace_meta_provider_id_t	name##_id;				\
+									\
+  static int name##_prov_exit(void)					\
+  {									\
+	return (dtrace_meta_unregister(name##_id) == 0);		\
+  }									\
+									\
+  static int __init name##_init(void)					\
+  {									\
+	int	ret = -ENOMEM;						\
+	dtrace_module_t *pdata = THIS_MODULE->pdata;			\
+									\
+	if (pdata == NULL)						\
+		goto failed;						\
+									\
+	ret = name##_dev_init();					\
+	if (ret)							\
+		goto failed;						\
+									\
+	ret = dtrace_meta_register(__stringify(name), &name##_mops,	\
+				   NULL, &name##_id);			\
+	if (ret)							\
+		goto failed;						\
+									\
+	pdata->prov_exit = name##_prov_exit;				\
+									\
+	return 0;							\
+									\
+  failed:								\
+	return ret;							\
+  }									\
+									\
+  static void __exit name##_exit(void)					\
+  {									\
+	name##_dev_exit();						\
+  }									\
+									\
+  module_init(name##_init);						\
+  module_exit(name##_exit);
+
+#define DT_MULTI_PROVIDER_MODULE(name, plist)				\
+  static int name##_prov_exit(void)					\
+  {									\
+	int			ret = 0;				\
+	dtrace_mprovider_t	*prov;					\
+									\
+	for (prov = plist; prov->dtmp_name != NULL; prov++) {		\
+		if (prov->dtmp_id != DTRACE_PROVNONE) {			\
+			ret = dtrace_unregister(prov->dtmp_id);		\
+			if (ret != 0) {					\
+				pr_warning("Failed to unregister "	\
+					   "provider %s: %d",		\
+					   prov->dtmp_name, ret);	\
+				break;					\
+			}						\
+									\
+			prov->dtmp_id = DTRACE_PROVNONE;		\
+		}							\
+	}								\
+									\
+	return (ret == 0);						\
+  }									\
+									\
+  static int __init name##_init(void)					\
+  {									\
+	int			ret = -ENOMEM;				\
+	dtrace_mprovider_t	*prov;					\
+	dtrace_module_t		*pdata = THIS_MODULE->pdata;		\
+									\
+	if (pdata == NULL)						\
+		goto failed;						\
+									\
+	ret = name##_dev_init();					\
+	if (ret)							\
+		goto failed;						\
+									\
+	for (prov = plist; prov->dtmp_name != NULL; prov++) {		\
+		if (dtrace_register(prov->dtmp_name, prov->dtmp_attr,	\
+				    prov->dtmp_priv, NULL,		\
+				    prov->dtmp_pops, prov,		\
+				    &prov->dtmp_id) != 0)		\
+			pr_warning("Failed to register provider %s",	\
+				   prov->dtmp_name);			\
+	}								\
+									\
+	pdata->prov_exit = name##_prov_exit;				\
+									\
+	return 0;							\
+									\
+  failed:								\
+	return ret;							\
+  }									\
+									\
+  static void __exit name##_exit(void)					\
+  {									\
+	name##_dev_exit();						\
+  }									\
+									\
+  module_init(name##_init);						\
+  module_exit(name##_exit);
+
+
+#endif /* _DTRACE_PROVIDER_H */
diff --git a/include/dtrace/provider_defines.h b/include/dtrace/provider_defines.h
new file mode 100644
index 000000000000..89b7b83d2eb1
--- /dev/null
+++ b/include/dtrace/provider_defines.h
@@ -0,0 +1,42 @@
+/*
+ * Dynamic Tracing for Linux - Provider defines
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _DTRACE_PROVIDER_DEFINES_H
+#define _DTRACE_PROVIDER_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/cred.h>
+#include <linux/in6.h>
+
+typedef uintptr_t		dtrace_provider_id_t;
+typedef uintptr_t		dtrace_meta_provider_id_t;
+typedef struct cred	cred_t;
+typedef __be32		ipaddr_t;
+typedef ipaddr_t *	ipaddr_t_p;
+typedef struct in6_addr	in6_addr_t;
+
+struct dtrace_pops;
+struct dtrace_helper_probedesc;
+struct dtrace_helper_provdesc;
+struct dtrace_mops;
+struct dtrace_meta;
+
+#endif /* _DTRACE_PROVIDER_DEFINES_H */
diff --git a/include/dtrace/types.h b/include/dtrace/types.h
new file mode 100644
index 000000000000..be2663e6fa11
--- /dev/null
+++ b/include/dtrace/types.h
@@ -0,0 +1,130 @@
+/*
+ * Dynamic Tracing for Linux - Kernel Types
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _DTRACE_TYPES_H
+#define _DTRACE_TYPES_H
+
+/*
+ * This file contains types needed to parse the DTrace shared userspace/ kernel
+ * headers, and a few others (it has not been gardened to remove constants used
+ * only by the DTrace core).  Userspace has its own version of these types
+ * (mostly from <unistd.h>).
+ * 
+ * This file is compiled both in a normal kernel environment and in a peculiar
+ * halfway-house environment used for headers_checking of <ioctl.h>, in which
+ * among other things, no config.h symbols are available.  As a result, you
+ * should be careful about #including kernel headers here: many will break
+ * headers_check if added.  So far, it has always been sufficient to add them to
+ * dtrace/dtrace.h instead; if this turns out to be insufficient later (perhaps
+ * because DTrace core files cease to #include all of <dtrace.h>), the
+ * HEADERS_CHECK #define may prove useful to disable kernel-only portions of
+ * this file.
+ */
+
+#include <asm/bitsperlong.h>
+#include <linux/dtrace_os.h>
+
+typedef unsigned char	uchar_t;
+typedef unsigned int	uint_t;
+typedef unsigned long	ulong_t;
+
+typedef long		intptr_t;
+
+#define UINT8_MAX		(0xff)
+#define UINT8_MIN		0
+#define UINT16_MAX		(0xffff)
+#define UINT16_MIN		0
+#define UINT32_MAX		(0xffffffff)
+#define UINT32_MIN		0
+#define UINT64_MAX		(~0ULL)
+#define UINT64_MIN		(0)
+#define INT64_MAX		((long long)(~0ULL>>1))
+#define INT64_MIN		(-INT64_MAX - 1LL)
+
+#define NBBY			(__BITS_PER_LONG / sizeof (long))
+
+/*
+ * This is a bit unusual, but OpenSolaris seems to like it.  Basically, the
+ * values below are the number of time units (sec, milli, micro, nano) that
+ * comprise 1 second.  As such, it is the value of the respective multiplier.
+ */
+#define SEC			1
+#define MILLISEC		1000
+#define MICROSEC		1000000
+#define NANOSEC			1000000000
+
+typedef enum {
+	TRUE = -1,
+	FALSE = 0
+} boolean_t;
+
+
+#define DTRACE_ACCESS_KERNEL	0x1
+
+#define DTRACE_CRA_PROC				0x0001
+#define DTRACE_CRA_PROC_CONTROL			0x0002
+#define DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER	0x0004
+#define DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG	0x0010
+#define DTRACE_CRA_KERNEL			0x0020
+#define DTRACE_CRA_KERNEL_DESTRUCTIVE		0x0040
+
+#define DTRACE_CRA_ALL		(DTRACE_CRA_PROC | \
+				 DTRACE_CRA_PROC_CONTROL | \
+				 DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER | \
+				 DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG | \
+				 DTRACE_CRA_KERNEL | \
+				 DTRACE_CRA_KERNEL_DESTRUCTIVE)
+
+#define DTRACE_CRV_ALLPROC	0x01
+#define DTRACE_CRV_KERNEL	0x02
+#define DTRACE_CRV_ALL		(DTRACE_CRV_ALLPROC | DTRACE_CRV_KERNEL)
+
+#define DTRACE_MATCH_FAIL	-1
+#define DTRACE_MATCH_NEXT	0
+#define DTRACE_MATCH_DONE	1
+
+#define DTRACE_COND_OWNER	0x01
+#define DTRACE_COND_USERMODE	0x02
+
+#define P2ROUNDUP(x, a)	(-(-(x) & -(a)))
+
+#if (BITS_PER_LONG == 64) || defined(CONFIG_KTIME_SCALAR)
+#define KTIME_INIT(s, ns)	((s64)(s) * NSEC_PER_SEC + (s64)(ns))
+#else
+# define KTIME_INIT(n, ns)	{ .sec = (s), .nsec = (ns) }
+#endif
+#define ktime_lt(t0, t1)	(t0 < t1)
+#define ktime_le(t0, t1)	(t0 <= t1)
+#define ktime_ge(t0, t1)	(t0 >= t1)
+#define ktime_gt(t0, t1)	(t0 > t1)
+#define ktime_cp(t0, t1)	(t0 = t1)
+
+/*
+ * Translate between kernel config options and userspace-compatible definitions.
+ */
+#ifdef CONFIG_64BIT
+#define _LP64 1
+#endif
+#ifdef __LITTLE_ENDIAN 
+#define _LITTLE_ENDIAN 1
+#endif
+
+#endif /* _DTRACE_TYPES_H */
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index 1c8a8a2aedf7..9f4e9b589298 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -55,6 +55,9 @@ struct bio {
 						 * accessors.
 						 */
 	unsigned short		bi_flags;	/* status, etc and bvec pool number */
+#ifdef CONFIG_DTRACE
+	struct block_device     *bi_bdev_orig;  /* for kABI compatibility */
+#endif
 	unsigned short		bi_ioprio;
 	unsigned short		bi_write_hint;
 	blk_status_t		bi_status;
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index fb83dee528a1..1ecaf6b32b92 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -100,6 +100,7 @@ enum cpuhp_state {
 	CPUHP_AP_IRQ_ARMADA_XP_STARTING,
 	CPUHP_AP_IRQ_BCM2836_STARTING,
 	CPUHP_AP_ARM_MVEBU_COHERENCY,
+	CPUHP_AP_CYCLIC_STARTING,
 	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING,
 	CPUHP_AP_PERF_X86_STARTING,
 	CPUHP_AP_PERF_X86_AMD_IBS_STARTING,
diff --git a/include/linux/cyclic.h b/include/linux/cyclic.h
new file mode 100644
index 000000000000..eec5317e42e8
--- /dev/null
+++ b/include/linux/cyclic.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _CYCLIC_H_
+#define _CYCLIC_H_
+
+#include <linux/ktime.h>
+#include <linux/types.h>
+
+#define CY_LOW_LEVEL	0
+#define CY_LOCK_LEVEL	1
+#define CY_HIGH_LEVEL	2
+#define CY_SOFT_LEVELS	2
+#define CY_LEVELS	3
+
+typedef uintptr_t	cyclic_id_t;
+typedef uint16_t	cyc_level_t;
+typedef void		(*cyc_func_t)(uintptr_t);
+
+#define CYCLIC_NONE	((cyclic_id_t)0)
+
+typedef struct cyc_handler {
+	cyc_func_t cyh_func;
+	uintptr_t cyh_arg;
+	cyc_level_t cyh_level;
+} cyc_handler_t;
+
+#define CY_INTERVAL_INF (-1)
+
+typedef struct cyc_time {
+	ktime_t cyt_when;
+	ktime_t cyt_interval;
+} cyc_time_t;
+
+typedef struct cyc_omni_handler {
+	void (*cyo_online)(void *, uint32_t, cyc_handler_t *, cyc_time_t *);
+	void (*cyo_offline)(void *, uint32_t, void *);
+	void *cyo_arg;
+} cyc_omni_handler_t;
+
+extern cyclic_id_t cyclic_add(cyc_handler_t *, cyc_time_t *);
+extern cyclic_id_t cyclic_add_omni(cyc_omni_handler_t *);
+extern void cyclic_remove(cyclic_id_t);
+extern void cyclic_reprogram(cyclic_id_t, ktime_t);
+
+#endif /* _CYCLIC_H_ */
diff --git a/include/linux/dtrace/cpu_defines.h b/include/linux/dtrace/cpu_defines.h
new file mode 100644
index 000000000000..b6f87bd05bf5
--- /dev/null
+++ b/include/linux/dtrace/cpu_defines.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 2011-2014 Oracle, Inc. */
+
+#ifndef _LINUX_DTRACE_CPU_DEFINES_H_
+#define _LINUX_DTRACE_CPU_DEFINES_H_
+
+#include <linux/percpu.h>
+
+#define	CPUC_SIZE	(sizeof (uint16_t) + sizeof(uint8_t) + \
+			 sizeof(uintptr_t) + sizeof(struct mutex))
+#define CPUC_PADSIZE	(192 - CPUC_SIZE)
+
+#define per_cpu_core(cpu)	(&per_cpu(dtrace_cpu_core, (cpu)))
+#if 0
+# define this_cpu_core		(this_cpu_ptr(&dtrace_cpu_core))
+#else
+# define this_cpu_core		(per_cpu_core(smp_processor_id()))
+#endif
+
+#define DTRACE_CPUFLAG_ISSET(flag) \
+	(this_cpu_core->cpuc_dtrace_flags & (flag))
+
+#define DTRACE_CPUFLAG_SET(flag) \
+	(this_cpu_core->cpuc_dtrace_flags |= (flag))
+
+#define DTRACE_CPUFLAG_CLEAR(flag) \
+	(this_cpu_core->cpuc_dtrace_flags &= ~(flag))
+
+#define CPU_DTRACE_NOFAULT	0x0001
+#define CPU_DTRACE_DROP		0x0002
+#define CPU_DTRACE_BADADDR	0x0004
+#define CPU_DTRACE_BADALIGN	0x0008
+#define CPU_DTRACE_DIVZERO	0x0010
+#define CPU_DTRACE_ILLOP	0x0020
+#define CPU_DTRACE_NOSCRATCH	0x0040
+#define CPU_DTRACE_KPRIV	0x0080
+#define CPU_DTRACE_UPRIV	0x0100
+#define CPU_DTRACE_TUPOFLOW	0x0200
+#define CPU_DTRACE_ENTRY	0x0800
+#define CPU_DTRACE_BADSTACK	0x1000
+#define CPU_DTRACE_NOPF		0x2000
+#define CPU_DTRACE_PF_TRAPPED	0x4000
+#define CPU_DTRACE_PROBE_CTX	0x8000
+
+#define CPU_DTRACE_FAULT	(CPU_DTRACE_BADADDR | CPU_DTRACE_BADALIGN | \
+				 CPU_DTRACE_DIVZERO | CPU_DTRACE_ILLOP | \
+				 CPU_DTRACE_NOSCRATCH | CPU_DTRACE_KPRIV | \
+				 CPU_DTRACE_UPRIV | CPU_DTRACE_TUPOFLOW | \
+				 CPU_DTRACE_BADSTACK | CPU_DTRACE_PF_TRAPPED)
+#define CPU_DTRACE_ERROR	(CPU_DTRACE_FAULT | CPU_DTRACE_DROP)
+
+typedef uint32_t	processorid_t;
+typedef uint32_t	psetid_t;
+typedef uint32_t	chipid_t;
+typedef uint32_t	lgrp_id_t;
+
+struct cpu_core;
+struct cpuinfo;
+
+#define per_cpu_info(cpu)	(&per_cpu(dtrace_cpu_info, (cpu)))
+#define this_cpu_info		(this_cpu_ptr(&dtrace_cpu_info))
+
+#endif /* _LINUX_DTRACE_CPU_DEFINES_H_ */
diff --git a/include/linux/dtrace_cpu.h b/include/linux/dtrace_cpu.h
new file mode 100644
index 000000000000..c4ec33451aaa
--- /dev/null
+++ b/include/linux/dtrace_cpu.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_CPU_H_
+#define _LINUX_DTRACE_CPU_H_
+
+#ifdef CONFIG_DTRACE
+
+#include <linux/ktime.h>
+#include <linux/mutex.h>
+#include <linux/rwlock.h>
+#include <linux/dtrace_cpu_defines.h>
+#include <asm/dtrace_cpuinfo.h>
+
+typedef struct cpu_core {
+	uint16_t cpuc_dtrace_flags;
+	uint8_t cpuc_dcpc_intr_state;
+	uint8_t cpuc_pad[CPUC_PADSIZE];
+	uintptr_t cpuc_dtrace_illval;
+	struct mutex cpuc_pid_lock;
+
+	uintptr_t cpu_dtrace_caller;
+	struct pt_regs *cpu_dtrace_regs;
+	ktime_t cpu_dtrace_chillmark;
+	ktime_t cpu_dtrace_chilled;
+	rwlock_t cpu_ft_lock;
+	atomic64_t cpuc_sync_requests;
+	atomic64_t cpuc_in_probe_ctx;
+} cpu_core_t;
+
+DECLARE_PER_CPU_SHARED_ALIGNED(cpu_core_t, dtrace_cpu_core);
+
+typedef struct cpuinfo {
+	processorid_t cpu_id;
+	psetid_t cpu_pset;
+	chipid_t cpu_chip;
+	lgrp_id_t cpu_lgrp;
+	cpuinfo_arch_t *cpu_info;
+} cpuinfo_t;
+
+DECLARE_PER_CPU_SHARED_ALIGNED(cpuinfo_t, dtrace_cpu_info);
+
+extern void dtrace_cpu_init(void);
+
+#endif /* CONFIG_DTRACE */
+#endif /* _LINUX_DTRACE_CPU_H_ */
diff --git a/include/linux/dtrace_cpu_defines.h b/include/linux/dtrace_cpu_defines.h
new file mode 100644
index 000000000000..2b8305a2db4b
--- /dev/null
+++ b/include/linux/dtrace_cpu_defines.h
@@ -0,0 +1 @@
+#include <linux/dtrace/cpu_defines.h>
diff --git a/include/linux/dtrace_fbt.h b/include/linux/dtrace_fbt.h
new file mode 100644
index 000000000000..da18a4ed06cf
--- /dev/null
+++ b/include/linux/dtrace_fbt.h
@@ -0,0 +1,45 @@
+/* Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved. */
+
+#ifndef _LINUX_DTRACE_FBT_H
+#define _LINUX_DTRACE_FBT_H
+
+#include <linux/module.h>
+#include <asm/dtrace_arch.h>
+
+extern unsigned long dtrace_fbt_nfuncs __attribute__((weak));
+
+/*
+ * Prototype for callback function that handles the actual creation of FBT
+ * probes.
+ *
+ * Arguments to pass:
+ *	- Pointer to module the probe will belong to
+ *	- function name
+ *	- probe type (FBT_ENTRY or FBT_RETURN)
+ *	- probe subtype (arch-specific)
+ *	- address (location of the probe)
+ *	- offset from the function start
+ *	- return value from previous callback invocation
+ *	- cookie passed to dtrace_fbt_init
+ * Returns:
+ *	- generic pointer (only to be used to pass back in)
+ */
+#define FBT_ENTRY	0
+#define FBT_RETURN	1
+
+typedef void *(*fbt_add_probe_fn)(struct module *, char *, int, int,
+				  asm_instr_t *, uintptr_t, void *, void *);
+extern void dtrace_fbt_init(fbt_add_probe_fn, struct module *, void *);
+
+/*
+ * Dynamic blacklist routines.
+ */
+typedef struct dt_fbt_bl_entry dt_fbt_bl_entry_t;
+
+extern dt_fbt_bl_entry_t *dtrace_fbt_bl_add(unsigned long, const char *);
+extern dt_fbt_bl_entry_t *dtrace_fbt_bl_first(void);
+extern dt_fbt_bl_entry_t *dtrace_fbt_bl_next(dt_fbt_bl_entry_t *);
+extern unsigned long dtrace_fbt_bl_entry_addr(dt_fbt_bl_entry_t *);
+extern const char *dtrace_fbt_bl_entry_name(dt_fbt_bl_entry_t *);
+
+#endif /* _LINUX_DTRACE_FBT_H */
diff --git a/include/linux/dtrace_os.h b/include/linux/dtrace_os.h
new file mode 100644
index 000000000000..52ab68738944
--- /dev/null
+++ b/include/linux/dtrace_os.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_OS_H_
+#define _LINUX_DTRACE_OS_H_
+
+typedef uint32_t dtrace_id_t;
+
+#ifndef HEADERS_CHECK
+
+#ifdef CONFIG_DTRACE
+
+#include <linux/ktime.h>
+#include <linux/mm.h>
+#include <linux/notifier.h>
+#include <linux/timekeeper_internal.h>
+#if defined(CONFIG_DT_FASTTRAP) || defined(CONFIG_DT_FASTTRAP_MODULE)
+#include <linux/uprobes.h>
+#endif
+#include <asm/unistd.h>
+#include <linux/dtrace_cpu.h>
+
+#define DTRACE_IDNONE 0
+
+extern struct module	*dtrace_kmod;
+
+extern void dtrace_os_init(void);
+extern void dtrace_os_exit(void);
+
+extern void *dtrace_alloc_text(struct module *, unsigned long);
+extern void dtrace_free_text(void *);
+
+extern void dtrace_mod_pdata_alloc(struct module *);
+extern void dtrace_mod_pdata_free(struct module *);
+extern int dtrace_destroy_prov(struct module *);
+
+extern int dtrace_enable(void);
+extern void dtrace_disable(void);
+
+extern ktime_t dtrace_gethrtime(void);
+extern ktime_t dtrace_getwalltime(void);
+
+typedef enum dtrace_vtime_state {
+	DTRACE_VTIME_INACTIVE = 0,
+	DTRACE_VTIME_ACTIVE
+} dtrace_vtime_state_t;
+
+extern dtrace_vtime_state_t dtrace_vtime_active;
+
+typedef void for_each_module_fn(void *, struct module *);
+extern void dtrace_for_each_module(for_each_module_fn *fn, void *arg);
+
+extern void dtrace_update_time(struct timekeeper *);
+extern ktime_t dtrace_get_walltime(void);
+
+extern void dtrace_vtime_enable(void);
+extern void dtrace_vtime_disable(void);
+extern void dtrace_vtime_switch(struct task_struct *, struct task_struct *);
+
+#include <asm/dtrace_util.h>
+
+extern void dtrace_skip_instruction(struct pt_regs *);
+
+extern int dtrace_die_notifier(struct notifier_block *, unsigned long, void *);
+
+#define STACKTRACE_KERNEL	0x01
+#define STACKTRACE_USER		0x02
+#define STACKTRACE_TYPE		0x0f
+
+typedef struct stacktrace_state {
+	uint64_t	*pcs;
+	uint64_t	*fps;
+	int		limit;
+	int		depth;
+	int		flags;
+} stacktrace_state_t;
+
+extern void dtrace_stacktrace(stacktrace_state_t *);
+extern void dtrace_user_stacktrace(stacktrace_state_t *);
+extern void dtrace_handle_badaddr(struct pt_regs *);
+extern void dtrace_mod_pdata_init(dtrace_module_t *pdata);
+extern void dtrace_mod_pdata_cleanup(dtrace_module_t *pdata);
+
+/*
+ * This is only safe to call if we know this is a userspace fault
+ * or that the call happens after early boot.
+ */
+static inline int dtrace_no_pf(struct pt_regs *regs)
+{
+	if (unlikely(DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))) {
+		dtrace_handle_badaddr(regs);
+		return 1;
+	}
+
+	return 0;
+}
+
+extern void dtrace_task_reinit(struct task_struct *);
+extern void dtrace_task_init(struct task_struct *);
+extern void dtrace_task_fork(struct task_struct *, struct task_struct *);
+extern void dtrace_task_cleanup(struct task_struct *);
+
+extern void (*dtrace_helpers_cleanup)(struct task_struct *);
+extern void (*dtrace_fasttrap_probes_cleanup)(struct task_struct *);
+extern void (*dtrace_helpers_fork)(struct task_struct *,
+				   struct task_struct *);
+
+#if defined(CONFIG_DT_FASTTRAP) || defined(CONFIG_DT_FASTTRAP_MODULE)
+typedef struct fasttrap_machtp {
+	struct inode		*fmtp_ino;
+	loff_t			fmtp_off;
+	struct uprobe_consumer	fmtp_cns;
+} fasttrap_machtp_t;
+
+extern int (*dtrace_tracepoint_hit)(fasttrap_machtp_t *, struct pt_regs *);
+
+extern struct task_struct *register_pid_provider(pid_t);
+extern void unregister_pid_provider(pid_t);
+
+extern int dtrace_tracepoint_enable(pid_t, uintptr_t, fasttrap_machtp_t *);
+extern int dtrace_tracepoint_disable(pid_t, fasttrap_machtp_t *);
+#endif /* CONFIG_DT_FASTTRAP || CONFIG_DT_FASTTRAP_MODULE */
+
+#else
+
+/*
+ * See arch/x86/mm/fault.c.
+ */
+
+#define dtrace_no_pf(ignore) 0
+
+/*
+ * See kernel/timekeeper.c
+ */
+#define	dtrace_update_time(ignore)
+
+/*
+ * See kernel/dtrace/dtrace_os.c
+ */
+#define dtrace_mod_pdata_alloc(ignore)
+#define dtrace_mod_pdata_free(ignore)
+#define dtrace_destroy_prov(ignore) 1
+
+#endif /* CONFIG_DTRACE */
+
+#endif /* !HEADERS_CHECK */
+
+#endif /* _LINUX_DTRACE_OS_H_ */
diff --git a/include/linux/dtrace_psinfo.h b/include/linux/dtrace_psinfo.h
new file mode 100644
index 000000000000..f6091ab49575
--- /dev/null
+++ b/include/linux/dtrace_psinfo.h
@@ -0,0 +1,44 @@
+/* Copyright (C) 2011, 2012, 2013 Oracle, Inc. */
+
+#ifndef _LINUX_DTRACE_PSINFO_H_
+#define _LINUX_DTRACE_PSINFO_H_
+
+#define PR_PSARGS_SZ		80
+#define PR_ARGV_SZ		512
+#define PR_ENVP_SZ		512
+
+typedef struct dtrace_psinfo {
+/* Orabug 18383027 - Remove the conditionals at the next major UEK release. */
+#ifndef __GENKSYMS__
+	atomic_t usage;
+#endif
+	union {
+		unsigned long argc;
+		struct dtrace_psinfo *next;
+	};
+	char **argv;
+	unsigned long envc;
+	char **envp;
+	char psargs[PR_PSARGS_SZ];
+#ifndef __GENKSYMS__
+	void *ustack;
+#endif
+} dtrace_psinfo_t;
+
+extern void dtrace_psinfo_alloc(struct task_struct *);
+extern void dtrace_psinfo_free(struct task_struct *);
+
+#define get_psinfo(tsk)							      \
+	do {								      \
+		if (likely((tsk)->dtrace_psinfo))			      \
+			atomic_inc(&(tsk)->dtrace_psinfo->usage);	      \
+	} while (0)
+#define put_psinfo(tsk)							      \
+	do {								      \
+		if (likely((tsk)->dtrace_psinfo)) {			      \
+			if (atomic_dec_and_test(&(tsk)->dtrace_psinfo->usage))\
+				dtrace_psinfo_free(tsk);		      \
+		}							      \
+	} while (0)
+
+#endif /* _LINUX_DTRACE_PSINFO_H_ */
diff --git a/include/linux/dtrace_sdt.h b/include/linux/dtrace_sdt.h
new file mode 100644
index 000000000000..eb07e58629bc
--- /dev/null
+++ b/include/linux/dtrace_sdt.h
@@ -0,0 +1,38 @@
+/* Copyright (C) 2011-2014 Oracle, Inc. */
+
+#ifndef _DTRACE_SDT_H_
+#define	_DTRACE_SDT_H_
+
+#ifdef CONFIG_DTRACE
+#include <linux/module.h>
+#include <asm/dtrace_arch.h>
+
+/*
+ * SDT probe called relocation information for the core kernel, provided by
+ * .tmp_sdtinfo.S.
+ */
+typedef struct dtrace_sdt_probeinfo {
+	unsigned long		addr;
+	unsigned long		name_len;
+	unsigned long		func_len;
+	char			name[0];
+} __aligned(sizeof(unsigned long)) dtrace_sdt_probeinfo_t;
+
+extern unsigned long dtrace_sdt_nprobes __attribute__((weak));
+extern void *dtrace_sdt_probes __attribute__((weak));
+
+extern void dtrace_sdt_init(void);
+extern void dtrace_sdt_register(struct module *);
+extern void dtrace_sdt_register_module(struct module *,
+				       void *sdt_names_addr, size_t,
+				       void *sdt_args_addr, size_t);
+extern void dtrace_sdt_exit(void);
+
+/*
+ * Functions to be defined in arch/<arch>/kernel/dtrace_sdt.c
+ */
+extern void __init_or_module dtrace_sdt_nop_multi(asm_instr_t **, int *, int);
+extern void dtrace_sdt_init_arch(void);
+
+#endif	/* CONFIG_DTRACE */
+#endif	/* _DTRACE_SDT_H_ */
diff --git a/include/linux/dtrace_syscall.h b/include/linux/dtrace_syscall.h
new file mode 100644
index 000000000000..59756b62cca0
--- /dev/null
+++ b/include/linux/dtrace_syscall.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_SYSCALL_H_
+#define _LINUX_DTRACE_SYSCALL_H_
+
+#include <linux/types.h>
+#include <linux/types.h>
+#include <linux/dtrace_os.h>
+#include <asm/syscall.h>
+
+#define DTRACE_SYSCALL_STUB(t, n)      SCE_##t,
+enum dtrace_sce_id {
+        SCE_NONE = 0,
+#include <asm/dtrace_syscall.h>
+	SCE_nr_stubs
+};
+#undef DTRACE_SYSCALL_STUB
+
+#define DTRACE_SYSCALL_STUB(t, n) \
+	asmlinkage long dtrace_stub_##n(uintptr_t, uintptr_t, uintptr_t, \
+					uintptr_t, uintptr_t, uintptr_t, \
+					uintptr_t);
+#include <asm/dtrace_syscall.h>
+#undef DTRACE_SYSCALL_STUB
+
+typedef asmlinkage long (*dt_sys_call_t)(uintptr_t, uintptr_t, uintptr_t,
+					 uintptr_t, uintptr_t, uintptr_t,
+					 uintptr_t);
+
+typedef struct dtrace_syscalls {
+	const char	*name;
+	dtrace_id_t	stsy_entry;
+	dtrace_id_t	stsy_return;
+	dt_sys_call_t	stsy_underlying;
+	dt_sys_call_t	*stsy_tblent;
+} dtrace_syscalls_t;
+
+typedef void (*dtrace_systrace_probe_t)(dtrace_id_t, uintptr_t, uintptr_t,
+					uintptr_t, uintptr_t, uintptr_t,
+					uintptr_t, uintptr_t);
+
+typedef struct systrace_info {
+	dtrace_systrace_probe_t	*probep;
+	dtrace_systrace_probe_t	stub;
+	dt_sys_call_t		syscall;
+	dt_sys_call_t		stubs[SCE_nr_stubs];
+	dtrace_syscalls_t	sysent[NR_syscalls];
+} systrace_info_t;
+
+extern systrace_info_t *dtrace_syscalls_init(void);
+
+#endif /* _LINUX_DTRACE_SYSCALL_H_ */
diff --git a/include/linux/kallsyms.h b/include/linux/kallsyms.h
index 11dd93e42580..d3a94e6c3c80 100644
--- a/include/linux/kallsyms.h
+++ b/include/linux/kallsyms.h
@@ -8,6 +8,7 @@
 
 #include <linux/errno.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/stddef.h>
 
 #define KSYM_NAME_LEN 128
@@ -17,6 +18,20 @@
 struct module;
 
 #ifdef CONFIG_KALLSYMS
+/* To avoid using get_symbol_offset for every symbol, we carry prefix along. */
+struct kallsym_iter {
+	loff_t pos;
+	loff_t pos_mod_end;
+	unsigned long value;
+	unsigned int nameoff; /* If iterating in core kernel symbols. */
+	unsigned long size;
+	int builtin_module;
+	int exported;
+	char type;
+	char name[KSYM_NAME_LEN];
+	char module_name[MODULE_NAME_LEN];
+};
+
 /* Lookup the address for a symbol. Returns 0 if not found. */
 unsigned long kallsyms_lookup_name(const char *name);
 
@@ -46,6 +61,8 @@ extern void __print_symbol(const char *fmt, unsigned long address);
 int lookup_symbol_name(unsigned long addr, char *symname);
 int lookup_symbol_attrs(unsigned long addr, unsigned long *size, unsigned long *offset, char *modname, char *name);
 
+extern void kallsyms_iter_reset(struct kallsym_iter *, loff_t);
+extern int kallsyms_iter_update(struct kallsym_iter *, loff_t);
 #else /* !CONFIG_KALLSYMS */
 
 static inline unsigned long kallsyms_lookup_name(const char *name)
diff --git a/include/linux/ktime.h b/include/linux/ktime.h
index 0c8bd45c8206..9d025e404a76 100644
--- a/include/linux/ktime.h
+++ b/include/linux/ktime.h
@@ -170,6 +170,14 @@ static inline s64 ktime_divns(const ktime_t kt, s64 div)
 }
 #endif
 
+/*
+ * ktime_nz - Check whether a ktime_v variable is non-zero
+ */
+static inline int ktime_nz(const ktime_t kt)
+{
+	return kt != 0LL;
+}
+
 static inline s64 ktime_to_us(const ktime_t kt)
 {
 	return ktime_divns(kt, NSEC_PER_USEC);
diff --git a/include/linux/mm.h b/include/linux/mm.h
index f50deada0f5c..3a20a73a4724 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1357,6 +1357,10 @@ extern int access_remote_vm(struct mm_struct *mm, unsigned long addr,
 extern int __access_remote_vm(struct task_struct *tsk, struct mm_struct *mm,
 		unsigned long addr, void *buf, int len, unsigned int gup_flags);
 
+long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
+		      unsigned long start, unsigned long nr_pages,
+		      unsigned int foll_flags, struct page **pages,
+		      struct vm_area_struct **vmas, int *nonblocking);
 long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
 			    unsigned long start, unsigned long nr_pages,
 			    unsigned int gup_flags, struct page **pages,
@@ -1796,6 +1800,12 @@ static inline void pgtable_page_dtor(struct page *page)
 	__pte;						\
 })
 
+#define pte_is_locked(mm, pmd)				\
+({							\
+	spinlock_t *__ptl = pte_lockptr(mm, pmd);	\
+	spin_is_locked(__ptl);				\
+})
+
 #define pte_unmap_unlock(pte, ptl)	do {		\
 	spin_unlock(ptl);				\
 	pte_unmap(pte);					\
@@ -2383,6 +2393,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_MLOCK	0x1000	/* lock present pages */
 #define FOLL_REMOTE	0x2000	/* we are working on non-current tsk/mm */
 #define FOLL_COW	0x4000	/* internal GUP flag */
+#define FOLL_IMMED	0x08000000	/* fail if locking, or faulting pages in */
 
 static inline int vm_fault_to_errno(int vm_fault, int foll_flags)
 {
diff --git a/include/linux/module.h b/include/linux/module.h
index b1cc541f2ddf..c42ad95e6a8b 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -23,6 +23,8 @@
 #include <linux/percpu.h>
 #include <asm/module.h>
 
+#include <linux/sdt.h>
+
 /* In stripped ARM and x86-64 modules, ~ is surprisingly rare. */
 #define MODULE_SIG_STRING "~Module signature appended~\n"
 
@@ -458,6 +460,12 @@ struct module {
 	struct klp_modinfo *klp_info;
 #endif
 
+#ifdef CONFIG_DTRACE
+	sdt_probedesc_t *sdt_probes;
+	unsigned int sdt_probec;
+	void *pdata;
+#endif
+
 #ifdef CONFIG_MODULE_UNLOAD
 	/* What modules depend on me? */
 	struct list_head source_list;
@@ -553,7 +561,8 @@ bool each_symbol_section(bool (*fn)(const struct symsearch *arr,
 /* Returns 0 and fills in value, defined and namebuf, or -ERANGE if
    symnum out of range. */
 int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
-			char *name, char *module_name, int *exported);
+		       char *name, char *module_name, unsigned long *size,
+		       int *exported);
 
 /* Look for this name: can be of form module:name. */
 unsigned long module_kallsyms_lookup_name(const char *name);
@@ -712,8 +721,8 @@ static inline int lookup_module_symbol_attrs(unsigned long addr, unsigned long *
 }
 
 static inline int module_get_kallsym(unsigned int symnum, unsigned long *value,
-					char *type, char *name,
-					char *module_name, int *exported)
+				     char *type, char *name, char *module_name,
+				     unsigned long *size, int *exported)
 {
 	return -ERANGE;
 }
diff --git a/include/linux/mutex.h b/include/linux/mutex.h
index 153274f78402..2582976fbb7a 100644
--- a/include/linux/mutex.h
+++ b/include/linux/mutex.h
@@ -21,6 +21,10 @@
 #include <linux/osq_lock.h>
 #include <linux/debug_locks.h>
 
+#ifdef CONFIG_SMP
+# include <asm/current.h>
+#endif
+
 struct ww_acquire_ctx;
 
 /*
@@ -228,4 +232,16 @@ mutex_trylock_recursive(struct mutex *lock)
 	return mutex_trylock(lock);
 }
 
+#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_SMP)
+static inline int mutex_owned(struct mutex *lock)
+{
+	return mutex_is_locked(lock) && __mutex_owner(lock) == current;
+}
+#else
+static inline int mutex_owned(struct mutex *lock)
+{
+	return mutex_is_locked(lock);
+}
+#endif
+
 #endif /* __LINUX_MUTEX_H */
diff --git a/include/linux/poll.h b/include/linux/poll.h
index d384f12abdd5..b880f75769fc 100644
--- a/include/linux/poll.h
+++ b/include/linux/poll.h
@@ -29,7 +29,8 @@ struct poll_table_struct;
 /* 
  * structures and helpers for f_op->poll implementations
  */
-typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);
+typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *,
+	unsigned long fixed_event);
 
 /*
  * Do not touch the structure directly, use the access functions
@@ -43,7 +44,14 @@ typedef struct poll_table_struct {
 static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
 {
 	if (p && p->_qproc && wait_address)
-		p->_qproc(filp, wait_address, p);
+		p->_qproc(filp, wait_address, p, 0);
+}
+
+static inline void poll_wait_fixed(struct file * filp, wait_queue_head_t * wait_address, poll_table *p,
+	unsigned long fixed_event)
+{
+	if (p && p->_qproc && wait_address)
+		p->_qproc(filp, wait_address, p, fixed_event);
 }
 
 /*
@@ -76,6 +84,7 @@ static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)
 struct poll_table_entry {
 	struct file *filp;
 	unsigned long key;
+	unsigned long fixed_key;
 	wait_queue_entry_t wait;
 	wait_queue_head_t *wait_address;
 };
diff --git a/include/linux/rwlock_api_smp.h b/include/linux/rwlock_api_smp.h
index 5b9b84b20407..c985120f5867 100644
--- a/include/linux/rwlock_api_smp.h
+++ b/include/linux/rwlock_api_smp.h
@@ -5,6 +5,8 @@
 # error "please don't include this file directly"
 #endif
 
+#include <linux/sdt.h>
+
 /*
  * include/linux/rwlock_api_smp.h
  *
@@ -119,6 +121,8 @@ static inline int __raw_read_trylock(rwlock_t *lock)
 	preempt_disable();
 	if (do_raw_read_trylock(lock)) {
 		rwlock_acquire_read(&lock->dep_map, 0, 1, _RET_IP_);
+		DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+				DTRACE_LOCKSTAT_RW_READER);
 		return 1;
 	}
 	preempt_enable();
@@ -130,6 +134,8 @@ static inline int __raw_write_trylock(rwlock_t *lock)
 	preempt_disable();
 	if (do_raw_write_trylock(lock)) {
 		rwlock_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+		DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+				DTRACE_LOCKSTAT_RW_WRITER);
 		return 1;
 	}
 	preempt_enable();
@@ -148,6 +154,8 @@ static inline void __raw_read_lock(rwlock_t *lock)
 	preempt_disable();
 	rwlock_acquire_read(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 }
 
 static inline unsigned long __raw_read_lock_irqsave(rwlock_t *lock)
@@ -159,6 +167,8 @@ static inline unsigned long __raw_read_lock_irqsave(rwlock_t *lock)
 	rwlock_acquire_read(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED_FLAGS(lock, do_raw_read_trylock, do_raw_read_lock,
 			     do_raw_read_lock_flags, &flags);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 	return flags;
 }
 
@@ -168,6 +178,8 @@ static inline void __raw_read_lock_irq(rwlock_t *lock)
 	preempt_disable();
 	rwlock_acquire_read(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 }
 
 static inline void __raw_read_lock_bh(rwlock_t *lock)
@@ -175,6 +187,8 @@ static inline void __raw_read_lock_bh(rwlock_t *lock)
 	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 	rwlock_acquire_read(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_read_trylock, do_raw_read_lock);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 }
 
 static inline unsigned long __raw_write_lock_irqsave(rwlock_t *lock)
@@ -186,6 +200,8 @@ static inline unsigned long __raw_write_lock_irqsave(rwlock_t *lock)
 	rwlock_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED_FLAGS(lock, do_raw_write_trylock, do_raw_write_lock,
 			     do_raw_write_lock_flags, &flags);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 	return flags;
 }
 
@@ -195,6 +211,8 @@ static inline void __raw_write_lock_irq(rwlock_t *lock)
 	preempt_disable();
 	rwlock_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_write_trylock, do_raw_write_lock);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 }
 
 static inline void __raw_write_lock_bh(rwlock_t *lock)
@@ -202,6 +220,8 @@ static inline void __raw_write_lock_bh(rwlock_t *lock)
 	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 	rwlock_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_write_trylock, do_raw_write_lock);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 }
 
 static inline void __raw_write_lock(rwlock_t *lock)
@@ -209,6 +229,8 @@ static inline void __raw_write_lock(rwlock_t *lock)
 	preempt_disable();
 	rwlock_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_write_trylock, do_raw_write_lock);
+	DTRACE_LOCKSTAT(rw__acquire, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 }
 
 #endif /* CONFIG_PREEMPT */
@@ -217,6 +239,8 @@ static inline void __raw_write_unlock(rwlock_t *lock)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_write_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 	preempt_enable();
 }
 
@@ -224,6 +248,8 @@ static inline void __raw_read_unlock(rwlock_t *lock)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_read_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 	preempt_enable();
 }
 
@@ -232,6 +258,8 @@ __raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_read_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 	local_irq_restore(flags);
 	preempt_enable();
 }
@@ -240,6 +268,8 @@ static inline void __raw_read_unlock_irq(rwlock_t *lock)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_read_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 	local_irq_enable();
 	preempt_enable();
 }
@@ -248,6 +278,8 @@ static inline void __raw_read_unlock_bh(rwlock_t *lock)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_read_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_READER);
 	__local_bh_enable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 }
 
@@ -256,6 +288,8 @@ static inline void __raw_write_unlock_irqrestore(rwlock_t *lock,
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_write_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 	local_irq_restore(flags);
 	preempt_enable();
 }
@@ -264,6 +298,8 @@ static inline void __raw_write_unlock_irq(rwlock_t *lock)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_write_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 	local_irq_enable();
 	preempt_enable();
 }
@@ -272,6 +308,8 @@ static inline void __raw_write_unlock_bh(rwlock_t *lock)
 {
 	rwlock_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_write_unlock(lock);
+	DTRACE_LOCKSTAT(rw__release, struct rwlock *, lock, int,
+			DTRACE_LOCKSTAT_RW_WRITER);
 	__local_bh_enable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 }
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index fdf74f27acf1..55223d7ce7b6 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -27,6 +27,7 @@
 #include <linux/signal_types.h>
 #include <linux/mm_types_task.h>
 #include <linux/task_io_accounting.h>
+#include <linux/dtrace_psinfo.h>
 
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
@@ -1068,7 +1069,18 @@ struct task_struct {
 	/* Number of pages to reclaim on returning to userland: */
 	unsigned int			memcg_nr_pages_over_high;
 #endif
+#ifdef CONFIG_DTRACE
+	uint32_t predcache;
+	ktime_t dtrace_vtime;
+	ktime_t dtrace_start;
+	uint8_t dtrace_stop;
+	uint8_t dtrace_sig;
+	dtrace_psinfo_t *dtrace_psinfo;
 
+	void *dtrace_helpers;
+	uint32_t dtrace_probes;
+	uint64_t dtrace_tp_count;
+#endif
 #ifdef CONFIG_UPROBES
 	struct uprobe_task		*utask;
 #endif
diff --git a/include/linux/sdt.h b/include/linux/sdt.h
new file mode 100644
index 000000000000..93bcb1af814c
--- /dev/null
+++ b/include/linux/sdt.h
@@ -0,0 +1,185 @@
+/* Copyright (C) 2011 -- 2016 Oracle, Inc. */
+
+#ifndef _LINUX_SDT_H_
+#define	_LINUX_SDT_H_
+
+#include <linux/sdt_internal.h>
+
+#if IS_ENABLED(CONFIG_DT_SDT)
+
+#include <asm/dtrace_sdt_arch.h>
+#include <linux/stringify.h>
+
+#define	DTRACE_PROBE(name, ...)	{				\
+	extern int __dtrace_probe_##name(__DTRACE_TYPE_APPLY_DEFAULT(__DTRACE_UINTPTR_EACH, void, ## __VA_ARGS__)); \
+	(void)__dtrace_probe_##name(__DTRACE_ARG_APPLY(__DTRACE_UINTCAST_EACH, ## __VA_ARGS__)); \
+	asm volatile(".pushsection _dtrace_sdt_names, \"a\", @progbits\n" \
+		     ".ascii \"" __stringify(name) "\"\n"		\
+		     ".byte 0\n"					\
+		     ".popsection\n"					\
+		     ".pushsection _dtrace_sdt_args, \"a\", @progbits\n" \
+		     __DTRACE_TYPE_APPLY_NOCOMMA(__DTRACE_TYPE_EACH, ## __VA_ARGS__) \
+		     ".byte 0\n"					\
+		     ".popsection\n");					\
+}
+
+#define	DTRACE_PROBE_ENABLED(name)	unlikely(({			\
+	extern int __dtrace_isenabled_##name(__DTRACE_SDT_ISENABLED_PROTO); \
+	__dtrace_isenabled_##name(__DTRACE_SDT_ISENABLED_ARGS);		\
+}))
+
+#ifdef CONFIG_DT_SDT_PERF
+
+#define __DTRACE_UINTPTR_CAST_EACH(x) ({				\
+  union {								\
+    typeof((x)) __val;							\
+    unsigned char __c;							\
+    unsigned short __s;							\
+    unsigned int __i;							\
+    unsigned long __l;							\
+    unsigned long long __ll; } __u = { .__val = (x) };			\
+  __builtin_choose_expr(sizeof(__u.__val) == sizeof(__u.__c), __u.__c,	\
+  __builtin_choose_expr(sizeof(__u.__val) == sizeof(__u.__s), __u.__s, 	\
+  __builtin_choose_expr(sizeof(__u.__val) == sizeof(__u.__i), __u.__i, 	\
+  __builtin_choose_expr(sizeof(__u.__val) == sizeof(__u.__l), __u.__l, 	\
+  __builtin_choose_expr(sizeof(__u.__val) == sizeof(__u.__ll), __u.__ll,\
+  (uintptr_t)&(__u.__val))))));})
+
+#define DTRACE_PROBE_TRACEPOINT(name, ...) {				\
+	extern void __dtrace_probe___perf_##name(__DTRACE_APPLY(__DTRACE_UINTPTR_EACH, ## __VA_ARGS__)); \
+	__dtrace_probe___perf_##name(__DTRACE_APPLY(__DTRACE_UINTPTR_CAST_EACH, ## __VA_ARGS__));	\
+}
+
+#define DTRACE_PROTO_TRACEPOINT(name, ...) {				\
+	asm volatile(".pushsection _dtrace_sdt_names, \"a\", @progbits\n"\
+		     ".ascii \"" __stringify(__perf_##name) "\"\n"	\
+		     ".byte 0\n"					\
+		     ".popsection\n"					\
+		     ".pushsection _dtrace_sdt_args, \"a\", @progbits\n" \
+		     ".ascii \"" __stringify(__VA_ARGS__) "\"\n"	\
+		     ".byte 0\n"					\
+		     ".popsection\n");					\
+}
+#else
+
+#define DTRACE_PROBE_TRACEPOINT(name, ...)
+#define DTRACE_PROTO_TRACEPOINT(name, ...)
+
+#endif
+
+#else /* ! IS_ENABLED(CONFIG_DT_SDT) */
+
+/*
+ * This apparently redundant call serves to validate the DTRACE_PROBE has the
+ * right number of args even when dtrace is turned off.
+ */
+#define	DTRACE_PROBE(name, ...)						\
+	__DTRACE_DOUBLE_APPLY_NOCOMMA(__DTRACE_NONE, __DTRACE_NONE, ## __VA_ARGS__)	\
+	do { } while (0)
+#define	DTRACE_PROBE_ENABLED(name) 0
+#define DTRACE_PROBE_TRACEPOINT(name, ...)
+#define DTRACE_PROTO_TRACEPOINT(name, ...)
+
+#endif /* IS_ENABLED(CONFIG_DT_SDT) */
+
+#ifdef CONFIG_DTRACE
+
+typedef struct sdt_probedesc {
+	char			*sdpd_name;	/* probe name */
+	char			*sdpd_func;	/* probe function */
+#ifndef __GENKSYMS__
+	const char		*sdpd_args;	/* arg string */
+#endif
+	unsigned long		sdpd_offset;	/* offset of call in text */
+	struct sdt_probedesc	*sdpd_next;	/* next static probe */
+} sdt_probedesc_t;
+
+#endif /* CONFIG_DTRACE */
+
+#define	DTRACE_SCHED(name, ...)						\
+	DTRACE_PROBE(__sched_##name, ## __VA_ARGS__);
+
+#define	DTRACE_PROC(name, ...)						\
+	DTRACE_PROBE(__proc_##name, ## __VA_ARGS__);
+
+#define	DTRACE_IO(name, ...)						\
+	DTRACE_PROBE(__io_##name, ## __VA_ARGS__);
+
+#define	DTRACE_IO_ENABLED(name)						\
+	DTRACE_PROBE_ENABLED(__io_##name)
+
+#define	DTRACE_ISCSI(name, ...)						\
+	DTRACE_PROBE(__iscsi_##name, ## __VA_ARGS__);
+
+#define	DTRACE_NFSV3(name, ...)						\
+	DTRACE_PROBE(__nfsv3_##name, ## __VA_ARGS__);
+
+#define	DTRACE_NFSV4(name, ...)						\
+	DTRACE_PROBE(__nfsv4_##name, ## __VA_ARGS__);
+
+#define	DTRACE_SMB(name, ...)						\
+	DTRACE_PROBE(__smb_##name, ## __VA_ARGS__);
+
+/*
+ * These definitions are used at probe points to specify the traffic direction;
+ * this helps simplify argument translation.
+ */
+#define	DTRACE_NET_PROBE_OUTBOUND	0x0
+#define	DTRACE_NET_PROBE_INBOUND	0x1
+
+#define	DTRACE_IP(name, ...)						\
+	DTRACE_PROBE(__ip_##name, ## __VA_ARGS__);
+
+/*
+ * Default DTRACE_TCP() and DTRACE_UDP() provider definitions specify the
+ * probe point within an is-enabled predicate.  This is to avoid the overhead
+ * incurred during argument dereferencing (e.g. calls to ip_hdr(skb)), along
+ * with any conditional evaluation (which would require branching) when the
+ * probe is disabled.
+ *
+ * Because some TCP probe points require additional argument preparation,
+ * we also define the is-enabled predicate directly as
+ * DTRACE_TCP_ENABLED(probename) along with a probe point which does not
+ * the probe in an is-enabled predicate; this allows us to handle cases such
+ * as this:
+ *
+ * if (DTRACE_TCP_ENABLED(state__change)) {
+ *      ...argument preparation...
+ *      DTRACE_TCP_NOCHECK(state__change, ...);
+ * }
+ */
+
+#define	DTRACE_TCP(name, ...)						\
+	if (DTRACE_PROBE_ENABLED(__tcp_##name))				\
+		DTRACE_PROBE(__tcp_##name, ## __VA_ARGS__)
+#define	DTRACE_TCP_ENABLED(name)					\
+	DTRACE_PROBE_ENABLED(__tcp_##name)
+#define	DTRACE_TCP_NOCHECK(name, ...)					\
+	DTRACE_PROBE(__tcp_##name, ## __VA_ARGS__);
+
+#define	DTRACE_UDP(name, ...)						\
+	if (DTRACE_PROBE_ENABLED(__udp_##name))				\
+		DTRACE_PROBE(__udp_##name, ## __VA_ARGS__);
+
+#define	DTRACE_SYSEVENT(name, ...)					\
+	DTRACE_PROBE(__sysevent_##name, ## __VA_ARGS__);
+
+#define	DTRACE_XPV(name, ...)						\
+	DTRACE_PROBE(__xpv_##name, ## __VA_ARGS__);
+
+#define	DTRACE_FC(name, ...)						\
+	DTRACE_PROBE(__fc_##name, ## __VA_ARGS__);
+
+#define	DTRACE_SRP(name, ...)						\
+	DTRACE_PROBE(__srp_##name, ## __VA_ARGS__);
+
+#define	DTRACE_LOCKSTAT_ENABLED(name)					\
+	DTRACE_PROBE_ENABLED(__lockstat_##name)
+
+#define	DTRACE_LOCKSTAT(name, ...)					\
+	DTRACE_PROBE(__lockstat_##name, ## __VA_ARGS__)
+
+#define	DTRACE_LOCKSTAT_RW_WRITER	0
+#define	DTRACE_LOCKSTAT_RW_READER	1
+
+#endif	/* _LINUX_SDT_H_ */
diff --git a/include/linux/sdt_internal.h b/include/linux/sdt_internal.h
new file mode 100644
index 000000000000..21dbe5c5b52b
--- /dev/null
+++ b/include/linux/sdt_internal.h
@@ -0,0 +1,153 @@
+/*
+ * Hide away all the terrible macro magic.
+ *
+ * Copyright (C) 2016 Oracle, Inc.
+ */
+
+#ifndef _LINUX_SDT_INTERNAL_H_
+#define _LINUX_SDT_INTERNAL_H_
+
+#include <linux/types.h>
+
+/*
+ * This counts the number of args.
+ */
+#define __DTRACE_NARGS_SEQ(dummy,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,N,...) N
+#define __DTRACE_NARGS(...)						\
+	__DTRACE_NARGS_SEQ(dummy, ##__VA_ARGS__, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
+
+/*
+ * This will let macros expand before concatting them.
+ */
+#define __DTRACE_PRIMITIVE_CAT(x, y) x ## y
+#define __DTRACE_CAT(x, y) __DTRACE_PRIMITIVE_CAT(x, y)
+
+#define __DTRACE_COMMA ,
+#define __DTRACE_NO_COMMA
+#define __DTRACE_NONE(x)
+
+/*
+ * This will call two macros on each argument-pair passed in (the first two args
+ * are the names of the macros to call).  Its TYPE and NAME variants will throw
+ * away the name and type arguments, respectively. __DTRACE_*_APPLY_NOCOMMA
+ * are like DTRACE_*_APPLY, but also omit the comma between arguments in the
+ * expansion of the macro.  DTRACE_TYPE_APPLY_DEFAULT lets you specify a default
+ * if no variadic args are provided.
+ */
+#define __DTRACE_DOUBLE_APPLY(type_macro, arg_macro, ...)		\
+	__DTRACE_CAT(__DTRACE_DOUBLE_APPLY_,				\
+		     __DTRACE_NARGS(__VA_ARGS__))(type_macro,		\
+						  arg_macro, __DTRACE_COMMA, \
+						  __DTRACE_COMMA, , ## __VA_ARGS__)
+#define __DTRACE_DOUBLE_APPLY_NOCOMMA(type_macro, arg_macro, ...)		\
+	__DTRACE_CAT(__DTRACE_DOUBLE_APPLY_,				\
+		     __DTRACE_NARGS(__VA_ARGS__))(type_macro,		\
+						  arg_macro, __DTRACE_NO_COMMA, \
+						  __DTRACE_NO_COMMA, , ## __VA_ARGS__)
+#define __DTRACE_TYPE_APPLY(type_macro, ...)				\
+	__DTRACE_CAT(__DTRACE_DOUBLE_APPLY_,				\
+		     __DTRACE_NARGS(__VA_ARGS__))(type_macro,		\
+						  __DTRACE_NONE, __DTRACE_NO_COMMA, \
+						  __DTRACE_COMMA, , ## __VA_ARGS__)
+#define __DTRACE_TYPE_APPLY_NOCOMMA(type_macro, ...)			\
+	__DTRACE_CAT(__DTRACE_DOUBLE_APPLY_,				\
+		     __DTRACE_NARGS(__VA_ARGS__))(type_macro,		\
+						  __DTRACE_NONE, __DTRACE_NO_COMMA, \
+						  __DTRACE_NO_COMMA, , ## __VA_ARGS__)
+#define __DTRACE_TYPE_APPLY_DEFAULT(type_macro, def, ...)		\
+	__DTRACE_CAT(__DTRACE_DOUBLE_APPLY_,				\
+		     __DTRACE_NARGS(__VA_ARGS__))(type_macro,		\
+						  __DTRACE_NONE, __DTRACE_NO_COMMA, \
+						  __DTRACE_COMMA, def, ## __VA_ARGS__)
+#define __DTRACE_ARG_APPLY(arg_macro, ...)				\
+	__DTRACE_CAT(__DTRACE_DOUBLE_APPLY_,				\
+		     __DTRACE_NARGS(__VA_ARGS__))(__DTRACE_NONE,	\
+						  arg_macro, __DTRACE_NO_COMMA,	\
+						  __DTRACE_COMMA, , ## __VA_ARGS__)
+#define __DTRACE_DOUBLE_APPLY_0(t, a, comma_t, comma_a, def) def
+#define __DTRACE_DOUBLE_APPLY_2(t, a, comma_t, comma_a, def, type1, arg1) \
+	t(type1) comma_t a(arg1)
+#define __DTRACE_DOUBLE_APPLY_4(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2)
+#define __DTRACE_DOUBLE_APPLY_6(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2, type3, arg3) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2) comma_a \
+	t(type3) comma_t a(arg3)
+#define __DTRACE_DOUBLE_APPLY_8(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2, type3, arg3, type4, arg4) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2) comma_a \
+	t(type3) comma_t a(arg3) comma_a t(type4) comma_t a(arg4)
+#define __DTRACE_DOUBLE_APPLY_10(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2) comma_a \
+	t(type3) comma_t a(arg3) comma_a t(type4) comma_t a(arg4) comma_a \
+	t(type5) comma_t a(arg5)
+#define __DTRACE_DOUBLE_APPLY_12(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5, type6, arg6) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2) comma_a \
+	t(type3) comma_t a(arg3) comma_a t(type4) comma_t a(arg4) comma_a \
+	t(type5) comma_t a(arg5) comma_a t(type6) comma_t a(arg6)
+#define __DTRACE_DOUBLE_APPLY_14(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5, type6, arg6, type7, arg7) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2) comma_a \
+	t(type3) comma_t a(arg3) comma_a t(type4) comma_t a(arg4) comma_a \
+	t(type5) comma_t a(arg5) comma_a t(type6) comma_t a(arg6) comma_a \
+	t(type7) comma_t a(arg7)
+#define __DTRACE_DOUBLE_APPLY_16(t, a, comma_t, comma_a, def, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5, type6, arg6, type7, arg7, type8, arg8) \
+	t(type1) comma_t a(arg1) comma_a t(type2) comma_t a(arg2) comma_a \
+	t(type3) comma_t a(arg3) comma_a t(type4) comma_t a(arg4) comma_a \
+	t(type5) comma_t a(arg5) comma_a t(type6) comma_t a(arg6) comma_a \
+	t(type7) comma_t a(arg7) comma_a t(type8) comma_t a(arg8)
+
+#define __DTRACE_DOUBLE_APPLY_ERROR Error: type specified without arg.
+#define __DTRACE_DOUBLE_APPLY_1 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_3 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_5 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_7 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_9 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_11 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_13 __DTRACE_DOUBLE_APPLY_ERROR
+#define __DTRACE_DOUBLE_APPLY_15 __DTRACE_DOUBLE_APPLY_ERROR
+
+#define __DTRACE_UINTPTR_EACH(x) uintptr_t
+
+#define __DTRACE_UINTCAST_EACH(x) (uintptr_t)(x)
+#define __DTRACE_TYPE_EACH(x) ".ascii \"" __stringify(x) ",\"\n"
+
+/*
+ * Convert everything to the appropriate integral type, unless too large to fit
+ * into any of them, in which case its address is taken instead.
+ */
+
+/*
+ * This will call a macro on each argument passed in, with optional default for
+ * zero args.
+ */
+#define __DTRACE_APPLY(macro, ...) __DTRACE_CAT(__DTRACE_APPLY_, __DTRACE_NARGS(__VA_ARGS__))(macro, , ## __VA_ARGS__)
+#define __DTRACE_APPLY_DEFAULT(macro, def, ...) __DTRACE_CAT(__DTRACE_APPLY_, __DTRACE_NARGS(__VA_ARGS__))(macro, def, ## __VA_ARGS__)
+#define __DTRACE_APPLY_0(m, def) def
+#define __DTRACE_APPLY_1(m, def, x1) m(x1)
+#define __DTRACE_APPLY_2(m, def, x1, x2) m(x1), m(x2)
+#define __DTRACE_APPLY_3(m, def, x1, x2, x3) m(x1), m(x2), m(x3)
+#define __DTRACE_APPLY_4(m, def, x1, x2, x3, x4) m(x1), m(x2), m(x3), m(x4)
+#define __DTRACE_APPLY_5(m, def, x1, x2, x3, x4, x5) m(x1), m(x2), m(x3), m(x4), m(x5)
+#define __DTRACE_APPLY_6(m, def, x1, x2, x3, x4, x5, x6) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6)
+#define __DTRACE_APPLY_7(m, def, x1, x2, x3, x4, x5, x6, x7) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7)
+#define __DTRACE_APPLY_8(m, def, x1, x2, x3, x4, x5, x6, x7, x8) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+
+/*
+ * DTrace probe args currently top out at 8, but this is purely
+ * arbitrary. However, there are existing perf tracepoints that pass as many as
+ * 18 arguments, so we must extend APPLY that far.
+ */
+
+#define __DTRACE_APPLY_9(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_10(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_11(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_12(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_13(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_14(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_15(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_16(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_17(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+#define __DTRACE_APPLY_18(m, def, x1, x2, x3, x4, x5, x6, x7, x8, ...) m(x1), m(x2), m(x3), m(x4), m(x5), m(x6), m(x7), m(x8)
+
+/* Needed for lockstat probes where we cannot include ktime.h */
+extern u64 dtrace_gethrtime_ns(void);
+
+#endif	/* _LINUX_SDT_INTERNAL_H */
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 042968dd98f0..d79656a5e909 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -414,6 +414,7 @@ int unhandled_signal(struct task_struct *tsk, int sig);
 
 void signals_init(void);
 
+int do_sigaltstack(const stack_t __user *, stack_t __user *, unsigned long);
 int restore_altstack(const stack_t __user *);
 int __save_altstack(stack_t __user *, unsigned long);
 
diff --git a/include/linux/spinlock_api_smp.h b/include/linux/spinlock_api_smp.h
index 42dfab89e740..1f572f62e86a 100644
--- a/include/linux/spinlock_api_smp.h
+++ b/include/linux/spinlock_api_smp.h
@@ -5,6 +5,8 @@
 # error "please don't include this file directly"
 #endif
 
+#include <linux/sdt.h>
+
 /*
  * include/linux/spinlock_api_smp.h
  *
@@ -88,6 +90,7 @@ static inline int __raw_spin_trylock(raw_spinlock_t *lock)
 	preempt_disable();
 	if (do_raw_spin_trylock(lock)) {
 		spin_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+		DTRACE_LOCKSTAT(spin__acquire, spinlock_t *, lock);
 		return 1;
 	}
 	preempt_enable();
@@ -118,6 +121,7 @@ static inline unsigned long __raw_spin_lock_irqsave(raw_spinlock_t *lock)
 #else
 	do_raw_spin_lock_flags(lock, &flags);
 #endif
+	DTRACE_LOCKSTAT(spin__acquire, spinlock_t *, lock);
 	return flags;
 }
 
@@ -127,6 +131,7 @@ static inline void __raw_spin_lock_irq(raw_spinlock_t *lock)
 	preempt_disable();
 	spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
+	DTRACE_LOCKSTAT(spin__acquire, spinlock_t *, lock);
 }
 
 static inline void __raw_spin_lock_bh(raw_spinlock_t *lock)
@@ -134,6 +139,7 @@ static inline void __raw_spin_lock_bh(raw_spinlock_t *lock)
 	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 	spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
+	DTRACE_LOCKSTAT(spin__acquire, spinlock_t *, lock);
 }
 
 static inline void __raw_spin_lock(raw_spinlock_t *lock)
@@ -141,6 +147,7 @@ static inline void __raw_spin_lock(raw_spinlock_t *lock)
 	preempt_disable();
 	spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);
 	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
+	DTRACE_LOCKSTAT(spin__acquire, spinlock_t *, lock);
 }
 
 #endif /* !CONFIG_GENERIC_LOCKBREAK || CONFIG_DEBUG_LOCK_ALLOC */
@@ -149,6 +156,7 @@ static inline void __raw_spin_unlock(raw_spinlock_t *lock)
 {
 	spin_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_spin_unlock(lock);
+	DTRACE_LOCKSTAT(spin__release, spinlock_t *, lock);
 	preempt_enable();
 }
 
@@ -157,6 +165,7 @@ static inline void __raw_spin_unlock_irqrestore(raw_spinlock_t *lock,
 {
 	spin_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_spin_unlock(lock);
+	DTRACE_LOCKSTAT(spin__release, spinlock_t *, lock);
 	local_irq_restore(flags);
 	preempt_enable();
 }
@@ -165,6 +174,7 @@ static inline void __raw_spin_unlock_irq(raw_spinlock_t *lock)
 {
 	spin_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_spin_unlock(lock);
+	DTRACE_LOCKSTAT(spin__release, spinlock_t *, lock);
 	local_irq_enable();
 	preempt_enable();
 }
@@ -173,6 +183,7 @@ static inline void __raw_spin_unlock_bh(raw_spinlock_t *lock)
 {
 	spin_release(&lock->dep_map, 1, _RET_IP_);
 	do_raw_spin_unlock(lock);
+	DTRACE_LOCKSTAT(spin__release, spinlock_t *, lock);
 	__local_bh_enable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 }
 
@@ -181,6 +192,7 @@ static inline int __raw_spin_trylock_bh(raw_spinlock_t *lock)
 	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
 	if (do_raw_spin_trylock(lock)) {
 		spin_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+		DTRACE_LOCKSTAT(spin__acquire, spinlock_t *, lock);
 		return 1;
 	}
 	__local_bh_enable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index a78186d826d7..69fe5aaf19e0 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -941,4 +941,8 @@ asmlinkage long sys_pkey_free(int pkey);
 asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags,
 			  unsigned mask, struct statx __user *buffer);
 
+#ifdef CONFIG_DTRACE
+asmlinkage long sys_waitfd(int which, pid_t upid, int options, int flags);
+#endif
+
 #endif
diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index a26ffbe09e71..c8e3b6e126b9 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -20,6 +20,7 @@
 #include <linux/cpumask.h>
 #include <linux/rcupdate.h>
 #include <linux/tracepoint-defs.h>
+#include <linux/sdt.h>
 
 struct module;
 struct tracepoint;
@@ -186,6 +187,8 @@ extern void syscall_unregfunc(void);
 	extern struct tracepoint __tracepoint_##name;			\
 	static inline void trace_##name(proto)				\
 	{								\
+		DTRACE_PROBE_TRACEPOINT(name, args);			\
+		DTRACE_PROTO_TRACEPOINT(name, proto);			\
 		if (static_key_false(&__tracepoint_##name.key))		\
 			__DO_TRACE(&__tracepoint_##name,		\
 				TP_PROTO(data_proto),			\
@@ -254,7 +257,10 @@ extern void syscall_unregfunc(void);
 #else /* !TRACEPOINTS_ENABLED */
 #define __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \
 	static inline void trace_##name(proto)				\
-	{ }								\
+	{								\
+		DTRACE_PROBE_TRACEPOINT(name, args);			\
+		DTRACE_PROTO_TRACEPOINT(name, proto);			\
+	}								\
 	static inline void trace_##name##_rcuidle(proto)		\
 	{ }								\
 	static inline int						\
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 8b87de067bc7..519e917a0b00 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -736,6 +736,14 @@ __SYSCALL(__NR_statx,     sys_statx)
 #undef __NR_syscalls
 #define __NR_syscalls 292
 
+#ifdef CONFIG_DTRACE
+#define __NR_waitfd 473
+__SYSCALL(__NR_waitfd, sys_waitfd)
+
+#undef __NR_syscalls
+#define __NR_syscalls 474
+#endif
+
 /*
  * All syscalls below here should go away really,
  * these are provided for both review and as a porting
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index ca2787d9bf0f..4331459597ed 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -1,5 +1,7 @@
 # UAPI Header export list
 
+header-y += dtrace/
+
 ifeq ($(wildcard $(srctree)/arch/$(SRCARCH)/include/uapi/asm/a.out.h),)
 no-export-headers += a.out.h
 endif
diff --git a/include/uapi/linux/dtrace/Kbuild b/include/uapi/linux/dtrace/Kbuild
new file mode 100644
index 000000000000..0cb5b941b72b
--- /dev/null
+++ b/include/uapi/linux/dtrace/Kbuild
@@ -0,0 +1,35 @@
+# UAPI Header export list
+header-y += actions_defines.h
+header-y += actions.h
+header-y += arg_defines.h
+header-y += arg.h
+header-y += buffer_defines.h
+header-y += buffer.h
+header-y += conf_defines.h
+header-y += conf.h
+header-y += cpu_defines.h
+header-y += dif_defines.h
+header-y += dif.h
+header-y += difo_defines.h
+header-y += difo.h
+header-y += dof_defines.h
+header-y += dof.h
+header-y += dtrace.h
+header-y += enabling_defines.h
+header-y += enabling.h
+header-y += fasttrap_defines.h
+header-y += fasttrap.h
+header-y += fasttrap_ioctl.h
+header-y += faults_defines.h
+header-y += faults.h
+header-y += helpers_defines.h
+header-y += helpers.h
+header-y += ioctl.h
+header-y += metadesc_defines.h
+header-y += metadesc.h
+header-y += options_defines.h
+header-y += options.h
+header-y += stability_defines.h
+header-y += stability.h
+header-y += status.h
+header-y += universal.h
diff --git a/include/uapi/linux/dtrace/actions.h b/include/uapi/linux/dtrace/actions.h
new file mode 100644
index 000000000000..51edbc75aa63
--- /dev/null
+++ b/include/uapi/linux/dtrace/actions.h
@@ -0,0 +1,13 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_ACTIONS_H
+#define _LINUX_DTRACE_ACTIONS_H
+
+#include <linux/dtrace/actions_defines.h>
+
+#endif /* _LINUX_DTRACE_ACTIONS_H */
diff --git a/include/uapi/linux/dtrace/actions_defines.h b/include/uapi/linux/dtrace/actions_defines.h
new file mode 100644
index 000000000000..6d4dda8a1705
--- /dev/null
+++ b/include/uapi/linux/dtrace/actions_defines.h
@@ -0,0 +1,179 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_ACTIONS_DEFINES_H
+#define _LINUX_DTRACE_ACTIONS_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+/*
+ * The upper byte determines the class of the action; the low bytes determines
+ * the specific action within that class.  The classes of actions are as
+ * follows:
+ *
+ *   [ no class ]                  <= May record process- or kernel-related data
+ *   DTRACEACT_PROC                <= Only records process-related data
+ *   DTRACEACT_PROC_DESTRUCTIVE    <= Potentially destructive to processes
+ *   DTRACEACT_KERNEL              <= Only records kernel-related data
+ *   DTRACEACT_KERNEL_DESTRUCTIVE  <= Potentially destructive to the kernel
+ *   DTRACEACT_SPECULATIVE         <= Speculation-related action
+ *   DTRACEACT_AGGREGATION         <= Aggregating action
+ */
+#define	DTRACEACT_NONE			0	/* no action */
+#define	DTRACEACT_DIFEXPR		1	/* action is DIF expression */
+#define	DTRACEACT_EXIT			2	/* exit() action */
+#define	DTRACEACT_PRINTF		3	/* printf() action */
+#define	DTRACEACT_PRINTA		4	/* printa() action */
+#define	DTRACEACT_LIBACT		5	/* library-controlled action */
+#define	DTRACEACT_TRACEMEM		6	/* tracemem() action */
+
+#define DTRACEACT_PROC			0x0100
+#define DTRACEACT_USTACK		(DTRACEACT_PROC + 1)
+#define DTRACEACT_JSTACK		(DTRACEACT_PROC + 2)
+#define DTRACEACT_USYM			(DTRACEACT_PROC + 3)
+#define DTRACEACT_UMOD			(DTRACEACT_PROC + 4)
+#define DTRACEACT_UADDR			(DTRACEACT_PROC + 5)
+
+#define DTRACEACT_PROC_DESTRUCTIVE	0x0200
+#define DTRACEACT_STOP			(DTRACEACT_PROC_DESTRUCTIVE + 1)
+#define DTRACEACT_RAISE			(DTRACEACT_PROC_DESTRUCTIVE + 2)
+#define DTRACEACT_SYSTEM		(DTRACEACT_PROC_DESTRUCTIVE + 3)
+#define DTRACEACT_FREOPEN		(DTRACEACT_PROC_DESTRUCTIVE + 4)
+
+#define DTRACEACT_PROC_CONTROL		0x0300
+
+#define DTRACEACT_KERNEL		0x0400
+#define DTRACEACT_STACK			(DTRACEACT_KERNEL + 1)
+#define DTRACEACT_SYM			(DTRACEACT_KERNEL + 2)
+#define DTRACEACT_MOD			(DTRACEACT_KERNEL + 3)
+
+#define DTRACEACT_KERNEL_DESTRUCTIVE	0x0500
+#define DTRACEACT_BREAKPOINT		(DTRACEACT_KERNEL_DESTRUCTIVE + 1)
+#define DTRACEACT_PANIC			(DTRACEACT_KERNEL_DESTRUCTIVE + 2)
+#define DTRACEACT_CHILL			(DTRACEACT_KERNEL_DESTRUCTIVE + 3)
+
+#define DTRACEACT_SPECULATIVE           0x0600
+#define DTRACEACT_SPECULATE		(DTRACEACT_SPECULATIVE + 1)
+#define DTRACEACT_COMMIT		(DTRACEACT_SPECULATIVE + 2)
+#define DTRACEACT_DISCARD		(DTRACEACT_SPECULATIVE + 3)
+
+#define DTRACEACT_CLASS(x)		((x) & 0xff00)
+
+#define DTRACEACT_ISAGG(x)		\
+		(DTRACEACT_CLASS(x) == DTRACEACT_AGGREGATION)
+
+#define DTRACEACT_ISDESTRUCTIVE(x)	\
+		(DTRACEACT_CLASS(x) == DTRACEACT_PROC_DESTRUCTIVE || \
+		 DTRACEACT_CLASS(x) == DTRACEACT_KERNEL_DESTRUCTIVE)
+
+#define DTRACEACT_ISSPECULATIVE(x)	\
+		(DTRACEACT_CLASS(x) == DTRACEACT_SPECULATIVE)
+
+#define DTRACEACT_ISPRINTFLIKE(x)	\
+		((x) == DTRACEACT_PRINTF || (x) == DTRACEACT_PRINTA || \
+		 (x) == DTRACEACT_SYSTEM || (x) == DTRACEACT_FREOPEN)
+
+/*
+ * DTrace Aggregating Actions
+ *
+ * These are functions f(x) for which the following is true:
+ *
+ *    f(f(x_0) U f(x_1) U ... U f(x_n)) = f(x_0 U x_1 U ... U x_n)
+ *
+ * where x_n is a set of arbitrary data.  Aggregating actions are in their own
+ * DTrace action class, DTTRACEACT_AGGREGATION.  The macros provided here allow
+ * for easier processing of the aggregation argument and data payload for a few
+ * aggregating actions (notably:  quantize(), lquantize(), and ustack()).
+ */
+
+#define DTRACEACT_AGGREGATION		0x0700
+#define DTRACEAGG_COUNT			(DTRACEACT_AGGREGATION + 1)
+#define DTRACEAGG_MIN			(DTRACEACT_AGGREGATION + 2)
+#define DTRACEAGG_MAX			(DTRACEACT_AGGREGATION + 3)
+#define DTRACEAGG_AVG			(DTRACEACT_AGGREGATION + 4)
+#define DTRACEAGG_SUM			(DTRACEACT_AGGREGATION + 5)
+#define DTRACEAGG_STDDEV		(DTRACEACT_AGGREGATION + 6)
+#define DTRACEAGG_QUANTIZE		(DTRACEACT_AGGREGATION + 7)
+#define DTRACEAGG_LQUANTIZE		(DTRACEACT_AGGREGATION + 8)
+#define DTRACEAGG_LLQUANTIZE		(DTRACEACT_AGGREGATION + 9)
+
+#define DTRACE_QUANTIZE_NBUCKETS		\
+		(((sizeof (uint64_t) * NBBY) - 1) * 2 + 1)
+
+#define DTRACE_QUANTIZE_ZEROBUCKET	((sizeof (uint64_t) * NBBY) - 1)
+
+#define DTRACE_QUANTIZE_BUCKETVAL(buck)		\
+	(int64_t)((buck) < DTRACE_QUANTIZE_ZEROBUCKET ? \
+		  -(1LL << (DTRACE_QUANTIZE_ZEROBUCKET - 1 - (buck))) : \
+		  (buck) == DTRACE_QUANTIZE_ZEROBUCKET ? 0 : \
+		  1LL << ((buck) - DTRACE_QUANTIZE_ZEROBUCKET - 1))
+
+#define DTRACE_LQUANTIZE_STEPSHIFT	48
+#define DTRACE_LQUANTIZE_STEPMASK	((uint64_t)UINT16_MAX << 48)
+#define DTRACE_LQUANTIZE_LEVELSHIFT	32
+#define DTRACE_LQUANTIZE_LEVELMASK	((uint64_t)UINT16_MAX << 32)
+#define DTRACE_LQUANTIZE_BASESHIFT	0
+#define DTRACE_LQUANTIZE_BASEMASK	UINT32_MAX
+
+#define DTRACE_LQUANTIZE_STEP(x)		\
+		(uint16_t)(((x) & DTRACE_LQUANTIZE_STEPMASK) >> \
+			   DTRACE_LQUANTIZE_STEPSHIFT)
+
+#define DTRACE_LQUANTIZE_LEVELS(x)		\
+		(uint16_t)(((x) & DTRACE_LQUANTIZE_LEVELMASK) >> \
+			   DTRACE_LQUANTIZE_LEVELSHIFT)
+
+#define DTRACE_LQUANTIZE_BASE(x)		\
+		(int32_t)(((x) & DTRACE_LQUANTIZE_BASEMASK) >> \
+			  DTRACE_LQUANTIZE_BASESHIFT)
+
+#define DTRACE_LLQUANTIZE_STEPSSHIFT	48
+#define DTRACE_LLQUANTIZE_STEPSMASK	((uint64_t)UINT16_MAX << 48)
+#define DTRACE_LLQUANTIZE_HMAGSHIFT	32
+#define DTRACE_LLQUANTIZE_HMAGMASK	((uint64_t)UINT16_MAX << 32)
+#define DTRACE_LLQUANTIZE_LMAGSHIFT	16
+#define DTRACE_LLQUANTIZE_LMAGMASK	((uint64_t)UINT16_MAX << 16)
+#define DTRACE_LLQUANTIZE_FACTORSHIFT	0
+#define DTRACE_LLQUANTIZE_FACTORMASK	UINT16_MAX
+
+#define DTRACE_LLQUANTIZE_STEPS(x)		\
+		(uint16_t)(((x) & DTRACE_LLQUANTIZE_STEPSMASK) >> \
+			DTRACE_LLQUANTIZE_STEPSSHIFT)
+
+#define DTRACE_LLQUANTIZE_HMAG(x)		\
+		(uint16_t)(((x) & DTRACE_LLQUANTIZE_HMAGMASK) >> \
+			DTRACE_LLQUANTIZE_HMAGSHIFT)
+
+#define DTRACE_LLQUANTIZE_LMAG(x)		\
+		(uint16_t)(((x) & DTRACE_LLQUANTIZE_LMAGMASK) >> \
+			DTRACE_LLQUANTIZE_LMAGSHIFT)
+
+#define DTRACE_LLQUANTIZE_FACTOR(x)		\
+		(uint16_t)(((x) & DTRACE_LLQUANTIZE_FACTORMASK) >> \
+			DTRACE_LLQUANTIZE_FACTORSHIFT)
+
+#define DTRACE_USTACK_NFRAMES(x)	(uint32_t)((x) & UINT32_MAX)
+#define DTRACE_USTACK_STRSIZE(x)	(uint32_t)((x) >> 32)
+#define DTRACE_USTACK_ARG(x, y)		\
+		((((uint64_t)(y)) << 32) | ((x) & UINT32_MAX))
+
+#ifndef _LP64
+# ifndef _LITTLE_ENDIAN
+#  define DTRACE_PTR(type, name)	uint32_t name##pad; type *name
+# else
+#  define DTRACE_PTR(type, name)	type *name; uint32_t name##pad
+# endif
+#else
+# define DTRACE_PTR(type, name)		type *name
+#endif
+
+#endif /* _LINUX_DTRACE_ACTIONS_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/arg.h b/include/uapi/linux/dtrace/arg.h
new file mode 100644
index 000000000000..fdc959b8ea56
--- /dev/null
+++ b/include/uapi/linux/dtrace/arg.h
@@ -0,0 +1,41 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_ARG_H
+#define _LINUX_DTRACE_ARG_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/arg_defines.h>
+
+/*
+ * Because it would waste both space and time, argument types do not reside
+ * with the probe.  In order to determine argument types for args[X]
+ * variables, the D compiler queries for argument types on a probe-by-probe
+ * basis.  (This optimizes for the common case that arguments are either not
+ * used or used in an untyped fashion.)  Typed arguments are specified with a
+ * string of the type name in the dtragd_native member of the argument
+ * description structure.  Typed arguments may be further translated to types
+ * of greater stability; the provider indicates such a translated argument by
+ * filling in the dtargd_xlate member with the string of the translated type.
+ * Finally, the provider may indicate which argument value a given argument
+ * maps to by setting the dtargd_mapping member -- allowing a single argument
+ * to map to multiple args[X] variables.
+ */
+typedef struct dtrace_argdesc {
+	dtrace_id_t dtargd_id;
+	int dtargd_ndx;
+	int dtargd_mapping;
+	char dtargd_native[DTRACE_ARGTYPELEN];
+	char dtargd_xlate[DTRACE_ARGTYPELEN];
+} dtrace_argdesc_t;
+
+#endif /* _LINUX_DTRACE_ARG_H */
diff --git a/include/uapi/linux/dtrace/arg_defines.h b/include/uapi/linux/dtrace/arg_defines.h
new file mode 100644
index 000000000000..c8eab9d72b2a
--- /dev/null
+++ b/include/uapi/linux/dtrace/arg_defines.h
@@ -0,0 +1,20 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_ARG_DEFINES_H
+#define _LINUX_DTRACE_ARG_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dtrace_argdesc;
+
+#endif /* _LINUX_DTRACE_ARG_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/buffer.h b/include/uapi/linux/dtrace/buffer.h
new file mode 100644
index 000000000000..31a8a12df968
--- /dev/null
+++ b/include/uapi/linux/dtrace/buffer.h
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_BUFFER_H
+#define _LINUX_DTRACE_BUFFER_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/actions_defines.h>
+#include <linux/dtrace/buffer_defines.h>
+
+/*
+ * In order to get a snapshot of the principal or aggregation buffer,
+ * user-level passes a buffer description to the kernel with the dtrace_bufdesc
+ * structure.  This describes which CPU user-level is interested in, and
+ * where user-level wishes the kernel to snapshot the buffer to (the
+ * dtbd_data field).  The kernel uses the same structure to pass back some
+ * information regarding the buffer:  the size of data actually copied out, the
+ * number of drops, the number of errors, and the offset of the oldest record.
+ * If the buffer policy is a "switch" policy, taking a snapshot of the
+ * principal buffer has the additional effect of switching the active and
+ * inactive buffers.  Taking a snapshot of the aggregation buffer _always_ has
+ * the additional effect of switching the active and inactive buffers.
+ */
+typedef struct dtrace_bufdesc {
+	uint64_t dtbd_size;			/* size of buffer */
+	uint32_t dtbd_cpu;			/* CPU or DTRACE_CPUALL */
+	uint32_t dtbd_errors;			/* number of errors */
+	uint64_t dtbd_drops;			/* number of drops */
+	DTRACE_PTR(char, dtbd_data);		/* data */
+	uint64_t dtbd_oldest;			/* offset of oldest record */
+} dtrace_bufdesc_t;
+
+#endif /* _LINUX_DTRACE_BUFFER_H */
diff --git a/include/uapi/linux/dtrace/buffer_defines.h b/include/uapi/linux/dtrace/buffer_defines.h
new file mode 100644
index 000000000000..136190d33e8f
--- /dev/null
+++ b/include/uapi/linux/dtrace/buffer_defines.h
@@ -0,0 +1,20 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_BUFFER_DEFINES_H
+#define _LINUX_DTRACE_BUFFER_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dtrace_bufdesc;
+
+#endif /* _LINUX_DTRACE_BUFFER_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/conf.h b/include/uapi/linux/dtrace/conf.h
new file mode 100644
index 000000000000..1a6cc9f61a07
--- /dev/null
+++ b/include/uapi/linux/dtrace/conf.h
@@ -0,0 +1,34 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_CONF_H
+#define _LINUX_DTRACE_CONF_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/conf_defines.h>
+
+/*
+ * User-level may need to understand some elements of the kernel DTrace
+ * configuration in order to generate correct DIF.  This information is
+ * conveyed via the dtrace_conf structure.
+ */
+typedef struct dtrace_conf {
+	uint_t dtc_difversion;			/* supported DIF version */
+	uint_t dtc_difintregs;			/* # of DIF integer registers */
+	uint_t dtc_diftupregs;			/* # of DIF tuple registers */
+	uint_t dtc_ctfmodel;			/* CTF data model */
+	/* Deviation from Solaris...  Used to just be 8 padding entries. */
+	uint_t dtc_maxbufs;			/* max # of buffers */
+	uint_t dtc_pad[7];			/* reserved for future use */
+} dtrace_conf_t;
+
+#endif /* _LINUX_DTRACE_CONF_H */
diff --git a/include/uapi/linux/dtrace/conf_defines.h b/include/uapi/linux/dtrace/conf_defines.h
new file mode 100644
index 000000000000..18c525beac00
--- /dev/null
+++ b/include/uapi/linux/dtrace/conf_defines.h
@@ -0,0 +1,20 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_CONF_DEFINES_H
+#define _LINUX_DTRACE_CONF_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dtrace_conf;
+
+#endif /* _LINUX_DTRACE_CONF_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/cpu_defines.h b/include/uapi/linux/dtrace/cpu_defines.h
new file mode 100644
index 000000000000..1a4d4210665e
--- /dev/null
+++ b/include/uapi/linux/dtrace/cpu_defines.h
@@ -0,0 +1,16 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_CPU_DEFINES_H_
+#define _LINUX_DTRACE_CPU_DEFINES_H_
+
+typedef uint32_t	processorid_t;
+typedef uint32_t	psetid_t;
+typedef uint32_t	chipid_t;
+typedef uint32_t	lgrp_id_t;
+
+#endif /* _LINUX_DTRACE_CPU_DEFINES_H_ */
diff --git a/include/uapi/linux/dtrace/dif.h b/include/uapi/linux/dtrace/dif.h
new file mode 100644
index 000000000000..e04f498c3c54
--- /dev/null
+++ b/include/uapi/linux/dtrace/dif.h
@@ -0,0 +1,59 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_DIF_H
+#define _LINUX_DTRACE_DIF_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/dif_defines.h>
+
+/*
+ * The following definitions describe the DTrace Intermediate Format (DIF), a a
+ * RISC-like instruction set and program encoding used to represent predicates
+ * and actions that can be bound to DTrace probes.  The constants below defining
+ * the number of available registers are suggested minimums; the compiler should
+ * use DTRACEIOC_CONF to dynamically obtain the number of registers provided by
+ * the current DTrace implementation.
+ */
+
+/*
+ * A DTrace Intermediate Format Type (DIF Type) is used to represent the types
+ * of variables, function and associative array arguments, and the return type
+ * for each DIF object (shown below).  It contains a description of the type,
+ * its size in bytes, and a module identifier.
+ */
+
+typedef struct dtrace_diftype {
+	uint8_t dtdt_kind;
+	uint8_t dtdt_ckind;
+	uint8_t dtdt_flags;
+	uint8_t dtdt_pad;
+	uint32_t dtdt_size;
+} dtrace_diftype_t;
+
+/*
+ * A DTrace Intermediate Format variable record is used to describe each of the
+ * variables referenced by a given DIF object.  It contains an integer variable
+ * identifier along with variable scope and properties, as shown below.  The
+ * size of this structure must be sizeof (int) aligned.
+ */
+
+typedef struct dtrace_difv {
+	uint32_t dtdv_name;
+	uint32_t dtdv_id;
+	uint8_t dtdv_kind;
+	uint8_t dtdv_scope;
+	uint16_t dtdv_flags;
+	dtrace_diftype_t dtdv_type;
+} dtrace_difv_t;
+
+#endif /* _LINUX_DTRACE_DIF_H */
diff --git a/include/uapi/linux/dtrace/dif_defines.h b/include/uapi/linux/dtrace/dif_defines.h
new file mode 100644
index 000000000000..6538a352e81f
--- /dev/null
+++ b/include/uapi/linux/dtrace/dif_defines.h
@@ -0,0 +1,287 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_DIF_DEFINES_H
+#define _LINUX_DTRACE_DIF_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+/*
+ * The following definitions describe the DTrace Intermediate Format (DIF), a a
+ * RISC-like instruction set and program encoding used to represent predicates
+ * and actions that can be bound to DTrace probes.  The constants below defining
+ * the number of available registers are suggested minimums; the compiler should
+ * use DTRACEIOC_CONF to dynamically obtain the number of registers provided by
+ * the current DTrace implementation.
+ */
+
+#define DIF_VERSION_1	1
+#define DIF_VERSION_2	2
+#define DIF_VERSION	DIF_VERSION_2
+#define	DIF_DIR_NREGS	8		/* number of DIF integer registers */
+#define	DIF_DTR_NREGS	8		/* number of DIF tuple registers */
+
+#define DIF_OP_OR	1		/* or   r1, r2, rd */
+#define DIF_OP_XOR	2		/* xor  r1, r2, rd */
+#define DIF_OP_AND	3		/* and  r1, r2, rd */
+#define DIF_OP_SLL	4		/* sll  r1, r2, rd */
+#define DIF_OP_SRL	5		/* srl  r1, r2, rd */
+#define DIF_OP_SUB	6		/* sub  r1, r2, rd */
+#define DIF_OP_ADD	7		/* add  r1, r2, rd */
+#define DIF_OP_MUL	8		/* mul  r1, r2, rd */
+#define DIF_OP_SDIV	9		/* sdiv r1, r2, rd */
+#define DIF_OP_UDIV	10		/* udiv r1, r2, rd */
+#define DIF_OP_SREM	11		/* srem r1, r2, rd */
+#define DIF_OP_UREM	12		/* urem r1, r2, rd */
+#define DIF_OP_NOT	13		/* not  r1, rd */
+#define DIF_OP_MOV	14		/* mov  r1, rd */
+#define DIF_OP_CMP	15		/* cmp  r1, r2 */
+#define DIF_OP_TST	16		/* tst  r1 */
+#define DIF_OP_BA	17		/* ba   label */
+#define DIF_OP_BE	18		/* be   label */
+#define DIF_OP_BNE	19		/* bne  label */
+#define DIF_OP_BG	20		/* bg   label */
+#define DIF_OP_BGU	21		/* bgu  label */
+#define DIF_OP_BGE	22		/* bge  label */
+#define DIF_OP_BGEU	23		/* bgeu label */
+#define DIF_OP_BL	24		/* bl   label */
+#define DIF_OP_BLU	25		/* blu  label */
+#define DIF_OP_BLE	26		/* ble  label */
+#define DIF_OP_BLEU	27		/* bleu label */
+#define DIF_OP_LDSB	28		/* ldsb [r1], rd */
+#define DIF_OP_LDSH	29		/* ldsh [r1], rd */
+#define DIF_OP_LDSW	30		/* ldsw [r1], rd */
+#define DIF_OP_LDUB	31		/* ldub [r1], rd */
+#define DIF_OP_LDUH	32		/* lduh [r1], rd */
+#define DIF_OP_LDUW	33		/* lduw [r1], rd */
+#define DIF_OP_LDX	34		/* ldx  [r1], rd */
+#define DIF_OP_RET	35		/* ret  rd */
+#define DIF_OP_NOP	36		/* nop */
+#define DIF_OP_SETX	37		/* setx intindex, rd */
+#define DIF_OP_SETS	38		/* sets strindex, rd */
+#define DIF_OP_SCMP	39		/* scmp r1, r2 */
+#define DIF_OP_LDGA	40		/* ldga var, ri, rd */
+#define DIF_OP_LDGS	41		/* ldgs var, rd */
+#define DIF_OP_STGS	42		/* stgs var, rs */
+#define DIF_OP_LDTA	43		/* ldta var, ri, rd */
+#define DIF_OP_LDTS	44		/* ldts var, rd */
+#define DIF_OP_STTS	45		/* stts var, rs */
+#define DIF_OP_SRA	46		/* sra  r1, r2, rd */
+#define DIF_OP_CALL	47		/* call subr, rd */
+#define DIF_OP_PUSHTR	48		/* pushtr type, rs, rr */
+#define DIF_OP_PUSHTV	49		/* pushtv type, rs, rv */
+#define DIF_OP_POPTS	50		/* popts */
+#define DIF_OP_FLUSHTS	51		/* flushts */
+#define DIF_OP_LDGAA	52		/* ldgaa var, rd */
+#define DIF_OP_LDTAA	53		/* ldtaa var, rd */
+#define DIF_OP_STGAA	54		/* stgaa var, rs */
+#define DIF_OP_STTAA	55		/* sttaa var, rs */
+#define DIF_OP_LDLS	56		/* ldls var, rd */
+#define DIF_OP_STLS	57		/* stls var, rs */
+#define DIF_OP_ALLOCS	58		/* allocs r1, rd */
+#define DIF_OP_COPYS	59		/* copys  r1, r2, rd */
+#define DIF_OP_STB	60		/* stb  r1, [rd] */
+#define DIF_OP_STH	61		/* sth  r1, [rd] */
+#define DIF_OP_STW	62		/* stw  r1, [rd] */
+#define DIF_OP_STX	63		/* stx  r1, [rd] */
+#define DIF_OP_ULDSB	64		/* uldsb [r1], rd */
+#define DIF_OP_ULDSH	65		/* uldsh [r1], rd */
+#define DIF_OP_ULDSW	66		/* uldsw [r1], rd */
+#define DIF_OP_ULDUB	67		/* uldub [r1], rd */
+#define DIF_OP_ULDUH	68		/* ulduh [r1], rd */
+#define DIF_OP_ULDUW	69		/* ulduw [r1], rd */
+#define DIF_OP_ULDX	70		/* uldx  [r1], rd */
+#define DIF_OP_RLDSB	71		/* rldsb [r1], rd */
+#define DIF_OP_RLDSH	72		/* rldsh [r1], rd */
+#define DIF_OP_RLDSW	73		/* rldsw [r1], rd */
+#define DIF_OP_RLDUB	74		/* rldub [r1], rd */
+#define DIF_OP_RLDUH	75		/* rlduh [r1], rd */
+#define DIF_OP_RLDUW	76		/* rlduw [r1], rd */
+#define DIF_OP_RLDX	77		/* rldx  [r1], rd */
+#define DIF_OP_XLATE	78		/* xlate xlrindex, rd */
+#define DIF_OP_XLARG	79		/* xlarg xlrindex, rd */
+
+#define	DIF_INTOFF_MAX		0xffff	/* highest integer table offset */
+#define	DIF_STROFF_MAX		0xffff	/* highest string table offset */
+#define	DIF_REGISTER_MAX	0xff	/* highest register number */
+#define	DIF_VARIABLE_MAX	0xffff	/* highest variable identifier */
+#define	DIF_SUBROUTINE_MAX	0xffff	/* highest subroutine code */
+
+#define	DIF_VAR_ARRAY_MIN	0x0000	/* lowest numbered array variable */
+#define	DIF_VAR_ARRAY_UBASE	0x0080	/* lowest user-defined array */
+#define	DIF_VAR_ARRAY_MAX	0x00ff	/* highest numbered array variable */
+
+#define	DIF_VAR_OTHER_MIN	0x0100	/* lowest numbered scalar or assc */
+#define	DIF_VAR_OTHER_UBASE	0x0500	/* lowest user-defined scalar or assc */
+#define	DIF_VAR_OTHER_MAX	0xffff	/* highest numbered scalar or assc */
+
+#define DIF_VAR_ARGS		0x0000
+#define DIF_VAR_REGS		0x0001
+#define DIF_VAR_UREGS		0x0002
+#define DIF_VAR_CURTHREAD	0x0100
+#define DIF_VAR_TIMESTAMP	0x0101
+#define DIF_VAR_VTIMESTAMP	0x0102
+#define DIF_VAR_IPL		0x0103
+#define DIF_VAR_EPID		0x0104
+#define DIF_VAR_ID		0x0105
+#define DIF_VAR_ARG0		0x0106
+#define DIF_VAR_ARG1		0x0107
+#define DIF_VAR_ARG2		0x0108
+#define DIF_VAR_ARG3		0x0109
+#define DIF_VAR_ARG4		0x010a
+#define DIF_VAR_ARG5		0x010b
+#define DIF_VAR_ARG6		0x010c
+#define DIF_VAR_ARG7		0x010d
+#define DIF_VAR_ARG8		0x010e
+#define DIF_VAR_ARG9		0x010f
+#define DIF_VAR_STACKDEPTH	0x0110
+#define DIF_VAR_CALLER		0x0111
+#define DIF_VAR_PROBEPROV	0x0112
+#define DIF_VAR_PROBEMOD	0x0113
+#define DIF_VAR_PROBEFUNC	0x0114
+#define DIF_VAR_PROBENAME	0x0115
+#define DIF_VAR_PID		0x0116
+#define DIF_VAR_TID		0x0117
+#define DIF_VAR_EXECNAME	0x0118
+#define DIF_VAR_ZONENAME	0x0119
+#define DIF_VAR_WALLTIMESTAMP	0x011a
+#define DIF_VAR_USTACKDEPTH	0x011b
+#define DIF_VAR_UCALLER		0x011c
+#define DIF_VAR_PPID		0x011d
+#define DIF_VAR_UID		0x011e
+#define DIF_VAR_GID		0x011f
+#define DIF_VAR_ERRNO		0x0120
+#define DIF_VAR_CURCPU		0x0121
+
+#define DIF_SUBR_RAND			0
+#define DIF_SUBR_MUTEX_OWNED		1
+#define DIF_SUBR_MUTEX_OWNER		2
+#define DIF_SUBR_MUTEX_TYPE_ADAPTIVE	3
+#define DIF_SUBR_MUTEX_TYPE_SPIN	4
+#define DIF_SUBR_RW_READ_HELD		5
+#define DIF_SUBR_RW_WRITE_HELD		6
+#define DIF_SUBR_RW_ISWRITER		7
+#define DIF_SUBR_COPYIN			8
+#define DIF_SUBR_COPYINSTR		9
+#define DIF_SUBR_SPECULATION		10
+#define DIF_SUBR_PROGENYOF		11
+#define DIF_SUBR_STRLEN			12
+#define DIF_SUBR_COPYOUT		13
+#define DIF_SUBR_COPYOUTSTR		14
+#define DIF_SUBR_ALLOCA			15
+#define DIF_SUBR_BCOPY			16
+#define DIF_SUBR_COPYINTO		17
+#define DIF_SUBR_MSGDSIZE		18
+#define DIF_SUBR_MSGSIZE		19
+#define DIF_SUBR_GETMAJOR		20
+#define DIF_SUBR_GETMINOR		21
+#define DIF_SUBR_DDI_PATHNAME		22
+#define DIF_SUBR_STRJOIN		23
+#define DIF_SUBR_LLTOSTR		24
+#define DIF_SUBR_BASENAME		25
+#define DIF_SUBR_DIRNAME		26
+#define DIF_SUBR_CLEANPATH		27
+#define DIF_SUBR_STRCHR			28
+#define DIF_SUBR_STRRCHR		29
+#define DIF_SUBR_STRSTR			30
+#define DIF_SUBR_STRTOK			31
+#define DIF_SUBR_SUBSTR			32
+#define DIF_SUBR_INDEX			33
+#define DIF_SUBR_RINDEX			34
+#define DIF_SUBR_HTONS			35
+#define DIF_SUBR_HTONL			36
+#define DIF_SUBR_HTONLL			37
+#define DIF_SUBR_NTOHS			38
+#define DIF_SUBR_NTOHL			39
+#define DIF_SUBR_NTOHLL			40
+#define DIF_SUBR_INET_NTOP		41
+#define DIF_SUBR_INET_NTOA		42
+#define DIF_SUBR_INET_NTOA6		43
+#define DIF_SUBR_D_PATH			44
+#define DIF_SUBR_LINK_NTOP		45
+
+#define DIF_SUBR_MAX			45
+
+typedef uint32_t	dif_instr_t;
+
+#define DIF_INSTR_OP(i)			(((i) >> 24) & 0xff)
+#define DIF_INSTR_R1(i)			(((i) >> 16) & 0xff)
+#define DIF_INSTR_R2(i)			(((i) >>  8) & 0xff)
+#define DIF_INSTR_RD(i)			((i) & 0xff)
+#define DIF_INSTR_RS(i)			((i) & 0xff)
+#define DIF_INSTR_LABEL(i)		((i) & 0xffffff)
+#define DIF_INSTR_VAR(i)		(((i) >>  8) & 0xffff)
+#define DIF_INSTR_INTEGER(i)		(((i) >>  8) & 0xffff)
+#define DIF_INSTR_STRING(i)		(((i) >>  8) & 0xffff)
+#define DIF_INSTR_SUBR(i)		(((i) >>  8) & 0xffff)
+#define DIF_INSTR_TYPE(i)		(((i) >> 16) & 0xff)
+#define DIF_INSTR_XLREF(i)		(((i) >>  8) & 0xffff)
+#define DIF_INSTR_FMT(op, r1, r2, d) \
+			(((op) << 24) | ((r1) << 16) | ((r2) << 8) | (d))
+
+#define DIF_INSTR_NOT(r1, d)		(DIF_INSTR_FMT(DIF_OP_NOT, r1, 0, d))
+#define DIF_INSTR_MOV(r1, d)		(DIF_INSTR_FMT(DIF_OP_MOV, r1, 0, d))
+#define DIF_INSTR_CMP(op, r1, r2)	(DIF_INSTR_FMT(op, r1, r2, 0))
+#define DIF_INSTR_TST(r1)		(DIF_INSTR_FMT(DIF_OP_TST, r1, 0, 0))
+#define DIF_INSTR_BRANCH(op, label)	(((op) << 24) | (label))
+#define DIF_INSTR_LOAD(op, r1, d)	(DIF_INSTR_FMT(op, r1, 0, d))
+#define DIF_INSTR_STORE(op, r1, d)	(DIF_INSTR_FMT(op, r1, 0, d))
+#define DIF_INSTR_SETX(i, d)		((DIF_OP_SETX << 24) | ((i) << 8) | (d))
+#define DIF_INSTR_SETS(s, d)		((DIF_OP_SETS << 24) | ((s) << 8) | (d))
+#define DIF_INSTR_RET(d)		(DIF_INSTR_FMT(DIF_OP_RET, 0, 0, d))
+#define DIF_INSTR_NOP			(DIF_OP_NOP << 24)
+#define DIF_INSTR_LDA(op, v, r, d)	(DIF_INSTR_FMT(op, v, r, d))
+#define DIF_INSTR_LDV(op, v, d)		(((op) << 24) | ((v) << 8) | (d))
+#define DIF_INSTR_STV(op, v, rs)	(((op) << 24) | ((v) << 8) | (rs))
+#define DIF_INSTR_CALL(s, d)		((DIF_OP_CALL << 24) | ((s) << 8) | (d))
+#define DIF_INSTR_PUSHTS(op, t, r2, rs)	(DIF_INSTR_FMT(op, t, r2, rs))
+#define DIF_INSTR_POPTS			(DIF_OP_POPTS << 24)
+#define DIF_INSTR_FLUSHTS		(DIF_OP_FLUSHTS << 24)
+#define DIF_INSTR_ALLOCS(r1, d)		(DIF_INSTR_FMT(DIF_OP_ALLOCS, r1, 0, d))
+#define DIF_INSTR_COPYS(r1, r2, d)	(DIF_INSTR_FMT(DIF_OP_COPYS, r1, r2, d))
+#define DIF_INSTR_XLATE(op, r, d)	(((op) << 24) | ((r) << 8) | (d))
+
+#define DIF_REG_R0		0
+
+/*
+ * A DTrace Intermediate Format Type (DIF Type) is used to represent the types
+ * of variables, function and associative array arguments, and the return type
+ * for each DIF object (shown below).  It contains a description of the type,
+ * its size in bytes, and a module identifier.
+ */
+
+#define DIF_TYPE_CTF		0
+#define DIF_TYPE_STRING		1
+
+#define DIF_TF_BYREF		0x1
+
+/*
+ * A DTrace Intermediate Format variable record is used to describe each of the
+ * variables referenced by a given DIF object.  It contains an integer variable
+ * identifier along with variable scope and properties, as shown below.  The
+ * size of this structure must be sizeof (int) aligned.
+ */
+
+#define DIFV_KIND_ARRAY		0
+#define DIFV_KIND_SCALAR	1
+
+#define DIFV_SCOPE_GLOBAL	0
+#define DIFV_SCOPE_THREAD	1
+#define DIFV_SCOPE_LOCAL	2
+
+#define DIFV_F_REF		0x1
+#define DIFV_F_MOD		0x2
+
+struct dtrace_diftype;
+struct dtrace_difv;
+
+#endif /* _LINUX_DTRACE_DIF_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/difo.h b/include/uapi/linux/dtrace/difo.h
new file mode 100644
index 000000000000..d2c1144fbda2
--- /dev/null
+++ b/include/uapi/linux/dtrace/difo.h
@@ -0,0 +1,56 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_DIFO_H
+#define _LINUX_DTRACE_DIFO_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/dif.h>
+#include <linux/dtrace/dof_defines.h>
+
+/*
+ * A DIFO is used to store the compiled DIF for a D expression, its return
+ * type, and its string and variable tables.  The string table is a single
+ * buffer of character data into which sets instructions and variable
+ * references can reference strings using a byte offset.  The variable table
+ * is an array of dtrace_difv_t structures that describe the name and type of
+ * each variable and the id used in the DIF code.  This structure is described
+ * above in the DIF section of this header file.  The DIFO is used at both
+ * user-level (in the library) and in the kernel, but the structure is never
+ * passed between the two: the DOF structures form the only interface.  As a
+ * result, the definition can change depending on the presence of _KERNEL.
+ */
+
+typedef struct dtrace_difo {
+	dif_instr_t *dtdo_buf;			/* instruction buffer */
+	uint64_t *dtdo_inttab;			/* integer table (optional) */
+	char *dtdo_strtab;			/* string table (optional) */
+	dtrace_difv_t *dtdo_vartab;		/* variable table (optional) */
+	uint_t dtdo_len;			/* length of instruction buffer */
+	uint_t dtdo_intlen;			/* length of integer table */
+	uint_t dtdo_strlen;			/* length of string table */
+	uint_t dtdo_varlen;			/* length of variable table */
+	dtrace_diftype_t dtdo_rtype;		/* return type */
+	uint_t dtdo_refcnt;			/* owner reference count */
+	uint_t dtdo_destructive;		/* invokes destructive subroutines */
+#ifndef _KERNEL
+	dtrace_diftype_t orig_dtdo_rtype;	/* orignal return type */
+	struct dof_relodesc *dtdo_kreltab;	/* kernel relocations */
+	struct dof_relodesc *dtdo_ureltab;	/* user relocations */
+	struct dt_node **dtdo_xlmtab;		/* translator references */
+	uint_t dtdo_krelen;			/* length of krelo table */
+	uint_t dtdo_urelen;			/* length of urelo table */
+	uint_t dtdo_xlmlen;			/* length of translator table */
+#endif
+} dtrace_difo_t;
+
+#endif /* _LINUX_DTRACE_DIFO_H */
diff --git a/include/uapi/linux/dtrace/difo_defines.h b/include/uapi/linux/dtrace/difo_defines.h
new file mode 100644
index 000000000000..3e95590d8903
--- /dev/null
+++ b/include/uapi/linux/dtrace/difo_defines.h
@@ -0,0 +1,20 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_DIFO_DEFINES_H
+#define _LINUX_DTRACE_DIFO_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dtrace_difo;
+
+#endif /* _LINUX_DTRACE_DIFO_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/dof.h b/include/uapi/linux/dtrace/dof.h
new file mode 100644
index 000000000000..e5dce0b18566
--- /dev/null
+++ b/include/uapi/linux/dtrace/dof.h
@@ -0,0 +1,195 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_DOF_H
+#define _LINUX_DTRACE_DOF_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/dif.h>
+#include <linux/dtrace/dof_defines.h>
+
+/*
+ * DTrace programs can be persistently encoded in the DOF format so that they
+ * may be embedded in other programs (for example, in an ELF file) or in the
+ * dtrace driver configuration file for use in anonymous tracing.  The DOF
+ * format is versioned and extensible so that it can be revised and so that
+ * internal data structures can be modified or extended compatibly.  All DOF
+ * structures use fixed-size types, so the 32-bit and 64-bit representations
+ * are identical and consumers can use either data model transparently.
+ *
+ * The file layout is structured as follows:
+ *
+ * +---------------+-------------------+----- ... ----+---- ... ------+
+ * |   dof_hdr_t   |  dof_sec_t[ ... ] |   loadable   | non-loadable  |
+ * | (file header) | (section headers) | section data | section data  |
+ * +---------------+-------------------+----- ... ----+---- ... ------+
+ * |<------------ dof_hdr.dofh_loadsz --------------->|               |
+ * |<------------ dof_hdr.dofh_filesz ------------------------------->|
+ *
+ * The file header stores meta-data including a magic number, data model for
+ * the instrumentation, data encoding, and properties of the DIF code within.
+ * The header describes its own size and the size of the section headers.  By
+ * convention, an array of section headers follows the file header, and then
+ * the data for all loadable sections and unloadable sections.  This permits
+ * consumer code to easily download the headers and all loadable data into the
+ * DTrace driver in one contiguous chunk, omitting other extraneous sections.
+ *
+ * The section headers describe the size, offset, alignment, and section type
+ * for each section.  Sections are described using a set of #defines that tell
+ * the consumer what kind of data is expected.  Sections can contain links to
+ * other sections by storing a dof_secidx_t, an index into the section header
+ * array, inside of the section data structures.  The section header includes
+ * an entry size so that sections with data arrays can grow their structures.
+ *
+ * The DOF data itself can contain many snippets of DIF (i.e. >1 DIFOs), which
+ * are represented themselves as a collection of related DOF sections.  This
+ * permits us to change the set of sections associated with a DIFO over time,
+ * and also permits us to encode DIFOs that contain different sets of sections.
+ * When a DOF section wants to refer to a DIFO, it stores the dof_secidx_t of a
+ * section of type DOF_SECT_DIFOHDR.  This section's data is then an array of
+ * dof_secidx_t's which in turn denote the sections associated with this DIFO.
+ *
+ * This loose coupling of the file structure (header and sections) to the
+ * structure of the DTrace program itself (ECB descriptions, action
+ * descriptions, and DIFOs) permits activities such as relocation processing
+ * to occur in a single pass without having to understand D program structure.
+ *
+ * Finally, strings are always stored in ELF-style string tables along with a
+ * string table section index and string table offset.  Therefore strings in
+ * DOF are always arbitrary-length and not bound to the current implementation.
+ */
+
+typedef struct dof_hdr {
+	uint8_t dofh_ident[DOF_ID_SIZE]; /* identification bytes (see defines) */
+	uint32_t dofh_flags;		/* file attribute flags (if any) */
+	uint32_t dofh_hdrsize;		/* size of file header in bytes */
+	uint32_t dofh_secsize;		/* size of section header in bytes */
+	uint32_t dofh_secnum;		/* number of section headers */
+	uint64_t dofh_secoff;		/* file offset of section headers */
+	uint64_t dofh_loadsz;		/* file size of loadable portion */
+	uint64_t dofh_filesz;		/* file size of entire DOF file */
+	uint64_t dofh_pad;		/* reserved for future use */
+} dof_hdr_t;
+
+typedef struct dof_sec {
+	uint32_t dofs_type;	/* section type (see defines) */
+	uint32_t dofs_align;	/* section data memory alignment */
+	uint32_t dofs_flags;	/* section flags (if any) */
+	uint32_t dofs_entsize;	/* size of section entry (if table) */
+	uint64_t dofs_offset;	/* offset of section data within file */
+	uint64_t dofs_size;	/* size of section data in bytes */
+} dof_sec_t;
+
+
+typedef struct dof_ecbdesc {
+	dof_secidx_t dofe_probes;	/* link to DOF_SECT_PROBEDESC */
+	dof_secidx_t dofe_pred;		/* link to DOF_SECT_DIFOHDR */
+	dof_secidx_t dofe_actions;	/* link to DOF_SECT_ACTDESC */
+	uint32_t dofe_pad;		/* reserved for future use */
+	uint64_t dofe_uarg;		/* user-supplied library argument */
+} dof_ecbdesc_t;
+
+typedef struct dof_probedesc {
+	dof_secidx_t dofp_strtab;	/* link to DOF_SECT_STRTAB section */
+	dof_stridx_t dofp_provider;	/* provider string */
+	dof_stridx_t dofp_mod;		/* module string */
+	dof_stridx_t dofp_func;		/* function string */
+	dof_stridx_t dofp_name;		/* name string */
+	uint32_t dofp_id;		/* probe identifier (or zero) */
+} dof_probedesc_t;
+
+typedef struct dof_actdesc {
+	dof_secidx_t dofa_difo;		/* link to DOF_SECT_DIFOHDR */
+	dof_secidx_t dofa_strtab;	/* link to DOF_SECT_STRTAB section */
+	uint32_t dofa_kind;		/* action kind (DTRACEACT_* constant) */
+	uint32_t dofa_ntuple;		/* number of subsequent tuple actions */
+	uint64_t dofa_arg;		/* kind-specific argument */
+	uint64_t dofa_uarg;		/* user-supplied argument */
+} dof_actdesc_t;
+
+typedef struct dof_difohdr {
+	dtrace_diftype_t dofd_rtype;	/* return type for this fragment */
+	dof_secidx_t dofd_links[1];	/* variable length array of indices */
+} dof_difohdr_t;
+
+typedef struct dof_relohdr {
+	dof_secidx_t dofr_strtab;	/* link to DOF_SECT_STRTAB for names */
+	dof_secidx_t dofr_relsec;	/* link to DOF_SECT_RELTAB for relos */
+	dof_secidx_t dofr_tgtsec;	/* link to section we are relocating */
+} dof_relohdr_t;
+
+typedef struct dof_relodesc {
+	dof_stridx_t dofr_name;		/* string name of relocation symbol */
+	uint32_t dofr_type;		/* relo type (DOF_RELO_* constant) */
+	uint64_t dofr_offset;		/* byte offset for relocation */
+	uint64_t dofr_data;		/* additional type-specific data */
+} dof_relodesc_t;
+
+typedef struct dof_optdesc {
+	uint32_t dofo_option;		/* option identifier */
+	dof_secidx_t dofo_strtab;	/* string table, if string option */
+	uint64_t dofo_value;		/* option value or string index */
+} dof_optdesc_t;
+
+typedef struct dof_provider {
+	dof_secidx_t dofpv_strtab;	/* link to DOF_SECT_STRTAB section */
+	dof_secidx_t dofpv_probes;	/* link to DOF_SECT_PROBES section */
+	dof_secidx_t dofpv_prargs;	/* link to DOF_SECT_PRARGS section */
+	dof_secidx_t dofpv_proffs;	/* link to DOF_SECT_PROFFS section */
+	dof_stridx_t dofpv_name;	/* provider name string */
+	dof_attr_t dofpv_provattr;	/* provider attributes */
+	dof_attr_t dofpv_modattr;	/* module attributes */
+	dof_attr_t dofpv_funcattr;	/* function attributes */
+	dof_attr_t dofpv_nameattr;	/* name attributes */
+	dof_attr_t dofpv_argsattr;	/* args attributes */
+	dof_secidx_t dofpv_prenoffs;	/* link to DOF_SECT_PRENOFFS section */
+} dof_provider_t;
+
+typedef struct dof_probe {
+	uint64_t dofpr_addr;		/* probe base address or offset */
+	dof_stridx_t dofpr_func;	/* probe function string */
+	dof_stridx_t dofpr_name;	/* probe name string */
+	dof_stridx_t dofpr_nargv;	/* native argument type strings */
+	dof_stridx_t dofpr_xargv;	/* translated argument type strings */
+	uint32_t dofpr_argidx;		/* index of first argument mapping */
+	uint32_t dofpr_offidx;		/* index of first offset entry */
+	uint8_t dofpr_nargc;		/* native argument count */
+	uint8_t dofpr_xargc;		/* translated argument count */
+	uint16_t dofpr_noffs;		/* number of offset entries for probe */
+	uint32_t dofpr_enoffidx;	/* index of first is-enabled offset */
+	uint16_t dofpr_nenoffs;		/* number of is-enabled offsets */
+	uint16_t dofpr_pad1;		/* reserved for future use */
+	uint32_t dofpr_pad2;		/* reserved for future use */
+} dof_probe_t;
+
+typedef struct dof_xlator {
+	dof_secidx_t dofxl_members;	/* link to DOF_SECT_XLMEMBERS section */
+	dof_secidx_t dofxl_strtab;	/* link to DOF_SECT_STRTAB section */
+	dof_stridx_t dofxl_argv;	/* input parameter type strings */
+	uint32_t dofxl_argc;		/* input parameter list length */
+	dof_stridx_t dofxl_type;	/* output type string name */
+	dof_attr_t dofxl_attr;		/* output stability attributes */
+} dof_xlator_t;
+
+typedef struct dof_xlmember {
+	dof_secidx_t dofxm_difo;	/* member link to DOF_SECT_DIFOHDR */
+	dof_stridx_t dofxm_name;	/* member name */
+	dtrace_diftype_t dofxm_type;	/* member type */
+} dof_xlmember_t;
+
+typedef struct dof_xlref {
+	dof_secidx_t dofxr_xlator;	/* link to DOF_SECT_XLATORS section */
+	uint32_t dofxr_member;		/* index of referenced dof_xlmember */
+	uint32_t dofxr_argn;		/* index of argument for DIF_OP_XLARG */
+} dof_xlref_t;
+
+#endif /* _LINUX_DTRACE_DOF_H */
diff --git a/include/uapi/linux/dtrace/dof_defines.h b/include/uapi/linux/dtrace/dof_defines.h
new file mode 100644
index 000000000000..15a508af6d01
--- /dev/null
+++ b/include/uapi/linux/dtrace/dof_defines.h
@@ -0,0 +1,191 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_DOF_DEFINES_H
+#define _LINUX_DTRACE_DOF_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+/*
+ * DTrace programs can be persistently encoded in the DOF format so that they
+ * may be embedded in other programs (for example, in an ELF file) or in the
+ * dtrace driver configuration file for use in anonymous tracing.  The DOF
+ * format is versioned and extensible so that it can be revised and so that
+ * internal data structures can be modified or extended compatibly.  All DOF
+ * structures use fixed-size types, so the 32-bit and 64-bit representations
+ * are identical and consumers can use either data model transparently.
+ *
+ * The file layout is structured as follows:
+ *
+ * +---------------+-------------------+----- ... ----+---- ... ------+
+ * |   dof_hdr_t   |  dof_sec_t[ ... ] |   loadable   | non-loadable  |
+ * | (file header) | (section headers) | section data | section data  |
+ * +---------------+-------------------+----- ... ----+---- ... ------+
+ * |<------------ dof_hdr.dofh_loadsz --------------->|               |
+ * |<------------ dof_hdr.dofh_filesz ------------------------------->|
+ *
+ * The file header stores meta-data including a magic number, data model for
+ * the instrumentation, data encoding, and properties of the DIF code within.
+ * The header describes its own size and the size of the section headers.  By
+ * convention, an array of section headers follows the file header, and then
+ * the data for all loadable sections and unloadable sections.  This permits
+ * consumer code to easily download the headers and all loadable data into the
+ * DTrace driver in one contiguous chunk, omitting other extraneous sections.
+ *
+ * The section headers describe the size, offset, alignment, and section type
+ * for each section.  Sections are described using a set of #defines that tell
+ * the consumer what kind of data is expected.  Sections can contain links to
+ * other sections by storing a dof_secidx_t, an index into the section header
+ * array, inside of the section data structures.  The section header includes
+ * an entry size so that sections with data arrays can grow their structures.
+ *
+ * The DOF data itself can contain many snippets of DIF (i.e. >1 DIFOs), which
+ * are represented themselves as a collection of related DOF sections.  This
+ * permits us to change the set of sections associated with a DIFO over time,
+ * and also permits us to encode DIFOs that contain different sets of sections.
+ * When a DOF section wants to refer to a DIFO, it stores the dof_secidx_t of a
+ * section of type DOF_SECT_DIFOHDR.  This section's data is then an array of
+ * dof_secidx_t's which in turn denote the sections associated with this DIFO.
+ *
+ * This loose coupling of the file structure (header and sections) to the
+ * structure of the DTrace program itself (ECB descriptions, action
+ * descriptions, and DIFOs) permits activities such as relocation processing
+ * to occur in a single pass without having to understand D program structure.
+ *
+ * Finally, strings are always stored in ELF-style string tables along with a
+ * string table section index and string table offset.  Therefore strings in
+ * DOF are always arbitrary-length and not bound to the current implementation.
+ */
+
+#define DOF_ID_SIZE     16      /* total size of dofh_ident[] in bytes */
+
+#define DOF_ID_MAG0	0
+#define DOF_ID_MAG1	1
+#define DOF_ID_MAG2	2
+#define DOF_ID_MAG3	3
+#define DOF_ID_MODEL	4
+#define DOF_ID_ENCODING	5
+#define DOF_ID_VERSION	6
+#define DOF_ID_DIFVERS	7
+#define	DOF_ID_DIFIREG	8	/* DIF integer registers used by compiler */
+#define	DOF_ID_DIFTREG	9	/* DIF tuple registers used by compiler */
+#define	DOF_ID_PAD	10	/* start of padding bytes (all zeroes) */
+
+#define DOF_MAG_MAG0	0x7F	/* DOF_ID_MAG[0-3] */
+#define DOF_MAG_MAG1	'D'
+#define DOF_MAG_MAG2	'O'
+#define DOF_MAG_MAG3	'F'
+
+#define DOF_MAG_STRING	"\177DOF"
+#define DOF_MAG_STRLEN	4
+
+#define DOF_MODEL_NONE	0	/* DOF_ID_MODEL */
+#define DOF_MODEL_ILP32	1
+#define DOF_MODEL_LP64	2
+
+#ifdef _LP64
+#define DOF_MODEL_NATIVE	DOF_MODEL_LP64
+#else
+#define DOF_MODEL_NATIVE	DOF_MODEL_ILP32
+#endif
+
+#define DOF_ENCODE_NONE	0	/* DOF_ID_ENCODING */
+#define DOF_ENCODE_LSB	1
+#define DOF_ENCODE_MSB	2
+
+#ifndef _LITTLE_ENDIAN
+#define DOF_ENCODE_NATIVE	DOF_ENCODE_MSB
+#else
+#define DOF_ENCODE_NATIVE	DOF_ENCODE_LSB
+#endif
+
+#define DOF_VERSION_1	1
+#define DOF_VERSION_2	2
+#define DOF_VERSION	DOF_VERSION_2
+
+#define DOF_FL_VALID	0	/* mask of all valid dofh_flags bits */
+
+typedef uint32_t dof_secidx_t;	/* section header table index type */
+typedef uint32_t dof_stridx_t;	/* string table index type */
+
+#define	DOF_SECIDX_NONE	-1U	/* null value for section indices */
+#define	DOF_STRIDX_NONE	-1U	/* null value for string indices */
+
+#define	DOF_SECT_NONE		0	/* null section */
+#define	DOF_SECT_COMMENTS	1	/* compiler comments */
+#define	DOF_SECT_SOURCE		2	/* D program source code */
+#define	DOF_SECT_ECBDESC	3	/* dof_ecbdesc_t */
+#define	DOF_SECT_PROBEDESC	4	/* dof_probedesc_t */
+#define	DOF_SECT_ACTDESC	5	/* dof_actdesc_t array */
+#define	DOF_SECT_DIFOHDR	6	/* dof_difohdr_t (variable length) */
+#define	DOF_SECT_DIF		7	/* uint32_t array of byte code */
+#define	DOF_SECT_STRTAB		8	/* string table */
+#define	DOF_SECT_VARTAB		9	/* dtrace_difv_t array */
+#define	DOF_SECT_RELTAB		10	/* dof_relodesc_t array */
+#define	DOF_SECT_TYPTAB		11	/* dtrace_diftype_t array */
+#define	DOF_SECT_URELHDR	12	/* dof_relohdr_t (user relocations) */
+#define	DOF_SECT_KRELHDR	13	/* dof_relohdr_t (kernel relocations) */
+#define	DOF_SECT_OPTDESC	14	/* dof_optdesc_t array */
+#define	DOF_SECT_PROVIDER	15	/* dof_provider_t */
+#define	DOF_SECT_PROBES		16	/* dof_probe_t array */
+#define	DOF_SECT_PRARGS		17	/* uint8_t array (probe arg mappings) */
+#define	DOF_SECT_PROFFS		18	/* uint32_t array (probe arg offsets) */
+#define	DOF_SECT_INTTAB		19	/* uint64_t array */
+#define	DOF_SECT_UTSNAME	20	/* struct utsname */
+#define	DOF_SECT_XLTAB		21	/* dof_xlref_t array */
+#define	DOF_SECT_XLMEMBERS	22	/* dof_xlmember_t array */
+#define	DOF_SECT_XLIMPORT	23	/* dof_xlator_t */
+#define	DOF_SECT_XLEXPORT	24	/* dof_xlator_t */
+#define	DOF_SECT_PREXPORT	25	/* dof_secidx_t array (exported objs) */
+#define	DOF_SECT_PRENOFFS	26	/* uint32_t array (enabled offsets) */
+
+#define	DOF_SECF_LOAD		1	/* section should be loaded */
+
+#define DOF_SEC_ISLOADABLE(x)						      \
+		(((x) == DOF_SECT_ECBDESC) || ((x) == DOF_SECT_PROBEDESC) ||  \
+		((x) == DOF_SECT_ACTDESC) || ((x) == DOF_SECT_DIFOHDR) ||     \
+		((x) == DOF_SECT_DIF) || ((x) == DOF_SECT_STRTAB) ||	      \
+		((x) == DOF_SECT_VARTAB) || ((x) == DOF_SECT_RELTAB) ||	      \
+		((x) == DOF_SECT_TYPTAB) || ((x) == DOF_SECT_URELHDR) ||      \
+		((x) == DOF_SECT_KRELHDR) || ((x) == DOF_SECT_OPTDESC) ||     \
+		((x) == DOF_SECT_PROVIDER) || ((x) == DOF_SECT_PROBES) ||     \
+		((x) == DOF_SECT_PRARGS) || ((x) == DOF_SECT_PROFFS) ||	      \
+		((x) == DOF_SECT_INTTAB) || ((x) == DOF_SECT_XLTAB) ||	      \
+		((x) == DOF_SECT_XLMEMBERS) || ((x) == DOF_SECT_XLIMPORT) ||  \
+		((x) == DOF_SECT_XLIMPORT) || ((x) == DOF_SECT_XLEXPORT) ||   \
+		((x) == DOF_SECT_PREXPORT) || ((x) == DOF_SECT_PRENOFFS))
+
+#define	DOF_RELO_NONE	0		/* empty relocation entry */
+#define	DOF_RELO_SETX	1		/* relocate setx value */
+
+typedef uint32_t dof_attr_t;		/* encoded stability attributes */
+
+#define DOF_ATTR(n, d, c)	(((n) << 24) | ((d) << 16) | ((c) << 8))
+#define DOF_ATTR_NAME(a)	(((a) >> 24) & 0xff)
+#define DOF_ATTR_DATA(a)	(((a) >> 16) & 0xff)
+#define DOF_ATTR_CLASS(a)	(((a) >>  8) & 0xff)
+
+struct dof_hdr;
+struct dof_sec;
+struct dof_ecbdesc;
+struct dof_probedesc;
+struct dof_actdesc;
+struct dof_difohdr;
+struct dof_relohdr;
+struct dof_relodesc;
+struct dof_optdesc;
+struct dof_provider;
+struct dof_xlator;
+struct dof_xlmember;
+struct dof_xlref;
+
+#endif /* _LINUX_DTRACE_DOF_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/dtrace.h b/include/uapi/linux/dtrace/dtrace.h
new file mode 100644
index 000000000000..09d33e54e923
--- /dev/null
+++ b/include/uapi/linux/dtrace/dtrace.h
@@ -0,0 +1,32 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_H_
+#define _LINUX_DTRACE_H_
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/dif.h>
+#include <linux/dtrace/actions.h>
+#include <linux/dtrace/dof.h>
+#include <linux/dtrace/difo.h>
+#include <linux/dtrace/enabling.h>
+#include <linux/dtrace/metadesc.h>
+#include <linux/dtrace/options.h>
+#include <linux/dtrace/buffer.h>
+#include <linux/dtrace/status.h>
+#include <linux/dtrace/conf.h>
+#include <linux/dtrace/faults.h>
+#include <linux/dtrace/arg.h>
+#include <linux/dtrace/stability.h>
+#include <linux/dtrace/helpers.h>
+
+#endif /* _LINUX_DTRACE_H_ */
diff --git a/include/uapi/linux/dtrace/enabling.h b/include/uapi/linux/dtrace/enabling.h
new file mode 100644
index 000000000000..13d0e727b57c
--- /dev/null
+++ b/include/uapi/linux/dtrace/enabling.h
@@ -0,0 +1,75 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_ENABLING_H
+#define _LINUX_DTRACE_ENABLING_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/difo_defines.h>
+#include <linux/dtrace/enabling_defines.h>
+
+/*
+ * When DTrace is tracking the description of a DTrace enabling entity (probe,
+ * predicate, action, ECB, record, etc.), it does so in a description
+ * structure.  These structures all end in "desc", and are used at both
+ * user-level and in the kernel -- but (with the exception of
+ * dtrace_probedesc_t) they are never passed between them.  Typically,
+ * user-level will use the description structures when assembling an enabling.
+ * It will then distill those description structures into a DOF object (see
+ * above), and send it into the kernel.  The kernel will again use the
+ * description structures to create a description of the enabling as it reads
+ * the DOF.  When the description is complete, the enabling will be actually
+ * created -- turning it into the structures that represent the enabling
+ * instead of merely describing it.  Not surprisingly, the description
+ * structures bear a strong resemblance to the DOF structures that act as their
+ * conduit.
+ */
+
+struct dtrace_predicate;
+
+typedef struct dtrace_probedesc {
+	dtrace_id_t dtpd_id;			/* probe identifier */
+	char dtpd_provider[DTRACE_PROVNAMELEN]; /* probe provider name */
+	char dtpd_mod[DTRACE_MODNAMELEN];	/* probe module name */
+	char dtpd_func[DTRACE_FUNCNAMELEN];	/* probe function name */
+	char dtpd_name[DTRACE_NAMELEN];		/* probe name */
+} dtrace_probedesc_t;
+
+typedef struct dtrace_repldesc {
+	dtrace_probedesc_t dtrpd_match;		/* probe descr. to match */
+	dtrace_probedesc_t dtrpd_create;	/* probe descr. to create */
+} dtrace_repldesc_t;
+
+typedef struct dtrace_preddesc {
+	struct dtrace_difo *dtpdd_difo;		/* pointer to DIF object */
+	struct dtrace_predicate *dtpdd_predicate; /* pointer to predicate */
+} dtrace_preddesc_t;
+
+typedef struct dtrace_actdesc {
+	struct dtrace_difo *dtad_difo;		/* pointer to DIF object */
+	struct dtrace_actdesc *dtad_next;	/* next action */
+	dtrace_actkind_t dtad_kind;		/* kind of action */
+	uint32_t dtad_ntuple;			/* number in tuple */
+	uint64_t dtad_arg;			/* action argument */
+	uint64_t dtad_uarg;			/* user argument */
+	int dtad_refcnt;			/* reference count */
+} dtrace_actdesc_t;
+
+typedef struct dtrace_ecbdesc {
+	dtrace_actdesc_t *dted_action;		/* action description(s) */
+	dtrace_preddesc_t dted_pred;		/* predicate description */
+	dtrace_probedesc_t dted_probe;		/* probe description */
+	uint64_t dted_uarg;			/* library argument */
+	int dted_refcnt;			/* reference count */
+} dtrace_ecbdesc_t;
+
+#endif /* _LINUX_DTRACE_ENABLING_H */
diff --git a/include/uapi/linux/dtrace/enabling_defines.h b/include/uapi/linux/dtrace/enabling_defines.h
new file mode 100644
index 000000000000..c8c7f3296ed2
--- /dev/null
+++ b/include/uapi/linux/dtrace/enabling_defines.h
@@ -0,0 +1,24 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_ENABLING_DEFINES_H
+#define _LINUX_DTRACE_ENABLING_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dtrace_probedesc;
+struct dtrace_repldesc;
+struct dtrace_preddesc;
+struct dtrace_actdesc;
+struct dtrace_ecbdesc;
+
+#endif /* _LINUX_DTRACE_ENABLING_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/fasttrap.h b/include/uapi/linux/dtrace/fasttrap.h
new file mode 100644
index 000000000000..41a1cd08af7d
--- /dev/null
+++ b/include/uapi/linux/dtrace/fasttrap.h
@@ -0,0 +1,55 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_FASTTRAP_H
+#define _LINUX_DTRACE_FASTTRAP_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/fasttrap_defines.h>
+
+typedef enum fasttrap_probe_type {
+	DTFTP_NONE = 0,
+	DTFTP_ENTRY,
+	DTFTP_RETURN,
+	DTFTP_OFFSETS,
+	DTFTP_POST_OFFSETS,
+	DTFTP_IS_ENABLED
+} fasttrap_probe_type_t;
+
+typedef struct fasttrap_probe_spec {
+	pid_t ftps_pid;
+	fasttrap_probe_type_t ftps_type;
+	char ftps_func[DTRACE_FUNCNAMELEN];
+	char ftps_mod[DTRACE_MODNAMELEN];
+	uint64_t ftps_pc;
+	uint64_t ftps_size;
+	uint64_t ftps_noffs;
+	uint64_t ftps_offs[1];
+} fasttrap_probe_spec_t;
+
+typedef uint8_t		fasttrap_instr_t;
+
+typedef struct fasttrap_instr_query {
+	uint64_t ftiq_pc;
+	pid_t ftiq_pid;
+	fasttrap_instr_t ftiq_instr;
+} fasttrap_instr_query_t;
+
+/*
+ * Include after the definitions, to get ioctl()s when fasttrap.h is included.
+ * fasttrap_ioctl.h also #includes this header, to get structures when it is
+ * included itself, as is done by headers_check.
+ */
+
+#include <linux/dtrace/fasttrap_ioctl.h>
+
+#endif /* _LINUX_DTRACE_FASTTRAP_H */
diff --git a/include/uapi/linux/dtrace/fasttrap_defines.h b/include/uapi/linux/dtrace/fasttrap_defines.h
new file mode 100644
index 000000000000..905a8c293576
--- /dev/null
+++ b/include/uapi/linux/dtrace/fasttrap_defines.h
@@ -0,0 +1,22 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_FASTTRAP_DEFINES_H
+#define _LINUX_DTRACE_FASTTRAP_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+enum fasttrap_probe_type;
+struct fasttrap_probe_spec;
+struct fasttrap_instr_query;
+
+#endif /* _LINUX_DTRACE_FASTTRAP_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/fasttrap_ioctl.h b/include/uapi/linux/dtrace/fasttrap_ioctl.h
new file mode 100644
index 000000000000..1308d672196e
--- /dev/null
+++ b/include/uapi/linux/dtrace/fasttrap_ioctl.h
@@ -0,0 +1,18 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_FASTRRAP_IOCTL_H_
+#define _LINUX_DTRACE_FASTTRAP_IOCTL_H_
+
+#include <linux/ioctl.h>
+#include <linux/dtrace/fasttrap.h>
+
+#define FASTTRAPIOC		0xf4
+#define FASTTRAPIOC_MAKEPROBE	_IOW(FASTTRAPIOC, 1, fasttrap_probe_spec_t)
+#define FASTTRAPIOC_GETINSTR	_IOR(FASTTRAPIOC, 2, fasttrap_instr_query_t)
+
+#endif /* _LINUX_DTRACE_FASTTRAP_IOCTL_H_ */
diff --git a/include/uapi/linux/dtrace/faults.h b/include/uapi/linux/dtrace/faults.h
new file mode 100644
index 000000000000..c4e565875c8f
--- /dev/null
+++ b/include/uapi/linux/dtrace/faults.h
@@ -0,0 +1,19 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_FAULTS_H
+#define _LINUX_DTRACE_FAULTS_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/faults_defines.h>
+
+#endif /* _LINUX_DTRACE_FAULTS_H */
diff --git a/include/uapi/linux/dtrace/faults_defines.h b/include/uapi/linux/dtrace/faults_defines.h
new file mode 100644
index 000000000000..88f0fc6c7cb0
--- /dev/null
+++ b/include/uapi/linux/dtrace/faults_defines.h
@@ -0,0 +1,38 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_FAULTS_DEFINES_H
+#define _LINUX_DTRACE_FAULTS_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+/*
+ * The constants below DTRACEFLT_LIBRARY indicate probe processing faults;
+ * constants at or above DTRACEFLT_LIBRARY indicate faults in probe
+ * postprocessing at user-level.  Probe processing faults induce an ERROR
+ * probe and are replicated in unistd.d to allow users' ERROR probes to decode
+ * the error condition using thse symbolic labels.
+ */
+#define DTRACEFLT_UNKNOWN		0	/* Unknown fault */
+#define DTRACEFLT_BADADDR		1	/* Bad address */
+#define DTRACEFLT_BADALIGN		2	/* Bad alignment */
+#define DTRACEFLT_ILLOP			3	/* Illegal operation */
+#define DTRACEFLT_DIVZERO		4	/* Divide-by-zero */
+#define DTRACEFLT_NOSCRATCH		5	/* Out of scratch space */
+#define DTRACEFLT_KPRIV			6	/* Illegal kernel access */
+#define DTRACEFLT_UPRIV			7	/* Illegal user access */
+#define DTRACEFLT_TUPOFLOW		8	/* Tuple stack overflow */
+#define DTRACEFLT_BADSTACK		9	/* Bad stack */
+
+#define DTRACEFLT_LIBRARY		1000	/* Library-level fault */
+
+#endif /* _LINUX_DTRACE_FAULTS_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/helpers.h b/include/uapi/linux/dtrace/helpers.h
new file mode 100644
index 000000000000..ee0336a27b40
--- /dev/null
+++ b/include/uapi/linux/dtrace/helpers.h
@@ -0,0 +1,100 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_HELPERS_H
+#define _LINUX_DTRACE_HELPERS_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/helpers_defines.h>
+
+/*
+ * DTrace Helpers
+ *
+ * In general, DTrace establishes probes in processes and takes actions on
+ * processes without knowing their specific user-level structures.  Instead of
+ * existing in the framework, process-specific knowledge is contained by the
+ * enabling D program -- which can apply process-specific knowledge by making
+ * appropriate use of DTrace primitives like copyin() and copyinstr() to
+ * operate on user-level data.  However, there may exist some specific probes
+ * of particular semantic relevance that the application developer may wish to
+ * explicitly export.  For example, an application may wish to export a probe
+ * at the point that it begins and ends certain well-defined transactions.  In
+ * addition to providing probes, programs may wish to offer assistance for
+ * certain actions.  For example, in highly dynamic environments (e.g., Java),
+ * it may be difficult to obtain a stack trace in terms of meaningful symbol
+ * names (the translation from instruction addresses to corresponding symbol
+ * names may only be possible in situ); these environments may wish to define
+ * a series of actions to be applied in situ to obtain a meaningful stack
+ * trace.
+ *
+ * These two mechanisms -- user-level statically defined tracing and assisting
+ * DTrace actions -- are provided via DTrace _helpers_.  Helpers are specified
+ * via DOF, but unlike enabling DOF, helper DOF may contain definitions of
+ * providers, probes and their arguments.  If a helper wishes to provide
+ * action assistance, probe descriptions and corresponding DIF actions may be
+ * specified in the helper DOF.  For such helper actions, however, the probe
+ * description describes the specific helper:  all DTrace helpers have the
+ * provider name "dtrace" and the module name "helper", and the name of the
+ * helper is contained in the function name (for example, the ustack() helper
+ * is named "ustack").  Any helper-specific name may be contained in the name
+ * (for example, if a helper were to have a constructor, it might be named
+ * "dtrace:helper:<helper>:init").  Helper actions are only called when the
+ * action that they are helping is taken.  Helper actions may only return DIF
+ * expressions, and may only call the following subroutines:
+ *
+ *    alloca()      <= Allocates memory out of the consumer's scratch space
+ *    bcopy()       <= Copies memory to scratch space
+ *    copyin()      <= Copies memory from user-level into consumer's scratch
+ *    copyinto()    <= Copies memory into a specific location in scratch
+ *    copyinstr()   <= Copies a string into a specific location in scratch
+ *
+ * Helper actions may only access the following built-in variables:
+ *
+ *    curthread     <= Current kthread_t pointer
+ *    tid           <= Current thread identifier
+ *    pid           <= Current process identifier
+ *    ppid          <= Parent process identifier
+ *    uid           <= Current user ID
+ *    gid           <= Current group ID
+ *    execname      <= Current executable name
+ *    zonename      <= Current zone name
+ *
+ * Helper actions may not manipulate or allocate dynamic variables, but they
+ * may have clause-local and statically-allocated global variables.  The
+ * helper action variable state is specific to the helper action -- variables
+ * used by the helper action may not be accessed outside of the helper
+ * action, and the helper action may not access variables that like outside
+ * of it.  Helper actions may not load from kernel memory at-large; they are
+ * restricting to loading current user state (via copyin() and variants) and
+ * scratch space.  As with probe enablings, helper actions are executed in
+ * program order.  The result of the helper action is the result of the last
+ * executing helper expression.
+ *
+ * Helpers -- composed of either providers/probes or probes/actions (or both)
+ * -- are added by opening the "helper" minor node, and issuing an ioctl(2)
+ * (DTRACEHIOC_ADDDOF) that specifies the dof_helper_t structure. This
+ * encapsulates the name and base address of the user-level library or
+ * executable publishing the helpers and probes as well as the DOF that
+ * contains the definitions of those helpers and probes.
+ *
+ * The DTRACEHIOC_ADD and DTRACEHIOC_REMOVE are left in place for legacy
+ * helpers and should no longer be used.  No other ioctls are valid on the
+ * helper minor node.
+ */
+
+typedef struct dof_helper {
+	char dofhp_mod[DTRACE_MODNAMELEN];	/* executable or library name */
+	uint64_t dofhp_addr;			/* base address of object */
+	uint64_t dofhp_dof;			/* address of helper DOF */
+} dof_helper_t;
+
+#endif /* _LINUX_DTRACE_HELPERS_H */
diff --git a/include/uapi/linux/dtrace/helpers_defines.h b/include/uapi/linux/dtrace/helpers_defines.h
new file mode 100644
index 000000000000..d853e42556a4
--- /dev/null
+++ b/include/uapi/linux/dtrace/helpers_defines.h
@@ -0,0 +1,20 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_HELPERS_DEFINES_H
+#define _LINUX_DTRACE_HELPERS_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dof_helper;
+
+#endif /* _LINUX_DTRACE_HELPERS_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/ioctl.h b/include/uapi/linux/dtrace/ioctl.h
new file mode 100644
index 000000000000..481ecb2b245d
--- /dev/null
+++ b/include/uapi/linux/dtrace/ioctl.h
@@ -0,0 +1,46 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef _LINUX_DTRACE_IOCTL_H_
+#define _LINUX_DTRACE_IOCTL_H_
+
+#include <linux/ioctl.h>
+#include <linux/dtrace/arg.h>
+#include <linux/dtrace/buffer.h>
+#include <linux/dtrace/conf.h>
+#include <linux/dtrace/dof.h>
+#include <linux/dtrace/enabling.h>
+#include <linux/dtrace/helpers.h>
+#include <linux/dtrace/metadesc.h>
+#include <linux/dtrace/stability.h>
+#include <linux/dtrace/status.h>
+#include <linux/dtrace/cpu_defines.h>
+
+#define DTRACEIOC		0xd4
+#define DTRACEIOC_PROVIDER	_IOR(DTRACEIOC, 1, dtrace_providerdesc_t)
+#define DTRACEIOC_PROBES	_IOR(DTRACEIOC, 2, dtrace_probedesc_t)
+#define DTRACEIOC_BUFSNAP	_IOR(DTRACEIOC, 4, dtrace_bufdesc_t)
+#define DTRACEIOC_PROBEMATCH	_IOR(DTRACEIOC, 5, dtrace_probedesc_t)
+#define DTRACEIOC_ENABLE	_IOW(DTRACEIOC, 6, void *)
+#define DTRACEIOC_AGGSNAP	_IOR(DTRACEIOC, 7, dtrace_bufdesc_t)
+#define DTRACEIOC_EPROBE	_IOW(DTRACEIOC, 8, dtrace_eprobedesc_t)
+#define DTRACEIOC_PROBEARG	_IOR(DTRACEIOC, 9, dtrace_argdesc_t)
+#define DTRACEIOC_CONF		_IOR(DTRACEIOC, 10, dtrace_conf_t)
+#define DTRACEIOC_STATUS	_IOR(DTRACEIOC, 11, dtrace_status_t)
+#define DTRACEIOC_GO		_IOW(DTRACEIOC, 12, processorid_t)
+#define DTRACEIOC_STOP		_IOW(DTRACEIOC, 13, processorid_t)
+#define DTRACEIOC_AGGDESC	_IOR(DTRACEIOC, 15, dtrace_aggdesc_t)
+#define DTRACEIOC_FORMAT	_IOR(DTRACEIOC, 16, dtrace_fmtdesc_t)
+#define DTRACEIOC_DOFGET	_IOR(DTRACEIOC, 17, dof_hdr_t)
+#define DTRACEIOC_REPLICATE	_IOR(DTRACEIOC, 18, void *)
+
+#define DTRACEHIOC		0xd8
+#define DTRACEHIOC_ADD		_IOW(DTRACEHIOC, 1, dof_hdr_t)
+#define DTRACEHIOC_REMOVE	_IOW(DTRACEHIOC, 2, int)
+#define DTRACEHIOC_ADDDOF	_IOW(DTRACEHIOC, 3, dof_helper_t)
+
+#endif /* _LINUX_DTRACE_IOCTL_H */
diff --git a/include/uapi/linux/dtrace/metadesc.h b/include/uapi/linux/dtrace/metadesc.h
new file mode 100644
index 000000000000..193b68f22b6a
--- /dev/null
+++ b/include/uapi/linux/dtrace/metadesc.h
@@ -0,0 +1,80 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_METADESC_H
+#define _LINUX_DTRACE_METADESC_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/actions_defines.h>
+#include <linux/dtrace/metadesc_defines.h>
+
+/*
+ * DTrace separates the trace data stream from the metadata stream.  The only
+ * metadata tokens placed in the data stream are enabled probe identifiers
+ * (EPIDs) or (in the case of aggregations) aggregation identifiers.  In order
+ * to determine the structure of the data, DTrace consumers pass the token to
+ * the kernel, and receive in return a corresponding description of the enabled
+ * probe (via the dtrace_eprobedesc structure) or the aggregation (via the
+ * dtrace_aggdesc structure).  Both of these structures are expressed in terms
+ * of record descriptions (via the dtrace_recdesc structure) that describe the
+ * exact structure of the data.  Some record descriptions may also contain a
+ * format identifier; this additional bit of metadata can be retrieved from the
+ * kernel, for which a format description is returned via the dtrace_fmtdesc
+ * structure.  Note that all four of these structures must be bitness-neutral
+ * to allow for a 32-bit DTrace consumer on a 64-bit kernel.
+ */
+typedef struct dtrace_recdesc {
+	dtrace_actkind_t dtrd_action;		/* kind of action */
+	uint32_t dtrd_size;			/* size of record */
+	uint32_t dtrd_offset;			/* offset in ECB's data */
+	uint16_t dtrd_alignment;		/* required alignment */
+	uint16_t dtrd_format;			/* format, if any */
+	uint64_t dtrd_arg;			/* action argument */
+	uint64_t dtrd_uarg;			/* user argument */
+} dtrace_recdesc_t;
+
+typedef struct dtrace_eprobedesc {
+	dtrace_epid_t dtepd_epid;		/* enabled probe ID */
+	dtrace_id_t dtepd_probeid;		/* probe ID */
+	uint64_t dtepd_uarg;			/* library argument */
+	uint32_t dtepd_size;			/* total size */
+	int dtepd_nrecs;			/* number of records */
+	dtrace_recdesc_t dtepd_rec[1];		/* recods themselves */
+} dtrace_eprobedesc_t;
+
+typedef struct dtrace_aggdesc {
+	DTRACE_PTR(char, dtagd_name);		/* not filled in by kernel */
+	dtrace_aggvarid_t dtagd_varid;		/* not filled in by kernel */
+	int dtagd_flags;			/* not filled in by kernel */
+	dtrace_aggid_t dtagd_id;		/* aggregation ID */
+	dtrace_epid_t dtagd_epid;		/* enabled probe ID */
+	uint32_t dtagd_size;			/* size in bytes */
+	int dtagd_nrecs;			/* number of records */
+	uint32_t dtagd_pad;			/* explicit padding */
+	dtrace_recdesc_t dtagd_rec[1];		/* record descriptions */
+} dtrace_aggdesc_t;
+
+typedef struct dtrace_fmtdesc {
+	DTRACE_PTR(char, dtfd_string);		/* format string */
+	int dtfd_length;			/* length of format string */
+	uint16_t dtfd_format;			/* format identifier */
+} dtrace_fmtdesc_t;
+
+#define DTRACE_SIZEOF_EPROBEDESC(desc)				\
+	(sizeof (dtrace_eprobedesc_t) + ((desc)->dtepd_nrecs ?  \
+	(((desc)->dtepd_nrecs - 1) * sizeof (dtrace_recdesc_t)) : 0))
+
+#define	DTRACE_SIZEOF_AGGDESC(desc)			       \
+	(sizeof (dtrace_aggdesc_t) + ((desc)->dtagd_nrecs ?     \
+	(((desc)->dtagd_nrecs - 1) * sizeof (dtrace_recdesc_t)) : 0))
+
+#endif /* _LINUX_DTRACE_METADESC_H */
diff --git a/include/uapi/linux/dtrace/metadesc_defines.h b/include/uapi/linux/dtrace/metadesc_defines.h
new file mode 100644
index 000000000000..52419cf2f4c7
--- /dev/null
+++ b/include/uapi/linux/dtrace/metadesc_defines.h
@@ -0,0 +1,23 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_METADESC_DEFINES_H
+#define _LINUX_DTRACE_METADESC_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+struct dtrace_recdesc;
+struct dtrace_eprobedesc;
+struct dtrace_aggdesc;
+struct dtrace_fmtdesc;
+
+#endif /* _LINUX_DTRACE_METADESC_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/options.h b/include/uapi/linux/dtrace/options.h
new file mode 100644
index 000000000000..5c7db1a8c3fe
--- /dev/null
+++ b/include/uapi/linux/dtrace/options.h
@@ -0,0 +1,19 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_OPTIONS_H
+#define _LINUX_DTRACE_OPTIONS_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/options_defines.h>
+
+#endif /* _LINUX_DTRACE_OPTIONS_H */
diff --git a/include/uapi/linux/dtrace/options_defines.h b/include/uapi/linux/dtrace/options_defines.h
new file mode 100644
index 000000000000..69b93cadf238
--- /dev/null
+++ b/include/uapi/linux/dtrace/options_defines.h
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_OPTIONS_DEFINES_H
+#define _LINUX_DTRACE_OPTIONS_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+/*
+ * Run-time DTrace options are set and retrieved via DOF_SECT_OPTDESC sections
+ * in a DOF image.  The dof_optdesc structure contains an option identifier and
+ * an option value.  The valid option identifiers are found below; the mapping
+ * between option identifiers and option identifying strings is maintained at
+ * user-level.  Note that the value of DTRACEOPT_UNSET is such that all of the
+ * following are potentially valid option values:  all positive integers, zero
+ * and negative one.  Some options (notably "bufpolicy" and "bufresize") take
+ * predefined tokens as their values; these are defined with
+ * DTRACEOPT_{option}_{token}.
+ */
+
+#define	DTRACEOPT_BUFSIZE	0	/* buffer size */
+#define	DTRACEOPT_BUFPOLICY	1	/* buffer policy */
+#define	DTRACEOPT_DYNVARSIZE	2	/* dynamic variable size */
+#define	DTRACEOPT_AGGSIZE	3	/* aggregation size */
+#define	DTRACEOPT_SPECSIZE	4	/* speculation size */
+#define	DTRACEOPT_NSPEC		5	/* number of speculations */
+#define	DTRACEOPT_STRSIZE	6	/* string size */
+#define	DTRACEOPT_CLEANRATE	7	/* dynvar cleaning rate */
+#define	DTRACEOPT_CPU		8	/* CPU to trace */
+#define	DTRACEOPT_BUFRESIZE	9	/* buffer resizing policy */
+#define	DTRACEOPT_GRABANON	10	/* grab anonymous state, if any */
+#define	DTRACEOPT_FLOWINDENT	11	/* indent function entry/return */
+#define	DTRACEOPT_QUIET		12	/* only output explicitly traced data */
+#define	DTRACEOPT_STACKFRAMES	13	/* number of stack frames */
+#define	DTRACEOPT_USTACKFRAMES	14	/* number of user stack frames */
+#define	DTRACEOPT_AGGRATE	15	/* aggregation snapshot rate */
+#define	DTRACEOPT_SWITCHRATE	16	/* buffer switching rate */
+#define	DTRACEOPT_STATUSRATE	17	/* status rate */
+#define	DTRACEOPT_DESTRUCTIVE	18	/* destructive actions allowed */
+#define	DTRACEOPT_STACKINDENT	19	/* output indent for stack traces */
+#define	DTRACEOPT_RAWBYTES	20	/* always print bytes in raw form */
+#define	DTRACEOPT_JSTACKFRAMES	21	/* number of jstack() frames */
+#define	DTRACEOPT_JSTACKSTRSIZE	22	/* size of jstack() string table */
+#define	DTRACEOPT_AGGSORTKEY	23	/* sort aggregations by key */
+#define	DTRACEOPT_AGGSORTREV	24	/* reverse-sort aggregations */
+#define	DTRACEOPT_AGGSORTPOS	25	/* agg. position to sort on */
+#define	DTRACEOPT_AGGSORTKEYPOS	26	/* agg. key position to sort on */
+#define DTRACEOPT_QUIETRESIZE	27	/* quieten buffer-resize messages */
+#define	DTRACEOPT_MAX		28	/* number of options */
+
+#define	DTRACEOPT_UNSET		(dtrace_optval_t)-2	/* unset option */
+
+#define	DTRACEOPT_BUFPOLICY_RING	0	/* ring buffer */
+#define	DTRACEOPT_BUFPOLICY_FILL	1	/* fill buffer, then stop */
+#define	DTRACEOPT_BUFPOLICY_SWITCH	2	/* switch buffers */
+
+#define	DTRACEOPT_BUFRESIZE_AUTO	0	/* automatic resizing */
+#define	DTRACEOPT_BUFRESIZE_MANUAL	1	/* manual resizing */
+
+#endif /* _LINUX_DTRACE_OPTIONS_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/stability.h b/include/uapi/linux/dtrace/stability.h
new file mode 100644
index 000000000000..a9d3a96d7fa9
--- /dev/null
+++ b/include/uapi/linux/dtrace/stability.h
@@ -0,0 +1,51 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_STABILITY_H
+#define _LINUX_DTRACE_STABILITY_H
+
+#include <linux/dtrace/universal.h>
+#include <linux/dtrace/stability_defines.h>
+
+/*
+ * Each DTrace provider advertises the name and data stability of each of its
+ * probe description components, as well as its architectural dependencies.  The
+ * D compiler can query the provider attributes (dtrace_pattr_t) in order to
+ * compute the properties of an input program and report them.
+ */
+
+typedef struct dtrace_ppriv {
+	uint32_t dtpp_flags;			/* privilege flags */
+	uid_t dtpp_uid;				/* user ID */
+} dtrace_ppriv_t;
+
+typedef struct dtrace_attribute {
+	dtrace_stability_t dtat_name;		/* entity name stability */
+	dtrace_stability_t dtat_data;		/* entity data stability */
+	dtrace_class_t dtat_class;		/* entity data dependency */
+} dtrace_attribute_t;
+
+typedef struct dtrace_pattr {
+	dtrace_attribute_t dtpa_provider;	/* provider attributes */
+	dtrace_attribute_t dtpa_mod;		/* module attributes */
+	dtrace_attribute_t dtpa_func;		/* function attributes */
+	dtrace_attribute_t dtpa_name;		/* name attributes */
+	dtrace_attribute_t dtpa_args;		/* args[] attributes */
+} dtrace_pattr_t;
+
+typedef struct dtrace_providerdesc {
+	char dtvd_name[DTRACE_PROVNAMELEN];	/* provider name */
+	dtrace_pattr_t dtvd_attr;		/* stability attributes */
+	dtrace_ppriv_t dtvd_priv;		/* privileges required */
+} dtrace_providerdesc_t;
+
+#endif /* _LINUX_DTRACE_STABILITY_H */
diff --git a/include/uapi/linux/dtrace/stability_defines.h b/include/uapi/linux/dtrace/stability_defines.h
new file mode 100644
index 000000000000..c7b3381f4eae
--- /dev/null
+++ b/include/uapi/linux/dtrace/stability_defines.h
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_STABILITY_DEFINES_H
+#define _LINUX_DTRACE_STABILITY_DEFINES_H
+
+#include <linux/dtrace/universal.h>
+
+typedef uint8_t dtrace_stability_t;	/* stability code */
+typedef uint8_t dtrace_class_t;		/* architectural dependency class */
+
+#define	DTRACE_STABILITY_INTERNAL	0	/* private to DTrace itself */
+#define	DTRACE_STABILITY_PRIVATE	1	/* private to Sun (see docs) */
+#define	DTRACE_STABILITY_OBSOLETE	2	/* scheduled for removal */
+#define	DTRACE_STABILITY_EXTERNAL	3	/* not controlled by Sun */
+#define	DTRACE_STABILITY_UNSTABLE	4	/* new or rapidly changing */
+#define	DTRACE_STABILITY_EVOLVING	5	/* less rapidly changing */
+#define	DTRACE_STABILITY_STABLE		6	/* mature interface from Sun */
+#define	DTRACE_STABILITY_STANDARD	7	/* industry standard */
+#define	DTRACE_STABILITY_MAX		7	/* maximum valid stability */
+
+#define	DTRACE_CLASS_UNKNOWN	0	/* unknown architectural dependency */
+#define	DTRACE_CLASS_CPU	1	/* CPU-module-specific */
+#define	DTRACE_CLASS_PLATFORM	2	/* platform-specific (uname -i) */
+#define	DTRACE_CLASS_GROUP	3	/* hardware-group-specific (uname -m) */
+#define	DTRACE_CLASS_ISA	4	/* ISA-specific (uname -p) */
+#define	DTRACE_CLASS_COMMON	5	/* common to all systems */
+#define	DTRACE_CLASS_MAX	5	/* maximum valid class */
+
+#define DTRACE_PRIV_NONE	0x0000
+#define DTRACE_PRIV_KERNEL	0x0001
+#define DTRACE_PRIV_USER	0x0002
+#define DTRACE_PRIV_PROC	0x0004
+#define DTRACE_PRIV_OWNER	0x0008
+#define DTRACE_PRIV_ALL		(DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER | \
+				 DTRACE_PRIV_PROC | DTRACE_PRIV_OWNER)
+
+struct dtrace_ppriv;
+struct dtrace_attribute;
+struct dtrace_pattr;
+struct dtrace_providerdesc;
+
+#endif /* _LINUX_DTRACE_STABILITY_DEFINES_H */
diff --git a/include/uapi/linux/dtrace/status.h b/include/uapi/linux/dtrace/status.h
new file mode 100644
index 000000000000..44df7c5bc23e
--- /dev/null
+++ b/include/uapi/linux/dtrace/status.h
@@ -0,0 +1,49 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_STATUS_H
+#define _LINUX_DTRACE_STATUS_H
+
+#include <linux/dtrace/universal.h>
+
+/*
+ * The status of DTrace is relayed via the dtrace_status structure.  This
+ * structure contains members to count drops other than the capacity drops
+ * available via the buffer interface (see above).  This consists of dynamic
+ * drops (including capacity dynamic drops, rinsing drops and dirty drops), and
+ * speculative drops (including capacity speculative drops, drops due to busy
+ * speculative buffers and drops due to unavailable speculative buffers).
+ * Additionally, the status structure contains a field to indicate the number
+ * of "fill"-policy buffers have been filled and a boolean field to indicate
+ * that exit() has been called.  If the dtst_exiting field is non-zero, no
+ * further data will be generated until tracing is stopped (at which time any
+ * enablings of the END action will be processed); if user-level sees that
+ * this field is non-zero, tracing should be stopped as soon as possible.
+ */
+
+typedef struct dtrace_status {
+	uint64_t dtst_dyndrops;			/* dynamic drops */
+	uint64_t dtst_dyndrops_rinsing;		/* dyn drops due to rinsing */
+	uint64_t dtst_dyndrops_dirty;		/* dyn drops due to dirty */
+	uint64_t dtst_specdrops;		/* speculative drops */
+	uint64_t dtst_specdrops_busy;		/* spec drops due to busy */
+	uint64_t dtst_specdrops_unavail;	/* spec drops due to unavail */
+	uint64_t dtst_errors;			/* total errors */
+	uint64_t dtst_filled;			/* number of filled bufs */
+	uint64_t dtst_stkstroverflows;		/* stack string tab overflows */
+	uint64_t dtst_dblerrors;		/* errors in ERROR probes */
+	char dtst_killed;			/* non-zero if killed */
+	char dtst_exiting;			/* non-zero if exit() called */
+	char dtst_pad[6];			/* pad out to 64-bit align */
+} dtrace_status_t;
+
+#endif /* _LINUX_DTRACE_STATUS_H */
diff --git a/include/uapi/linux/dtrace/universal.h b/include/uapi/linux/dtrace/universal.h
new file mode 100644
index 000000000000..59ca59b2072a
--- /dev/null
+++ b/include/uapi/linux/dtrace/universal.h
@@ -0,0 +1,46 @@
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ *
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * Note: The contents of this file are private to the implementation of the
+ * DTrace subsystem and are subject to change at any time without notice.
+ */
+
+#ifndef _LINUX_DTRACE_UNIVERSAL_H_
+#define _LINUX_DTRACE_UNIVERSAL_H_
+
+#define	DTRACE_CPUALL		-1	/* all CPUs */
+#define	DTRACE_IDNONE		0	/* invalid probe identifier */
+#define	DTRACE_EPIDNONE		0	/* invalid enabled probe identifier */
+#define	DTRACE_AGGIDNONE	0	/* invalid aggregation identifier */
+#define	DTRACE_AGGVARIDNONE	0	/* invalid aggregation variable ID */
+#define	DTRACE_CACHEIDNONE	0	/* invalid predicate cache */
+#define	DTRACE_PROVNONE		0	/* invalid provider identifier */
+#define	DTRACE_METAPROVNONE	0	/* invalid meta-provider identifier */
+#define	DTRACE_ARGNONE		-1	/* invalid argument index */
+
+#define DTRACE_PROVNAMELEN	64
+#define DTRACE_MODNAMELEN	64
+#define DTRACE_FUNCNAMELEN	128
+#define DTRACE_NAMELEN		64
+#define DTRACE_FULLNAMELEN	(DTRACE_PROVNAMELEN + DTRACE_MODNAMELEN + \
+				 DTRACE_FUNCNAMELEN + DTRACE_NAMELEN + 4)
+#define DTRACE_ARGTYPELEN	128
+
+typedef uint16_t	dtrace_actkind_t;	/* action kind */
+
+typedef uint32_t	dtrace_aggid_t;		/* aggregation identifier */
+typedef uint32_t	dtrace_cacheid_t;	/* predicate cache identifier */
+typedef uint32_t	dtrace_epid_t;		/* enabled probe identifier */
+typedef uint32_t	dtrace_optid_t;		/* option identifier */
+typedef uint32_t	dtrace_specid_t;	/* speculation identifier */
+
+typedef uint64_t	dtrace_aggvarid_t;	/* aggregation variable id */
+typedef uint64_t	dtrace_genid_t;		/* generation identifier */
+typedef uint64_t	dtrace_optval_t;	/* option value */
+
+#endif /* _LINUX_DTRACE_UNIVERSAL_H_ */
diff --git a/init/Kconfig b/init/Kconfig
index 46075327c165..24a1395ce17f 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1221,6 +1221,15 @@ config KALLSYMS_BASE_RELATIVE
 	  time constants, and no relocation pass is required at runtime to fix
 	  up the entries based on the runtime load address of the kernel.
 
+config KALLMODSYMS
+	default y
+	bool "Enable support for /proc/kallmodsyms" if EXPERT
+	depends on KALLSYMS
+	help
+	  This option enables the /proc/kallmodsyms file, which maps symbols
+	  to addresses and their associated modules.  This support requires
+	  a fairly recent elfutils.
+
 config PRINTK
 	default y
 	bool "Enable support for printk" if EXPERT
@@ -1302,6 +1311,20 @@ config EPOLL
 	  Disabling this option will cause the kernel to be built without
 	  support for epoll family of system calls.
 
+config WAITFD
+	bool "Enable waitfd() system call" if EXPERT
+	select ANON_INODES
+	default n
+	help
+	  Enable the waitfd() system call that allows receiving child state
+	  changes from a file descriptor.
+
+          Note: this system call is not upstream: its syscall number is not
+          finalized, and the call itself should only be used by DTrace.
+
+	  If unsure, say N.
+
+
 config SIGNALFD
 	bool "Enable signalfd() system call" if EXPERT
 	select ANON_INODES
@@ -1649,6 +1672,8 @@ config PROFILING
 	  Say Y here to enable the extended profiling support mechanisms used
 	  by profilers such as OProfile.
 
+source "kernel/dtrace/Kconfig"
+
 #
 # Place an empty function call at each tracepoint site. Can be
 # dynamically changed for a probe function.
diff --git a/init/main.c b/init/main.c
index 2d355a61dfc5..85a7b6ff8dd2 100644
--- a/init/main.c
+++ b/init/main.c
@@ -88,6 +88,7 @@
 #include <linux/io.h>
 #include <linux/cache.h>
 #include <linux/rodata_test.h>
+#include <linux/sdt.h>
 
 #include <asm/io.h>
 #include <asm/bugs.h>
@@ -101,6 +102,11 @@ extern void init_IRQ(void);
 extern void fork_init(void);
 extern void radix_tree_init(void);
 
+#ifdef CONFIG_DTRACE
+extern void dtrace_os_init(void);
+extern void dtrace_cpu_init(void);
+#endif
+
 /*
  * Debug helper: via this flag we know that we are in 'early bootup code'
  * where only the boot processor is running with IRQ disabled.  This means
@@ -706,6 +712,10 @@ asmlinkage __visible void __init start_kernel(void)
 		efi_free_boot_services();
 	}
 
+#ifdef CONFIG_DTRACE
+	dtrace_os_init();
+#endif                                                                        
+
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
@@ -1055,6 +1065,10 @@ static noinline void __init kernel_init_freeable(void)
 
 	init_mm_internals();
 
+#ifdef CONFIG_DTRACE
+	dtrace_cpu_init();
+#endif
+
 	do_pre_smp_initcalls();
 	lockup_detector_init();
 
diff --git a/kernel/Makefile b/kernel/Makefile
index 172d151d429c..884aa3df2c3c 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -112,6 +112,7 @@ obj-$(CONFIG_CONTEXT_TRACKING) += context_tracking.o
 obj-$(CONFIG_TORTURE_TEST) += torture.o
 
 obj-$(CONFIG_HAS_IOMEM) += memremap.o
+obj-$(CONFIG_DTRACE) += dtrace/
 
 $(obj)/configs.o: $(obj)/config_data.h
 
diff --git a/kernel/dtrace/Kconfig b/kernel/dtrace/Kconfig
new file mode 100644
index 000000000000..1f070e49c69f
--- /dev/null
+++ b/kernel/dtrace/Kconfig
@@ -0,0 +1,108 @@
+#
+# Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+menuconfig DTRACE
+	bool "DTrace (Dynamic Tracing) Support"
+	default y
+	depends on ARCH_SUPPORTS_DTRACE
+	select KALLSYMS
+	select KALLMODSYMS
+	select WAITFD
+	select CTF
+	help
+	  The DTrace dynamic tracing framework.
+
+if DTRACE
+
+config DT_CORE
+	tristate "DTrace core"
+	default m
+	help
+	  The core of DTrace: needed for all providers.
+
+if DT_CORE
+
+config DT_FASTTRAP
+	tristate "Fasttrap Tracing"
+	default m
+	depends on ARCH_SUPPORTS_UPROBES
+	select UPROBE_EVENT
+	help
+	  Userspace tracing, providing the kernel support needed for tracing
+	  userspace programs.  Currently, only statically defined probes
+	  (USDT) are supported.
+
+config DT_PROFILE
+	tristate "Profile Interrupt Tracing"
+	default m
+	help
+	  The profile and tick providers, firing probes at specific intervals.
+
+config DT_SDT
+	tristate "Statically Defined Tracing"
+	default m
+	select KALLSYMS
+	help
+	  Statically defined tracepoints in the kernel.
+
+config DT_SDT_PERF
+	bool "DTrace perf-events Probes"
+	default y
+        depends on DT_SDT
+        select TRACEPOINTS
+	help
+	  Provides the perf provider, containing a DTrace probe for each
+	  perf-events tracepoint in the system.
+
+config DT_FBT
+	tristate "Function boundary tracing"
+	default m
+	select FTRACE
+	help
+	  Provides function boundary tracing for functions in the kernel.
+
+config DT_SYSTRACE
+	tristate "System Call Tracing"
+	default m
+	select FTRACE
+	select FTRACE_SYSCALLS
+	help
+	  Provides DTrace probes at the entry and exit of all system calls,
+	  in the syscall provider.
+
+config DT_DT_TEST
+	tristate "DTrace Test Probe"
+	default m
+	help
+	  A test provider used by the testsuite.
+
+config DT_DT_PERF
+	tristate "DTrace Performance Test Probe"
+	default m
+	help
+	  A test provider used for performance testing.
+
+config DT_DEBUG
+	bool "DTrace debugging"
+	default m
+	help
+	  This controls the inclusion of various piece of code that perform
+	  internal checks within the DTrace core.  It also enables all the
+	  assertions within the DTrace code.
+
+if DT_DEBUG
+
+config DT_DEBUG_MUTEX
+	bool "DTrace mutex debugging"
+	default n
+	help
+	  This controls the use of DTrace specific wrappers to output debug
+	  messages whenever a mutex is locked or unlocked within the DTrace
+	  code (core and providers).
+
+endif	# DT_DEBUG
+
+endif	# DT_CORE
+
+endif   #DTRACE
diff --git a/kernel/dtrace/Makefile b/kernel/dtrace/Makefile
new file mode 100644
index 000000000000..a0aeb236a424
--- /dev/null
+++ b/kernel/dtrace/Makefile
@@ -0,0 +1,15 @@
+#
+# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+GCOV_PROFILE := y
+
+DT_CORE_ARCH_OBJS		= $(addprefix ../../arch/$(SRCARCH)/kernel/, \
+				    dtrace_syscall.o dtrace_syscall_stubs.o \
+				    dtrace_fbt.o dtrace_sdt.o dtrace_util.o)
+
+ifdef CONFIG_DT_CORE
+obj-y				+= cyclic.o dtrace_os.o dtrace_cpu.o \
+				   dtrace_sdt_core.o dtrace_fbt_core.o \
+				   $(DT_CORE_ARCH_OBJS)
+endif
diff --git a/kernel/dtrace/cyclic.c b/kernel/dtrace/cyclic.c
new file mode 100644
index 000000000000..692400eab22a
--- /dev/null
+++ b/kernel/dtrace/cyclic.c
@@ -0,0 +1,525 @@
+/*
+ * FILE:	cyclic.c
+ * DESCRIPTION:	Minimal cyclic implementation
+ *
+ * Copyright (c) 2010, 2011, 2012, 2013, 2017 Oracle Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/cpu.h>
+#include <linux/cyclic.h>
+#include <linux/hrtimer.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+
+static int		omni_enabled = 0;
+
+#define _CYCLIC_CPU_UNDEF		(-1)
+#define _CYCLIC_CPU_OMNI		(-2)
+#define CYCLIC_IS_OMNI(cyc)		((cyc)->cpu == _CYCLIC_CPU_OMNI)
+
+typedef struct cyclic cyclic_t;
+
+typedef struct cyclic_work {
+	struct work_struct	work;
+	struct cyclic		*cyc;
+} cyclic_work_t;
+
+struct cyclic {
+	struct list_head		list;
+	int				cpu;
+	union {
+		struct {
+			cyc_time_t		when;
+			cyc_handler_t		hdlr;
+			uint32_t		pend;
+			struct hrtimer		timr;
+			cyclic_work_t		work;
+		} cyc;
+		struct {
+			cyc_omni_handler_t	hdlr;
+			struct list_head	cycl;
+		} omni;
+	};
+};
+
+static LIST_HEAD(cyclics);
+
+static void cyclic_fire(struct work_struct *work)
+{
+	cyclic_work_t	*cwork = (cyclic_work_t *)work;
+	cyclic_t	*cyc = cwork->cyc;
+	uint32_t	cpnd, npnd;
+
+	do {
+		/*
+		 * We know that the 'pend' counter for the cyclic is non-zero.
+		 * So, we can start with calling the handler at least once.
+		 */
+		(*cyc->cyc.hdlr.cyh_func)(cyc->cyc.hdlr.cyh_arg);
+
+again:
+		/*
+		 * The 'pend' counter may be modified by cyclic_expire() while
+		 * we go through this loop.  We use an atomic compare-and-set
+		 * instruction to determine whether it got changed.  If so, we
+		 * retrieve the updated 'pend' value and try this again.
+		 *
+		 * Note that when the cyclic is being removed, the hrtimer will
+		 * be cancelled first, which ensures that 'pend' will no longer
+		 * be incremented.  When that happens, this loop will simply
+		 * run through the remaining pending calls, and terminate.
+		 */
+		cpnd = cyc->cyc.pend;
+		npnd = cpnd - 1;
+		if (cmpxchg(&cyc->cyc.pend, cpnd, npnd) != cpnd)
+			goto again;
+	} while (npnd > 0);
+}
+
+/*
+ * Timer expiration handler for cyclic hrtimers.  Cyclic worker functions must
+ * be able to perform a variety of tasks (including calling functions that
+ * could sleep), and therefore they cannot be called from interrupt context.
+ *
+ * We schedule a workqueue to do the actual work.
+ *
+ * But... under heavy load it is possible that the hrtimer will expire again
+ * before the workqueu had a chance to run.  That would lead to missed events
+ * which isn't quite acceptable.  Therefore, we use a counter to record how
+ * many times the timer has expired vs how many times the handler has been
+ * called.  The counter is incremented by this function upon hrtimer expiration
+ * and decremented by the cyclic_fire.  Note that the workqueue is responsible
+ * for calling the handler multiple times if the counter indicates that multiple
+ * invocation are pending.
+ *
+ * This function is called as hrtimer handler, and therefore runs in interrupt
+ * context, which by definition will ensure that manipulation of the 'pend'
+ * counter in the cyclic can be done without locking, and changes will appear
+ * atomic to the cyclic_fire().
+ *
+ * Moral of the story: the handler may not get called at the absolute times as
+ * requested, but it will be called the correct number of times.
+ */
+static enum hrtimer_restart cyclic_expire(struct hrtimer *timr)
+{
+	cyclic_t		*cyc = container_of(timr, cyclic_t, cyc.timr);
+
+	/*
+	 * High priority cyclics call directly into their handler.  This means
+	 * that the handler must satisfy all requirements for executing code in
+	 * interrupt context.
+	 */
+	if (cyc->cyc.hdlr.cyh_level == CY_HIGH_LEVEL) {
+		(*cyc->cyc.hdlr.cyh_func)(cyc->cyc.hdlr.cyh_arg);
+		goto done;
+	}
+
+	/*
+	 * Increment the 'pend' counter, in case the work is already set to
+	 * run.  If the counter was 0 upon entry, we need to schedule the
+	 * work.  If the increment wraps the counter back to 0, we admit
+	 * defeat, and reset it to its max value.
+	 */
+	if (cyc->cyc.pend++ == 0)
+		schedule_work((struct work_struct *)&cyc->cyc.work);
+	else if (cyc->cyc.pend == 0)
+		cyc->cyc.pend = UINT_MAX;
+
+done:
+	/*
+	 * Prepare the timer for the next expiration.
+	 */
+	if (cyc->cyc.when.cyt_interval == CY_INTERVAL_INF)
+		return HRTIMER_NORESTART;
+
+	hrtimer_forward_now(timr, cyc->cyc.when.cyt_interval);
+
+	return HRTIMER_RESTART;
+}
+
+cyclic_t *cyclic_new(int omni)
+{
+	cyclic_t	*cyc;
+
+	cyc = kmalloc(sizeof(cyclic_t), GFP_KERNEL);
+	if (cyc == NULL)
+		return NULL;
+
+	INIT_LIST_HEAD(&cyc->list);
+
+	if (!omni) {
+		cyc->cpu = _CYCLIC_CPU_UNDEF;
+		cyc->cyc.pend = 0;
+		hrtimer_init(&cyc->cyc.timr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		cyc->cyc.timr.function = cyclic_expire;
+		cyc->cyc.work.cyc = cyc;
+		INIT_WORK((struct work_struct *)&cyc->cyc.work, cyclic_fire);
+	} else {
+		cyc->cpu = _CYCLIC_CPU_OMNI;
+		INIT_LIST_HEAD(&cyc->omni.cycl);
+	}
+
+	return cyc;
+}
+
+static inline void cyclic_restart(cyclic_t *cyc)
+{
+	if (cyc->cyc.when.cyt_interval == CY_INTERVAL_INF)
+		return;
+
+	if (cyc->cyc.when.cyt_when == 0)
+		hrtimer_start(&cyc->cyc.timr, cyc->cyc.when.cyt_interval,
+			      HRTIMER_MODE_REL_PINNED);
+	else
+		hrtimer_start(&cyc->cyc.timr, cyc->cyc.when.cyt_when,
+			      HRTIMER_MODE_ABS_PINNED);
+}
+
+/*
+ * Add a new cyclic to the system.
+ */
+cyclic_id_t cyclic_add(cyc_handler_t *hdlr, cyc_time_t *when)
+{
+	cyclic_t	*cyc;
+
+	if (hdlr == NULL || when == NULL)
+		return CYCLIC_NONE;
+
+	cyc = cyclic_new(0);
+	if (cyc == NULL)
+		return CYCLIC_NONE;
+
+	list_add(&cyc->list, &cyclics);
+	cyc->cpu = smp_processor_id();
+	cyc->cyc.when = *when;
+	cyc->cyc.hdlr = *hdlr;
+
+	cyclic_restart(cyc);
+
+	return (cyclic_id_t)cyc;
+}
+EXPORT_SYMBOL(cyclic_add);
+
+static void cyclic_omni_xcall(cyclic_t *cyc)
+{
+	cyclic_restart(cyc);
+}
+
+/*
+ * Add a new cyclic to the system.
+ */
+static void cyclic_add_pinned(int cpu, cyclic_t *omni,
+			      cyc_handler_t *hdlr, cyc_time_t *when)
+{
+	cyclic_t	*cyc;
+
+	cyc = cyclic_new(0);
+	if (cyc == NULL)
+		return;
+
+	list_add(&cyc->list, &omni->omni.cycl);
+	cyc->cpu = cpu;
+	cyc->cyc.when = *when;
+	cyc->cyc.hdlr = *hdlr;
+
+	smp_call_function_single(cpu, (smp_call_func_t)cyclic_omni_xcall,
+				 cyc, 1);
+}
+
+/*
+ * Start a cyclic on a specific CPU as sub-cyclic to an omni-present cyclic.
+ */
+static void cyclic_omni_start(cyclic_t *omni, int cpu)
+{
+	cyc_time_t	when;
+	cyc_handler_t	hdlr;
+
+	omni->omni.hdlr.cyo_online(omni->omni.hdlr.cyo_arg, cpu, &hdlr, &when);
+	cyclic_add_pinned(cpu, omni, &hdlr, &when);
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+static int cyclic_cpu_offline(unsigned int cpu)
+{
+	cyclic_t	*cyc;
+
+	list_for_each_entry(cyc, &cyclics, list) {
+		cyclic_t	*c, *n;
+
+		if (!CYCLIC_IS_OMNI(cyc))
+			continue;
+
+		list_for_each_entry_safe(c, n, &cyc->omni.cycl, list) {
+			if (c->cpu == cpu)
+				cyclic_remove((cyclic_id_t)c);
+		}
+	}
+	return 0;
+}
+
+static int cyclic_cpu_online(unsigned int cpu)
+{
+	cyclic_t	*cyc;
+
+	list_for_each_entry(cyc, &cyclics, list) {
+		cyclic_t	*c, *n;
+
+		if (!CYCLIC_IS_OMNI(cyc))
+			continue;
+
+		list_for_each_entry_safe(c, n, &cyc->omni.cycl, list) {
+			if (c->cpu == cpu)
+				break;
+		}
+
+		if (c->cpu == cpu)
+			continue;
+
+		cyclic_omni_start(cyc, cpu);
+	}
+	return 0;
+}
+#endif
+
+/*
+ * Add a new omnipresent cyclic to the system.
+ */
+cyclic_id_t cyclic_add_omni(cyc_omni_handler_t *omni)
+{
+	int		cpu;
+	cyclic_t	*cyc;
+
+	cyc = cyclic_new(1);
+	if (cyc == NULL)
+		return CYCLIC_NONE;
+
+	list_add(&cyc->list, &cyclics);
+	cyc->omni.hdlr = *omni;
+
+	for_each_online_cpu(cpu)
+		cyclic_omni_start(cyc, cpu);
+
+	return (cyclic_id_t)cyc;
+}
+EXPORT_SYMBOL(cyclic_add_omni);
+
+/*
+ * Remove a specific cyclic from the system.
+ */
+void cyclic_remove(cyclic_id_t id)
+{
+	cyclic_t	*cyc = (cyclic_t *)id;
+
+	if (CYCLIC_IS_OMNI(cyc)) {
+		cyclic_t	*child, *n;
+
+		/*
+		 * If this is an omni-present cyclic, we first need to remove
+		 * all the associated per-CPU cyclics.  Note that the recursive
+		 * call into cyclic_remove() for a child cyclic will remove it
+		 * from the list of per-CPU cyclics associated with the
+		 * omni-present cyclic, so we do not need to handle that here.
+		 */
+		list_for_each_entry_safe(child, n, &cyc->omni.cycl, list)
+			cyclic_remove((cyclic_id_t)child);
+	} else {
+		/*
+		 * We know that hrtimer_cancel() will wait for the timer
+		 * callback to finish if it is being executed at the time of
+		 * making this call.  It is therefore guaranteed that 'pend'
+		 * will no longer get incremented.
+		 *
+		 * The call to cancel_work_sync() will wait for the workqueue
+		 * handler to finish also, and since the handler always brings
+		 * 'pend' down to zero prior to returning, it is guaranteed that
+		 * (1) all pending handler calls will be made before
+		 *     cyclic_remove() returns
+		 * (2) the amount of work to do before returning is finite.
+		 */
+		hrtimer_cancel(&cyc->cyc.timr);
+		cancel_work_sync((struct work_struct *)&cyc->cyc.work);
+	}
+
+	list_del(&cyc->list);
+	kfree(cyc);
+}
+EXPORT_SYMBOL(cyclic_remove);
+
+typedef struct cyclic_reprog {
+	cyclic_id_t	cycid;
+	ktime_t		delta;
+} cyclic_reprog_t;
+
+static void cyclic_reprogram_xcall(cyclic_reprog_t *creprog)
+{
+	cyclic_reprogram(creprog->cycid, creprog->delta);
+}
+
+/*
+ * Reprogram cyclic to fire with given delta from now.
+ *
+ * The underlying design makes it safe to call cyclic_reprogram from whithin a
+ * cyclic handler without race with cylic_remove. If called from outside of the
+ * cyclic handler it is up to the owner to ensure to not call cyclic_reprogram
+ * after call to cyclic_remove.
+ *
+ * This function cannot be called from interrupt/bottom half contexts.
+ */
+void cyclic_reprogram(cyclic_id_t id, ktime_t delta)
+{
+	cyclic_t	*cyc = (cyclic_t *)id;
+
+	/*
+	 * For omni present cyclic we reprogram child for current CPU.
+	 */
+	if (CYCLIC_IS_OMNI(cyc)) {
+		cyclic_t *c, *n;
+
+		list_for_each_entry_safe(c, n, &cyc->omni.cycl, list) {
+			if (c->cpu != smp_processor_id())
+				continue;
+
+			hrtimer_start(&c->cyc.timr, delta,
+				      HRTIMER_MODE_ABS_PINNED);
+
+			break;
+		}
+
+		return;
+	}
+
+	/*
+	 * Regular cyclic reprogram must ensure that the timer remains bound
+	 * to the CPU it was registered on. In case we are called from
+	 * different CPU we use xcall to trigger reprogram from correct cpu.
+	 */
+	if (cyc->cpu != smp_processor_id()) {
+		cyclic_reprog_t creprog = {
+			.cycid = id,
+			.delta = delta,
+		};
+
+		smp_call_function_single(cyc->cpu, (smp_call_func_t)
+					 cyclic_reprogram_xcall, &creprog, 1);
+	} else {
+		hrtimer_start(&cyc->cyc.timr, delta, HRTIMER_MODE_REL_PINNED);
+	}
+}
+EXPORT_SYMBOL(cyclic_reprogram);
+
+static void *s_start(struct seq_file *seq, loff_t *pos)
+{
+	loff_t		n = *pos;
+	cyclic_t	*cyc;
+
+	list_for_each_entry(cyc, &cyclics, list) {
+		if (n == 0)
+			return cyc;
+
+		n--;
+	}
+
+	return NULL;
+}
+
+static void *s_next(struct seq_file *seq, void *p, loff_t *pos)
+{
+	cyclic_t	*cyc = p;
+
+	++*pos;
+
+	cyc = list_entry(cyc->list.next, cyclic_t, list);
+	if (&cyc->list == &cyclics)
+		return NULL;
+
+	return cyc;
+}
+
+static void s_stop(struct seq_file *seq, void *p)
+{
+}
+
+static int s_show(struct seq_file *seq, void *p)
+{
+	cyclic_t	*cyc = p;
+
+	if (CYCLIC_IS_OMNI(cyc)) {
+		cyclic_t	*c;
+
+		seq_printf(seq, "Omni-present cyclic:\n");
+		list_for_each_entry(c, &cyc->omni.cycl, list)
+			seq_printf(seq,
+				   "  CPU-%d: %c %lld ns hdlr %pB arg %llx\n",
+				   c->cpu,
+				   c->cyc.hdlr.cyh_level == CY_HIGH_LEVEL
+					? 'H' : 'l',
+				   c->cyc.when.cyt_interval,
+				   c->cyc.hdlr.cyh_func,
+				   (uint64_t)c->cyc.hdlr.cyh_arg);
+	} else
+		seq_printf(seq, "CPU-%d: %c %lld ns hdlr %pB arg %llx\n",
+			   cyc->cpu,
+			   cyc->cyc.hdlr.cyh_level == CY_HIGH_LEVEL
+				? 'H' : 'l',
+			   cyc->cyc.when.cyt_interval,
+			   cyc->cyc.hdlr.cyh_func,
+			   (uint64_t)cyc->cyc.hdlr.cyh_arg);
+
+	return 0;
+}
+
+static const struct seq_operations	cyclicinfo_ops = {
+	.start	= s_start,
+	.next	= s_next,
+	.stop	= s_stop,
+	.show	= s_show,
+};
+
+static int cyclicinfo_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &cyclicinfo_ops);
+}
+
+static const struct file_operations	proc_cyclicinfo_ops = {
+	.open		= cyclicinfo_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+static int __init cyclic_init(void)
+{
+	int	ret;
+
+	proc_create("cyclicinfo", S_IRUSR, NULL, &proc_cyclicinfo_ops);
+
+#ifdef CONFIG_HOTPLUG_CPU
+	if (!omni_enabled) {
+		ret = cpuhp_setup_state_nocalls(CPUHP_AP_CYCLIC_STARTING,
+						"Cyclic omni-timer starting",
+						cyclic_cpu_online,
+						cyclic_cpu_offline);
+		if (ret)
+			pr_warn_once("Cannot enable cyclic omni timer\n");
+		else
+			omni_enabled = 1;
+	}
+#endif
+
+	return 0;
+}
+module_init(cyclic_init);
diff --git a/kernel/dtrace/dtrace_cpu.c b/kernel/dtrace/dtrace_cpu.c
new file mode 100644
index 000000000000..5187e2909c27
--- /dev/null
+++ b/kernel/dtrace/dtrace_cpu.c
@@ -0,0 +1,52 @@
+/*
+ * FILE:	dtrace_cpu.c
+ * DESCRIPTION:	DTrce - per-CPU state
+ *
+ * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/module.h>
+#include <asm/dtrace_cpuinfo.h>
+
+DEFINE_PER_CPU_SHARED_ALIGNED(cpu_core_t, dtrace_cpu_core);
+EXPORT_PER_CPU_SYMBOL(dtrace_cpu_core);
+
+DEFINE_PER_CPU_SHARED_ALIGNED(cpuinfo_t, dtrace_cpu_info);
+EXPORT_PER_CPU_SYMBOL(dtrace_cpu_info);
+
+void dtrace_cpu_init(void)
+{
+	int	cpu;
+
+	for_each_present_cpu(cpu) {
+		cpuinfo_arch_t		*ci = &cpu_data(cpu);
+		cpuinfo_t		*cpui = per_cpu_info(cpu);
+		cpu_core_t		*cpuc = per_cpu_core(cpu);
+
+		cpui->cpu_id = cpu;
+		cpui->cpu_pset = 0;
+		cpui->cpu_chip = dtrace_cpuinfo_chip(ci);
+		cpui->cpu_lgrp = 0;
+		cpui->cpu_info = ci;
+
+		cpuc->cpuc_dtrace_flags = 0;
+		cpuc->cpuc_dcpc_intr_state = 0;
+		cpuc->cpuc_dtrace_illval = 0;
+		mutex_init(&cpuc->cpuc_pid_lock);
+
+		cpuc->cpu_dtrace_regs = NULL;
+		cpuc->cpu_dtrace_caller = 0;
+		rwlock_init(&cpuc->cpu_ft_lock);
+	}
+}
diff --git a/kernel/dtrace/dtrace_fbt_core.c b/kernel/dtrace/dtrace_fbt_core.c
new file mode 100644
index 000000000000..4d4d9c293492
--- /dev/null
+++ b/kernel/dtrace/dtrace_fbt_core.c
@@ -0,0 +1,123 @@
+/*
+ * FILE:        dtrace_fbt_core.c
+ * DESCRIPTION: DTrace - FBT common code
+ *
+ * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/kallsyms.h>
+#include <linux/rbtree.h>
+#include <linux/slab.h>
+#include <linux/dtrace_fbt.h>
+
+struct dt_fbt_bl_entry {
+	struct rb_node		dfbe_node;
+	unsigned long		dfbe_addr;
+	const char		*dfbe_name;
+};
+
+static struct rb_root dt_fbt_root = RB_ROOT;
+
+dt_fbt_bl_entry_t *
+dtrace_fbt_bl_add(unsigned long addr, const char *name)
+{
+	struct rb_node **p = &dt_fbt_root.rb_node;
+	struct rb_node *parent = NULL;
+	struct dt_fbt_bl_entry *entry;
+
+	/*
+	 * If no address was given, we need to do a symbol name lookup:
+	 *  - If no symbol name was given, we cannot add anything.
+	 *  - If the lookup failed, we cannot add anything.
+	 */
+	if (addr == 0) {
+		if (name == NULL)
+			return NULL;
+
+		addr = kallsyms_lookup_name(name);
+
+		if (addr == 0)
+			return NULL;
+	}
+
+	/* Find place in the tree. */
+	while (*p) {
+		parent = *p;
+		entry = rb_entry(parent, dt_fbt_bl_entry_t, dfbe_node);
+
+		if (addr > entry->dfbe_addr)
+			p = &parent->rb_right;
+		else if (addr < entry->dfbe_addr)
+			p = &parent->rb_left;
+		else
+			return NULL;		/* no duplicates please */
+	}
+
+	/* Create a new blacklist entry. */
+	if ((entry = kmalloc(sizeof(*entry), GFP_KERNEL)) == NULL)
+		return NULL;
+
+	entry->dfbe_name = name;
+	entry->dfbe_addr = addr;
+
+	/* Update the tree. */
+	rb_link_node(&entry->dfbe_node, parent, p);
+	rb_insert_color(&entry->dfbe_node, &dt_fbt_root);
+
+	return entry;
+}
+
+/*
+ * Iterators for blacklisted symbols. The iteration happens in sort order by
+ * virtual memory address. Symbols with pending resolution are inored.
+ */
+dt_fbt_bl_entry_t *
+dtrace_fbt_bl_first(void)
+{
+	struct rb_node *node = rb_first(&dt_fbt_root);
+
+	if (node == NULL)
+		return (NULL);
+
+	return (rb_entry(node, dt_fbt_bl_entry_t, dfbe_node));
+}
+
+dt_fbt_bl_entry_t *
+dtrace_fbt_bl_next(dt_fbt_bl_entry_t *entry)
+{
+	struct rb_node *node = rb_next(&entry->dfbe_node);
+
+	if (node == NULL)
+		return (NULL);
+
+	return (rb_entry(node, dt_fbt_bl_entry_t, dfbe_node));
+}
+
+unsigned long
+dtrace_fbt_bl_entry_addr(dt_fbt_bl_entry_t *entry)
+{
+	if (entry == NULL)
+		return (0);
+
+	return (entry->dfbe_addr);
+}
+
+const char *
+dtrace_fbt_bl_entry_name(dt_fbt_bl_entry_t *entry)
+{
+	if (entry == NULL)
+		return (NULL);
+
+	return (entry->dfbe_name);
+}
diff --git a/kernel/dtrace/dtrace_os.c b/kernel/dtrace/dtrace_os.c
new file mode 100644
index 000000000000..ed3301ea103c
--- /dev/null
+++ b/kernel/dtrace/dtrace_os.c
@@ -0,0 +1,876 @@
+/*
+ * FILE:	dtrace_os.c
+ * DESCRIPTION:	DTrace - OS support functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/binfmts.h>
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_fbt.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_sdt.h>
+#include <linux/fs.h>
+#include <linux/hardirq.h>
+#include <linux/interrupt.h>
+#include <linux/kdebug.h>
+#include <linux/module.h>
+#include <linux/moduleloader.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/stacktrace.h>
+#include <linux/timekeeping.h>
+#include <linux/vmalloc.h>
+#include <linux/kallsyms.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <asm/ptrace.h>
+#include <linux/init_task.h>
+#include <linux/sched/mm.h>
+
+#if defined(CONFIG_DT_FASTTRAP) || defined(CONFIG_DT_FASTTRAP_MODULE)
+# include <linux/uprobes.h>
+#endif /* CONFIG_DT_FASTTRAP || CONFIG_DT_FASTTRAP_MODULE */
+
+/*---------------------------------------------------------------------------*\
+(* OS SPECIFIC DTRACE SETUP                                                  *)
+\*---------------------------------------------------------------------------*/
+struct module		*dtrace_kmod = NULL;
+EXPORT_SYMBOL(dtrace_kmod);
+
+int			dtrace_ustackdepth_max = 2048;
+
+struct kmem_cache	*psinfo_cachep = NULL;
+struct kmem_cache	*dtrace_pdata_cachep = NULL;
+
+void dtrace_os_init(void)
+{
+	size_t module_size;
+
+	if (dtrace_kmod != NULL) {
+		pr_warn_once("%s: cannot be called twice\n", __func__);
+		return;
+	}
+
+	/*
+	 * Setup for module handling.
+	 */
+	dtrace_pdata_cachep = kmem_cache_create("dtrace_pdata_cache",
+				sizeof(dtrace_module_t), 0,
+				SLAB_HWCACHE_ALIGN|SLAB_PANIC,
+				NULL);
+	if (dtrace_pdata_cachep == NULL)
+		pr_debug("Can't allocate kmem cache for pdata\n");
+
+	/*
+	 * A little bit of magic...
+	 * We create a dummy module to represent the core Linux kernel.  The
+	 * only data we're interested in is the name, the SDT probe points data
+	 * (to be filled in by dtrace_sdt_register()), and the probe data.
+	 * DTrace uses an architecture-specific structure (hidden from us here)
+	 * to hold some data.
+	 */
+	module_size = ALIGN(sizeof(struct module), 8);
+	dtrace_kmod = module_alloc(module_size);
+	if (dtrace_kmod == NULL) {
+		pr_warning("%s: cannot allocate kernel pseudo-module\n",
+			   __func__);
+		return;
+	}
+
+	memset(dtrace_kmod, 0, module_size);
+	strlcpy(dtrace_kmod->name, "vmlinux", MODULE_NAME_LEN);
+
+	/*
+	 * Some sizing info is required for kernel module. We are going to use
+	 * modules VA range for trampoline anyway so lets pretend a kernel has
+	 * no init section and VA range (0, MODULES_VADDR) is occupied by kernel itself
+	 */
+#ifdef CONFIG_X86_64
+	dtrace_kmod->core_layout.base = (void *)__START_KERNEL_map;
+	dtrace_kmod->core_layout.size = KERNEL_IMAGE_SIZE;
+#elif defined(CONFIG_SPARC64)
+	/* Hardcoded see pgtable_64.h */
+	dtrace_kmod->core_layout.base = (void *)0x4000000;
+	dtrace_kmod->core_layout.size = 0x2000000;
+#endif
+
+	dtrace_kmod->num_ftrace_callsites = dtrace_fbt_nfuncs;
+	dtrace_kmod->state = MODULE_STATE_LIVE;
+	atomic_inc(&dtrace_kmod->refcnt);
+
+	dtrace_mod_pdata_alloc(dtrace_kmod);
+
+	INIT_LIST_HEAD(&dtrace_kmod->source_list);
+	INIT_LIST_HEAD(&dtrace_kmod->target_list);
+
+	psinfo_cachep = kmem_cache_create("psinfo_cache",
+				sizeof(dtrace_psinfo_t), 0,
+				SLAB_HWCACHE_ALIGN|SLAB_PANIC,
+				NULL);
+
+	/*
+	 * We need to set up a psinfo structure for PID 0 (swapper).
+	 */
+	dtrace_psinfo_alloc(&init_task);
+
+	dtrace_sdt_init();
+	dtrace_sdt_register(dtrace_kmod);
+}
+EXPORT_SYMBOL(dtrace_os_init);
+
+#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
+#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))
+#define TRAMP_RANGE	0x80000000
+
+void *dtrace_alloc_text(struct module *mp, unsigned long size)
+{
+	unsigned long mp_start, mp_end;
+	unsigned long va_start, va_end;
+	void *trampoline;
+
+	/* module range */
+	mp_start = (unsigned long) mp->core_layout.base;
+	mp_end = mp_start + mp->core_layout.size;
+
+	if (mp->init_layout.size) {
+		mp_start = MIN(mp_start, (unsigned long)mp->init_layout.base);
+		mp_end = MAX(mp_end, (unsigned long)mp->init_layout.base +
+			     mp->init_layout.size);
+	}
+
+	/* get trampoline range */
+	va_end = MIN(mp_start + TRAMP_RANGE, MODULES_END);
+	va_start = (mp_end < TRAMP_RANGE) ? 0 : mp_end - TRAMP_RANGE;
+	va_start = MAX(va_start, MODULES_VADDR);
+
+	trampoline =  __vmalloc_node_range(size, 1, va_start, va_end,
+				    GFP_KERNEL, PAGE_KERNEL, 0, NUMA_NO_NODE,
+				    __builtin_return_address(0));
+
+	return trampoline;
+}
+EXPORT_SYMBOL(dtrace_alloc_text);
+
+void dtrace_free_text(void *ptr)
+{
+	return vfree(ptr);
+}
+EXPORT_SYMBOL(dtrace_free_text);
+
+/*---------------------------------------------------------------------------*\
+(* TASK PSINFO SUPPORT                                                       *)
+\*---------------------------------------------------------------------------*/
+/*
+ * Allocate a new dtrace_psinfo_t structure.
+ */
+void dtrace_psinfo_alloc(struct task_struct *tsk)
+{
+	dtrace_psinfo_t		*psinfo;
+	struct mm_struct	*mm = NULL;
+
+	if (likely(tsk->dtrace_psinfo)) {
+		put_psinfo(tsk);
+		tsk->dtrace_psinfo = NULL;	/* while we build one */
+	}
+
+	psinfo = kmem_cache_alloc(psinfo_cachep, GFP_KERNEL);
+	if (psinfo == NULL)
+		goto fail;
+
+	mm = get_task_mm(tsk);
+	if (mm) {
+		size_t	len = mm->arg_end - mm->arg_start;
+		int	i = 0;
+		char	*p;
+
+		/*
+		 * Construct the psargs string.
+		 */
+		if (len > 0) {
+			if (len >= PR_PSARGS_SZ)
+				len = PR_PSARGS_SZ - 1;
+
+			i = access_process_vm(tsk, mm->arg_start,
+					      psinfo->psargs, len, 0);
+
+			if (i > 0) {
+				if (i < len)
+					len = i;
+
+				for (i = 0, --len; i < len; i++) {
+					if (psinfo->psargs[i] == '\0')
+						psinfo->psargs[i] = ' ';
+				}
+			}
+		}
+
+		if (i < 0)
+			i = 0;
+
+		while (i < PR_PSARGS_SZ)
+			psinfo->psargs[i++] = 0;
+
+		/*
+		 * Determine the number of arguments.
+		 */
+		psinfo->argc = 0;
+		for (p = (char *)mm->arg_start; p < (char *)mm->arg_end;
+		     psinfo->argc++) {
+			size_t	l = strnlen_user(p, MAX_ARG_STRLEN);
+
+			if (!l)
+				break;
+
+			p += l + 1;
+		}
+
+		/*
+		 * Limit the number of stored argument pointers.
+		 */
+		if ((len = psinfo->argc) >= PR_ARGV_SZ)
+			len = PR_ARGV_SZ - 1;
+
+		psinfo->argv = kmalloc((len + 1) * sizeof(char *),
+					 GFP_KERNEL);
+		if (psinfo->argv == NULL)
+			goto fail;
+
+		/*
+		 * Now populate the array of argument strings.
+		 */
+		for (i = 0, p = (char *)mm->arg_start; i < len; i++) {
+			psinfo->argv[i] = p;
+			p += strnlen_user(p, MAX_ARG_STRLEN) + 1;
+		}
+		psinfo->argv[len] = NULL;
+
+		/*
+		 * Determine the number of environment variables.
+		 */
+		psinfo->envc = 0;
+		for (p = (char *)mm->env_start; p < (char *)mm->env_end;
+		     psinfo->envc++) {
+			size_t	l = strnlen_user(p, MAX_ARG_STRLEN);
+
+			if (!l)
+				break;
+
+			p += l + 1;
+		}
+
+		/*
+		 * Limit the number of stored environment pointers.
+		 */
+		if ((len = psinfo->envc) >= PR_ENVP_SZ)
+			len = PR_ENVP_SZ - 1;
+
+		psinfo->envp = kmalloc((len + 1) * sizeof(char *),
+					 GFP_KERNEL);
+		if (psinfo->envp == NULL)
+			goto fail;
+
+		/*
+		 * Now populate the array of environment variable strings.
+		 */
+		for (i = 0, p = (char *)mm->env_start; i < len; i++) {
+			psinfo->envp[i] = p;
+			p += strnlen_user(p, MAX_ARG_STRLEN) + 1;
+		}
+		psinfo->envp[len] = NULL;
+
+		psinfo->ustack = (void *)mm->start_stack;
+
+		mmput(mm);
+	} else {
+		size_t	len = min(TASK_COMM_LEN, PR_PSARGS_SZ);
+		int	i;
+
+		/*
+		 * We end up here for tasks that do not have managed memory at
+		 * all, which generally means that this is a kernel thread.
+		 * If it is not, this is still safe because we know that tasks
+		 * always have the comm member populated with something (even
+		 * if it would be an empty string).
+		 */
+		memcpy(psinfo->psargs, tsk->comm, len);
+		for (i = len; i < PR_PSARGS_SZ; i++)
+			psinfo->psargs[i] = 0;
+
+		psinfo->argc = 0;
+		psinfo->argv = kmalloc(sizeof(char *), GFP_KERNEL);
+		psinfo->argv[0] = NULL;
+		psinfo->envc = 0;
+		psinfo->envp = kmalloc(sizeof(char *), GFP_KERNEL);
+		psinfo->envp[0] = NULL;
+	}
+
+	atomic_set(&psinfo->usage, 1);
+	tsk->dtrace_psinfo = psinfo;		/* new one */
+
+	return;
+
+fail:
+	if (mm)
+		mmput(mm);
+
+	if (psinfo) {
+		if (psinfo->argv)
+			kfree(psinfo->argv);
+		if (psinfo->envp)
+			kfree(psinfo->envp);
+
+		kmem_cache_free(psinfo_cachep, psinfo);
+	}
+}
+
+static DEFINE_SPINLOCK(psinfo_lock);
+static dtrace_psinfo_t *psinfo_free_list;
+
+#ifdef CONFIG_DT_DEBUG
+void dt_debug_probe(uint64_t a0, uint64_t a1, uint64_t a2, uint64_t a3,
+		    uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
+{
+	DTRACE_PROBE(test, uint64_t, a0, uint64_t, a1, uint64_t, a2,
+			   uint64_t, a3, uint64_t, a4, uint64_t, a5,
+			   uint64_t, a6, uint64_t, a7);
+}
+#endif
+
+/*
+ * Work queue handler to clean up psinfo structures for tasks that no longer
+ * exist.
+ */
+static void psinfo_cleaner(struct work_struct *work)
+{
+	unsigned long	flags;
+	dtrace_psinfo_t	*psinfo;
+
+	spin_lock_irqsave(&psinfo_lock, flags);
+	psinfo = psinfo_free_list;
+	psinfo_free_list = NULL;
+	spin_unlock_irqrestore(&psinfo_lock, flags);
+
+#ifdef CONFIG_DT_DEBUG
+	dt_debug_probe(10, 20, 30, 40, 50, 60, 70, 80);
+#endif
+
+	while (psinfo) {
+		dtrace_psinfo_t	*next = psinfo->next;
+
+		if (psinfo->argv)
+			kfree(psinfo->argv);
+		if (psinfo->envp)
+			kfree(psinfo->envp);
+
+		kmem_cache_free(psinfo_cachep, psinfo);
+		psinfo = next;
+	}
+}
+
+static DECLARE_WORK(psinfo_cleanup, psinfo_cleaner);
+
+/*
+ * Schedule a psinfo structure for free'ing.
+ */
+void dtrace_psinfo_free(struct task_struct *tsk)
+{
+	unsigned long	flags;
+	dtrace_psinfo_t	*psinfo = tsk->dtrace_psinfo;
+
+	/*
+	 * There are (very few) tasks without psinfo...
+	 */
+	if (unlikely(psinfo == NULL))
+		return;
+
+	tsk->dtrace_psinfo = NULL;
+
+	spin_lock_irqsave(&psinfo_lock, flags);
+	psinfo->next = psinfo_free_list;
+	psinfo_free_list = psinfo;
+	spin_unlock_irqrestore(&psinfo_lock, flags);
+
+	schedule_work(&psinfo_cleanup);
+}
+
+/*---------------------------------------------------------------------------*\
+(* MODULE SUPPORT FUNCTIONS                                                  *)
+\*---------------------------------------------------------------------------*/
+extern struct list_head *dtrace_modules;
+
+/*
+ * Iterate over all loaded kernel modules.  This is requried until the linux
+ * kernel receives its own module iterator.
+ */
+void dtrace_for_each_module(for_each_module_fn func, void *arg)
+{
+	struct module *mp;
+
+	if (func == NULL)
+		return;
+
+	/* The dtrace fake module is not in the list. */
+	func(arg, dtrace_kmod);
+
+	list_for_each_entry(mp, dtrace_modules, list) {
+
+#ifdef MODULES_VADDR
+		if ((uintptr_t)mp < MODULES_VADDR ||
+		    (uintptr_t)mp >= MODULES_END)
+			continue;
+#else
+		if ((uintptr_t)mp < VMALLOC_START ||
+		    (uintptr_t)mp >= VMALLOC_END)
+			continue;
+#endif
+
+		func(arg, mp);
+	}
+}
+EXPORT_SYMBOL_GPL(dtrace_for_each_module);
+
+
+void dtrace_mod_pdata_alloc(struct module *mp)
+{
+	dtrace_module_t *pdata;
+
+	pdata = kmem_cache_alloc(dtrace_pdata_cachep, GFP_KERNEL | __GFP_ZERO);
+	if (pdata == NULL) {
+		mp->pdata = NULL;
+		return;
+	}
+
+	dtrace_mod_pdata_init(pdata);
+	mp->pdata = pdata;
+}
+
+void dtrace_mod_pdata_free(struct module *mp)
+{
+	dtrace_module_t *pdata = mp->pdata;
+
+	if (mp->pdata == NULL)
+		return;
+
+	mp->pdata = NULL;
+	dtrace_mod_pdata_cleanup(pdata);
+	kmem_cache_free(dtrace_pdata_cachep, pdata);
+}
+
+int dtrace_destroy_prov(struct module *mp)
+{
+	dtrace_module_t *pdata = mp->pdata;
+
+	if (pdata != NULL && pdata->prov_exit != NULL)
+		return pdata->prov_exit();
+
+	return 1;
+}
+
+/*---------------------------------------------------------------------------*\
+(* TIME SUPPORT FUNCTIONS                                                    *)
+\*---------------------------------------------------------------------------*/
+dtrace_vtime_state_t	dtrace_vtime_active = 0;
+
+/*
+ * Until Linux kernel gains lock-free realtime clock access we are maintaining
+ * our own version for lock-free access from within a probe context.
+ */
+static struct dtrace_time_fast {
+	seqcount_t	dtwf_seq;
+	ktime_t		dtwf_offsreal[2];
+} dtrace_time ____cacheline_aligned;
+
+/*
+ * Callback from timekeeper code that allows dtrace to update its own time data.
+ */
+void dtrace_update_time(struct timekeeper *tk)
+{
+	raw_write_seqcount_latch(&dtrace_time.dtwf_seq);
+	dtrace_time.dtwf_offsreal[0] = tk->offs_real;
+	raw_write_seqcount_latch(&dtrace_time.dtwf_seq);
+	dtrace_time.dtwf_offsreal[1] = tk->offs_real;
+}
+
+/* Lock free walltime */
+ktime_t dtrace_get_walltime(void)
+{
+	u64 nsec = ktime_get_mono_fast_ns();
+	unsigned int seq;
+	ktime_t offset;
+
+	do {
+		seq = raw_read_seqcount_latch(&dtrace_time.dtwf_seq);
+		offset = dtrace_time.dtwf_offsreal[seq & 0x1];
+	} while (read_seqcount_retry(&dtrace_time.dtwf_seq, seq));
+
+	return ktime_add_ns(offset, nsec);
+}
+EXPORT_SYMBOL(dtrace_get_walltime);
+
+ktime_t dtrace_gethrtime(void)
+{
+	return ns_to_ktime(ktime_get_raw_fast_ns());
+}
+EXPORT_SYMBOL(dtrace_gethrtime);
+
+/* Needed for lockstat probes where we cannot include ktime.h */
+u64 dtrace_gethrtime_ns(void)
+{
+	return ktime_get_raw_fast_ns();
+}
+EXPORT_SYMBOL(dtrace_gethrtime_ns);
+
+void dtrace_vtime_enable(void)
+{
+	dtrace_vtime_state_t	old, new;
+
+	do {
+		old = dtrace_vtime_active;
+		if (old == DTRACE_VTIME_ACTIVE) {
+			pr_warn_once("DTrace virtual time already enabled");
+			return;
+		}
+
+		new = DTRACE_VTIME_ACTIVE;
+	} while (cmpxchg(&dtrace_vtime_active, old, new) != old);
+}
+EXPORT_SYMBOL(dtrace_vtime_enable);
+
+void dtrace_vtime_disable(void)
+{
+	int	old, new;
+
+	do {
+		old = dtrace_vtime_active;
+		if (old == DTRACE_VTIME_INACTIVE) {
+			pr_warn_once("DTrace virtual time already disabled");
+			return;
+		}
+
+		new = DTRACE_VTIME_INACTIVE;
+	} while (cmpxchg(&dtrace_vtime_active, old, new) != old);
+}
+EXPORT_SYMBOL(dtrace_vtime_disable);
+
+void dtrace_vtime_switch(struct task_struct *prev, struct task_struct *next)
+{
+	ktime_t	now = dtrace_gethrtime();
+
+	if (ktime_nz(prev->dtrace_start)) {
+		prev->dtrace_vtime = ktime_add(prev->dtrace_vtime,
+					       ktime_sub(now,
+							 prev->dtrace_start));
+		prev->dtrace_start = ktime_set(0, 0);
+	}
+
+	next->dtrace_start = now;
+}
+
+void dtrace_stacktrace(stacktrace_state_t *st)
+{
+	struct stack_trace	trace;
+	int			i;
+
+	if ((st->flags & STACKTRACE_TYPE) == STACKTRACE_USER) {
+		dtrace_user_stacktrace(st);
+		return;
+	}
+
+	trace.nr_entries = 0;
+	trace.max_entries = st->limit ? st->limit : 512;
+	trace.entries = (typeof(trace.entries))st->pcs;
+	trace.skip = st->depth;
+
+	if (st->pcs == NULL) {
+		st->depth = 0;
+		return;
+	}
+
+	save_stack_trace(&trace);
+
+	/*
+	 * For entirely unknown reasons, the save_stack_trace() implementation
+	 * on x86_64 adds a ULONG_MAX entry after the last stack trace entry.
+	 * This might be a sentinel value, but given that struct stack_trace
+	 * already contains a nr_entries counter, this seems rather pointless.
+	 * Alas, we need to add a special case for that...  And to make matters
+	 * worse, it actually does this only when there is room for it (i.e.
+	 * when nr_entries < max_entries).
+	 * Since ULONG_MAX inever a valid PC, we can just check for that.
+	 */
+#ifdef CONFIG_X86_64
+	if (trace.nr_entries && st->pcs[trace.nr_entries - 1] == ULONG_MAX)
+		st->depth = trace.nr_entries - 1;
+#else
+	st->depth = trace.nr_entries;
+#endif
+
+	if (st->fps != NULL) {
+		for (i = 0; i < st->limit; i++)
+			st->fps[i] = 0;
+	}
+}
+EXPORT_SYMBOL(dtrace_stacktrace);
+
+/*---------------------------------------------------------------------------*\
+(* INVALID OPCODE AND PAGE FAULT HANDLING                                    *)
+\*---------------------------------------------------------------------------*/
+static struct notifier_block	dtrace_die = {
+	.notifier_call = dtrace_die_notifier,
+	.priority = 0x7fffffff
+};
+
+static int	dtrace_enabled = 0;
+
+/*
+ * DTrace enable/disable must be called with dtrace_lock being held. It is not
+ * possible to check for safety here with an ASSERT as the lock itself is in the
+ * DTrace Framework kernel module.
+ */
+int dtrace_enable(void)
+{
+	if (dtrace_enabled)
+		return 0;
+
+	if (register_die_notifier(&dtrace_die) != 0)
+		return 1;
+
+	dtrace_enabled = 1;
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_enable);
+
+void dtrace_disable(void)
+{
+	if (!dtrace_enabled)
+		return;
+
+	unregister_die_notifier(&dtrace_die);
+	dtrace_enabled = 0;
+}
+EXPORT_SYMBOL(dtrace_disable);
+
+/*---------------------------------------------------------------------------*\
+(* USER SPACE TRACING (FASTTRAP) SUPPORT                                     *)
+\*---------------------------------------------------------------------------*/
+void (*dtrace_helpers_cleanup)(struct task_struct *);
+EXPORT_SYMBOL(dtrace_helpers_cleanup);
+void (*dtrace_fasttrap_probes_cleanup)(struct task_struct *);
+EXPORT_SYMBOL(dtrace_fasttrap_probes_cleanup);
+void (*dtrace_helpers_fork)(struct task_struct *, struct task_struct *);
+EXPORT_SYMBOL(dtrace_helpers_fork);
+
+void dtrace_task_reinit(struct task_struct *tsk)
+{
+	tsk->predcache = 0;
+	tsk->dtrace_stop = 0;
+	tsk->dtrace_sig = 0;
+
+	tsk->dtrace_helpers = NULL;
+	tsk->dtrace_probes = 0;
+	tsk->dtrace_tp_count = 0;
+}
+
+void dtrace_task_init(struct task_struct *tsk)
+{
+	dtrace_task_reinit(tsk);
+
+	tsk->dtrace_vtime = ktime_set(0, 0);
+	tsk->dtrace_start = ktime_set(0, 0);
+}
+
+void dtrace_task_fork(struct task_struct *tsk, struct task_struct *child)
+{
+	if (likely(dtrace_helpers_fork == NULL))
+		return;
+
+	if (tsk->dtrace_helpers != NULL)
+		(*dtrace_helpers_fork)(tsk, child);
+}
+
+void dtrace_task_cleanup(struct task_struct *tsk)
+{
+	if (likely(dtrace_helpers_cleanup == NULL))
+		return;
+
+	if (tsk->dtrace_helpers != NULL)
+		(*dtrace_helpers_cleanup)(tsk);
+
+	if (tsk->dtrace_probes) {
+		if (dtrace_fasttrap_probes_cleanup != NULL)
+			(*dtrace_fasttrap_probes_cleanup)(tsk);
+	}
+}
+
+#if defined(CONFIG_DT_FASTTRAP) || defined(CONFIG_DT_FASTTRAP_MODULE)
+int (*dtrace_tracepoint_hit)(fasttrap_machtp_t *, struct pt_regs *);
+EXPORT_SYMBOL(dtrace_tracepoint_hit);
+
+struct task_struct *register_pid_provider(pid_t pid)
+{
+	struct task_struct	*p;
+
+	/*
+	 * Make sure the process exists, (FIXME: isn't a child created as the
+	 * result of a vfork(2)), and isn't a zombie (but may be in fork).
+	 */
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	if ((p = find_task_by_vpid(pid)) == NULL) {
+		read_unlock(&tasklist_lock);
+		rcu_read_unlock();
+		return NULL;
+	}
+
+	get_task_struct(p);
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	if (p->state & TASK_DEAD ||
+	    p->exit_state & (EXIT_ZOMBIE | EXIT_DEAD)) {
+		put_task_struct(p);
+		return NULL;
+	}
+
+	/*
+	 * Increment dtrace_probes so that the process knows to inform us
+	 * when it exits or execs. fasttrap_provider_free() decrements this
+	 * when we're done with this provider.
+	 */
+	p->dtrace_probes++;
+	put_task_struct(p);
+
+	return p;
+}
+EXPORT_SYMBOL(register_pid_provider);
+
+void unregister_pid_provider(pid_t pid)
+{
+	struct task_struct	*p;
+
+	/*
+	 * Decrement dtrace_probes on the process whose provider we're
+	 * freeing. We don't have to worry about clobbering somone else's
+	 * modifications to it because we have locked the bucket that
+	 * corresponds to this process's hash chain in the provider hash
+	 * table. Don't sweat it if we can't find the process.
+	 */
+	rcu_read_lock();
+	read_lock(&tasklist_lock);
+	if ((p = find_task_by_vpid(pid)) == NULL) {
+		read_unlock(&tasklist_lock);
+		rcu_read_unlock();
+		return;
+	}
+
+	get_task_struct(p);
+	read_unlock(&tasklist_lock);
+	rcu_read_unlock();
+
+	p->dtrace_probes--;
+	put_task_struct(p);
+}
+EXPORT_SYMBOL(unregister_pid_provider);
+
+static int handler(struct uprobe_consumer *self, struct pt_regs *regs)
+{
+	fasttrap_machtp_t	*mtp = container_of(self, fasttrap_machtp_t,
+						    fmtp_cns);
+	int			rc = 0;
+
+	read_lock(&this_cpu_core->cpu_ft_lock);
+	if (dtrace_tracepoint_hit == NULL)
+		pr_warn("Fasttrap probes, but no handler\n");
+	else
+		rc = (*dtrace_tracepoint_hit)(mtp, regs);
+	read_unlock(&this_cpu_core->cpu_ft_lock);
+
+	return rc;
+}
+
+int dtrace_tracepoint_enable(pid_t pid, uintptr_t addr,
+			     fasttrap_machtp_t *mtp)
+{
+	struct task_struct	*p;
+	struct inode		*ino;
+	struct vm_area_struct	*vma;
+	loff_t			off;
+	int			rc = 0;
+
+	mtp->fmtp_ino = NULL;
+	mtp->fmtp_off = 0;
+
+	p = find_task_by_vpid(pid);
+	if (!p) {
+		pr_warn("PID %d not found\n", pid);
+		return -ESRCH;
+	}
+
+	vma = find_vma(p->mm, addr);
+	if (vma == NULL || vma->vm_file == NULL)
+		return -EFAULT;
+
+	ino = vma->vm_file->f_mapping->host;
+	off = ((loff_t)vma->vm_pgoff << PAGE_SHIFT) + (addr - vma->vm_start);
+
+	mtp->fmtp_cns.handler = handler;
+
+	rc = uprobe_register(ino, off, &mtp->fmtp_cns);
+
+	/*
+	 * If successful, increment the count of the number of
+	 * tracepoints active in the victim process.
+	 */
+	if (rc == 0) {
+		mtp->fmtp_ino = ino;
+		mtp->fmtp_off = off;
+
+		p->dtrace_tp_count++;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(dtrace_tracepoint_enable);
+
+int dtrace_tracepoint_disable(pid_t pid, fasttrap_machtp_t *mtp)
+{
+	struct task_struct	*p;
+
+	if (!mtp || !mtp->fmtp_ino) {
+		pr_warn("DTRACE: Tracepoint was never enabled\n");
+		return -ENOENT;
+	}
+
+	if (!mtp->fmtp_cns.handler) {
+		pr_warn("DTRACE: No handler for tracepoint\n");
+		return -ENOENT;
+	}
+
+	uprobe_unregister(mtp->fmtp_ino, mtp->fmtp_off, &mtp->fmtp_cns);
+
+	mtp->fmtp_ino = NULL;
+	mtp->fmtp_off = 0;
+
+	/*
+	 * Decrement the count of the number of tracepoints active in
+	 * the victim process (if it still exists).
+	 */
+	p = find_task_by_vpid(pid);
+	if (p)
+		p->dtrace_tp_count--;
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_tracepoint_disable);
+#endif /* CONFIG_DT_FASTTRAP || CONFIG_DT_FASTTRAP_MODULE */
diff --git a/kernel/dtrace/dtrace_sdt_core.c b/kernel/dtrace/dtrace_sdt_core.c
new file mode 100644
index 000000000000..28fbab2cd655
--- /dev/null
+++ b/kernel/dtrace/dtrace_sdt_core.c
@@ -0,0 +1,357 @@
+/*
+ * FILE:        dtrace_sdt_core.c
+ * DESCRIPTION: DTrace - SDT probes
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/memory.h>
+#include <linux/module.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_sdt.h>
+#include <linux/jhash.h>
+#include <linux/sdt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <asm-generic/bitsperlong.h>
+#include <asm-generic/sections.h>
+
+const char		*sdt_prefix = "__dtrace_probe_";
+
+/*
+ * Markers of core-kernel sdt_args and sdt_names sections.
+ */
+extern const char __start_dtrace_sdt_args[];
+extern const char __stop_dtrace_sdt_args[];
+extern const char __start_dtrace_sdt_names[];
+extern const char __stop_dtrace_sdt_names[];
+
+static int sdt_probe_set(sdt_probedesc_t *sdp, char *name, char *func,
+			 uintptr_t addr, asm_instr_t **paddr,\
+			 sdt_probedesc_t *prv)
+{
+	if ((sdp->sdpd_name = kstrdup(name, GFP_KERNEL)) == NULL) {
+		kfree(sdp);
+		return 1;
+	}
+
+	if ((sdp->sdpd_func = kstrdup(func, GFP_KERNEL)) == NULL) {
+		kfree(sdp->sdpd_name);
+		kfree(sdp);
+		return 1;
+	}
+
+	sdp->sdpd_args = NULL;
+	sdp->sdpd_offset = addr;
+	sdp->sdpd_next = NULL;
+
+	*paddr = (asm_instr_t *)addr;
+
+	if (prv && strcmp(prv->sdpd_name, sdp->sdpd_name) == 0
+		&& strcmp(prv->sdpd_func, sdp->sdpd_func) == 0)
+		prv->sdpd_next = sdp;
+
+	return 0;
+}
+
+/*
+ * Transfer the SDT args section into the sdpd_args field left NULL above.
+ *
+ * The memory pointed to by args_start must have a lifetime at least as long as
+ * that pointed to by sdpd.
+ */
+void dtrace_sdt_stash_args(const char *module_name,
+			   sdt_probedesc_t *sdpd, size_t nprobes,
+			   const char *names_start, size_t names_len,
+			   const char *args_start, size_t args_len)
+{
+	struct probe_name_hashent_t {
+		const char *pnhe_name;
+		const char *pnhe_args;
+	} *args_by_name;
+	int i;
+	const char *namep, *argp;
+	size_t hashsize;
+
+	/*
+	 * We need to find the probes (and there may be many) in the sdpd
+	 * corresponding to the probe with that name in the argtype section.
+	 *
+	 * Build a hashtable mapping from probe name -> args string, ignoring
+	 * duplicate probe names except to check (in debugging mode) that they
+	 * have the same args string as the first.  Then cycle over the sdpd
+	 * looking up each probe in turn and pointing to the same place.
+	 *
+	 * We don't know how many entries there are in the table, but we do know
+	 * there cannot be more than nprobes (and are probably less).
+	 */
+
+	hashsize = nprobes * 4;			/* arbitrary expansion factor */
+	args_by_name = vzalloc(hashsize * sizeof (struct probe_name_hashent_t));
+	if (args_by_name == NULL) {
+		pr_warning("%s: cannot allocate hash for sdt args population\n",
+			   __func__);
+		return;
+	}
+
+	namep = names_start;
+	argp = args_start;
+	while ((namep < names_start + names_len) &&
+	       (argp < args_start + args_len)) {
+
+		size_t l = strlen(namep);
+		u32 h = jhash(namep, l, 0);
+		h = h % hashsize;
+
+		while (args_by_name[h].pnhe_name != NULL &&
+		       strcmp(args_by_name[h].pnhe_name, namep) != 0) {
+			h++;
+			h %= hashsize;
+		}
+
+		if (args_by_name[h].pnhe_name == NULL) {
+			args_by_name[h].pnhe_name = namep;
+			args_by_name[h].pnhe_args = argp;
+		}
+#if defined(CONFIG_DT_DEBUG)
+		else if (strcmp(args_by_name[h].pnhe_name, namep) != 0)
+			printk(KERN_WARNING "%s: multiple "
+			       "distinct arg strings for probe "
+			       "%s found: %s versus %s",
+			       module_name, namep,
+			       args_by_name[h].pnhe_args,
+			       argp);
+#endif
+		namep += l + 1;
+		argp += strlen(argp) + 1;
+	}
+
+#if defined(CONFIG_DT_DEBUG)
+	if ((namep < names_start + names_len) || (argp < args_start + args_len))
+		printk(KERN_WARNING "%s: Not all SDT names or args consumed: %zi "
+		       "bytes of names and %zi of args left over.  Some arg types "
+		       "will be mis-assigned.\n", module_name,
+		       namep - (names_start + names_len),
+		       argp - (args_start + args_len));
+#endif
+
+	for (i = 0; i < nprobes; i++) {
+		size_t l = strlen(sdpd[i].sdpd_name);
+		u32 h = jhash(sdpd[i].sdpd_name, l, 0);
+		h = h % hashsize;
+
+		/*
+		 * Is-enabled probes have no arg string.
+		 */
+		if (sdpd[i].sdpd_name[0] == '?')
+			continue;
+
+		while (args_by_name[h].pnhe_name != NULL &&
+		       strcmp(sdpd[i].sdpd_name,
+			      args_by_name[h].pnhe_name) != 0) {
+			h++;
+			h %= hashsize;
+		}
+
+		if (args_by_name[h].pnhe_name == NULL) {
+			/*
+			 * No arg string. Peculiar: report in debugging mode.
+			 */
+#if defined(CONFIG_DT_DEBUG)
+			printk(KERN_WARNING "%s: probe %s has no arg string.\n",
+			       module_name, sdpd[i].sdpd_name);
+#endif
+			continue;
+		}
+
+		sdpd[i].sdpd_args = args_by_name[h].pnhe_args;
+	}
+	vfree(args_by_name);
+}
+
+/*
+ * Register the SDT probes for the core kernel, i.e. SDT probes that reside in
+ * vmlinux.  For SDT probes in kernel modules, we use dtrace_mod_notifier().
+ */
+void dtrace_sdt_register(struct module *mp)
+{
+	int			i, cnt;
+	dtrace_sdt_probeinfo_t	*pi =
+				(dtrace_sdt_probeinfo_t *)&dtrace_sdt_probes;
+	void			*nextpi;
+	sdt_probedesc_t		*sdps;
+	asm_instr_t		**addrs;
+	int			*is_enabled;
+	void			*args;
+	size_t			args_len;
+
+	if (mp == NULL) {
+		pr_warning("%s: no module provided - nothing registered\n",
+			   __func__);
+		return;
+	}
+
+	/*
+	 * Just in case we run into failures further on...
+	 */
+	mp->sdt_probes = NULL;
+	mp->sdt_probec = 0;
+
+	if (dtrace_sdt_nprobes == 0)
+		return;
+
+	/*
+	 * Allocate the array of SDT probe descriptions to be registered in the
+	 * vmlinux pseudo-module.
+	 */
+	sdps = (sdt_probedesc_t *)vmalloc(dtrace_sdt_nprobes *
+				          sizeof(sdt_probedesc_t));
+	if (sdps == NULL) {
+		pr_warning("%s: cannot allocate SDT probe array\n", __func__);
+		return;
+	}
+
+	/*
+	 * Create a list of addresses (SDT probe locations) that need to be
+	 * patched with a NOP instruction (or instruction sequence), and another
+	 * array indicating whether each probe needs patching with an
+	 * arch-dependent false return instead.
+	 */
+	addrs = (asm_instr_t **)vmalloc(dtrace_sdt_nprobes *
+					sizeof(asm_instr_t *));
+	is_enabled = (int *)vmalloc(dtrace_sdt_nprobes * sizeof(int));
+	if ((addrs == NULL) || (is_enabled == NULL)) {
+		pr_warning("%s: cannot allocate SDT probe address/is-enabled "
+			   "lists\n", __func__);
+		vfree(sdps);
+		vfree(addrs);
+		vfree(is_enabled);
+		return;
+	}
+
+	for (i = cnt = 0; cnt < dtrace_sdt_nprobes; i++) {
+		char	*func = pi->name + pi->name_len + 1;
+
+		is_enabled[cnt] = (pi->name[0] == '?');
+
+		if (sdt_probe_set(&sdps[cnt], pi->name, func, pi->addr,
+				  &addrs[cnt],
+				  cnt > 0 ? &sdps[cnt - 1] : NULL))
+			pr_warning("%s: failed to add SDT probe %s\n",
+				   __func__, pi->name);
+		else
+			cnt++;
+
+		nextpi = (void *)pi + sizeof(dtrace_sdt_probeinfo_t)
+			+ roundup(pi->name_len + 1 +
+				  pi->func_len + 1, BITS_PER_LONG / 8);
+		pi = nextpi;
+	}
+
+	mp->sdt_probes = sdps;
+	mp->sdt_probec = cnt;
+
+	dtrace_sdt_nop_multi(addrs, is_enabled, cnt);
+
+	/*
+	 * Allocate space for the array of arg types, and copy it in from the
+	 * (discardable) kernel section.  We will need to keep it.  (The
+	 * identically-ordered array of probe names is not needed after
+	 * initialization.)
+	 */
+	args_len = __stop_dtrace_sdt_args - __start_dtrace_sdt_args;
+	args = vmalloc(args_len);
+	if (args == NULL) {
+		pr_warning("%s: cannot allocate table of SDT arg types\n",
+			__func__);
+		goto end;
+	}
+
+	memcpy(args, __start_dtrace_sdt_args, args_len);
+
+	dtrace_sdt_stash_args("vmlinux", sdps, cnt,
+			      __start_dtrace_sdt_names,
+			      (__stop_dtrace_sdt_names - __start_dtrace_sdt_names),
+			      args, args_len);
+
+end:
+	vfree(addrs);
+	vfree(is_enabled);
+}
+
+static int __init nosdt(char *str)
+{
+        dtrace_sdt_nprobes = 0;
+
+        return 0;
+}
+
+early_param("nosdt", nosdt);
+
+void dtrace_sdt_register_module(struct module *mp,
+				void *sdt_names_addr, size_t sdt_names_len,
+				void *sdt_args_addr, size_t sdt_args_len)
+{
+	int			i, cnt;
+	sdt_probedesc_t		*sdp;
+	asm_instr_t		**addrs;
+	int			*is_enabled;
+
+	if (mp->sdt_probec == 0 || mp->sdt_probes == NULL)
+		return;
+
+	/*
+	 * Create a list of addresses (SDT probe locations) that need to be
+	 * patched with a NOP instruction (or instruction sequence).
+	 */
+	addrs = (asm_instr_t **)vmalloc(mp->sdt_probec *
+					sizeof(asm_instr_t *));
+	is_enabled = (int *)vmalloc(mp->sdt_probec * sizeof(int));
+	if ((addrs == NULL) || (is_enabled == NULL)) {
+		pr_warning("%s: cannot allocate SDT probe address list (%s)\n",
+			   __func__, mp->name);
+		vfree(addrs);
+		vfree(is_enabled);
+		return;
+	}
+
+	for (i = cnt = 0, sdp = mp->sdt_probes; i < mp->sdt_probec;
+	     i++, sdp++) {
+		addrs[cnt] = (asm_instr_t *)sdp->sdpd_offset;
+		is_enabled[cnt++] = (sdp->sdpd_name[0] == '?');
+	}
+
+	dtrace_sdt_nop_multi(addrs, is_enabled, cnt);
+
+	dtrace_sdt_stash_args(mp->name, mp->sdt_probes, mp->sdt_probec,
+			      sdt_names_addr, sdt_names_len,
+			      sdt_args_addr, sdt_args_len);
+
+	vfree(addrs);
+	vfree(is_enabled);
+}
+
+void dtrace_sdt_init(void)
+{
+	dtrace_sdt_init_arch();
+}
+
+#if defined(CONFIG_DT_DT_PERF) || defined(CONFIG_DT_DT_PERF_MODULE)
+void dtrace_sdt_perf(void)
+{
+	DTRACE_PROBE(measure);
+}
+EXPORT_SYMBOL(dtrace_sdt_perf);
+#endif
diff --git a/kernel/exit.c b/kernel/exit.c
index e3a08761eb40..e31d41bc93da 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -62,6 +62,8 @@
 #include <linux/random.h>
 #include <linux/rcuwait.h>
 #include <linux/compat.h>
+#include <linux/sdt.h>
+#include <linux/dtrace_os.h>
 
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
@@ -849,6 +851,14 @@ void __noreturn do_exit(long code)
 	tsk->exit_code = code;
 	taskstats_exit(tsk, group_dead);
 
+	DTRACE_PROC(lwp__exit);
+	if (group_dead)
+		DTRACE_PROC(exit, int, code & 0x80 ? 3 : code & 0x7f ? 2 : 1);
+
+#ifdef CONFIG_DTRACE
+	dtrace_task_cleanup(tsk);
+#endif
+
 	exit_mm();
 
 	if (group_dead)
@@ -1635,7 +1645,10 @@ long kernel_wait4(pid_t upid, int __user *stat_addr, int options,
 	enum pid_type type;
 	long ret;
 
-	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
+	/*
+	 * As for wait4(), except that waitfd() additionally needs WNOWAIT.
+	 */
+	if (options & ~(WNOHANG|WNOWAIT|WUNTRACED|WCONTINUED|
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
@@ -1674,7 +1687,13 @@ SYSCALL_DEFINE4(wait4, pid_t, upid, int __user *, stat_addr,
 		int, options, struct rusage __user *, ru)
 {
 	struct rusage r;
-	long err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);
+	long err;
+
+	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
+			__WNOTHREAD|__WCLONE|__WALL))
+		return -EINVAL;
+
+	err = kernel_wait4(upid, stat_addr, options, ru ? &r : NULL);
 
 	if (err > 0) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
diff --git a/kernel/fork.c b/kernel/fork.c
index 98c91bd341b4..5fb2c79d2664 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -90,6 +90,8 @@
 #include <linux/kcov.h>
 #include <linux/livepatch.h>
 #include <linux/thread_info.h>
+#include <linux/sdt.h>
+#include <linux/dtrace_os.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -367,6 +369,9 @@ void put_task_stack(struct task_struct *tsk)
 
 void free_task(struct task_struct *tsk)
 {
+#ifdef CONFIG_DTRACE
+	put_psinfo(tsk);
+#endif
 #ifndef CONFIG_THREAD_INFO_IN_TASK
 	/*
 	 * The task is finally done with both the stack and thread_info,
@@ -585,6 +590,12 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	tsk->fail_nth = 0;
 #endif
 
+#ifdef CONFIG_DTRACE
+	if (likely(tsk->dtrace_psinfo))
+		get_psinfo(tsk);
+
+	dtrace_task_init(tsk);
+#endif
 	return tsk;
 
 free_stack:
@@ -1924,6 +1935,26 @@ static __latent_entropy struct task_struct *copy_process(
 	syscall_tracepoint_update(p);
 	write_unlock_irq(&tasklist_lock);
 
+#ifdef CONFIG_DTRACE
+	/*
+	 * If we're called with stack_start != 0, this is almost certainly a
+	 * thread being created in current.  Make sure it gets its own psinfo
+	 * data, because we need to record a new bottom of stack value.
+	 */
+	if (p->mm && stack_start) {
+		dtrace_psinfo_alloc(p);
+		p->dtrace_psinfo->ustack = (void *)stack_start;
+	}
+
+	/*
+	 * We make this call fairly late into the copy_process() handling,
+	 * because we need to ensure that we can look up this task based on
+	 * its pid using find_task_by_vpid().  We also must ensure that the
+	 * tasklist_lock has been released.
+	 */
+	dtrace_task_fork(current, p);
+#endif
+
 	proc_fork_connector(p);
 	cgroup_post_fork(p);
 	cgroup_threadgroup_change_end(current);
@@ -2082,6 +2113,8 @@ long _do_fork(unsigned long clone_flags,
 		}
 
 		put_pid(pid);
+		DTRACE_PROC(lwp__create, struct task_struct * : (lwpsinfo_t *, psinfo_t *), p);
+		DTRACE_PROC(create, struct task_struct * : psinfo_t *, p);
 	} else {
 		nr = PTR_ERR(p);
 	}
diff --git a/kernel/kallsyms.c b/kernel/kallsyms.c
index 127e7cfafa55..c2e4f79f0dde 100644
--- a/kernel/kallsyms.c
+++ b/kernel/kallsyms.c
@@ -48,6 +48,8 @@ __attribute__((weak, section(".rodata")));
 
 extern const u8 kallsyms_token_table[] __weak;
 extern const u16 kallsyms_token_index[] __weak;
+extern const char kallsyms_modules[] __weak;
+extern const u32 kallsyms_symbol_modules[] __weak;
 
 extern const unsigned long kallsyms_markers[] __weak;
 
@@ -228,12 +230,59 @@ int kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,
 }
 EXPORT_SYMBOL_GPL(kallsyms_on_each_symbol);
 
+static unsigned long get_symbol_size(unsigned long kallsyms_addr)
+{
+	unsigned long size = 0;
+	unsigned long sym_addr = kallsyms_sym_address(kallsyms_addr);
+	unsigned long used_i = 0;
+	unsigned long used_i_addr = 0;
+
+	/*
+	 * __per_cpu_end always has size zero.
+	 */
+	if (sym_addr == (unsigned long)__per_cpu_end)
+		return 0;
+
+	/*
+	 * Search for next non-aliased symbol.  Aliased symbols are symbols with
+	 * the same address.
+	 */
+	if (kallsyms_addr < (kallsyms_num_syms - 1)) {
+		unsigned long i;
+
+		for (i = kallsyms_addr + 1; i < kallsyms_num_syms; i++) {
+			if (kallsyms_sym_address(i) > sym_addr) {
+				size = kallsyms_sym_address(i) - sym_addr;
+				used_i = i;
+				used_i_addr = kallsyms_sym_address(i);
+				break;
+			}
+		}
+	}
+
+	/* If we found no next symbol, we use the end of the section. */
+	if (!size) {
+		unsigned long symbol_end;
+
+		if (is_kernel_inittext(sym_addr))
+			symbol_end = (unsigned long)_einittext;
+		else if (IS_ENABLED(CONFIG_KALLSYMS_ALL))
+			symbol_end = (unsigned long)_end;
+		else
+			symbol_end = (unsigned long)_etext;
+
+		size = symbol_end - sym_addr;
+	}
+
+	return size;
+}
+
+
 static unsigned long get_symbol_pos(unsigned long addr,
 				    unsigned long *symbolsize,
 				    unsigned long *offset)
 {
-	unsigned long symbol_start = 0, symbol_end = 0;
-	unsigned long i, low, high, mid;
+	unsigned long low, high, mid;
 
 	/* This kernel should never had been booted. */
 	if (!IS_ENABLED(CONFIG_KALLSYMS_BASE_RELATIVE))
@@ -254,36 +303,15 @@ static unsigned long get_symbol_pos(unsigned long addr,
 	}
 
 	/*
-	 * Search for the first aliased symbol. Aliased
-	 * symbols are symbols with the same address.
+	 * Search for the first aliased symbol.
 	 */
 	while (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))
 		--low;
 
-	symbol_start = kallsyms_sym_address(low);
-
-	/* Search for next non-aliased symbol. */
-	for (i = low + 1; i < kallsyms_num_syms; i++) {
-		if (kallsyms_sym_address(i) > symbol_start) {
-			symbol_end = kallsyms_sym_address(i);
-			break;
-		}
-	}
-
-	/* If we found no next symbol, we use the end of the section. */
-	if (!symbol_end) {
-		if (is_kernel_inittext(addr))
-			symbol_end = (unsigned long)_einittext;
-		else if (IS_ENABLED(CONFIG_KALLSYMS_ALL))
-			symbol_end = (unsigned long)_end;
-		else
-			symbol_end = (unsigned long)_etext;
-	}
-
 	if (symbolsize)
-		*symbolsize = symbol_end - symbol_start;
+		*symbolsize = get_symbol_size(low);
 	if (offset)
-		*offset = addr - symbol_start;
+		*offset = addr - kallsyms_sym_address(low);
 
 	return low;
 }
@@ -301,6 +329,7 @@ int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,
 	return !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||
 	       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);
 }
+EXPORT_SYMBOL_GPL(kallsyms_lookup_size_offset);
 
 /*
  * Lookup an address
@@ -470,24 +499,14 @@ void __print_symbol(const char *fmt, unsigned long address)
 }
 EXPORT_SYMBOL(__print_symbol);
 
-/* To avoid using get_symbol_offset for every symbol, we carry prefix along. */
-struct kallsym_iter {
-	loff_t pos;
-	loff_t pos_mod_end;
-	unsigned long value;
-	unsigned int nameoff; /* If iterating in core kernel symbols. */
-	char type;
-	char name[KSYM_NAME_LEN];
-	char module_name[MODULE_NAME_LEN];
-	int exported;
-};
-
 static int get_ksymbol_mod(struct kallsym_iter *iter)
 {
 	int ret = module_get_kallsym(iter->pos - kallsyms_num_syms,
 				     &iter->value, &iter->type,
 				     iter->name, iter->module_name,
-				     &iter->exported);
+				     &iter->size, &iter->exported);
+	iter->builtin_module = 0;
+
 	if (ret < 0) {
 		iter->pos_mod_end = iter->pos;
 		return 0;
@@ -509,10 +528,22 @@ static int get_ksymbol_bpf(struct kallsym_iter *iter)
 static unsigned long get_ksymbol_core(struct kallsym_iter *iter)
 {
 	unsigned off = iter->nameoff;
+	u32 mod_index = 0;
 
-	iter->module_name[0] = '\0';
+	if (kallsyms_symbol_modules)
+		mod_index = kallsyms_symbol_modules[iter->pos];
+
+	if (mod_index == 0 || kallsyms_modules == NULL) {
+		iter->module_name[0] = '\0';
+		iter->builtin_module = 0;
+	} else {
+		strcpy(iter->module_name, &kallsyms_modules[mod_index]);
+		iter->builtin_module = 1;
+	}
+	iter->exported = 0;
 	iter->value = kallsyms_sym_address(iter->pos);
 
+	iter->size = get_symbol_size(iter->pos);
 	iter->type = kallsyms_get_symbol_type(off);
 
 	off = kallsyms_expand_symbol(off, iter->name, ARRAY_SIZE(iter->name));
@@ -520,7 +551,7 @@ static unsigned long get_ksymbol_core(struct kallsym_iter *iter)
 	return off - iter->nameoff;
 }
 
-static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)
+void kallsyms_iter_reset(struct kallsym_iter *iter, loff_t new_pos)
 {
 	iter->name[0] = '\0';
 	iter->nameoff = get_symbol_offset(new_pos);
@@ -528,6 +559,7 @@ static void reset_iter(struct kallsym_iter *iter, loff_t new_pos)
 	if (new_pos == 0)
 		iter->pos_mod_end = 0;
 }
+EXPORT_SYMBOL_GPL(kallsyms_iter_reset);
 
 static int update_iter_mod(struct kallsym_iter *iter, loff_t pos)
 {
@@ -544,7 +576,7 @@ static int update_iter_mod(struct kallsym_iter *iter, loff_t pos)
 }
 
 /* Returns false if pos at or past end of file. */
-static int update_iter(struct kallsym_iter *iter, loff_t pos)
+int kallsyms_iter_update(struct kallsym_iter *iter, loff_t pos)
 {
 	/* Module symbols can be accessed randomly. */
 	if (pos >= kallsyms_num_syms)
@@ -552,26 +584,27 @@ static int update_iter(struct kallsym_iter *iter, loff_t pos)
 
 	/* If we're not on the desired position, reset to new position. */
 	if (pos != iter->pos)
-		reset_iter(iter, pos);
+		kallsyms_iter_reset(iter, pos);
 
 	iter->nameoff += get_ksymbol_core(iter);
 	iter->pos++;
 
 	return 1;
 }
+EXPORT_SYMBOL_GPL(kallsyms_iter_update);
 
 static void *s_next(struct seq_file *m, void *p, loff_t *pos)
 {
 	(*pos)++;
 
-	if (!update_iter(m->private, *pos))
+	if (!kallsyms_iter_update(m->private, *pos))
 		return NULL;
 	return p;
 }
 
 static void *s_start(struct seq_file *m, loff_t *pos)
 {
-	if (!update_iter(m->private, *pos))
+	if (!kallsyms_iter_update(m->private, *pos))
 		return NULL;
 	return m->private;
 }
@@ -580,7 +613,7 @@ static void s_stop(struct seq_file *m, void *p)
 {
 }
 
-static int s_show(struct seq_file *m, void *p)
+static int s_show_internal(struct seq_file *m, void *p, int builtin_modules)
 {
 	struct kallsym_iter *iter = m->private;
 
@@ -588,7 +621,9 @@ static int s_show(struct seq_file *m, void *p)
 	if (!iter->name[0])
 		return 0;
 
-	if (iter->module_name[0]) {
+	if ((iter->builtin_module == 0 && iter->module_name[0]) ||
+	    (iter->builtin_module != 0 && iter->module_name[0] &&
+	     builtin_modules != 0)) {
 		char type;
 
 		/*
@@ -597,14 +632,31 @@ static int s_show(struct seq_file *m, void *p)
 		 */
 		type = iter->exported ? toupper(iter->type) :
 					tolower(iter->type);
-		seq_printf(m, "%pK %c %s\t[%s]\n", (void *)iter->value,
-			   type, iter->name, iter->module_name);
-	} else
+		if (builtin_modules)
+			seq_printf(m, "%pK %lx %c %s\t[%s]\n", (void *)iter->value,
+				   iter->size, type, iter->name, iter->module_name);
+		else
+			seq_printf(m, "%pK %c %s\t[%s]\n", (void *)iter->value,
+				   type, iter->name, iter->module_name);
+	} else if (builtin_modules)
+		seq_printf(m, "%pK %lx %c %s\n", (void *)iter->value,
+			   iter->size, iter->type, iter->name);
+	else
 		seq_printf(m, "%pK %c %s\n", (void *)iter->value,
 			   iter->type, iter->name);
 	return 0;
 }
 
+static int s_show(struct seq_file *m, void *p)
+{
+	return s_show_internal(m, p, 0);
+}
+
+static int s_mod_show(struct seq_file *m, void *p)
+{
+	return s_show_internal(m, p, 1);
+}
+
 static const struct seq_operations kallsyms_op = {
 	.start = s_start,
 	.next = s_next,
@@ -612,7 +664,15 @@ static const struct seq_operations kallsyms_op = {
 	.show = s_show
 };
 
-static int kallsyms_open(struct inode *inode, struct file *file)
+static const struct seq_operations kallmodsyms_op = {
+	.start = s_start,
+	.next = s_next,
+	.stop = s_stop,
+	.show = s_mod_show
+};
+
+static int kallsyms_open_internal(struct inode *inode, struct file *file,
+	const struct seq_operations *ops)
 {
 	/*
 	 * We keep iterator in m->private, since normal case is to
@@ -620,14 +680,24 @@ static int kallsyms_open(struct inode *inode, struct file *file)
 	 * using get_symbol_offset for every symbol.
 	 */
 	struct kallsym_iter *iter;
-	iter = __seq_open_private(file, &kallsyms_op, sizeof(*iter));
+	iter = __seq_open_private(file, ops, sizeof(*iter));
 	if (!iter)
 		return -ENOMEM;
-	reset_iter(iter, 0);
+	kallsyms_iter_reset(iter, 0);
 
 	return 0;
 }
 
+static int kallsyms_open(struct inode *inode, struct file *file)
+{
+	return kallsyms_open_internal(inode, file, &kallsyms_op);
+}
+
+static int kallmodsyms_open(struct inode *inode, struct file *file)
+{
+	return kallsyms_open_internal(inode, file, &kallmodsyms_op);
+}
+
 #ifdef	CONFIG_KGDB_KDB
 const char *kdb_walk_kallsyms(loff_t *pos)
 {
@@ -635,10 +705,10 @@ const char *kdb_walk_kallsyms(loff_t *pos)
 	if (*pos == 0) {
 		memset(&kdb_walk_kallsyms_iter, 0,
 		       sizeof(kdb_walk_kallsyms_iter));
-		reset_iter(&kdb_walk_kallsyms_iter, 0);
+		kallsyms_iter_reset(&kdb_walk_kallsyms_iter, 0);
 	}
 	while (1) {
-		if (!update_iter(&kdb_walk_kallsyms_iter, *pos))
+		if (!kallsyms_iter_update(&kdb_walk_kallsyms_iter, *pos))
 			return NULL;
 		++*pos;
 		/* Some debugging symbols have no name.  Ignore them. */
@@ -655,9 +725,19 @@ static const struct file_operations kallsyms_operations = {
 	.release = seq_release_private,
 };
 
+static const struct file_operations kallmodsyms_operations = {
+	.open = kallmodsyms_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release_private,
+};
+
 static int __init kallsyms_init(void)
 {
 	proc_create("kallsyms", 0444, NULL, &kallsyms_operations);
+#ifdef CONFIG_KALLMODSYMS
+	proc_create("kallmodsyms", 0444, NULL, &kallmodsyms_operations);
+#endif
 	return 0;
 }
 device_initcall(kallsyms_init);
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index a66e838640ea..69cfd0e85bed 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -49,6 +49,10 @@
 #include <linux/cpu.h>
 #include <linux/jump_label.h>
 
+#ifdef CONFIG_DTRACE
+#include <linux/dtrace_fbt.h>
+#endif
+
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
 #include <asm/errno.h>
@@ -2155,6 +2159,10 @@ static int __init populate_kprobe_blacklist(unsigned long *start,
 			continue;
 		}
 
+#ifdef CONFIG_DTRACE
+		dtrace_fbt_bl_add(entry, NULL);
+#endif
+
 		ent = kmalloc(sizeof(*ent), GFP_KERNEL);
 		if (!ent)
 			return -ENOMEM;
diff --git a/kernel/locking/mutex.c b/kernel/locking/mutex.c
index 858a07590e39..b3a88e89dfeb 100644
--- a/kernel/locking/mutex.c
+++ b/kernel/locking/mutex.c
@@ -28,6 +28,7 @@
 #include <linux/interrupt.h>
 #include <linux/debug_locks.h>
 #include <linux/osq_lock.h>
+#include <linux/sdt.h>
 
 #ifdef CONFIG_DEBUG_MUTEXES
 # include "mutex-debug.h"
@@ -239,6 +240,7 @@ void __sched mutex_lock(struct mutex *lock)
 
 	if (!__mutex_trylock_fast(lock))
 		__mutex_lock_slowpath(lock);
+	DTRACE_LOCKSTAT(adaptive__acquire, struct mutex *, lock);
 }
 EXPORT_SYMBOL(mutex_lock);
 #endif
@@ -608,10 +610,14 @@ static noinline void __sched __mutex_unlock_slowpath(struct mutex *lock, unsigne
 void __sched mutex_unlock(struct mutex *lock)
 {
 #ifndef CONFIG_DEBUG_LOCK_ALLOC
-	if (__mutex_unlock_fast(lock))
+	if (__mutex_unlock_fast(lock)) {
+		DTRACE_LOCKSTAT(adaptive__release, struct mutex *, lock);
 		return;
+	}
 #endif
+
 	__mutex_unlock_slowpath(lock, _RET_IP_);
+	DTRACE_LOCKSTAT(adaptive__release, struct mutex *, lock);
 }
 EXPORT_SYMBOL(mutex_unlock);
 
@@ -739,6 +745,8 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		    struct lockdep_map *nest_lock, unsigned long ip,
 		    struct ww_acquire_ctx *ww_ctx, const bool use_ww_ctx)
 {
+	u64 spinstart = 0, spinend, spintotal = 0;
+	u64 waitstart, waitend, waittotal = 0;
 	struct mutex_waiter waiter;
 	bool first = false;
 	struct ww_mutex *ww;
@@ -758,9 +766,11 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 	if (__mutex_trylock(lock) ||
 	    mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx, NULL)) {
 		/* got the lock, yay! */
+
 		lock_acquired(&lock->dep_map, ip);
 		if (use_ww_ctx && ww_ctx)
 			ww_mutex_set_context_fastpath(ww, ww_ctx);
+		DTRACE_LOCKSTAT(adaptive__acquire, struct mutex *, lock);
 		preempt_enable();
 		return 0;
 	}
@@ -803,6 +813,9 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		__mutex_set_flag(lock, MUTEX_FLAG_WAITERS);
 
 	set_current_state(state);
+	if (DTRACE_LOCKSTAT_ENABLED(adaptive__spin))
+		spinstart = dtrace_gethrtime_ns();
+
 	for (;;) {
 		/*
 		 * Once we hold wait_lock, we're serialized against
@@ -830,7 +843,15 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		}
 
 		spin_unlock(&lock->wait_lock);
-		schedule_preempt_disabled();
+
+		if (DTRACE_LOCKSTAT_ENABLED(adaptive__block)) {
+			waitstart = dtrace_gethrtime_ns();
+			schedule_preempt_disabled();
+			waitend = dtrace_gethrtime_ns();
+			if (waitend > waitstart)
+				waittotal += waitend - waitstart;
+		} else
+			schedule_preempt_disabled();
 
 		/*
 		 * ww_mutex needs to always recheck its position since its waiter
@@ -872,6 +893,19 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 		ww_mutex_set_context_slowpath(ww, ww_ctx);
 
 	spin_unlock(&lock->wait_lock);
+
+	if (DTRACE_LOCKSTAT_ENABLED(adaptive__spin) && spinstart) {
+		spinend = dtrace_gethrtime_ns();
+		spintotal = (spinend > spinstart) ? (spinend - spinstart) : 0;
+		spintotal = (spintotal > waittotal) ?
+			(spintotal - waittotal) : 0;
+		DTRACE_LOCKSTAT(adaptive__spin, struct mutex *, lock,
+				uint64_t, spintotal);
+	}
+	if (DTRACE_LOCKSTAT_ENABLED(adaptive__block) && waittotal)
+		DTRACE_LOCKSTAT(adaptive__block, struct mutex *, lock,
+				uint64_t, waittotal);
+	DTRACE_LOCKSTAT(adaptive__acquire, struct mutex *, lock);
 	preempt_enable();
 	return 0;
 
@@ -882,6 +916,8 @@ __mutex_lock_common(struct mutex *lock, long state, unsigned int subclass,
 	spin_unlock(&lock->wait_lock);
 	debug_mutex_free_waiter(&waiter);
 	mutex_release(&lock->dep_map, 1, ip);
+	DTRACE_LOCKSTAT(adaptive__acquire__error, struct mutex *, lock,
+			int, ret);
 	preempt_enable();
 	return ret;
 }
@@ -1096,8 +1132,10 @@ int __sched mutex_lock_interruptible(struct mutex *lock)
 {
 	might_sleep();
 
-	if (__mutex_trylock_fast(lock))
+	if (__mutex_trylock_fast(lock)) {
+		DTRACE_LOCKSTAT(adaptive__acquire, struct mutex *, lock);
 		return 0;
+	}
 
 	return __mutex_lock_interruptible_slowpath(lock);
 }
@@ -1108,8 +1146,10 @@ int __sched mutex_lock_killable(struct mutex *lock)
 {
 	might_sleep();
 
-	if (__mutex_trylock_fast(lock))
+	if (__mutex_trylock_fast(lock)) {
+		DTRACE_LOCKSTAT(adaptive__acquire, struct mutex *, lock);
 		return 0;
+	}
 
 	return __mutex_lock_killable_slowpath(lock);
 }
@@ -1178,8 +1218,10 @@ int __sched mutex_trylock(struct mutex *lock)
 {
 	bool locked = __mutex_trylock(lock);
 
-	if (locked)
+	if (locked) {
 		mutex_acquire(&lock->dep_map, 0, 1, _RET_IP_);
+		DTRACE_LOCKSTAT(adaptive__acquire, struct mutex *, lock);
+	}
 
 	return locked;
 }
diff --git a/kernel/locking/qrwlock.c b/kernel/locking/qrwlock.c
index 2655f26ec882..8182da304206 100644
--- a/kernel/locking/qrwlock.c
+++ b/kernel/locking/qrwlock.c
@@ -20,6 +20,7 @@
 #include <linux/cpumask.h>
 #include <linux/percpu.h>
 #include <linux/hardirq.h>
+#include <linux/sdt.h>
 #include <linux/spinlock.h>
 #include <asm/qrwlock.h>
 
@@ -67,9 +68,13 @@ rspin_until_writer_unlock(struct qrwlock *lock, u32 cnts)
  */
 void queued_read_lock_slowpath(struct qrwlock *lock, u32 cnts)
 {
+	u64 spinstart = 0, spinend, spintime;
+
 	/*
 	 * Readers come here when they cannot get the lock without waiting
 	 */
+	if (DTRACE_LOCKSTAT_ENABLED(rw__spin))
+		spinstart = dtrace_gethrtime_ns();
 	if (unlikely(in_interrupt())) {
 		/*
 		 * Readers in interrupt context will get the lock immediately
@@ -80,7 +85,7 @@ void queued_read_lock_slowpath(struct qrwlock *lock, u32 cnts)
 		 * the queue.
 		 */
 		rspin_until_writer_unlock(lock, cnts);
-		return;
+		goto done;
 	}
 	atomic_sub(_QR_BIAS, &lock->cnts);
 
@@ -101,6 +106,13 @@ void queued_read_lock_slowpath(struct qrwlock *lock, u32 cnts)
 	 * Signal the next one in queue to become queue head
 	 */
 	arch_spin_unlock(&lock->wait_lock);
+done:
+	if (DTRACE_LOCKSTAT_ENABLED(rw__spin) && spinstart) {
+		spinend = dtrace_gethrtime_ns();
+		spintime = spinend > spinstart ? spinend - spinstart : 0;
+		DTRACE_LOCKSTAT(rw__spin, rwlock_t *, lock, uint64_t, spintime,
+				int, DTRACE_LOCKSTAT_RW_READER);
+	}
 }
 EXPORT_SYMBOL(queued_read_lock_slowpath);
 
@@ -111,8 +123,11 @@ EXPORT_SYMBOL(queued_read_lock_slowpath);
 void queued_write_lock_slowpath(struct qrwlock *lock)
 {
 	u32 cnts;
+	u64 spinstart = 0, spinend, spintime;
 
 	/* Put the writer into the wait queue */
+	if (DTRACE_LOCKSTAT_ENABLED(rw__spin))
+		spinstart = dtrace_gethrtime_ns();
 	arch_spin_lock(&lock->wait_lock);
 
 	/* Try to acquire the lock directly if no reader is present */
@@ -146,5 +161,11 @@ void queued_write_lock_slowpath(struct qrwlock *lock)
 	}
 unlock:
 	arch_spin_unlock(&lock->wait_lock);
+	if (DTRACE_LOCKSTAT_ENABLED(rw__spin) && spinstart) {
+		spinend = dtrace_gethrtime_ns();
+		spintime = spinend > spinstart ? spinend - spinstart : 0;
+		DTRACE_LOCKSTAT(rw__spin, rwlock_t *, lock, uint64_t, spintime,
+				int, DTRACE_LOCKSTAT_RW_WRITER);
+	}
 }
 EXPORT_SYMBOL(queued_write_lock_slowpath);
diff --git a/kernel/locking/qspinlock.c b/kernel/locking/qspinlock.c
index 294294c71ba4..ea8ce3c11eec 100644
--- a/kernel/locking/qspinlock.c
+++ b/kernel/locking/qspinlock.c
@@ -29,6 +29,7 @@
 #include <linux/hardirq.h>
 #include <linux/mutex.h>
 #include <linux/prefetch.h>
+#include <linux/sdt.h>
 #include <asm/byteorder.h>
 #include <asm/qspinlock.h>
 
@@ -294,16 +295,20 @@ static __always_inline u32  __pv_wait_head_or_lock(struct qspinlock *lock,
 void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)
 {
 	struct mcs_spinlock *prev, *next, *node;
+	u64 spinstart = 0, spinend, spintime;
 	u32 new, old, tail;
 	int idx;
 
 	BUILD_BUG_ON(CONFIG_NR_CPUS >= (1U << _Q_TAIL_CPU_BITS));
 
+	if (DTRACE_LOCKSTAT_ENABLED(spin__spin))
+		spinstart = dtrace_gethrtime_ns();
+
 	if (pv_enabled())
 		goto queue;
 
 	if (virt_spin_lock(lock))
-		return;
+		goto out;
 
 	/*
 	 * wait for in-progress pending->locked hand-overs
@@ -347,7 +352,7 @@ void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)
 	 * we won the trylock
 	 */
 	if (new == _Q_LOCKED_VAL)
-		return;
+		goto out;
 
 	/*
 	 * we're pending, wait for the owner to go away.
@@ -367,7 +372,7 @@ void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)
 	 * *,1,0 -> *,0,1
 	 */
 	clear_pending_set_locked(lock);
-	return;
+	goto out;
 
 	/*
 	 * End of pending bit optimistic spinning and beginning of MCS
@@ -504,6 +509,17 @@ void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)
 	 * release the node
 	 */
 	__this_cpu_dec(mcs_nodes[0].count);
+
+	/*
+	 * Fire spin-spin probe to note time waiting for a lock.
+	 */
+out:
+	if (DTRACE_LOCKSTAT_ENABLED(spin__spin)) {
+		spinend = dtrace_gethrtime_ns();
+		spintime = spinend > spinstart ? spinend - spinstart : 0;
+		DTRACE_LOCKSTAT(spin__spin, spinlock_t *, lock,
+				uint64_t, spintime);
+	}
 }
 EXPORT_SYMBOL(queued_spin_lock_slowpath);
 
diff --git a/kernel/module.c b/kernel/module.c
index 690c0651c40f..a1dd3c9f645c 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -53,6 +53,8 @@
 #include <asm/mmu_context.h>
 #include <linux/license.h>
 #include <asm/sections.h>
+#include <linux/dtrace_os.h>
+#include <linux/dtrace_sdt.h>
 #include <linux/tracepoint.h>
 #include <linux/ftrace.h>
 #include <linux/livepatch.h>
@@ -97,6 +99,9 @@
 DEFINE_MUTEX(module_mutex);
 EXPORT_SYMBOL_GPL(module_mutex);
 static LIST_HEAD(modules);
+#ifdef CONFIG_DTRACE
+struct list_head *dtrace_modules = &modules;
+#endif /* CONFIG_DTRACE */
 
 #ifdef CONFIG_MODULES_TREE_LOOKUP
 
@@ -1000,6 +1005,12 @@ SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
 		}
 	}
 
+	/* Try destroying DTrace provider. */
+	if (!dtrace_destroy_prov(mod)) {
+		ret = -EBUSY;
+		goto out;
+	}
+
 	/* Stop the machine so refcounts can't move and disable module. */
 	ret = try_stop_module(mod, flags, &forced);
 	if (ret != 0)
@@ -2124,6 +2135,7 @@ void __weak module_arch_freeing_init(struct module *mod)
 /* Free a module, remove from lists, etc. */
 static void free_module(struct module *mod)
 {
+	dtrace_mod_pdata_free(mod);
 	trace_module_free(mod);
 
 	mod_sysfs_teardown(mod);
@@ -3340,6 +3352,7 @@ static struct module *layout_and_allocate(struct load_info *info, int flags)
 	/* Module has been copied to its final place now: return it. */
 	mod = (void *)info->sechdrs[info->index.mod].sh_addr;
 	kmemleak_load_module(mod, info);
+
 	return mod;
 }
 
@@ -3581,6 +3594,18 @@ static int complete_formation(struct module *mod, struct load_info *info)
 {
 	int err;
 
+#ifdef CONFIG_DTRACE
+	void *sdt_args, *sdt_names;
+	unsigned int sdt_args_len, sdt_names_len;
+
+	sdt_names = section_objs(info, "_dtrace_sdt_names", 1,
+				 &sdt_names_len);
+	sdt_args = section_objs(info, "_dtrace_sdt_args", 1,
+				&sdt_args_len);
+	dtrace_sdt_register_module(mod, sdt_names, sdt_names_len,
+				   sdt_args, sdt_args_len);
+#endif
+
 	mutex_lock(&module_mutex);
 
 	/* Find duplicate symbols (must be called under lock). */
@@ -3731,6 +3756,9 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	/* Ftrace init must be called in the MODULE_STATE_UNFORMED state */
 	ftrace_module_init(mod);
 
+	/* Allocate DTrace per-module data. */
+	dtrace_mod_pdata_alloc(mod);
+
 	/* Finally it's fully formed, ready to start executing. */
 	err = complete_formation(mod, info);
 	if (err)
@@ -4020,7 +4048,7 @@ int lookup_module_symbol_attrs(unsigned long addr, unsigned long *size,
 }
 
 int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
-			char *name, char *module_name, int *exported)
+		       char *name, char *module_name, unsigned long *size, int *exported)
 {
 	struct module *mod;
 
@@ -4037,6 +4065,7 @@ int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
 			strlcpy(name, symname(kallsyms, symnum), KSYM_NAME_LEN);
 			strlcpy(module_name, mod->name, MODULE_NAME_LEN);
 			*exported = is_exported(name, *value, mod);
+			*size = kallsyms->symtab[symnum].st_size;
 			preempt_enable();
 			return 0;
 		}
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 55062461b2fd..046b219fc274 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -26,6 +26,7 @@
 #include <linux/profile.h>
 #include <linux/security.h>
 #include <linux/syscalls.h>
+#include <linux/dtrace_os.h>
 
 #include <asm/switch_to.h>
 #include <asm/tlb.h>
@@ -752,6 +753,9 @@ static void set_load_weight(struct task_struct *p)
 
 static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)
 {
+	DTRACE_SCHED(enqueue, struct task_struct * : (lwpsinfo_t *,
+						      psinfo_t *), p,
+		     cpuinfo_t *, rq->dtrace_cpu_info);
 	if (!(flags & ENQUEUE_NOCLOCK))
 		update_rq_clock(rq);
 
@@ -763,6 +767,10 @@ static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)
 
 static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
 {
+	DTRACE_SCHED(dequeue, struct task_struct * : (lwpsinfo_t *,
+						      psinfo_t *), p,
+		     cpuinfo_t *, rq->dtrace_cpu_info,
+		     int, 0);
 	if (!(flags & DEQUEUE_NOCLOCK))
 		update_rq_clock(rq);
 
@@ -1981,6 +1989,8 @@ try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
 		goto out;
 
 	trace_sched_waking(p);
+	DTRACE_SCHED(wakeup, struct task_struct * : (lwpsinfo_t *,
+						     psinfo_t *), p);
 
 	/* We're going to change ->state: */
 	success = 1;
@@ -2580,6 +2590,8 @@ prepare_task_switch(struct rq *rq, struct task_struct *prev,
 {
 	sched_info_switch(rq, prev, next);
 	perf_event_task_sched_out(prev, next);
+	DTRACE_SCHED(off__cpu, struct task_struct * : (lwpsinfo_t *,
+						       psinfo_t *), next);
 	fire_sched_out_preempt_notifiers(prev, next);
 	prepare_lock_switch(rq, next);
 	prepare_arch_switch(next);
@@ -2629,6 +2641,11 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 
 	rq->prev_mm = NULL;
 
+#ifdef CONFIG_DTRACE
+	if (dtrace_vtime_active)
+		dtrace_vtime_switch(prev, current);
+#endif
+
 	/*
 	 * A task struct has one reference for the use as "current".
 	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls
@@ -2656,6 +2673,7 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 	finish_lock_switch(rq, prev);
 	finish_arch_post_lock_switch();
 
+	DTRACE_SCHED(on__cpu);
 	fire_sched_in_preempt_notifiers(current);
 	if (mm)
 		mmdrop(mm);
@@ -2740,6 +2758,9 @@ asmlinkage __visible void schedule_tail(struct task_struct *prev)
 
 	if (current->set_child_tid)
 		put_user(task_pid_vnr(current), current->set_child_tid);
+
+	DTRACE_PROC(start);
+	DTRACE_PROC(lwp__start);
 }
 
 /*
@@ -3308,6 +3329,7 @@ static void __sched notrace __schedule(bool preempt)
 
 	switch_count = &prev->nivcsw;
 	if (!preempt && prev->state) {
+		DTRACE_SCHED(sleep);
 		if (unlikely(signal_pending_state(prev->state, prev))) {
 			prev->state = TASK_RUNNING;
 		} else {
@@ -3333,7 +3355,8 @@ static void __sched notrace __schedule(bool preempt)
 			}
 		}
 		switch_count = &prev->nvcsw;
-	}
+	} else
+		DTRACE_SCHED(preempt);
 
 	next = pick_next_task(rq, prev, &rf);
 	clear_tsk_need_resched(prev);
@@ -3365,6 +3388,7 @@ static void __sched notrace __schedule(bool preempt)
 		rq = context_switch(rq, prev, next, &rf);
 	} else {
 		rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);
+		DTRACE_SCHED(remain__cpu);
 		rq_unlock_irq(rq, &rf);
 	}
 
@@ -3809,6 +3833,9 @@ void set_user_nice(struct task_struct *p, long nice)
 	p->prio = effective_prio(p);
 	delta = p->prio - old_prio;
 
+	DTRACE_SCHED(change__pri, struct task_struct * : (lwpsinfo_t *,
+							  psinfo_t *), p,
+		      int, old_prio);
 	if (queued) {
 		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);
 		/*
@@ -4829,6 +4856,9 @@ SYSCALL_DEFINE0(sched_yield)
 	rq_unlock(rq, &rf);
 	sched_preempt_enable_no_resched();
 
+	DTRACE_SCHED(surrender,
+		     struct task_struct * : (lwpsinfo_t *, psinfo_t *),
+		     current);
 	schedule();
 
 	return 0;
@@ -4984,8 +5014,12 @@ int __sched yield_to(struct task_struct *p, bool preempt)
 out_irq:
 	local_irq_restore(flags);
 
-	if (yielded > 0)
+	if (yielded > 0) {
+		DTRACE_SCHED(surrender,
+			     struct task_struct * : (lwpsinfo_t *, psinfo_t *),
+			     curr);
 		schedule();
+	}
 
 	return yielded;
 }
@@ -5930,6 +5964,10 @@ void __init sched_init(void)
 #endif /* CONFIG_SMP */
 		init_rq_hrtick(rq);
 		atomic_set(&rq->nr_iowait, 0);
+
+#ifdef CONFIG_DTRACE
+		rq->dtrace_cpu_info = per_cpu_info(i);
+#endif
 	}
 
 	set_load_weight(&init_task);
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 307c35d33660..071a95d206b2 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -30,6 +30,7 @@
 #include <linux/irq_work.h>
 #include <linux/tick.h>
 #include <linux/slab.h>
+#include <linux/dtrace_cpu.h>
 
 #ifdef CONFIG_PARAVIRT
 #include <asm/paravirt.h>
@@ -810,6 +811,9 @@ struct rq {
 	/* Must be inspected within a rcu lock section */
 	struct cpuidle_state *idle_state;
 #endif
+#ifdef CONFIG_DTRACE
+	cpuinfo_t *dtrace_cpu_info;
+#endif
 };
 
 static inline int cpu_of(struct rq *rq)
diff --git a/kernel/signal.c b/kernel/signal.c
index 6895f6bb98a7..cc22abedc9c4 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -43,6 +43,7 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/signal.h>
+#include <linux/sdt.h>
 
 #include <asm/param.h>
 #include <linux/uaccess.h>
@@ -1003,8 +1004,12 @@ static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,
 
 	result = TRACE_SIGNAL_IGNORED;
 	if (!prepare_signal(sig, t,
-			from_ancestor_ns || (info == SEND_SIG_FORCED)))
+			    from_ancestor_ns || (info == SEND_SIG_FORCED))) {
+		DTRACE_PROC(signal__discard,
+			    struct task_struct * : (lwpsinfo_t *, psinfo_t *), t,
+			    int, sig);
 		goto ret;
+	}
 
 	pending = group ? &t->signal->shared_pending : &t->pending;
 	/*
@@ -1089,6 +1094,9 @@ static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,
 	signalfd_notify(t, sig);
 	sigaddset(&pending->signal, sig);
 	complete_signal(sig, t, group);
+	DTRACE_PROC(signal__send,
+		    struct task_struct * : (lwpsinfo_t *, psinfo_t *), t,
+		    int, sig);
 ret:
 	trace_signal_generate(sig, info, t, group, result);
 	return ret;
@@ -1583,6 +1591,9 @@ int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)
 	list_add_tail(&q->list, &pending->list);
 	sigaddset(&pending->signal, sig);
 	complete_signal(sig, t, group);
+	DTRACE_PROC(signal__send,
+		    struct task_struct * : (lwpsinfo_t *, psinfo_t *), t,
+		    int, sig);
 	result = TRACE_SIGNAL_DELIVERED;
 out:
 	trace_signal_generate(sig, &q->info, t, group, result);
@@ -2238,6 +2249,15 @@ int get_signal(struct ksignal *ksig)
 
 		ka = &sighand->action[signr-1];
 
+		DTRACE_PROC(signal__handle,
+			    int, signal->group_exit_code
+						? signal->group_exit_code
+						: signr,
+			    siginfo_t *, ksig->ka.sa.sa_handler != SIG_DFL
+						? NULL
+						: &ksig->info,
+			    void (*)(void), ksig->ka.sa.sa_handler);
+
 		/* Trace actually delivered signals. */
 		trace_signal_deliver(signr, &ksig->info, ka);
 
@@ -2868,8 +2888,10 @@ static int do_sigtimedwait(const sigset_t *which, siginfo_t *info,
 	}
 	spin_unlock_irq(&tsk->sighand->siglock);
 
-	if (sig)
+	if (sig) {
+		DTRACE_PROC(signal__clear, int, sig);
 		return sig;
+	}
 	return ret ? -EINTR : -EAGAIN;
 }
 
@@ -3201,7 +3223,7 @@ int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)
 	return 0;
 }
 
-static int
+int
 do_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp)
 {
 	struct task_struct *t = current;
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index b5189762d275..4e9a9395830d 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -213,6 +213,7 @@ cond_syscall(sys_ioprio_set);
 cond_syscall(sys_ioprio_get);
 
 /* New file descriptors */
+cond_syscall(sys_waitfd);
 cond_syscall(sys_signalfd);
 cond_syscall(sys_signalfd4);
 cond_syscall(compat_sys_signalfd);
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index 2cafb49aa65e..cb2a62155c9c 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -25,6 +25,7 @@
 #include <linux/stop_machine.h>
 #include <linux/pvclock_gtod.h>
 #include <linux/compiler.h>
+#include <linux/dtrace_os.h>
 
 #include "tick-internal.h"
 #include "ntp_internal.h"
@@ -652,6 +653,7 @@ static void timekeeping_update(struct timekeeper *tk, unsigned int action)
 	tk_update_ktime_data(tk);
 
 	update_vsyscall(tk);
+	dtrace_update_time(tk);
 	update_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);
 
 	update_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);
diff --git a/kernel/time/timer.c b/kernel/time/timer.c
index db5e6daadd94..2a502abde779 100644
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@ -44,6 +44,7 @@
 #include <linux/sched/debug.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
+#include <linux/sdt.h>
 
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
@@ -1582,6 +1583,9 @@ void update_process_times(int user_tick)
 {
 	struct task_struct *p = current;
 
+	DTRACE_SCHED(tick, struct task_struct * : (lwpsinfo_t *, psinfo_t *),
+		     p);
+
 	/* Note: this timer irq context must be accounted for as well. */
 	account_process_tick(p, user_tick);
 	run_local_timers();
diff --git a/lib/Kconfig b/lib/Kconfig
index b1445b22a6de..d63bd26a08c5 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -532,6 +532,18 @@ config SIGNATURE
 #
 config LIBFDT
 	bool
+#
+# CTF support is select'ed if needed
+#
+config CTF
+        bool "Compact Type Format generation"
+        default n
+        select STRIP_ASM_SYMS
+        depends on DEBUG_INFO && !DEBUG_INFO_REDUCED && !DEBUG_INFO_SPLIT && !DEBUG_INFO_DWARF4 && DTRACE
+        help
+          Emit a compact, compressed description of the kernel's datatypes and
+          global variables into the vmlinux.ctfa archive (for in-tree modules)
+          or into .ctf sections in kernel modules (for out-of-tree modules).
 
 config OID_REGISTRY
 	tristate
diff --git a/mm/gup.c b/mm/gup.c
index e0d82b6706d7..55056e05d10a 100644
--- a/mm/gup.c
+++ b/mm/gup.c
@@ -83,6 +83,9 @@ static struct page *follow_page_pte(struct vm_area_struct *vma,
 	if (unlikely(pmd_bad(*pmd)))
 		return no_page_table(vma, flags);
 
+	if ((flags & FOLL_IMMED) && pte_is_locked(mm, pmd))
+                return no_page_table(vma, flags);
+
 	ptep = pte_offset_map_lock(mm, pmd, address, &ptl);
 	pte = *ptep;
 	if (!pte_present(pte)) {
@@ -374,9 +377,10 @@ static struct page *follow_p4d_mask(struct vm_area_struct *vma,
  *
  * @flags can have FOLL_ flags set, defined in <linux/mm.h>
  *
- * Returns the mapped (struct page *), %NULL if no mapping exists, or
- * an error pointer if there is a mapping to something not represented
- * by a page descriptor (see also vm_normal_page()).
+ * Returns the mapped (struct page *), %NULL if no mapping exists or if
+ * FOLL_IMMED is set and the PTE is locked, or an error pointer if there is a
+ * mapping to something not represented by a page descriptor (see also
+ * vm_normal_page()).
  */
 struct page *follow_page_mask(struct vm_area_struct *vma,
 			      unsigned long address, unsigned int flags,
@@ -486,6 +490,13 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
+
+	if (unlikely(*flags & FOLL_IMMED)) {
+		if (nonblocking)
+			*nonblocking = 0;
+		return -EBUSY;
+	}
+
 	if (*flags & FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (*flags & FOLL_REMOTE)
@@ -620,11 +631,16 @@ static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)
  * appropriate) must be called after the page is finished with, and
  * before put_page is called.
  *
- * If @nonblocking != NULL, __get_user_pages will not wait for disk IO
- * or mmap_sem contention, and if waiting is needed to pin all pages,
- * *@nonblocking will be set to 0.  Further, if @gup_flags does not
- * include FOLL_NOWAIT, the mmap_sem will be released via up_read() in
- * this case.
+ * If FOLL_IMMED is set, pinning of pages will cease as soon as a page is
+ * encountered that needs to be faulted in.  (No attempt is made to see if
+ * further pages could be pinned without faulting: the caller must do that, if
+ * desired.)
+ *
+ * If @nonblocking != NULL, __get_user_pages will not wait for disk IO or
+ * mmap_sem contention, and if waiting is needed to pin all pages, or
+ * FOLL_IMMED is set and a fault is needed, *@nonblocking will be set to 0.
+ * Further, if @gup_flags does not include FOLL_NOWAIT, the mmap_sem will be
+ * released via up_read() in this case.
  *
  * A caller using such a combination of @nonblocking and @gup_flags
  * must therefore hold the mmap_sem for reading only, and recognize
@@ -635,7 +651,7 @@ static int check_vma_flags(struct vm_area_struct *vma, unsigned long gup_flags)
  * instead of __get_user_pages. __get_user_pages should be used only if
  * you need some special @gup_flags.
  */
-static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
+long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		unsigned long start, unsigned long nr_pages,
 		unsigned int gup_flags, struct page **pages,
 		struct vm_area_struct **vmas, int *nonblocking)
@@ -664,7 +680,12 @@ static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 
 		/* first iteration or cross vma bound */
 		if (!vma || start >= vma->vm_end) {
-			vma = find_extend_vma(mm, start);
+			/* Do not extend stack in no-fault mode. */
+			if (gup_flags & FOLL_IMMED)
+				vma = find_vma(mm, start);
+			else
+				vma = find_extend_vma(mm, start);
+
 			if (!vma && in_gate_area(mm, start)) {
 				int ret;
 				ret = get_gate_page(mm, start & PAGE_MASK,
@@ -692,7 +713,8 @@ static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 		 */
 		if (unlikely(fatal_signal_pending(current)))
 			return i ? i : -ERESTARTSYS;
-		cond_resched();
+		if (likely(!(foll_flags & FOLL_IMMED)))
+			cond_resched();
 		page = follow_page_mask(vma, start, foll_flags, &page_mask);
 		if (!page) {
 			int ret;
@@ -740,6 +762,7 @@ static long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 	} while (nr_pages);
 	return i;
 }
+EXPORT_SYMBOL(__get_user_pages);
 
 static bool vma_permits_fault(struct vm_area_struct *vma,
 			      unsigned int fault_flags)
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index c539941671b4..5714d88a3fad 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -4184,6 +4184,8 @@ long follow_hugetlb_page(struct mm_struct *mm, struct vm_area_struct *vma,
 
 			if (pte)
 				spin_unlock(ptl);
+			if (flags & FOLL_IMMED)
+				return i;
 			if (flags & FOLL_WRITE)
 				fault_flags |= FAULT_FLAG_WRITE;
 			if (nonblocking)
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 66e7efabf0a1..f34e71304717 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -3805,7 +3805,7 @@ static int memcg_event_wake(wait_queue_entry_t *wait, unsigned mode,
 }
 
 static void memcg_event_ptable_queue_proc(struct file *file,
-		wait_queue_head_t *wqh, poll_table *pt)
+		wait_queue_head_t *wqh, poll_table *pt, unsigned long unused)
 {
 	struct mem_cgroup_event *event =
 		container_of(pt, struct mem_cgroup_event, pt);
diff --git a/net/9p/trans_fd.c b/net/9p/trans_fd.c
index 985046ae4231..40204db0817d 100644
--- a/net/9p/trans_fd.c
+++ b/net/9p/trans_fd.c
@@ -548,7 +548,8 @@ static int p9_pollwake(wait_queue_entry_t *wait, unsigned int mode, int sync, vo
  */
 
 static void
-p9_pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p)
+p9_pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p,
+	    unsigned long unused)
 {
 	struct p9_conn *m = container_of(p, struct p9_conn, pt);
 	struct p9_poll_wait *pwait = NULL;
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 57fc13c6ab2b..f57a11d8d56e 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -147,6 +147,7 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 #include <net/dst_metadata.h>
+#include <linux/sdt.h>
 
 /*
  *	Process Router Attention IP option (RFC 2113)
@@ -244,16 +245,26 @@ static int ip_local_deliver_finish(struct net *net, struct sock *sk, struct sk_b
  */
 int ip_local_deliver(struct sk_buff *skb)
 {
+	struct iphdr *iph = ip_hdr(skb);
+
 	/*
 	 *	Reassemble IP fragments.
 	 */
 	struct net *net = dev_net(skb->dev);
 
-	if (ip_is_fragment(ip_hdr(skb))) {
+	if (ip_is_fragment(iph)) {
 		if (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))
 			return 0;
 	}
 
+	DTRACE_IP(receive,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, iph,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, iph,
+		  struct ipv6hdr * : ipv6info_t *, NULL);
+
 	return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,
 		       net, NULL, skb, skb->dev, NULL,
 		       ip_local_deliver_finish);
@@ -262,8 +273,9 @@ int ip_local_deliver(struct sk_buff *skb)
 static inline bool ip_rcv_options(struct sk_buff *skb)
 {
 	struct ip_options *opt;
-	const struct iphdr *iph;
+	const struct iphdr *iph = NULL;
 	struct net_device *dev = skb->dev;
+	const char *dropreason;
 
 	/* It looks as overkill, because not all
 	   IP options require packet mangling.
@@ -273,6 +285,7 @@ static inline bool ip_rcv_options(struct sk_buff *skb)
 					      --ANK (980813)
 	*/
 	if (skb_cow(skb, skb_headroom(skb))) {
+		dropreason = "copy-on-write failed";
 		__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INDISCARDS);
 		goto drop;
 	}
@@ -282,6 +295,7 @@ static inline bool ip_rcv_options(struct sk_buff *skb)
 	opt->optlen = iph->ihl*4 - sizeof(struct iphdr);
 
 	if (ip_options_compile(dev_net(dev), opt, skb)) {
+		dropreason = "invalid options";
 		__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INHDRERRORS);
 		goto drop;
 	}
@@ -295,16 +309,28 @@ static inline bool ip_rcv_options(struct sk_buff *skb)
 					net_info_ratelimited("source route option %pI4 -> %pI4\n",
 							     &iph->saddr,
 							     &iph->daddr);
+				dropreason = "invalid source route options";
 				goto drop;
 			}
 		}
 
-		if (ip_options_rcv_srr(skb))
+		if (ip_options_rcv_srr(skb)) {
+			dropreason = "invalid options";
 			goto drop;
+		}
 	}
 
 	return false;
 drop:
+	DTRACE_IP(drop__in,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, iph,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, iph,
+		  struct ipv6hdr * : ipv6info_t *, NULL,
+		  char * : string, dropreason);
+
 	return true;
 }
 
@@ -411,9 +437,10 @@ static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
  */
 int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
 {
-	const struct iphdr *iph;
+	const struct iphdr *iph = NULL;
 	struct net *net;
 	u32 len;
+	const char *dropreason = "header invalid";
 
 	/* When the interface is in promisc. mode, drop all the crap
 	 * that it receives, do not try to analyse it.
@@ -427,8 +454,9 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 
 	skb = skb_share_check(skb, GFP_ATOMIC);
 	if (!skb) {
+		dropreason = "could not clone shared buffer";
 		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);
-		goto out;
+		goto drop;
 	}
 
 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
@@ -467,6 +495,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 
 	len = ntohs(iph->tot_len);
 	if (skb->len < len) {
+		dropreason = "packet too short";
 		__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);
 		goto drop;
 	} else if (len < (iph->ihl*4))
@@ -477,6 +506,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 	 * Note this now means skb->len holds ntohs(iph->tot_len).
 	 */
 	if (pskb_trim_rcsum(skb, len)) {
+		dropreason = "could not trim buffer";
 		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);
 		goto drop;
 	}
@@ -496,10 +526,18 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 
 csum_error:
 	__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);
+	dropreason = "checksum error";
 inhdr_error:
 	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);
 drop:
+	DTRACE_IP(drop__in,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb ? skb->sk : NULL,
+		  void_ip_t * : ipinfo_t *, iph,
+		  struct net_device * : ifinfo_t *, dev,
+		  struct iphdr * : ipv4info_t *, iph,
+		  void * : ipv6info_t *, NULL,
+		  char * : string, dropreason);
 	kfree_skb(skb);
-out:
 	return NET_RX_DROP;
 }
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index e8e675be60ec..ad7aec6309af 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -80,6 +80,7 @@
 #include <linux/netfilter_bridge.h>
 #include <linux/netlink.h>
 #include <linux/tcp.h>
+#include <linux/sdt.h>
 
 static int
 ip_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
@@ -110,6 +111,14 @@ int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)
 
 	skb->protocol = htons(ETH_P_IP);
 
+	DTRACE_IP(send,
+		  struct sk_buff * :  pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, sk,
+		  void_ip_t * : ipinfo_t *, iph,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, iph,
+		  struct ipv6hdr * : ipv6info_t *, NULL);
+
 	return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
 		       net, sk, skb, NULL, skb_dst(skb)->dev,
 		       dst_output);
@@ -877,6 +886,7 @@ static int __ip_append_data(struct sock *sk,
 	int csummode = CHECKSUM_NONE;
 	struct rtable *rt = (struct rtable *)cork->dst;
 	u32 tskey = 0;
+	const char *dropreason;
 
 	skb = skb_peek_tail(queue);
 
@@ -893,9 +903,13 @@ static int __ip_append_data(struct sock *sk,
 	maxnonfragsize = ip_sk_ignore_df(sk) ? 0xFFFF : mtu;
 
 	if (cork->length + length > maxnonfragsize - fragheaderlen) {
+		struct iphdr *iph __attribute__((unused)) = ip_hdr(skb);
+
 		ip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,
 			       mtu - (opt ? opt->optlen : 0));
-		return -EMSGSIZE;
+		dropreason = "packet too big";
+		err = -EMSGSIZE;
+		goto error2;
 	}
 
 	/*
@@ -976,8 +990,10 @@ static int __ip_append_data(struct sock *sk,
 					skb = sock_wmalloc(sk,
 							   alloclen + hh_len + 15, 1,
 							   sk->sk_allocation);
-				if (unlikely(!skb))
+				if (unlikely(!skb)) {
+					dropreason = "no buffers";
 					err = -ENOBUFS;
+				}
 			}
 			if (!skb)
 				goto error;
@@ -1017,7 +1033,9 @@ static int __ip_append_data(struct sock *sk,
 			copy = datalen - transhdrlen - fraggap;
 			if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {
 				err = -EFAULT;
+				dropreason = "could not fragment packet";
 				kfree_skb(skb);
+				skb = NULL;
 				goto error;
 			}
 
@@ -1047,6 +1065,7 @@ static int __ip_append_data(struct sock *sk,
 			if (getfrag(from, skb_put(skb, copy),
 					offset, copy, off, skb) < 0) {
 				__skb_trim(skb, off);
+				dropreason = "could not fragment packet";
 				err = -EFAULT;
 				goto error;
 			}
@@ -1054,14 +1073,18 @@ static int __ip_append_data(struct sock *sk,
 			int i = skb_shinfo(skb)->nr_frags;
 
 			err = -ENOMEM;
-			if (!sk_page_frag_refill(sk, pfrag))
+			if (!sk_page_frag_refill(sk, pfrag)) {
+				dropreason = "no memory";
 				goto error;
+			}
 
 			if (!skb_can_coalesce(skb, i, pfrag->page,
 					      pfrag->offset)) {
 				err = -EMSGSIZE;
-				if (i == MAX_SKB_FRAGS)
+				if (i == MAX_SKB_FRAGS) {
+					dropreason = "too many fragments";
 					goto error;
+				}
 
 				__skb_fill_page_desc(skb, i, pfrag->page,
 						     pfrag->offset, 0);
@@ -1071,8 +1094,10 @@ static int __ip_append_data(struct sock *sk,
 			copy = min_t(int, copy, pfrag->size - pfrag->offset);
 			if (getfrag(from,
 				    page_address(pfrag->page) + pfrag->offset,
-				    offset, copy, skb->len, skb) < 0)
+				    offset, copy, skb->len, skb) < 0) {
+				dropreason = "could not framgent packet";
 				goto error_efault;
+			}
 
 			pfrag->offset += copy;
 			skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
@@ -1092,6 +1117,16 @@ static int __ip_append_data(struct sock *sk,
 error:
 	cork->length -= length;
 	IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTDISCARDS);
+error2:
+	DTRACE_IP(drop__out,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb ? skb->sk : NULL,
+		  void_ip_t * : ipinfo_t *, skb ? ip_hdr(skb) : NULL,
+		  struct net_device * : ifinfo_t *, skb ? skb->dev : NULL,
+		  struct iphdr * : ipv4info_t *, skb ? ip_hdr(skb) : NULL,
+		  struct ipv6hdr * : ipv6info_t *, NULL,
+		  char * : string, dropreason);
+
 	return err;
 }
 
@@ -1185,6 +1220,8 @@ ssize_t	ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
 	int len;
 	int err;
 	unsigned int maxfraglen, fragheaderlen, fraggap, maxnonfragsize;
+	struct iphdr *iph;
+	const char *dropreason;
 
 	if (inet->hdrincl)
 		return -EPERM;
@@ -1238,6 +1275,7 @@ ssize_t	ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
 			alloclen = fragheaderlen + hh_len + fraggap + 15;
 			skb = sock_wmalloc(sk, alloclen, 1, sk->sk_allocation);
 			if (unlikely(!skb)) {
+				dropreason = "no buffers";
 				err = -ENOBUFS;
 				goto error;
 			}
@@ -1277,6 +1315,7 @@ ssize_t	ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
 			len = size;
 
 		if (skb_append_pagefrags(skb, page, offset, len)) {
+			dropreason = "packet too big";
 			err = -EMSGSIZE;
 			goto error;
 		}
@@ -1299,6 +1338,16 @@ ssize_t	ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
 error:
 	cork->length -= size;
 	IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTDISCARDS);
+	iph = skb ? ip_hdr(skb) : NULL;
+	DTRACE_IP(drop__out,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb ? skb->sk : NULL,
+		  void_ip_t * : ipinfo_t *, iph,
+		  struct net_device * : ifinfo_t *, skb ? skb->dev : NULL,
+		  struct iphdr * : ipv4info_t *, iph,
+		  struct ipv6hdr * : ipv6info_t *, NULL,
+		  char * : string, dropreason);
+
 	return err;
 }
 
@@ -1415,8 +1464,18 @@ int ip_send_skb(struct net *net, struct sk_buff *skb)
 	if (err) {
 		if (err > 0)
 			err = net_xmit_errno(err);
-		if (err)
+		if (err) {
 			IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);
+			/* skb may have been freed */
+			DTRACE_IP(drop__out,
+				  struct sk_buff * : pktinfo_t *, NULL,
+				  struct sock * : csinfo_t *, NULL,
+				  void_ip_t * : ipinfo_t *, NULL,
+				  struct net_device * : ifinfo_t *, NULL,
+				  struct iphdr * : ipv4info_t *, NULL,
+				  struct ipv6hdr * : ipv6info_t *, NULL,
+				  char * : string, "packet too short");
+		}
 	}
 
 	return err;
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index 125c1eab3eaa..9617bed21398 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -79,6 +79,7 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/compat.h>
 #include <linux/uio.h>
+#include <linux/sdt.h>
 
 struct raw_frag_vec {
 	struct msghdr *msg;
@@ -429,6 +430,14 @@ static int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,
 				skb_transport_header(skb))->type);
 	}
 
+	DTRACE_IP(send,
+		  struct sk_buff * :  pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, sk,
+		  void_ip_t * : ipinfo_t *, iph,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, iph,
+		  struct ipv6hdr * : ipv6info_t *, NULL);
+
 	err = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
 		      net, sk, skb, NULL, rt->dst.dev,
 		      dst_output);
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index fe11128d7df4..3b6f1973d19a 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -270,6 +270,7 @@
 #include <linux/time.h>
 #include <linux/slab.h>
 #include <linux/errqueue.h>
+#include <linux/sdt.h>
 
 #include <net/icmp.h>
 #include <net/inet_common.h>
@@ -2013,6 +2014,19 @@ int tcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 }
 EXPORT_SYMBOL(tcp_recvmsg);
 
+/* We wish to avoid instrumenting TCP state transitions to SYN_SENT as we trace
+ * those state changes later once the destination address is committed to the
+ * sk.  We also need to deal with the fact that separate timewait sockets are
+ * used to handle the TIME_WAIT state.  We do not want to trace direct
+ * transitions from CLOSING/FIN_WAIT2 -> CLOSE since they do not represent
+ * connection close, rather a transition to using the timewait socket.
+ * Accordingly skip instrumentation of transitions from CLOSING/FIN_WAIT2 to
+ * CLOSE.
+ */
+#define	REAL_STATE_CHANGE(old, new)					\
+	(old != new && new != TCP_SYN_SENT &&				\
+	((old != TCP_CLOSING && old != TCP_FIN_WAIT2) || new != TCP_CLOSE))
+
 void tcp_set_state(struct sock *sk, int state)
 {
 	int oldstate = sk->sk_state;
@@ -2042,6 +2056,18 @@ void tcp_set_state(struct sock *sk, int state)
 	 */
 	sk_state_store(sk, state);
 
+	if (DTRACE_TCP_ENABLED(state__change) &&
+	    REAL_STATE_CHANGE(oldstate, state))
+		DTRACE_TCP_NOCHECK(state__change,
+				   struct sk_buff * : pktinfo_t *, NULL,
+				   struct sock * : csinfo_t *, sk,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *, NULL,
+				   struct tcp_sock * : tcpsinfo_t *, tcp_sk(sk),
+				   struct tcphdr * : tcpinfo_t *, NULL,
+				   int : tcplsinfo_t *, oldstate,
+				   int : int, state,
+				   int : int, DTRACE_NET_PROBE_OUTBOUND);
+
 #ifdef STATE_TRACE
 	SOCK_DEBUG(sk, "TCP sk=%p, State %s -> %s\n", sk, statename[oldstate], statename[state]);
 #endif
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index d9d215e27b8a..4e1aafae8ad7 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -76,6 +76,7 @@
 #include <linux/ipsec.h>
 #include <asm/unaligned.h>
 #include <linux/errqueue.h>
+#include <linux/sdt.h>
 
 int sysctl_tcp_fack __read_mostly;
 int sysctl_tcp_max_reordering __read_mostly = 300;
@@ -5533,6 +5534,14 @@ void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct inet_connection_sock *icsk = inet_csk(sk);
 
+	DTRACE_TCP(connect__established,
+		   struct sk_buff * :  pktinfo_t *, skb,
+		   struct sock * : csinfo_t *, sk,
+		   __dtrace_tcp_void_ip_t * : ipinfo_t *, ip_hdr(skb),
+		   struct tcp_sock * : tcpsinfo_t *, tp,
+		   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+		   int : tcplsinfo_t *, TCP_ESTABLISHED,
+		   int, TCP_ESTABLISHED, int, DTRACE_NET_PROBE_INBOUND);
 	tcp_set_state(sk, TCP_ESTABLISHED);
 	icsk->icsk_ack.lrcvtime = tcp_jiffies32;
 
@@ -5666,6 +5675,17 @@ static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,
 		 */
 
 		if (th->rst) {
+			DTRACE_TCP(connect__refused,
+				   struct sk_buff * : pktinfo_t *, skb,
+				   struct sock * : csinfo_t *, sk,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *,
+				   ip_hdr(skb),
+				   struct tcp_sock * : tcpsinfo_t *, tp,
+				   struct tcphdr * : tcpinfo_t *, th,
+				   int : tcplsinfo_t *,
+				   sk ? sk->sk_state : TCP_CLOSE,
+				   int, sk ? sk->sk_state : TCP_CLOSE,
+				   int, DTRACE_NET_PROBE_INBOUND);
 			tcp_reset(sk);
 			goto discard;
 		}
@@ -5958,6 +5978,16 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb)
 			tcp_init_buffer_space(sk);
 		}
 		smp_mb();
+
+		DTRACE_TCP(accept__established,
+			   struct sk_buff * :  pktinfo_t *, skb,
+			   struct sock * : csinfo_t *, sk,
+			   __dtrace_tcp_void_ip_t * : ipinfo_t *, ip_hdr(skb),
+			   struct tcp_sock * : tcpsinfo_t *, tp,
+			   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+			   int : tcplsinfo_t *, TCP_ESTABLISHED,
+			   int, TCP_ESTABLISHED,
+			   int, DTRACE_NET_PROBE_INBOUND);
 		tcp_set_state(sk, TCP_ESTABLISHED);
 		sk->sk_state_change(sk);
 
@@ -6384,6 +6414,19 @@ int tcp_conn_request(struct request_sock_ops *rsk_ops,
 		af_ops->send_synack(sk, dst, &fl, req, &foc,
 				    !want_cookie ? TCP_SYNACK_NORMAL :
 						   TCP_SYNACK_COOKIE);
+		/* Do not pass in tcp sock as ports/addresses are not yet
+		 * populated - instead translators will fill them in from
+		 * skb data.
+		 */
+		DTRACE_TCP(state__change,
+			   struct sk_buff * : pktinfo_t *, skb,
+			   struct sock * : csinfo_t *, sk,
+			   __dtrace_tcp_void_ip_t * : ipinfo_t *, ip_hdr(skb),
+			   struct tcp_sock * : tcpsinfo_t *, NULL,
+			   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+			   int : tcplsinfo_t *, TCP_LISTEN,
+			   int, TCP_SYN_RECV, int, DTRACE_NET_PROBE_INBOUND);
+
 		if (want_cookie) {
 			reqsk_free(req);
 			return 0;
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index cab4b935e474..a988ce4b73ad 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -84,6 +84,7 @@
 
 #include <crypto/hash.h>
 #include <linux/scatterlist.h>
+#include <linux/sdt.h>
 
 #ifdef CONFIG_TCP_MD5SIG
 static int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,
@@ -580,6 +581,21 @@ void tcp_v4_send_check(struct sock *sk, struct sk_buff *skb)
 }
 EXPORT_SYMBOL(tcp_v4_send_check);
 
+/* Since we want to trace send events in TCP prior to pushing the segment to
+ * IP - where the IP header is added - we need to construct an argument
+ * containing relevant IP info so that TCP probe consumers can utilize it.
+ */
+static inline void dtrace_tcp_build_iphdr(__be32 saddr, __be32 daddr,
+					  struct iphdr *iph)
+{
+	iph->version = 4;
+	iph->ihl = 5;
+	iph->tot_len = 5;
+	iph->protocol = IPPROTO_TCP;
+	iph->saddr = saddr;
+	iph->daddr = daddr;
+}
+
 /*
  *	This routine will send an RST to the other tcp.
  *
@@ -710,6 +726,39 @@ static void tcp_v4_send_reset(const struct sock *sk, struct sk_buff *skb)
 	arg.tos = ip_hdr(skb)->tos;
 	arg.uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);
 	local_bh_disable();
+
+	if (DTRACE_TCP_ENABLED(send) ||
+	    DTRACE_TCP_ENABLED(accept__refused)) {
+		struct iphdr iph;
+
+		dtrace_tcp_build_iphdr(ip_hdr(skb)->daddr, ip_hdr(skb)->saddr,
+				       &iph);
+
+		DTRACE_TCP_NOCHECK(send,
+				   struct sk_buff * : pktinfo_t *, NULL,
+				   struct sock * : csinfo_t *, NULL,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *, &iph,
+				   struct tcp_sock * : tcpsinfo_t *, NULL,
+				   struct tcphdr * : tcpinfo_t *, &rep.th,
+				   int : tcplsinfo_t *, TCP_CLOSE,
+				   int : int, TCP_CLOSE,
+				   int : int, DTRACE_NET_PROBE_OUTBOUND);
+		if (th->syn && rep.th.seq == 0)
+			DTRACE_TCP_NOCHECK(accept__refused,
+					   struct sk_buff * : pktinfo_t *, NULL,
+					   struct sock * : csinfo_t *, NULL,
+					   __dtrace_tcp_void_ip_t * :
+					   ipinfo_t *, &iph,
+					   struct tcp_sock * : tcpsinfo_t *,
+					   NULL,
+					   struct tcphdr * : tcpinfo_t *,
+					   &rep.th,
+					   int : tcplsinfo_t *, TCP_CLOSE,
+					   int : int, TCP_CLOSE,
+					   int : int,
+					   DTRACE_NET_PROBE_OUTBOUND);
+	}
+
 	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),
 			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
 			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
@@ -796,6 +845,24 @@ static void tcp_v4_send_ack(const struct sock *sk,
 	arg.tos = tos;
 	arg.uid = sock_net_uid(net, sk_fullsock(sk) ? sk : NULL);
 	local_bh_disable();
+
+	if (DTRACE_TCP_ENABLED(send)) {
+		struct iphdr iph;
+
+		dtrace_tcp_build_iphdr(ip_hdr(skb)->daddr, ip_hdr(skb)->saddr,
+				       &iph);
+
+		DTRACE_TCP_NOCHECK(send,
+				   struct sk_buff * : pktinfo_t *, NULL,
+				   struct sock * : csinfo_t *, NULL,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *, &iph,
+				   struct tcp_sock * : tcpsinfo_t *, NULL,
+				   struct tcphdr * : tcpinfo_t *, &rep,
+				   int : tcplsinfo_t *, TCP_CLOSE,
+				   int : int, TCP_CLOSE,
+				   int : int, DTRACE_NET_PROBE_OUTBOUND);
+	}
+
 	ip_send_unicast_reply(*this_cpu_ptr(net->ipv4.tcp_sk),
 			      skb, &TCP_SKB_CB(skb)->header.h4.opt,
 			      ip_hdr(skb)->saddr, ip_hdr(skb)->daddr,
@@ -875,6 +942,30 @@ static int tcp_v4_send_synack(const struct sock *sk, struct dst_entry *dst,
 	if (skb) {
 		__tcp_v4_send_check(skb, ireq->ir_loc_addr, ireq->ir_rmt_addr);
 
+		if (DTRACE_TCP_ENABLED(send)) {
+			struct iphdr iph;
+
+			dtrace_tcp_build_iphdr(ireq->ir_loc_addr,
+					       ireq->ir_rmt_addr, &iph);
+
+			/* Do not supply tcp sk - addresses/ports are not
+			 * committed yet - instead translators will fill them
+			 * in from skb/IP info.
+			 */
+			DTRACE_TCP_NOCHECK(send,
+					   struct sk_buff * :  pktinfo_t *, skb,
+					   struct sock * : csinfo_t *, sk,
+					   __dtrace_tcp_void_ip_t * :
+					   ipinfo_t *, &iph,
+					   struct tcp_sock * : tcpsinfo_t *,
+					   NULL,
+					   struct tcphdr * : tcpinfo_t *,
+					   tcp_hdr(skb),
+					   int : tcplsinfo_t *, TCP_LISTEN,
+					   int, TCP_LISTEN,
+					   int, DTRACE_NET_PROBE_OUTBOUND);
+		}
+
 		err = ip_build_and_send_pkt(skb, sk, ireq->ir_loc_addr,
 					    ireq->ir_rmt_addr,
 					    ireq_opt_deref(ireq));
@@ -1626,7 +1717,7 @@ int tcp_v4_rcv(struct sk_buff *skb)
 	const struct iphdr *iph;
 	const struct tcphdr *th;
 	bool refcounted;
-	struct sock *sk;
+	struct sock *sk = NULL;
 	int ret;
 
 	if (skb->pkt_type != PACKET_HOST)
@@ -1661,6 +1752,15 @@ int tcp_v4_rcv(struct sk_buff *skb)
 	if (!sk)
 		goto no_tcp_socket;
 
+	DTRACE_TCP(receive,
+		   struct sk_buff * :  pktinfo_t *, skb,
+		   struct sock * : csinfo_t *, sk,
+		   __dtrace_tcp_void_ip_t * : ipinfo_t *, ip_hdr(skb),
+		   struct tcp_sock * : tcpsinfo_t *, tcp_sk(sk),
+		   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+		   int : tcplsinfo_t *, sk ? sk->sk_state : TCP_CLOSE,
+		   int, sk ? sk->sk_state : TCP_CLOSE,
+		   int, DTRACE_NET_PROBE_INBOUND);
 process:
 	if (sk->sk_state == TCP_TIME_WAIT)
 		goto do_time_wait;
@@ -1767,6 +1867,18 @@ int tcp_v4_rcv(struct sk_buff *skb)
 
 discard_it:
 	/* Discard frame. */
+	if (DTRACE_TCP_ENABLED(receive) && skb->pkt_type == PACKET_HOST)
+		DTRACE_TCP_NOCHECK(receive,
+				   struct sk_buff * :  pktinfo_t *, skb,
+				   struct sock * : csinfo_t *, sk,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *,
+				   ip_hdr(skb),
+				   struct tcp_sock * : tcpsinfo_t *, tcp_sk(sk),
+				   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+				   int : tcplsinfo_t *,
+				   sk ? sk->sk_state : TCP_CLOSE,
+				   int, sk ? sk->sk_state : TCP_CLOSE,
+				   int, DTRACE_NET_PROBE_INBOUND);
 	kfree_skb(skb);
 	return 0;
 
diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c
index 420fecbb98fe..c502a683ba0a 100644
--- a/net/ipv4/tcp_minisocks.c
+++ b/net/ipv4/tcp_minisocks.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/sysctl.h>
 #include <linux/workqueue.h>
+#include <linux/sdt.h>
 #include <net/tcp.h>
 #include <net/inet_common.h>
 #include <net/xfrm.h>
@@ -322,6 +323,20 @@ void tcp_time_wait(struct sock *sk, int state, int timeo)
 		__inet_twsk_hashdance(tw, sk, &tcp_hashinfo);
 		inet_twsk_put(tw);
 		local_bh_enable();
+
+		if (DTRACE_TCP_ENABLED(state__change) &&
+		    state != sk->sk_state)
+			DTRACE_TCP_NOCHECK(state__change,
+					   struct sk_buff * : pktinfo_t *, NULL,
+					   struct sock * : csinfo_t *, sk,
+					   __dtrace_tcp_void_ip_t * :
+					   ipinfo_t *, NULL,
+					   struct tcp_sock * : tcpsinfo_t *,
+					   tcp_sk(sk),
+					   struct tcphdr * : tcpinfo_t *, NULL,
+					   int : tcplsinfo_t *, sk->sk_state,
+					   int, state,
+					   int, DTRACE_NET_PROBE_OUTBOUND);
 	} else {
 		/* Sorry, if we're out of memory, just CLOSE this
 		 * socket up.  We've got bigger problems than
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index cd3d60bb7cc8..24c979a785cf 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -41,6 +41,7 @@
 #include <linux/compiler.h>
 #include <linux/gfp.h>
 #include <linux/module.h>
+#include <linux/sdt.h>
 
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse __read_mostly = 1;
@@ -1106,6 +1107,27 @@ static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 		tcp_internal_pacing(sk, skb);
 	}
 
+	DTRACE_TCP(send,
+		   struct sk_buff * :  pktinfo_t *, skb,
+		   struct sock * : csinfo_t *, sk,
+		   __dtrace_tcp_void_ip_t * : ipinfo_t *, ip_hdr(skb),
+		   struct tcp_sock * : tcpsinfo_t *, tp,
+		   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+		   int : tcplsinfo_t *, sk->sk_state, int, sk->sk_state,
+		   int, DTRACE_NET_PROBE_OUTBOUND);
+	if (DTRACE_TCP_ENABLED(connect__request) && th->syn &&
+	    th->ack_seq == 0)
+		DTRACE_TCP_NOCHECK(connect__request,
+				   struct sk_buff * : pktinfo_t *, skb,
+				   struct sock * : csinfo_t *, sk,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *,
+				   ip_hdr(skb),
+				   struct tcp_sock * : tcpsinfo_t *, tp,
+				   struct tcphdr * : tcpinfo_t *, th,
+				   int : tcplsinfo_t *, sk->sk_state,
+				   int, sk->sk_state,
+				   int, DTRACE_NET_PROBE_OUTBOUND);
+
 	if (after(tcb->end_seq, tp->snd_nxt) || tcb->seq == tcb->end_seq)
 		TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,
 			      tcp_skb_pcount(skb));
@@ -3435,6 +3457,13 @@ int tcp_connect(struct sock *sk)
 	tp->retrans_stamp = tcp_time_stamp(tp);
 	tcp_connect_queue_skb(sk, buff);
 	tcp_ecn_send_syn(sk, buff);
+	DTRACE_TCP(state__change, struct sk_buff * : pktinfo_t *, NULL,
+		   struct sock * : csinfo_t *, sk,
+		   __dtrace_tcp_void_ip_t * : ipinfo_t *, ip_hdr(buff),
+		   struct tcp_sock * : tcpsinfo_t *, tp,
+		   struct tcphdr * : tcpinfo_t *, tcp_hdr(buff),
+		   int : tcplsinfo_t *, TCP_CLOSE,
+		   int, sk->sk_state, int, DTRACE_NET_PROBE_OUTBOUND);
 
 	/* Send off SYN; include data in Fast Open. */
 	err = tp->fastopen_req ? tcp_send_syn_data(sk, buff) :
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index ebfbccae62fd..b2aada90bbc1 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -110,6 +110,7 @@
 #include <net/xfrm.h>
 #include <trace/events/udp.h>
 #include <linux/static_key.h>
+#include <linux/sdt.h>
 #include <trace/events/skb.h>
 #include <net/busy_poll.h>
 #include "udp_impl.h"
@@ -826,6 +827,13 @@ static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)
 		uh->check = CSUM_MANGLED_0;
 
 send:
+	DTRACE_UDP(send,
+		   struct sk_buff * :  pktinfo_t *, skb,
+		   struct sock * : csinfo_t *, sk,
+		   void_ip_t * : ipinfo_t *, ip_hdr(skb),
+		   struct udp_sock * : udpsinfo_t *, udp_sk(sk),
+		   struct udphdr * : udpinfo_t *, uh);
+
 	err = ip_send_skb(sock_net(sk), skb);
 	if (err) {
 		if (err == -ENOBUFS && !inet->recverr) {
@@ -1634,9 +1642,16 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
 		return err;
 	}
 
-	if (!peeked)
+	if (!peeked) {
+		DTRACE_UDP(receive,
+			   struct sk_buff * :  pktinfo_t *, skb,
+			   struct sock * : csinfo_t *, sk,
+			   void_ip_t * : ipinfo_t *, ip_hdr(skb),
+			   struct udp_sock * : udpsinfo_t *, udp_sk(sk),
+			   struct udphdr * : udpinfo_t *, udp_hdr(skb));
 		UDP_INC_STATS(sock_net(sk),
 			      UDP_MIB_INDATAGRAMS, is_udplite);
+	}
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 
@@ -1863,6 +1878,15 @@ static int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 
 			ret = encap_rcv(sk, skb);
 			if (ret <= 0) {
+				DTRACE_UDP(receive,
+					   struct sk_buff * :  pktinfo_t *, skb,
+					   struct sock * : csinfo_t *, sk,
+					   void_ip_t * : ipinfo_t *,
+					   ip_hdr(skb),
+					   struct udp_sock * : udpsinfo_t *,
+					   udp_sk(sk),
+					   struct udphdr * : udpinfo_t *,
+					   udp_hdr(skb));
 				__UDP_INC_STATS(sock_net(sk),
 						UDP_MIB_INDATAGRAMS,
 						is_udplite);
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 9ee208a348f5..390f7b0f2b69 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -46,6 +46,7 @@
 #include <net/xfrm.h>
 #include <net/inet_ecn.h>
 #include <net/dst_metadata.h>
+#include <linux/sdt.h>
 
 int ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
@@ -73,10 +74,11 @@ int ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 
 int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
 {
-	const struct ipv6hdr *hdr;
+	const struct ipv6hdr *hdr = NULL;
 	u32 pkt_len;
 	struct inet6_dev *idev;
 	struct net *net = dev_net(skb->dev);
+	const char *dropreason = "header invalid";
 
 	if (skb->pkt_type == PACKET_OTHERHOST) {
 		kfree_skb(skb);
@@ -92,6 +94,7 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL ||
 	    !idev || unlikely(idev->cnf.disable_ipv6)) {
 		__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);
+		dropreason = "could not clone shared buffer";
 		goto drop;
 	}
 
@@ -110,8 +113,10 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	 */
 	IP6CB(skb)->iif = skb_valid_dst(skb) ? ip6_dst_idev(skb_dst(skb))->dev->ifindex : dev->ifindex;
 
-	if (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))
+	if (unlikely(!pskb_may_pull(skb, sizeof(*hdr)))) {
+		hdr = ipv6_hdr(skb);
 		goto err;
+	}
 
 	hdr = ipv6_hdr(skb);
 
@@ -131,8 +136,10 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	 */
 	if ((ipv6_addr_loopback(&hdr->saddr) ||
 	     ipv6_addr_loopback(&hdr->daddr)) &&
-	     !(dev->flags & IFF_LOOPBACK))
+	     !(dev->flags & IFF_LOOPBACK)) {
+		dropreason = "loopback destination received on interface";
 		goto err;
+	}
 
 	/* RFC4291 Errata ID: 3480
 	 * Interface-Local scope spans only a single interface on a
@@ -143,8 +150,10 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	if (!(skb->pkt_type == PACKET_LOOPBACK ||
 	      dev->flags & IFF_LOOPBACK) &&
 	    ipv6_addr_is_multicast(&hdr->daddr) &&
-	    IPV6_ADDR_MC_SCOPE(&hdr->daddr) == 1)
+	    IPV6_ADDR_MC_SCOPE(&hdr->daddr) == 1) {
+		dropreason = "interface-local scope received from other node";
 		goto err;
+	}
 
 	/* If enabled, drop unicast packets that were encapsulated in link-layer
 	 * multicast or broadcast to protected against the so-called "hole-196"
@@ -162,16 +171,21 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 	 * must be silently dropped.
 	 */
 	if (ipv6_addr_is_multicast(&hdr->daddr) &&
-	    IPV6_ADDR_MC_SCOPE(&hdr->daddr) == 0)
+	    IPV6_ADDR_MC_SCOPE(&hdr->daddr) == 0) {
+		dropreason =
+		    "packet to multicast address with reserved scope 0";
 		goto err;
+	}
 
 	/*
 	 * RFC4291 2.7
 	 * Multicast addresses must not be used as source addresses in IPv6
 	 * packets or appear in any Routing header.
 	 */
-	if (ipv6_addr_is_multicast(&hdr->saddr))
+	if (ipv6_addr_is_multicast(&hdr->saddr)) {
+		dropreason = "multicast source address in IPv6 packet";
 		goto err;
+	}
 
 	skb->transport_header = skb->network_header + sizeof(*hdr);
 	IP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);
@@ -183,10 +197,12 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 		if (pkt_len + sizeof(struct ipv6hdr) > skb->len) {
 			__IP6_INC_STATS(net,
 					idev, IPSTATS_MIB_INTRUNCATEDPKTS);
+			dropreason = "packet too short";
 			goto drop;
 		}
 		if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr))) {
 			__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);
+			dropreason = "could not trim buffer";
 			goto drop;
 		}
 		hdr = ipv6_hdr(skb);
@@ -211,6 +227,15 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 err:
 	__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);
 drop:
+	DTRACE_IP(drop__in,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb ? skb->sk : NULL,
+		  void_ip_t * : ipinfo_t *, hdr,
+		  struct net_device * : ifinfo_t *, skb ? skb->dev : NULL,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, hdr,
+		  char * : string, dropreason);
+
 	rcu_read_unlock();
 	kfree_skb(skb);
 	return NET_RX_DROP;
@@ -229,6 +254,8 @@ static int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *sk
 	int nexthdr;
 	bool raw;
 	bool have_final = false;
+	struct ipv6hdr *hdr;
+	const char *dropreason = "header invalid";
 
 	/*
 	 *	Parse extension headers
@@ -274,12 +301,17 @@ static int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *sk
 			if (ipv6_addr_is_multicast(&hdr->daddr) &&
 			    !ipv6_chk_mcast_addr(skb->dev, &hdr->daddr,
 			    &hdr->saddr) &&
-			    !ipv6_is_mld(skb, nexthdr, skb_network_header_len(skb)))
+			    !ipv6_is_mld(skb, nexthdr,
+					 skb_network_header_len(skb))) {
+				dropreason = "destination is multicast";
 				goto discard;
+			}
 		}
 		if (!(ipprot->flags & INET6_PROTO_NOPOLICY) &&
-		    !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
+		    !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
+			dropreason = "policy failure";
 			goto discard;
+		}
 
 		ret = ipprot->handler(skb);
 		if (ret > 0) {
@@ -316,6 +348,15 @@ static int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *sk
 
 discard:
 	__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);
+	hdr = ipv6_hdr(skb);
+	DTRACE_IP(drop__in,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, hdr,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, hdr,
+		  char * : string, dropreason);
 	rcu_read_unlock();
 	kfree_skb(skb);
 	return 0;
@@ -324,6 +365,16 @@ static int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *sk
 
 int ip6_input(struct sk_buff *skb)
 {
+	struct ipv6hdr *hdr = ipv6_hdr(skb);
+
+	DTRACE_IP(receive,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, hdr,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, hdr);
+
 	return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN,
 		       dev_net(skb->dev), NULL, skb, skb->dev, NULL,
 		       ip6_input_finish);
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 3763dc01e374..3108c36e57a3 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -58,6 +58,7 @@
 #include <linux/mroute6.h>
 #include <net/l3mdev.h>
 #include <net/lwtunnel.h>
+#include <linux/sdt.h>
 
 static int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
@@ -86,6 +87,18 @@ static int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *
 					dev_loopback_xmit);
 
 			if (ipv6_hdr(skb)->hop_limit == 0) {
+				DTRACE_IP(drop__out,
+					  struct sk_buff * : pktinfo_t *, skb,
+					  struct sock * : csinfo_t *, skb->sk,
+					  void_ip_t * : ipinfo_t *,
+					  ipv6_hdr(skb),
+					  struct net_device * : ifinfo_t *,
+					  skb->dev,
+					  struct iphdr * : ipv4info_t *, NULL,
+					  struct ipv6hdr * : ipv6info_t *,
+					  ipv6_hdr(skb),
+					  char * : string, "hoplimit exceeded");
+
 				IP6_INC_STATS(net, idev,
 					      IPSTATS_MIB_OUTDISCARDS);
 				kfree_skb(skb);
@@ -155,6 +168,15 @@ int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)
 	skb->dev = dev;
 
 	if (unlikely(idev->cnf.disable_ipv6)) {
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, skb,
+			  struct sock * : csinfo_t *, skb->sk,
+			  void_ip_t * : ipinfo_t *, NULL,
+			  struct net_device * : ifinfo_t *, skb->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, NULL,
+			  char * : string, "IPv6 is disabled");
+
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
 		kfree_skb(skb);
 		return 0;
@@ -206,6 +228,16 @@ int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 		if (skb_headroom(skb) < head_room) {
 			struct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);
 			if (!skb2) {
+				DTRACE_IP(drop__out,
+					  struct sk_buff * : pktinfo_t *, skb,
+					  struct sock * : csinfo_t *, skb->sk,
+					  void_ip_t * : ipinfo_t *, NULL,
+					  struct net_device * : ifinfo_t *,
+					  skb->dev,
+					  struct iphdr * : ipv4info_t *, NULL,
+					  struct ipv6hdr * : ipv6info_t *, NULL,
+					  char * : string, "out of memory");
+
 				IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
 					      IPSTATS_MIB_OUTDISCARDS);
 				kfree_skb(skb);
@@ -263,6 +295,14 @@ int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,
 		if (unlikely(!skb))
 			return 0;
 
+		DTRACE_IP(send,
+			  struct sk_buff * : pktinfo_t *, skb,
+			  struct sock * : csinfo_t *, skb->sk,
+			  void_ip_t * : ipinfo_t *, hdr,
+			  struct net_device * : ifinfo_t *, skb->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, hdr);
+
 		/* hooks should never assume socket lock is held.
 		 * we promote our socket to non const
 		 */
@@ -416,22 +456,32 @@ int ip6_forward(struct sk_buff *skb)
 	struct inet6_skb_parm *opt = IP6CB(skb);
 	struct net *net = dev_net(dst->dev);
 	u32 mtu;
+	const char *dropreason;
 
-	if (net->ipv6.devconf_all->forwarding == 0)
+	if (net->ipv6.devconf_all->forwarding == 0) {
+		dropreason = "forwarding disabled";
 		goto error;
+	}
 
-	if (skb->pkt_type != PACKET_HOST)
+	if (skb->pkt_type != PACKET_HOST) {
+		dropreason = "non-host packet type cannot be forwarded";
 		goto drop;
+	}
 
-	if (unlikely(skb->sk))
+	if (unlikely(skb->sk)) {
+		dropreason = "socket found for packet to be forwarded";
 		goto drop;
+	}
 
-	if (skb_warn_if_lro(skb))
+	if (skb_warn_if_lro(skb)) {
+		dropreason = "LRO warning";
 		goto drop;
+	}
 
 	if (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {
 		__IP6_INC_STATS(net, ip6_dst_idev(dst),
 				IPSTATS_MIB_INDISCARDS);
+		dropreason = "forwarding disabled by policy";
 		goto drop;
 	}
 
@@ -461,6 +511,16 @@ int ip6_forward(struct sk_buff *skb)
 	if (hdr->hop_limit <= 1) {
 		/* Force OUTPUT device used as source address */
 		skb->dev = dst->dev;
+
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, skb,
+			  struct sock * : csinfo_t *, skb->sk,
+			  void_ip_t * : ipinfo_t *, hdr,
+			  struct net_device * : ifinfo_t *, skb->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, hdr,
+			  char * : string, "hoplimit exceeded");
+
 		icmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);
 		__IP6_INC_STATS(net, ip6_dst_idev(dst),
 				IPSTATS_MIB_INHDRERRORS);
@@ -476,6 +536,7 @@ int ip6_forward(struct sk_buff *skb)
 		if (proxied > 0)
 			return ip6_input(skb);
 		else if (proxied < 0) {
+			dropreason = "proxy router cannot forward";
 			__IP6_INC_STATS(net, ip6_dst_idev(dst),
 					IPSTATS_MIB_INDISCARDS);
 			goto drop;
@@ -485,6 +546,7 @@ int ip6_forward(struct sk_buff *skb)
 	if (!xfrm6_route_forward(skb)) {
 		__IP6_INC_STATS(net, ip6_dst_idev(dst),
 				IPSTATS_MIB_INDISCARDS);
+		dropreason = "forwarding disabled for destination";
 		goto drop;
 	}
 	dst = skb_dst(skb);
@@ -523,9 +585,12 @@ int ip6_forward(struct sk_buff *skb)
 
 		/* This check is security critical. */
 		if (addrtype == IPV6_ADDR_ANY ||
-		    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))
+		    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK)) {
+			dropreason = "invalid address type for forwarding";
 			goto error;
+		}
 		if (addrtype & IPV6_ADDR_LINKLOCAL) {
+			dropreason = "invalid address type for forwarding";
 			icmpv6_send(skb, ICMPV6_DEST_UNREACH,
 				    ICMPV6_NOT_NEIGHBOUR, 0);
 			goto error;
@@ -539,6 +604,15 @@ int ip6_forward(struct sk_buff *skb)
 	if (ip6_pkt_too_big(skb, mtu)) {
 		/* Again, force OUTPUT device used as source address */
 		skb->dev = dst->dev;
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, skb,
+			  struct sock * : csinfo_t *, skb->sk,
+			  void_ip_t * : ipinfo_t *, hdr,
+			  struct net_device * : ifinfo_t *, skb->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, hdr,
+			  char * : string, "packet too big");
+
 		icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
 		__IP6_INC_STATS(net, ip6_dst_idev(dst),
 				IPSTATS_MIB_INTOOBIGERRORS);
@@ -551,6 +625,7 @@ int ip6_forward(struct sk_buff *skb)
 	if (skb_cow(skb, dst->dev->hard_header_len)) {
 		__IP6_INC_STATS(net, ip6_dst_idev(dst),
 				IPSTATS_MIB_OUTDISCARDS);
+		dropreason = "copy-on-write failed";
 		goto drop;
 	}
 
@@ -569,6 +644,15 @@ int ip6_forward(struct sk_buff *skb)
 error:
 	__IP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);
 drop:
+	DTRACE_IP(drop__out,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, hdr,
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, hdr,
+		  char * : string, dropreason);
+
 	kfree_skb(skb);
 	return -EINVAL;
 }
@@ -1250,6 +1334,7 @@ static int __ip6_append_data(struct sock *sk,
 	struct ipv6_txoptions *opt = v6_cork->opt;
 	int csummode = CHECKSUM_NONE;
 	unsigned int maxnonfragsize, headersize;
+	const char *dropreason;
 
 	skb = skb_peek_tail(queue);
 	if (!skb) {
@@ -1278,6 +1363,7 @@ static int __ip6_append_data(struct sock *sk,
 	     sk->sk_protocol == IPPROTO_RAW)) {
 		ipv6_local_rxpmtu(sk, fl6, mtu - headersize +
 				sizeof(struct ipv6hdr));
+		dropreason = "fragmentation needed but disabled";
 		goto emsgsize;
 	}
 
@@ -1291,6 +1377,14 @@ static int __ip6_append_data(struct sock *sk,
 		ipv6_local_error(sk, EMSGSIZE, fl6,
 				 mtu - headersize +
 				 sizeof(struct ipv6hdr));
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, skb,
+			  struct sock * : csinfo_t *, skb->sk,
+			  void_ip_t * : ipinfo_t *, NULL,
+			  struct net_device * : ifinfo_t *, skb->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, NULL,
+			  char * : string, "packet too big");
 		return -EMSGSIZE;
 	}
 
@@ -1410,8 +1504,11 @@ static int __ip6_append_data(struct sock *sk,
 				if (unlikely(!skb))
 					err = -ENOBUFS;
 			}
-			if (!skb)
+			if (!skb) {
+				dropreason = "out of memory";
 				goto error;
+			}
+
 			/*
 			 *	Fill in the control structures
 			 */
@@ -1449,7 +1546,9 @@ static int __ip6_append_data(struct sock *sk,
 			    getfrag(from, data + transhdrlen, offset,
 				    copy, fraggap, skb) < 0) {
 				err = -EFAULT;
+				dropreason = "could not get fragment";
 				kfree_skb(skb);
+				skb = NULL;
 				goto error;
 			}
 
@@ -1480,20 +1579,25 @@ static int __ip6_append_data(struct sock *sk,
 						offset, copy, off, skb) < 0) {
 				__skb_trim(skb, off);
 				err = -EFAULT;
+				dropreason = "could not get fragment";
 				goto error;
 			}
 		} else {
 			int i = skb_shinfo(skb)->nr_frags;
 
 			err = -ENOMEM;
-			if (!sk_page_frag_refill(sk, pfrag))
+			if (!sk_page_frag_refill(sk, pfrag)) {
+				dropreason = "out of memory";
 				goto error;
+			}
 
 			if (!skb_can_coalesce(skb, i, pfrag->page,
 					      pfrag->offset)) {
 				err = -EMSGSIZE;
-				if (i == MAX_SKB_FRAGS)
+				if (i == MAX_SKB_FRAGS) {
+					dropreason = "too many fragments";
 					goto error;
+				}
 
 				__skb_fill_page_desc(skb, i, pfrag->page,
 						     pfrag->offset, 0);
@@ -1503,8 +1607,10 @@ static int __ip6_append_data(struct sock *sk,
 			copy = min_t(int, copy, pfrag->size - pfrag->offset);
 			if (getfrag(from,
 				    page_address(pfrag->page) + pfrag->offset,
-				    offset, copy, skb->len, skb) < 0)
+				    offset, copy, skb->len, skb) < 0) {
+				dropreason = "could not get fragment";
 				goto error_efault;
+			}
 
 			pfrag->offset += copy;
 			skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
@@ -1522,6 +1628,15 @@ static int __ip6_append_data(struct sock *sk,
 error_efault:
 	err = -EFAULT;
 error:
+	DTRACE_IP(drop__out,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb ? skb->sk : NULL,
+		  void_ip_t * : ipinfo_t *, NULL,
+		  struct net_device * : ifinfo_t *, skb ? skb->dev : NULL,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, NULL,
+		  char * : string, dropreason);
+
 	cork->length -= length;
 	IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);
 	return err;
@@ -1669,9 +1784,20 @@ int ip6_send_skb(struct sk_buff *skb)
 	if (err) {
 		if (err > 0)
 			err = net_xmit_errno(err);
-		if (err)
+		if (err) {
+			/* skb may have been freed */
+			DTRACE_IP(drop__out,
+				  struct sk_buff * : pktinfo_t *, NULL,
+				  struct sock * : csinfo_t *, NULL,
+				  void_ip_t * : ipinfo_t *, NULL,
+				  struct net_device * : ifinfo_t *, NULL,
+				  struct iphdr * : ipv4info_t *, NULL,
+				  struct ipv6hdr * : ipv6info_t *, NULL,
+				  char * : string, "out of memory");
+
 			IP6_INC_STATS(net, rt->rt6i_idev,
 				      IPSTATS_MIB_OUTDISCARDS);
+		}
 	}
 
 	return err;
@@ -1697,9 +1823,19 @@ static void __ip6_flush_pending_frames(struct sock *sk,
 	struct sk_buff *skb;
 
 	while ((skb = __skb_dequeue_tail(queue)) != NULL) {
-		if (skb_dst(skb))
+		if (skb_dst(skb)) {
+			DTRACE_IP(drop__out,
+				  struct sk_buff * : pktinfo_t *, skb,
+				  struct sock * : csinfo_t *, skb->sk,
+				  void_ip_t * : ipinfo_t *, ipv6_hdr(skb),
+				  struct net_device * : ifinfo_t *, skb->dev,
+				  struct iphdr * : ipv4info_t *, NULL,
+				  struct ipv6hdr * : ipv6info_t *,
+				  ipv6_hdr(skb),
+				  char * : string, "flushing pending frames");
 			IP6_INC_STATS(sock_net(sk), ip6_dst_idev(skb_dst(skb)),
 				      IPSTATS_MIB_OUTDISCARDS);
+		}
 		kfree_skb(skb);
 	}
 
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index 9a38a2c641fa..a867f34071b0 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -64,6 +64,8 @@
 
 #include <net/ip6_checksum.h>
 
+#include <linux/sdt.h>
+
 /* Ensure that we have struct in6_addr aligned on 32bit word. */
 static void *__mld2_query_bugs[] __attribute__((__unused__)) = {
 	BUILD_BUG_ON_NULL(offsetof(struct mld2_query, mld2q_srcs) % 4),
@@ -1652,11 +1654,22 @@ static void mld_sendpack(struct sk_buff *skb)
 		dst = NULL;
 	}
 	skb_dst_set(skb, dst);
-	if (err)
-		goto err_out;
+	if (err) {
+		kfree_skb(skb);
+		skb = NULL;
+		goto out;
+	}
 
 	payload_len = skb->len;
 
+	DTRACE_IP(send,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, ipv6_hdr(skb),
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, ipv6_hdr(skb));
+
 	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
 		      net, net->ipv6.igmp_sk, skb, NULL, skb->dev,
 		      dst_output);
@@ -1665,15 +1678,21 @@ static void mld_sendpack(struct sk_buff *skb)
 		ICMP6MSGOUT_INC_STATS(net, idev, ICMPV6_MLD2_REPORT);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
 	} else {
+		/* skb may have been freed */
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, NULL,
+			  struct sock * : csinfo_t *, NULL,
+			  void_ip_t * : ipinfo_t *, NULL,
+			  struct net_device * : ifinfo_t *, idev->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, NULL,
+			  char * : string, "multicast send error");
+
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
 	}
 
 	rcu_read_unlock();
 	return;
-
-err_out:
-	kfree_skb(skb);
-	goto out;
 }
 
 static int grec_size(struct ifmcaddr6 *pmc, int type, int gdel, int sdel)
@@ -1992,6 +2011,15 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 
 	if (!skb) {
 		rcu_read_lock();
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, NULL,
+			  struct sock * : csinfo_t *, sk,
+			  void_ip_t * : ipinfo_t *, NULL,
+			  struct net_device * : ifinfo_t *, NULL,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, NULL,
+			  char * : string, "out of memory");
+
 		IP6_INC_STATS(net, __in6_dev_get(dev),
 			      IPSTATS_MIB_OUTDISCARDS);
 		rcu_read_unlock();
@@ -2030,10 +2058,19 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 	dst = icmp6_dst_alloc(skb->dev, &fl6);
 	if (IS_ERR(dst)) {
 		err = PTR_ERR(dst);
-		goto err_out;
+		kfree_skb(skb);
+		skb = NULL;
+		goto out;
 	}
 
 	skb_dst_set(skb, dst);
+	DTRACE_IP(send,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, ipv6_hdr(skb),
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, ipv6_hdr(skb));
 	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
 		      net, sk, skb, NULL, skb->dev,
 		      dst_output);
@@ -2041,15 +2078,21 @@ static void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, type);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
-	} else
+	} else {
+		/* skb may have been freed */
+		DTRACE_IP(drop__out,
+			  struct sk_buff * : pktinfo_t *, NULL,
+			  struct sock * : csinfo_t *, sk,
+			  void_ip_t * : ipinfo_t *, NULL,
+			  struct net_device * : ifinfo_t *, idev->dev,
+			  struct iphdr * : ipv4info_t *, NULL,
+			  struct ipv6hdr * : ipv6info_t *, NULL,
+			  char * : string, "multicast send error");
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
+	}
 
 	rcu_read_unlock();
 	return;
-
-err_out:
-	kfree_skb(skb);
-	goto out;
 }
 
 static void mld_send_initial_cr(struct inet6_dev *idev)
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 2a937c8d19e9..3c3eea0a178e 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -71,6 +71,7 @@
 
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
+#include <linux/sdt.h>
 
 static u32 ndisc_hash(const void *pkey,
 		      const struct net_device *dev,
@@ -480,6 +481,14 @@ static void ndisc_send_skb(struct sk_buff *skb,
 	idev = __in6_dev_get(dst->dev);
 	IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);
 
+	DTRACE_IP(send,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, ipv6_hdr(skb),
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, ipv6_hdr(skb));
+
 	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
 		      net, sk, skb, NULL, dst->dev,
 		      dst_output);
diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c
index 4fe7c90962dd..53f7ea06c204 100644
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@ -9,6 +9,7 @@
 #include <net/addrconf.h>
 #include <net/secure_seq.h>
 #include <linux/netfilter.h>
+#include <linux/sdt.h>
 
 static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,
 			       const struct in6_addr *dst,
@@ -161,6 +162,14 @@ int __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)
 
 	skb->protocol = htons(ETH_P_IPV6);
 
+	DTRACE_IP(send,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, ipv6_hdr(skb),
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, ipv6_hdr(skb));
+
 	return nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT,
 		       net, sk, skb, NULL, skb_dst(skb)->dev,
 		       dst_output);
diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c
index e4462b0ff801..89487e389cad 100644
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -62,6 +62,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/export.h>
+#include <linux/sdt.h>
 
 #define	ICMPV6_HDRLEN	4	/* ICMPv6 header, RFC 4443 Section 2.1 */
 
@@ -675,6 +676,13 @@ static int rawv6_send_hdrinc(struct sock *sk, struct msghdr *msg, int length,
 		return 0;
 
 	IP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);
+	DTRACE_IP(send,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb->sk,
+		  void_ip_t * : ipinfo_t *, ipv6_hdr(skb),
+		  struct net_device * : ifinfo_t *, skb->dev,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, ipv6_hdr(skb));
 	err = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, net, sk, skb,
 		      NULL, rt->dst.dev, dst_output);
 	if (err > 0)
@@ -687,7 +695,15 @@ static int rawv6_send_hdrinc(struct sock *sk, struct msghdr *msg, int length,
 error_fault:
 	err = -EFAULT;
 	kfree_skb(skb);
+	skb = NULL;
 error:
+	DTRACE_IP(send,
+		  struct sk_buff * : pktinfo_t *, skb,
+		  struct sock * : csinfo_t *, skb ? skb->sk : NULL,
+		  void_ip_t * : ipinfo_t *, skb ? ipv6_hdr(skb) : NULL,
+		  struct net_device * : ifinfo_t *, skb ? skb->dev : NULL,
+		  struct iphdr * : ipv4info_t *, NULL,
+		  struct ipv6hdr * : ipv6info_t *, skb ? ipv6_hdr(skb) : NULL);
 	IP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);
 	if (err == -ENOBUFS && !np->recverr)
 		err = 0;
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 237cc6187c5a..a9008b4fee6e 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -68,6 +68,7 @@
 
 #include <crypto/hash.h>
 #include <linux/scatterlist.h>
+#include <linux/sdt.h>
 
 static void	tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);
 static void	tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,
@@ -453,6 +454,20 @@ static void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,
 	sock_put(sk);
 }
 
+/* Since we want to trace send events in TCP prior to pushing the segment to
+ * IP - where the IP header is added - we need to construct an argument
+ * containing relevant IP info so that TCP probe consumers can utilize it.
+ */
+static inline void dtrace_tcp_build_ipv6hdr(struct in6_addr *saddr,
+					    struct in6_addr *daddr,
+					    struct ipv6hdr *ip6h)
+{
+	ip6h->version = 6;
+	ip6h->payload_len = 0;
+	ip6h->nexthdr = IPPROTO_TCP;
+	ip6h->saddr = *saddr;
+	ip6h->daddr = *daddr;
+}
 
 static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,
 			      struct flowi *fl,
@@ -486,6 +501,32 @@ static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,
 		opt = ireq->ipv6_opt;
 		if (!opt)
 			opt = rcu_dereference(np->opt);
+
+		if (DTRACE_TCP_ENABLED(send)) {
+			struct ipv6hdr ip6h;
+
+			dtrace_tcp_build_ipv6hdr(&ireq->ir_v6_loc_addr,
+						 &ireq->ir_v6_rmt_addr, &ip6h);
+
+			/* Do not supply tcp sk - addresses/ports are not
+			 * committed yet - instead translators will fill them
+			 * in from IP/TCP data.
+			 */
+			DTRACE_TCP_NOCHECK(send,
+					   struct sk_buff * :  pktinfo_t *,
+					   NULL,
+					   struct sock * : csinfo_t *, sk,
+					   __dtrace_tcp_void_ip_t * :
+					   ipinfo_t *, &ip6h,
+					   struct tcp_sock * : tcpsinfo_t *,
+					   NULL,
+					   struct tcphdr * : tcpinfo_t *,
+					   tcp_hdr(skb),
+					   int : tcplsinfo_t *, TCP_LISTEN,
+					   int, TCP_LISTEN,
+					   int, DTRACE_NET_PROBE_OUTBOUND);
+		}
+
 		err = ip6_xmit(sk, skb, fl6, sk->sk_mark, opt, np->tclass);
 		rcu_read_unlock();
 		err = net_xmit_eval(err);
@@ -868,6 +909,48 @@ static void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32
 	dst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);
 	if (!IS_ERR(dst)) {
 		skb_dst_set(buff, dst);
+		if (DTRACE_TCP_ENABLED(send) ||
+		    DTRACE_TCP_ENABLED(accept__refused)) {
+			struct ipv6hdr ip6h;
+
+			dtrace_tcp_build_ipv6hdr(&fl6.saddr, &fl6.daddr,
+						 &ip6h);
+
+			/* Do not supply tcp sk - addresses/ports are not
+			 * committed yet - instead translators will fill them
+			 * in from IP/TCP data.
+			 */
+			DTRACE_TCP_NOCHECK(send,
+					   struct sk_buff * :  pktinfo_t *,
+					   NULL,
+					   struct sock * : csinfo_t *, NULL,
+					   __dtrace_tcp_void_ip_t * :
+					   ipinfo_t *, &ip6h,
+					   struct tcp_sock * : tcpsinfo_t *,
+					   NULL,
+					   struct tcphdr * : tcpinfo_t *, t1,
+					   int : tcplsinfo_t *, TCP_CLOSE,
+					   int, TCP_CLOSE,
+					   int, DTRACE_NET_PROBE_OUTBOUND);
+			if (rst && th->syn && th->ack == 0)
+				DTRACE_TCP_NOCHECK(accept__refused,
+						   struct sk_buff * :
+						   pktinfo_t *, NULL,
+						   struct sock * : csinfo_t *,
+						   NULL,
+						   __dtrace_tcp_void_ip_t * :
+						   ipinfo_t *, &ip6h,
+						   struct tcp_sock * :
+						   tcpsinfo_t *, NULL,
+						   struct tcphdr * :
+						   tcpinfo_t *, t1,
+						   int : tcplsinfo_t *,
+						   TCP_CLOSE,
+						   int, TCP_CLOSE,
+						   int,
+						   DTRACE_NET_PROBE_OUTBOUND);
+		}
+
 		ip6_xmit(ctl_sk, buff, &fl6, fl6.flowi6_mark, NULL, tclass);
 		TCP_INC_STATS(net, TCP_MIB_OUTSEGS);
 		if (rst)
@@ -1404,7 +1487,7 @@ static int tcp_v6_rcv(struct sk_buff *skb)
 	const struct tcphdr *th;
 	const struct ipv6hdr *hdr;
 	bool refcounted;
-	struct sock *sk;
+	struct sock *sk = NULL;
 	int ret;
 	struct net *net = dev_net(skb->dev);
 
@@ -1439,6 +1522,15 @@ static int tcp_v6_rcv(struct sk_buff *skb)
 	if (!sk)
 		goto no_tcp_socket;
 
+	DTRACE_TCP(receive,
+		   struct sk_buff * :  pktinfo_t *, skb,
+		   struct sock * : csinfo_t *, sk,
+		   __dtrace_tcp_void_ip_t * : ipinfo_t *, hdr,
+		   struct tcp_sock * : tcpsinfo_t *, tcp_sk(sk),
+		   struct tcphdr * : tcpinfo_t *, th,
+		   int : tcplsinfo_t *, sk ? sk->sk_state : TCP_CLOSE,
+		   int, sk ? sk->sk_state : TCP_CLOSE,
+		   int, DTRACE_NET_PROBE_INBOUND);
 process:
 	if (sk->sk_state == TCP_TIME_WAIT)
 		goto do_time_wait;
@@ -1538,6 +1630,18 @@ static int tcp_v6_rcv(struct sk_buff *skb)
 	}
 
 discard_it:
+	if (DTRACE_TCP_ENABLED(receive) && skb->pkt_type == PACKET_HOST)
+		DTRACE_TCP_NOCHECK(receive,
+				   struct sk_buff * :  pktinfo_t *, skb,
+				   struct sock * : csinfo_t *, sk,
+				   __dtrace_tcp_void_ip_t * : ipinfo_t *,
+				   ipv6_hdr(skb),
+				   struct tcp_sock * : tcpsinfo_t *, tcp_sk(sk),
+				   struct tcphdr * : tcpinfo_t *, tcp_hdr(skb),
+				   int : tcplsinfo_t *,
+				   sk ? sk->sk_state : TCP_CLOSE,
+				   int, sk ? sk->sk_state : TCP_CLOSE,
+				   int, DTRACE_NET_PROBE_INBOUND);
 	kfree_skb(skb);
 	return 0;
 
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 40d7234c27b9..e986971fb85f 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -53,6 +53,7 @@
 
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/sdt.h>
 #include <trace/events/skb.h>
 #include "udp_impl.h"
 
@@ -419,6 +420,12 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 		return err;
 	}
 	if (!peeked) {
+		DTRACE_UDP(receive,
+			   struct sk_buff * :  pktinfo_t *, skb,
+			   struct sock * : csinfo_t *, sk,
+			   void_ip_t * : ipinfo_t *, ip_hdr(skb),
+			   struct udp_sock * : udpsinfo_t *, udp_sk(sk),
+			   struct udphdr * : udpinfo_t *, udp_hdr(skb));
 		if (is_udp4)
 			UDP_INC_STATS(sock_net(sk), UDP_MIB_INDATAGRAMS,
 				      is_udplite);
@@ -616,6 +623,15 @@ static int udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 
 			ret = encap_rcv(sk, skb);
 			if (ret <= 0) {
+				DTRACE_UDP(receive,
+					   struct sk_buff * :  pktinfo_t *, skb,
+					   struct sock * : csinfo_t *, sk,
+					   void_ip_t * : ipinfo_t *,
+					   ip_hdr(skb),
+					   struct udp_sock * : udpsinfo_t *,
+					   udp_sk(sk),
+					   struct udphdr * : udpinfo_t *,
+					   udp_hdr(skb));
 				__UDP_INC_STATS(sock_net(sk),
 						UDP_MIB_INDATAGRAMS,
 						is_udplite);
@@ -1071,6 +1087,13 @@ static int udp_v6_send_skb(struct sk_buff *skb, struct flowi6 *fl6)
 		uh->check = CSUM_MANGLED_0;
 
 send:
+	DTRACE_UDP(send,
+		   struct sk_buff * :  pktinfo_t *, skb,
+		   struct sock * : csinfo_t *, sk,
+		   void_ip_t * : ipinfo_t *, ip_hdr(skb),
+		   struct udp_sock * : udpsinfo_t *, udp_sk(sk),
+		   struct udphdr * : udpinfo_t *, uh);
+
 	err = ip6_send_skb(skb);
 	if (err) {
 		if (err == -ENOBUFS && !inet6_sk(sk)->recverr) {
diff --git a/scripts/.gitignore b/scripts/.gitignore
index 0442c06eefcb..1f774eecd310 100644
--- a/scripts/.gitignore
+++ b/scripts/.gitignore
@@ -13,3 +13,4 @@ asn1_compiler
 extract-cert
 sign-file
 insert-sys-cert
+kmodsdt
diff --git a/scripts/Makefile b/scripts/Makefile
index 25ab143cbe14..2a2f8b82b4ba 100644
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -7,6 +7,7 @@
 # pnmttologo:    Convert pnm files to logo files
 # conmakehash:   Create chartable
 # conmakehash:	 Create arrays for initializing the kernel console tables
+# kmodsdt:       Post-process module .o files for SDT probes
 
 HOST_EXTRACFLAGS += -I$(srctree)/tools/include
 
@@ -19,6 +20,7 @@ hostprogs-$(CONFIG_ASN1)	 += asn1_compiler
 hostprogs-$(CONFIG_MODULE_SIG)	 += sign-file
 hostprogs-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += extract-cert
 hostprogs-$(CONFIG_SYSTEM_EXTRA_CERTIFICATE) += insert-sys-cert
+hostprogs-$(CONFIG_DTRACE)	 += kmodsdt
 
 HOSTCFLAGS_sortextable.o = -I$(srctree)/tools/include
 HOSTCFLAGS_asn1_compiler.o = -I$(srctree)/include
@@ -27,6 +29,21 @@ HOSTLOADLIBES_extract-cert = -lcrypto
 
 always		:= $(hostprogs-y) $(hostprogs-m)
 
+kallsyms-objs   := kallsyms.o
+
+ifeq ($(CONFIG_KALLMODSYMS),y)
+kallsyms-objs   += eu_simple.o
+
+HOSTCFLAGS_eu_simple.o := -I$(srctree)/scripts
+HOSTCFLAGS_kallsyms.o := $(shell pkg-config --cflags glib-2.0) -I$(srctree)/scripts
+HOSTLOADLIBES_kallsyms := $(shell pkg-config --libs glib-2.0) -ldw
+endif
+
+ifeq ($(CONFIG_DTRACE),y)
+HOSTCFLAGS_kmodsdt.o := -I$(srctree)/include/generated
+HOSTLOADLIBES_kmodsdt := -lelf
+endif
+
 # The following hostprogs-y programs are only build on demand
 hostprogs-y += unifdef
 
@@ -37,6 +54,7 @@ build_unifdef: $(obj)/unifdef
 
 subdir-$(CONFIG_MODVERSIONS) += genksyms
 subdir-y                     += mod
+subdir-$(CONFIG_CTF)         += dwarf2ctf
 subdir-$(CONFIG_SECURITY_SELINUX) += selinux
 subdir-$(CONFIG_DTC)         += dtc
 subdir-$(CONFIG_GDB_SCRIPTS) += gdb
diff --git a/scripts/Makefile.modpost b/scripts/Makefile.modpost
index 991db7d6e4df..9012bedc1f6d 100644
--- a/scripts/Makefile.modpost
+++ b/scripts/Makefile.modpost
@@ -14,8 +14,11 @@
 # 2) modpost is then used to
 # 3)  create one <module>.mod.c file pr. module
 # 4)  create one Module.symvers file with CRC for all exported symbols
-# 5) compile all <module>.mod.c files
-# 6) final link of the module to a <module.ko> file
+# 5) compute SDT offsets, generate SDT stubs, and compile all .mod.c files
+# 6) for external modules, generate CTF for the module (there is an extra,
+#    externally-invoked target that does this for the entire kernel but does
+#    not invoke the rst of the module-building process)
+# 7) final link of the module to a <module.ko> file
 
 # Step 3 is used to place certain information in the module's ELF
 # section, including information such as:
@@ -33,6 +36,10 @@
 # Step 4 is solely used to allow module versioning in external modules,
 # where the CRC of each module is retrieved from the Module.symvers file.
 
+# We need secondary expansion for 'module-ctfs-modular-prereq', below.
+
+.SECONDEXPANSION:
+
 # KBUILD_MODPOST_WARN can be set to avoid error out in case of undefined
 # symbols in the final module linking stage
 # KBUILD_MODPOST_NOFINAL can be set to skip the final link of modules.
@@ -100,37 +107,186 @@ vmlinux.o: FORCE
 # Declare generated files as targets for modpost
 $(modules:.ko=.mod.c): __modpost ;
 
-
-# Step 5), compile all *.mod.c files
+# Step 5), compile all *.mod.c files (includes the generation of SDT data
+# and SDT stubs)
 
 # modname is set to make c_flags define KBUILD_MODNAME
 modname = $(notdir $(@:.mod.o=))
 
 quiet_cmd_cc_o_c = CC      $@
       cmd_cc_o_c = $(CC) $(c_flags) $(KBUILD_CFLAGS_MODULE) $(CFLAGS_MODULE) \
-		   -c -o $@ $<
+		   -I$(dir $@) -c -o $@ $<
+
+quiet_cmd_as_o_S = AS      $@
+      cmd_as_o_S = $(CC) $(a_flags) -c -o $@ $<
+
+ifdef CONFIG_DTRACE
+
+sdtgen = $(srctree)/scripts/dtrace_sdt.sh
+
+quiet_cmd_sdtinfo = SDTINF  $@
+      cmd_sdtinfo = $(sdtgen) sdtinfo $@ $< kmod
+
+quiet_cmd_sdtstub = SDTSTB  $@
+      cmd_sdtstub = $(sdtgen) sdtstub $@ $<
+
+# We depend on the .mod.c file to ensure that modpost runs before sdtinfo.
+$(modules:.ko=.sdtinfo.c): %.sdtinfo.c: %.o %.mod.c
+	$(call cmd,sdtinfo)
+
+# We depend on the sdtinfo file because info generation rewrites the .o,
+# while sdtstubs reads it.
+$(modules:.ko=.sdtstub.S) : %.sdtstub.S: %.o %.sdtinfo.c
+	$(call cmd,sdtstub)
+
+$(modules:.ko=.mod.o): %.mod.o: %.mod.c %.sdtinfo.c FORCE
+	$(call if_changed_dep,cc_o_c)
+
+$(modules:.ko=.sdtstub.o): %.sdtstub.o: %.sdtstub.S
+	$(call if_changed,as_o_S)
+
+module-sdt-modular-prereq = %.sdtstub.o
+sdtinfo-prereq = $(modules:.ko=.sdtinfo.c)
+
+else
 
 $(modules:.ko=.mod.o): %.mod.o: %.mod.c FORCE
 	$(call if_changed_dep,cc_o_c)
 
+module-sdt-modular-prereq =
+sdtinfo-prereq =
+
+endif
+
 targets += $(modules:.ko=.mod.o)
 
-ARCH_POSTLINK := $(wildcard $(srctree)/arch/$(SRCARCH)/Makefile.postlink)
+# Step 6), generate CTF for the entire kernel (in a separate $(CTF_FILENAME)),
+# or for the module alone if this is a build of an external module.
+
+# These are overridden below for standalone modules only.
+module-ctfs-modular-prereq =
+module-ctfs-modular =
+module-ctf-flags =
+cmd_touch_ctf =
+ctf-dir = ///.nonexistent
+cmd-touch-ctf = @:
+
+ifdef CONFIG_CTF
 
-# Step 6), final link of the modules with optional arch pass after final link
+# This is quite tricky.  If called for non-external-modules, dwarf2ctf needs to
+# be told about all the built-in objects as well as all the external modules --
+# but Makefile.modpost only knows about the latter.  So the toplevel makefile
+# emits the names of the built-in objects into a temporary file, which is
+# then catted and its contents used as prerequisites by this rule.
+#
+# We write the names of the object files to be scanned for CTF content into a
+# file, then use that, to avoid hitting command-line length limits.
+
+ifeq ($(KBUILD_EXTMOD),)
+ctf-dir-mk :=
+quiet_cmd_ctf = CTFA
+      cmd_ctf = scripts/dwarf2ctf/dwarf2ctf $(CTF_FILENAME) $(srctree) objects.builtin modules_thick.builtin $(srctree)/scripts/dwarf2ctf/member.blacklist $(ctf-filelist)
+ctf-builtins := $(CTF_DEBUGDIR)/vmlinux
+ ctf-modules := $(shell find $(CTF_DEBUGDIR) \( -name '*.ko' -o -name '*.ko.debug' \) -print)
+ctf-filelist := .ctf.filelist
+ctf-stamp :=
+
+else
+ctf-dir := $(KBUILD_EXTMOD)/.ctf
+ctf-dir-mk := $(ctf-dir)
+quiet_cmd_ctf = CTF
+      cmd_ctf = scripts/dwarf2ctf/dwarf2ctf $(ctf-dir) -e $(ctf-filelist)
+override ctf-builtins :=
+ctf-modules := $(modules:.ko=.o)
+ctf-filelist := $(ctf-dir)/$(notdir $(M)-extmod).ctf.filelist
+ctf-stamp = $(ctf-dir)/$(notdir $(M)-extmod).stamp
+
+# All the modules' CTF depends on the stamp file.
+
+all-module-ctfs = $(addprefix $(ctf-dir)/,$(notdir $(modules:.ko=.mod.ctf)))
+$(all-module-ctfs): $(ctf-stamp)
+
+endif
+
+$(ctf-filelist): $(ctf-builtins) $(ctf-modules) | $(sdtinfo-prereq)
+	@rm -f $(ctf-filelist);
+	@if [[ -n "$(ctf-dir-mk)" ]]; then \
+		mkdir -p "$(ctf-dir-mk)"; \
+	fi
+	@for obj in $^; do \
+		if [[ `file $$obj` =~ ' ELF ' ]]; then \
+			echo "$$obj" >> $(ctf-filelist); \
+		else \
+			ar t $$obj >> $(ctf-filelist); \
+		fi; \
+	done
+
+ifeq ($(KBUILD_EXTMOD),)
+# The CTF depends on the output CTF file list, and that depends
+# on the .ko files for the modules.
+$(CTF_FILENAME): $(ctf-filelist)
+	$(call if_changed,ctf)
+else
+
+# The CTF depends on the output CTF file list, and that depends
+# on the .o files for the modules, and on the sdtinfo files, if any
+# (for the same reason that the sdtstub does).
+$(ctf-stamp): $(ctf-filelist)
+	$(call if_changed,ctf)
+	@shopt -s nullglob; \
+	for name in $(ctf-dir)/*.ctf.new; do \
+		$(srctree)/scripts/move-if-change $$name $${name%.new}; \
+	done; \
+	touch $(ctf-stamp)
+
+# Expands to the names of the CTF files to be incorporated into this module.
+# The former is used in prerequisite lists, thanks to secondary expansion.
+
+module-ctfs-modular-prereq = $$(addprefix $(ctf-dir)/,$$(notdir $$*.mod.ctf))
+module-ctfs-modular = $(addprefix $(ctf-dir)/,$(notdir $*.mod.ctf))
+
+# Expands to the name of a CTF file, given a target of a module name given to
+# one of the link rules below.
+
+ctf-module-name = $(addprefix $(ctf-dir)/,$(notdir $(basename $@)).mod.ctf)
+
+# Expands to a series of objcopy --add-section arguments to add all
+# necessary CTF files to a module, with appropriate section names.
+# We also take advantage of the opportunity to strip the guaranteed-
+# useless debugging information out of ctf.ko at the same time.
+
+module-ctf-flags = $(if $(filter ctf.ko,$(notdir $@)), \
+		   --strip-debug \
+		   --add-section .ctf=$(ctf-module-name))
+
+# We have to put content in our dummy no-CTF files because --add-section
+# in binutils 2.20 silently fails if asked to add an empty file as a section.
+
+cmd_touch_ctf = @for name in $(filter $(ctf-dir)/%,$(module-ctfs-modular)); do \
+		    test -f $$name || dd if=/dev/zero of=$$name bs=1 count=1 2>/dev/null; \
+		done
+
+endif		# KBUILD_EXTMOD
+
+endif		# !CONFIG_CTF
+
+# Step 7), final link of the modules with optional arch pass after final link
+ARCH_POSTLINK := $(wildcard $(srctree)/arch/$(SRCARCH)/Makefile.postlink)
 quiet_cmd_ld_ko_o = LD [M]  $@
-      cmd_ld_ko_o =                                                     \
+      cmd_ld_ko_o =                     				\
 	$(LD) -r $(LDFLAGS)                                             \
-                 $(KBUILD_LDFLAGS_MODULE) $(LDFLAGS_MODULE)             \
-                 -o $@ $(filter-out FORCE,$^) ;                         \
-	$(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)
-
-$(modules): %.ko :%.o %.mod.o FORCE
+                 $(KBUILD_LDFLAGS_MODULE) $(LDFLAGS_MODULE) 		\
+                 $(LDFLAGS_$(modname)) -o $@.tmp            		\
+                 $(patsubst $(ctf-dir)/%,,$(filter-out FORCE,$^)) &&	\
+        $(OBJCOPY) $(module-ctf-flags) $@.tmp $@ && rm -f $@.tmp ;	\
+       	$(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)
+
+$(modules): %.ko : %.o %.mod.o $(module-sdt-modular-prereq) $(module-ctfs-modular-prereq) FORCE
+	$(call cmd_touch_ctf)
 	+$(call if_changed,ld_ko_o)
 
 targets += $(modules)
 
-
 # Add FORCE to the prequisites of a target to force it to be always rebuilt.
 # ---------------------------------------------------------------------------
 
diff --git a/scripts/dtrace_sdt.sh b/scripts/dtrace_sdt.sh
new file mode 100755
index 000000000000..2c4b47bcaf6c
--- /dev/null
+++ b/scripts/dtrace_sdt.sh
@@ -0,0 +1,458 @@
+#!/bin/sh
+
+LANG=C
+
+#
+# Syntax:
+#	dtrace_sdt.sh sdtstub <S-file> <o-file>+
+#		This is used to generate DTrace SDT probe stubs based on one
+#		or more object file(s).  The stubs are written to <S-file>.
+#	dtrace_sdt.sh sdtinfo <c-file> <o-file> kmod
+#		This is used to generate DTrace SDT probe definitions for a
+#		kmod .o file.  The output is written to <c-file>.
+#	dtrace_sdt.sh sdtinfo <S-file> <l-file>
+#		This is used to generate DTrace SDT probe definitions for a
+#		linked kernel image file <l-file>.  The output is written to
+#		<S-file>.
+#
+
+opr="$1"
+shift
+if [ -z "$opr" ]; then
+    echo "ERROR: Missing operation" > /dev/stderr
+    exit 1
+fi
+
+tfn="$1"
+shift
+if [ -z "$tfn" ]; then
+    echo "ERROR: Missing target filename" > /dev/stderr
+    exit 1
+fi
+
+ofn="$1"
+tok="$2"
+
+if [ -z "$ofn" ]; then
+    echo "ERROR: Missing object file argument" > /dev/stderr
+    exit 1
+fi
+
+if [ "$opr" = "sdtstub" ]; then
+    ${NM} -u $* | grep -E '__dtrace_(probe|isenabled)_' | sort | uniq | \
+	${AWK} -v arch=${ARCH} \
+	       '{
+		    printf("\t.globl %s\n\t.type %s,@function\n%s:\n",
+			   $2, $2, $2);
+		    count++;
+		}
+
+		END {
+		    if (count) {
+			if (arch == "x86" || arch == "x86_64") {
+			    print "\txor %eax,%eax";
+			    print "\tretq";
+			} else if (arch == "sparc" || arch == "sparc64") {
+			    print "\tretl";
+			    print "\tnop";
+			} else if (arch == "arm" || arch == "arm64") {
+			    print "\tmov w0, #0x0";
+			    print "\tret";
+			}
+		    }
+		}' > $tfn
+    exit $?
+fi
+
+if [ "$opr" != "sdtinfo" ]; then
+    echo "ERROR: Invalid operation, should be sdtstub or sdtinfo" > /dev/stderr
+    exit 1
+fi
+
+if [ "$tok" = "kmod" ]; then
+    # Pre-process the object file to handle any local functions that contain
+    # SDT probes.
+    scripts/kmodsdt ${ofn}
+
+    # Output all function symbols in the symbol table of the object file.
+    # Subsequently, output all relocation records for DTrace SDT probes.  The
+    # probes are identified by either a __dtrace_probe_ or __dtrace_isenabled_
+    # prefix.
+    #
+    # We sort the output primarily based on the section, using the value (or
+    # offset) as secondary sort criterion  The overall result is that the
+    # output will be structured as a list of functions, and for any functions
+    # that contain DTrace SDT probes, relocation records will follow the
+    # function entry they are associated with.
+    #
+    # Relocations are reported by objdump per section, with a header line
+    # documenting the specific section being reported:
+    #	RELOCATION RECORDS FOR [<section>]:
+    # This is followed by a column header line, and a list of relocations.
+    # The relocations are listed with 3 tokens per line:
+    #	<offset> <type> <value>
+    #
+    # Three different types can show up in the output (all with 4 tokens):
+    #    <section> <offset> F <value>
+    #        Function within a section at a specific offset.
+    #        (See STAGE 3a below.)
+    #    <section> <offset> G <value>
+    #        Global alias for a local function within a section at a specific
+    #        offset.  A function can only have one alias, and there cannot be
+    #        an alias without its respective function.
+    #        (See STAGE 3a below.)
+    #    <section> <offset> R <value>
+    #        Relocation within a section at a specific offset.
+    #        (See STAGE 3b below.)
+    #
+    ${OBJDUMP} -tr ${ofn} | \
+    awk '/^RELOC/ {
+	     sect = substr($4, 2, length($4) - 3);
+	     next;
+	 }
+
+	 sect && /__dtrace_probe_/ {
+	     $3 = substr($3, 16);
+	     sub(/[\-+].*$/, "", $3);
+	     print sect " " $1 " R " $3;
+	     next;
+	 }
+
+	 sect && /__dtrace_isenabled_/ {
+	     $3 = substr($3, 20);
+	     sub(/[\-+].*$/, "", $3);
+	     print sect " " $1 " R ?" $3;
+	     next;
+	 }
+
+	 /file format/ {
+	     next;
+	 }
+
+	 / F / {
+	     if ($6 == ".hidden")
+		 print $4 " " $1 " G " $7;
+	     else
+		 print $4 " " $1 " F " $6;
+	 }' | \
+    sort -k1,2 | \
+    awk -v arch=${ARCH} \
+	'function subl(v0, v1, v0h, v0l, v1h, v1l, d, tmp) {
+             tmp = $0;
+             if (length(v0) > 8) {
+                 d = length(v0);
+                 v0h = strtonum("0x"substr(v0, 1, d - 8));
+                 v0l = strtonum("0x"substr(v0, d - 8 + 1));
+                 d = length(v1);
+                 v1h = strtonum("0x"substr(v1, 1, d - 8));
+                 v1l = strtonum("0x"substr(v1, d - 8 + 1));
+
+                 if (v0l >= v1l) {
+                     if (v0h >= v1h) {
+                         d = sprintf("%08x%08x", v0h - v1h, v0l - v1l);
+                     } else {
+                         printf "#error Invalid addresses: %x vs %x", v0, v1 \
+                                                                >"/dev/stderr";
+                         errc++;
+                     }
+                 } else {
+                     printf "#error Invalid addresses: %x vs %x", v0, v1 \
+                                                                >"/dev/stderr";
+                     errc++;
+                 }
+             } else {
+                 v0 = strtonum("0x"v0);
+                 v1 = strtonum("0x"v1);
+                 d = sprintf("%016x", v0 - v1);
+             }
+             $0 = tmp;
+
+             return d;
+         }
+
+	 BEGIN {
+	     print "#include <linux/sdt.h>";
+
+	     probec = 0;
+	 }
+
+	 #
+	 # Process a symbol table definition for a function in the object
+	 # file ($ofn).  As we pass through the symbol table, we record the
+	 # function name, address, and symbol table index or alias.  This
+	 # information is needed for any potential DTrace probes that may exist
+	 # in the function.  They will be listed in relocation records
+	 # subsequent to this function definition (and are processed in the
+	 # next action block).
+	 #
+	 NF == 4 && $3 == "F" {
+	     fname = $4;
+	     sub(/\..*$/, "", fname);
+	     alias = $4;
+	     faddr = $2;
+	     sub(/^0+/, "", faddr);
+
+	     next;
+	 }
+
+	 NF == 4 && $3 == "G" {
+	     alias = $4;
+
+	     next;
+	 }
+
+	 #
+	 # Process a relocation record associated with the preceding function.
+	 #
+	 # For kernel modules:
+	 # Convert the section offset into an offset in the function where the
+	 # DTrace probe is located, i.e. an offset from the start of the
+	 # function.  This will be resolved in an absolute address at runtime
+	 # when the module is loaded.
+	 #
+	 NF == 4 && $3 == "R" {
+	     sub(/^0+/, "", $2);
+
+	     addr = subl($2, faddr);
+
+	     if (arch == "x86" || arch == "x86_64")
+		 addr = subl(addr, 1);
+
+	     protom[alias] = 1;
+	     probev[probec] = sprintf("  {\042%s\042,  \042%s\042 /* %s */, 0 /* sdt_args string */, (uintptr_t)%s+0x%s },", $4, fname, $1, alias, addr);
+	     probec++;
+
+	     next;
+	 }
+
+	 END {
+	     if (probec > 0) {
+		 for (alias in protom)
+		     printf "extern void %s(void);\n", alias;
+		 print "\nstatic sdt_probedesc_t\t_sdt_probes[] = {";
+		 for (i = 0; i < probec; i++)
+		     print probev[i];
+		 print "};\n";
+	     } else
+		print "#define _sdt_probes\tNULL";
+
+	     print "#define _sdt_probec\t" probec;
+
+	     exit(errc == 0 ? 0 : 1);
+	 }' > $tfn
+else
+    # For a linked kernel (with relocation data), the scope of DTrace SDT
+    # probe discovery can be limited to just the .text section.
+    #
+    # First the section record is retrieved in order to determine the base
+    # address for symbols in the .text section.
+    #
+    # Subsequently, all function symbols that are located in the .text sectio
+    # are read from the symbol table of the linked kernel object.  Each symbol
+    # is reported in the output stream with its address, a token identifying it
+    # as a function (or alias), and its name.
+    #
+    # Finally, each relocation record from the .text section that relates to
+    # SDT probes are written to the output stream with its address, a token
+    # identifying it as a relocation, and its name.  Probes are identified in
+    # the relocation records as symbols with either a __dtrace_probe_ or
+    # __dtrace_isenabled_ prefix.
+    #
+    # We sort the output based on the address, which guarantees that the output
+    # will be a list of functions, and each function record will be followed 
+    # immediately by any DTrace SDT probe records that are used in that
+    # function.
+    #
+    # Three different record types can show up in the output (3 tokens each):
+    #    <address> F <name>
+    #        Named function at a specific address.
+    #    <address> G <name>
+    #        Global alias for a local function at a specific offset.  A
+    #        function can only have one alias, and there cannot be an alias
+    #        without its respective function.
+    #    <address> R <value>
+    #        Relocation within a section at a specific address
+    #
+    ${OBJDUMP} -htrj .text ${ofn} | \
+    awk 'function subl(v0, v1, v0h, v0l, v1h, v1l, d, tmp) {
+             tmp = $0;
+             if (length(v0) > 8) {
+                 d = length(v0);
+                 v0h = strtonum("0x"substr(v0, 1, d - 8));
+                 v0l = strtonum("0x"substr(v0, d - 8 + 1));
+                 d = length(v1);
+                 v1h = strtonum("0x"substr(v1, 1, d - 8));
+                 v1l = strtonum("0x"substr(v1, d - 8 + 1));
+
+                 if (v0l >= v1l) {
+                     if (v0h >= v1h) {
+                         d = sprintf("%08x%08x", v0h - v1h, v0l - v1l);
+                     } else {
+                         printf "#error Invalid addresses h: %x vs %x", v0, v1 \
+                                                                >"/dev/stderr";
+                         errc++;
+                     }
+                 } else {
+                     printf "#error Invalid addresses l: %x vs %x", v0, v1 \
+                                                                >"/dev/stderr";
+                     errc++;
+                 }
+             } else {
+                 v0 = strtonum("0x"v0);
+                 v1 = strtonum("0x"v1);
+                 d = sprintf("%016x", v0 - v1);
+             }
+             $0 = tmp;
+
+             return d;
+         }
+
+	 NF == 7 && $2 == ".text" {
+	     base = $4;
+	     next;
+	 }
+
+	 /^RELOC/ {
+	     in_reloc = $4 == "[.text]:";
+	     next;
+	 }
+
+	 in_reloc && /__dtrace_probe_/ {
+	     $3 = substr($3, 16);
+	     sub(/[\-+].*$/, "", $3);
+	     print $1 " R " $3;
+	     next;
+	 }
+
+	 in_reloc && /__dtrace_isenabled_/ {
+	     $3 = substr($3, 20);
+	     sub(/[\-+].*$/, "", $3);
+	     print $1 " R ?" $3;
+	     next;
+	 }
+
+	 / F / {
+	     if ($6 == ".hidden")
+		 print subl($1, base) " G " $7;
+	     else
+		 print subl($1, base) " F " $6;
+	 }' | \
+    sort -k1,2 | \
+    awk -v arch=${ARCH} \
+	'function subl(v0, v1, v0h, v0l, v1h, v1l, d, tmp) {
+             tmp = $0;
+             if (length(v0) > 8) {
+                 d = length(v0);
+                 v0h = strtonum("0x"substr(v0, 1, d - 8));
+                 v0l = strtonum("0x"substr(v0, d - 8 + 1));
+                 d = length(v1);
+                 v1h = strtonum("0x"substr(v1, 1, d - 8));
+                 v1l = strtonum("0x"substr(v1, d - 8 + 1));
+
+                 if (v0l >= v1l) {
+                     if (v0h >= v1h) {
+                         d = sprintf("%08x%08x", v0h - v1h, v0l - v1l);
+                     } else {
+                         printf "#error Invalid addresses: %x vs %x", v0, v1 \
+                                                                >"/dev/stderr";
+                         errc++;
+                     }
+                 } else {
+                     printf "#error Invalid addresses: %x vs %x", v0, v1 \
+                                                                >"/dev/stderr";
+                     errc++;
+                 }
+             } else {
+                 v0 = strtonum("0x"v0);
+                 v1 = strtonum("0x"v1);
+                 d = sprintf("%016x", v0 - v1);
+             }
+             $0 = tmp;
+
+             return d;
+         }
+
+	 BEGIN {
+	     print "#include <asm/types.h>";
+	     print "#if BITS_PER_LONG == 64";
+	     print "# define PTR .quad";
+	     print "# define ALGN .align 8";
+	     print "#else";
+	     print "# define PTR .long";
+	     print "# define ALGN .align 4";
+	     print "#endif";
+
+	     print "\t.section .rodata, \042a\042";
+	     print "";
+
+	     print ".globl dtrace_sdt_probes";
+	     print "\tALGN";
+	     print "dtrace_sdt_probes:";
+
+	     probec = 0;
+	 }
+
+	 #
+	 # Process a symbol table definition for a function in the .text
+	 # section of the kernel image.  As we pass through the symbol table,
+	 # we record the function name and address.
+	 #
+	 NF == 3 && $2 == "F" {
+	     fname = $3;
+	     sub(/\..*$/, "", fname);
+	     alias = $3;
+
+	     if ($1 != prev)
+		 funcc++;
+	     prev = $1;
+
+	     next;
+	 }
+
+	 NF == 3 && $2 == "G" {
+	     alias = $3;
+
+	     next;
+	 }
+
+	 #
+	 # Process a relocation record associated with the preceding function.
+	 #
+	 # Since all addresses are already resolved earlier, we can simply
+	 # generate the SDT probe information record.
+	 #
+	 NF == 3 && $2 == "R" {
+	     sub(/^0+/, "", $1);
+
+	     addr = $1;
+
+	     if (arch == "x86" || arch == "x86_64")
+		 addr = subl(addr, 1);
+
+	     printf "\tPTR\t_stext + 0x%s\n", addr;
+	     printf "\tPTR\t%d\n", length($3);
+	     printf "\tPTR\t%d\n", length(fname);
+	     printf "\t.asciz\t\042%s\042\n", $3;
+	     printf "\t.asciz\t\042%s\042\n", fname;
+	     print "\tALGN";
+
+	     probec++;
+
+	     next;
+	 }
+
+	 END {
+	     print "";
+	     print ".globl dtrace_sdt_nprobes";
+	     print ".globl dtrace_fbt_nfuncs";
+	     print "\tALGN";
+	     print "dtrace_sdt_nprobes:";
+	     printf "\tPTR\t%d\n", probec;
+	     print "dtrace_fbt_nfuncs:";
+	     printf "\tPTR\t%d\n", funcc;
+
+	     exit(errc == 0 ? 0 : 1);
+	 }' > $tfn
+fi
+
+exit $?
diff --git a/scripts/dwarf2ctf/.gitignore b/scripts/dwarf2ctf/.gitignore
new file mode 100644
index 000000000000..e37b47cf3028
--- /dev/null
+++ b/scripts/dwarf2ctf/.gitignore
@@ -0,0 +1 @@
+dwarf2ctf
diff --git a/scripts/dwarf2ctf/Makefile b/scripts/dwarf2ctf/Makefile
new file mode 100644
index 000000000000..800dc20e1a15
--- /dev/null
+++ b/scripts/dwarf2ctf/Makefile
@@ -0,0 +1,11 @@
+ifdef CONFIG_CTF
+hostprogs-y	:= dwarf2ctf
+always		:= $(hostprogs-y)
+
+dwarf2ctf-objs  := dwarf2ctf.o eu_simple.o
+
+HOSTCFLAGS_eu_simple.o := -I$(srctree)/scripts
+HOSTCFLAGS_dwarf2ctf.o := $(shell pkg-config --cflags glib-2.0) -I$(srctree)/scripts
+
+HOSTLOADLIBES_dwarf2ctf := -ldtrace-ctf -lelf -ldw $(shell pkg-config --libs glib-2.0) -lz
+endif
diff --git a/scripts/dwarf2ctf/dwarf2ctf.c b/scripts/dwarf2ctf/dwarf2ctf.c
new file mode 100644
index 000000000000..3d99bfd96850
--- /dev/null
+++ b/scripts/dwarf2ctf/dwarf2ctf.c
@@ -0,0 +1,4643 @@
+/*
+ * dwarf2ctf.c: Read in DWARF[23] debugging information from some set of ELF
+ * files, and generate CTF in correspondingly-named files, or in a single
+ * representation meant for mmapping.
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE 1
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <libelf.h>
+#include <dwarf.h>
+#include <elfutils/libdwfl.h>
+#include <elfutils/libdw.h>
+#include <elfutils/version.h>
+#include <sys/ctf_api.h>
+#include <glib.h>
+
+#include <eu_simple.h>
+
+#ifndef PATH_MAX
+#define PATH_MAX 1024
+#endif
+
+#ifndef __GNUC__
+#define __attribute__((foo))
+#endif
+
+#define __unused__ __attribute__((__unused__))
+
+/*
+ * If non-NULL, tracing is on.
+ */
+static const char *trace;
+
+/*
+ * Trace something.
+ */
+#ifdef DEBUG
+#define dw_ctf_trace(format, ...) if (trace) fprintf(stderr, (format), ## __VA_ARGS__)
+#else
+#define dw_ctf_trace(format, ...)
+#endif
+
+/*
+ * Run dwarf2ctf over a single object file or set thereof.
+ *
+ * output_dir is the directory into which the CTF goes, if 'standalone', or the
+ * CTF archive file name otherwise.
+ */
+static void run(char *output, int standalone);
+
+/*
+ * Whether we are deduplicating.  We do not deduplicate if run over external
+ * modules.
+ */
+static int deduplicating;
+
+/*
+ * A fully descriptive CTF type ID: both file and type ID in one place.
+ */
+typedef struct ctf_full_id {
+	ctf_file_t *ctf_file;
+	ctf_id_t ctf_id;
+#ifdef DEBUG
+	char module_name[PATH_MAX];
+	char file_name[PATH_MAX];
+#endif
+} ctf_full_id_t;
+
+/*
+ * A mapping from the type ID of a DIE (see type_id()) to ctf_full_id_t's
+ * describing the type with that ID.
+ *
+ * This is used to look up types regardless of which CTF file they may reside
+ * in.  Not the same as a DWARF4 type signature because we must encode scope
+ * information which DWARF4 can encode in its DIE refs.
+ *
+ * (TODO: store a hash of the ID rather than the ID itself, to save memory.
+ * Makes debugging slightly harder though.)
+ */
+static GHashTable *id_to_type;
+
+/*
+ * A mapping from the type ID of a DIE to the name of the module (and thus CTF
+ * table) incorporating that type.  (Modules in this context, and throughout
+ * dwarf2ctf, are DTrace modules: a name without suffix or path.)
+ *
+ * This is used to merge types identical across modules (e.g. those in global
+ * header files).
+ */
+static GHashTable *id_to_module;
+
+/*
+ * Module-specific state.  The module named 'vmlinux' is that corresponding to
+ * the types in always-built-in translation units; the module named 'shared_ctf'
+ * (not appearing in this mapping) is that corresponding to types shared between
+ * more than one module (even between two currently-built-in modules: we do not
+ * distinguish at this level between built-in modules and non-built-in modules.)
+ */
+static GHashTable *per_module;
+
+/*
+ * The data structure that per_module maps module names to.
+ */
+typedef struct per_module {
+	/*
+	 * The CTF file containing the types in this module.
+	 */
+	ctf_file_t *ctf_file;
+
+	/*
+	 * A hash from a "CTF-form" structure name (in the form 's/u NAME') to
+	 * a ctf_memb_count_t (see below).
+	 */
+	GHashTable *member_counts;
+} per_module_t;
+
+/*
+ * A count associating a type ID relating to a structure or union with a count
+ * of members in that structure.
+ */
+typedef struct ctf_memb_count {
+	ctf_id_t ctf_id;
+	size_t count;
+} ctf_memb_count_t;
+
+/*
+ * Get a ctf_file out of the per_module hash for a given module.
+ */
+static ctf_file_t *lookup_ctf_file(const char *module_name);
+
+/*
+ * The names of the object files to run over.  Except in -e mode, this comes
+ * straight from the module filelist passed in.
+ */
+static char **object_names;
+static size_t object_names_cnt;
+
+/*
+ * Populate the object_names list from the module filelist.
+ */
+static void init_object_names(const char *object_names_file);
+
+/*
+ * Populate and object_to_module from the objects.builtin and modules.builtin
+ * file.
+ */
+static void init_builtin(const char *builtin_objects_file,
+			 const char *builtin_module_file);
+
+/*
+ * The member blacklist bans fields with specific names in specifically named
+ * structures, declared in specific source files, from being emitted.  The
+ * mapping is from absolute source file name:structure.member to NULL (this is
+ * safe because type names cannot contain a colon, and structure names cannot
+ * contain a period).
+ */
+static GHashTable *member_blacklist;
+
+/*
+ * Populate the member blacklist from the member_blacklist file.
+ */
+static void init_member_blacklist(const char *member_blacklist_file,
+				  const char *srcdir);
+
+/*
+ * Return 1 if a given DWARF DIE, which must be a DW_TAG_member, appears in the
+ * member blacklist.
+ */
+static int member_blacklisted(Dwarf_Die *die, Dwarf_Die *parent_die);
+
+/*
+ * The variable blacklist, like the others, is an automatically-maintained
+ * blacklist giving variables in specific modules which should not be emitted.
+ * (These are variables whose names are ambiguous within a module, and may
+ * appear multiple times in /proc/kallmodsyms, identical but for address and
+ * thus indistinguishable.)
+ *
+ * The mapping is from module`variable to NULL (safe because variable names
+ * cannot begin with a backtick, and even if they could DTrace's notation could
+ * not reference such variables).
+ */
+static GHashTable *variable_blacklist;
+
+/*
+ * A mapping from object file name to the name of the module that translation
+ * unit is part of.
+ *
+ * Actual, real, on-disk .ko modules do not appear here, because the translation
+ * is trivial for them.
+ */
+static GHashTable *object_to_module;
+
+/*
+ * Initialize a CTF type table, and possibly fill it with those special types
+ * that appear in CTF but not in DWARF (such as 'void').  (This filling happens
+ * only for the type table named "shared_ctf", unless deduplication is turned
+ * off.)
+ *
+ * If this is a local type table, and deduplication is active, make the global
+ * type table its parent.
+ */
+static void init_ctf_table(const char *module_name);
+
+/*
+ * A few useful singleton CTF type IDs in the global type table: a void pointer
+ * and a function pointer.  Constructed by init_ctf_table().
+ */
+static ctf_id_t ctf_void_type;
+static ctf_id_t ctf_funcptr_type;
+
+/*
+ * Override the presence and value of FORM_u/sdata attributes on DWARF DIEs,
+ * either adding to it, or replacing it.
+ *
+ * (Used so that a caller of construct_ctf_id() that wants a type to be created
+ * can override aspects of that type.)
+ */
+typedef struct die_override {
+	int tag;
+	int attribute;
+	enum { DIE_OVERRIDE_REPLACE, DIE_OVERRIDE_ADD } op;
+	Dwarf_Sword value;
+} die_override_t;
+
+/*
+ * Compute the type ID of a DWARF DIE (with possibly-overridden attributes) and
+ * return it in a new dynamically- allocated string.
+ *
+ * Optionally, call a callback with the computed ID once we know it (this is a
+ * recursive process, so the callback can be called multiple times as the ID
+ * is built up).  The overrides are not passed down to the callback.
+ *
+ * An ID of NULL indicates that this DIE has no ID and need not be considered.
+ */
+static char *type_id(Dwarf_Die *die, die_override_t *overrides,
+		     void (*fun)(Dwarf_Die *die,
+				 const char *id,
+				 void *data),
+		     void *data) __attribute__((__warn_unused_result__));
+
+/*
+ * If non-NULL, a prefix attached to all type ID types.  This is used to ensure
+ * that types in blacklisted modules do not appear anywhere else.
+ */
+static char *blacklist_type_prefix;
+
+/*
+ * Process a file, calling the dwarf_process function for every type found
+ * therein (even types in functions).  Optionally call tu_init() at the start of
+ * each translation unit, and tu_done() at the end.
+ */
+static void process_file(const char *file_name,
+			 void (*dwarf_process)(const char *module_name,
+					       const char *file_name,
+					       Dwarf_Die *die,
+					       Dwarf_Die *parent_die,
+					       void *data),
+			 void (*tu_init)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void (*tu_done)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void *data);
+
+/*
+ * process_file() helper, walking over subroutines recursively and picking up
+ * types therein.
+ */
+static void process_tu_func(const char *module_name,
+			    const char *file_name,
+			    Dwarf_Die *parent_die,
+			    Dwarf_Die *die,
+			    void (*dwarf_process)(const char *module_name,
+						  const char *file_name,
+						  Dwarf_Die *die,
+						  Dwarf_Die *parent_die,
+						  void *data),
+			    void *data);
+
+/*
+ * Records the type ID of interesting types, the files they are contained in,
+ * and their DWARF offset, so they can be found rapidly.
+ *
+ * Used to avoid rescanning files that can contain no duplicates.
+ */
+struct detect_duplicates_id_file
+{
+	char *file_name;
+	char *id;
+	Dwarf_Off dieoff;
+};
+
+/*
+ * The structure used as the data argument for detect_duplicates() and
+ * detect_duplicates_alias_fixup().
+ *
+ * structs_seen tracks the IDs of structures marked as duplicates within a given
+ * translation unit, in order that recursion terminates if two such structures
+ * have pointers to each other.
+ *
+ * vars_seen tracks variables seen in this module, mapping from unadorned name
+ * to a non-NULL pointer (for static, non-'external') or NULL (for non-static or
+ * 'extern').  If a static variable coexists with any other variable with the
+ * same name, static or not, the variable is blacklisted.  (Non-static
+ * coexistence is fine, because they are just different references to the same
+ * variable).  Note that management of this variable is a little annoying
+ * because it varies by module, not by TU, so we can't use tu_init/tu_done to
+ * manage its lifetime.
+ *
+ * named_structs tracks type IDs and contained modules for every type that may
+ * contain undetected duplicates and thus may require rescanning.
+ *
+ * dwfl and dwfl_file_name identify the opened DWARF file (if any) during the
+ * second duplicates detection pass.
+ *
+ * repeat_detection is set by each phase if it considers that another round of
+ * alias fixup detection is needed.
+ */
+struct detect_duplicates_state {
+	const char *file_name;
+	const char *module_name;
+	GHashTable *structs_seen;
+	GList *named_structs;
+	GHashTable *vars_seen;
+	char *dwfl_file_name;
+	Dwarf *dwarf;
+	Dwfl *dwfl;
+	int repeat_detection;
+};
+
+/*
+ * Scan and identify duplicates across the entire set of object files.
+ */
+static void scan_duplicates(void);
+
+/*
+ * Recursively detect duplicate types and types referenced by them, and
+ * determine which CTF file they should be located in, and request a
+ * detect_duplicates_alias_fixup() pass if any structures are shared.
+ * Determine the mapping from translation unit name to module name.
+ */
+static void detect_duplicates(const char *module_name, const char *file_name,
+			      Dwarf_Die *die, Dwarf_Die *parent_die,
+			      void *data);
+
+/*
+ * Note in the detect_duplicates_id_file list that we will rescan a DIE in
+ * a later duplicate detection pass.
+ *
+ * A type_id() callback.
+ */
+static void detect_duplicates_will_rescan(Dwarf_Die *die, const char *id,
+					  void *data);
+
+/*
+ * Note the variable referenced by this DIE in vars_seen: blacklist it if an
+ * entry for this variable already exists in vars_seen and this instance is
+ * static, or if a static entry already exists in vars_seen, whether this
+ * instance is static or not.
+ */
+static void detect_duplicates_blacklist_var_dups(Dwarf_Die *die,
+						 struct detect_duplicates_state *state);
+
+/*
+ * Detect duplicates and mark seen types for a given type, via a type_id()
+ * callback: used to detect dependent types (particularly those at child-DIE
+ * level) as duplicates.
+ */
+static void detect_duplicates_typeid(Dwarf_Die *die, const char *id,
+				     void *data);
+
+/*
+ * Mark any aggregates contained within a particular type DIE as seen.  This is
+ * needed since even nameless aggregates contained within other aggregates can
+ * be used as the type of members of the outer aggregate (though they cannot
+ * possibly be found in a module different from that of their containing
+ * aggregate, any more than a structure member can).
+ */
+static void mark_seen_contained(Dwarf_Die *die, const char *module_name);
+
+/*
+ * Determine if some type (whose ultimate base type is an non-opaque structure,
+ * alias, or enum) has an opaque equivalent which is shared, and mark it and
+ * all its bases as shared too if so.
+ *
+ * A list_filter() filter function.
+ */
+static int detect_duplicates_alias_fixup(void *id_file_data, void *data);
+
+/*
+ * Mark a basic type shared by name and intern it in all relevant hashes.  (Used
+ * for marking basic types we don't have a DIE for.)
+ */
+static void mark_shared_by_name(ctf_file_t *ctf, ctf_id_t ctf_id,
+				const char *name);
+
+/*
+ * Determine if a type is a named struct, union, or enum.
+ *
+ * A type_id() callback.
+ */
+static void is_named_struct_union_enum(Dwarf_Die *die, const char *unused,
+				       void *data);
+
+/*
+ * Set up state for detect_duplicates().  A tu_init() callback.
+ */
+static void detect_duplicates_tu_init(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *tu_die,
+				      void *data);
+
+/*
+ * Free state for detect_duplicates().  A tu_done() callback.
+ */
+static void detect_duplicates_tu_done(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *tu_die,
+				      void *data);
+
+/*
+ * Free DWARF state for detect_duplicates().
+ */
+static void detect_duplicates_dwarf_free(struct detect_duplicates_state *state);
+
+/*
+ * Determine if a type is duplicated and needs sharing.
+ */
+enum needs_sharing { NS_NOT_SHARED, NS_NO_MARKING, NS_NEEDS_SHARING };
+static enum needs_sharing type_needs_sharing(const char *module_name, const char *id);
+
+/*
+ * Mark a type (optionally, with an already-known ID) as duplicated and located
+ * in the shared CTF table.
+ *
+ * A type_id() callback (though also called directly).
+ */
+static void mark_shared(Dwarf_Die *die, const char *id,
+			void *data);
+
+/*
+ * Construct CTF out of each type.
+ */
+static void construct_ctf(const char *module_name, const char *file_name,
+			  Dwarf_Die *die,
+			  Dwarf_Die *parent_die,
+			  void *unused __unused__);
+
+/*
+ * Write out the CTF files from the per_module->ctf_file into files in the
+ * output directory (if standalone), or into the output file (otherwise).
+ */
+static void write_types(char *output, int standalone);
+
+/*
+ * Construct CTF out of each type and return that type's ID and file.
+ */
+static ctf_full_id_t *construct_ctf_id(const char *module_name,
+				       const char *file_name,
+				       Dwarf_Die *die,
+				       Dwarf_Die *parent_die,
+				       die_override_t *overrides);
+
+/*
+ * Things to do after a CTF recursion step.
+ */
+enum skip_type { SKIP_CONTINUE = 0, SKIP_SKIP, SKIP_ABORT };
+
+/*
+ * Recursive over a given DWARF DIE and its children andconstruct CTF out of it.
+ *
+ * Most parameters are shared with the ctf_assembly_fun: see the comment below.
+ */
+static ctf_id_t die_to_ctf(const char *module_name, const char *file_name,
+			   Dwarf_Die *die, Dwarf_Die *parent_die,
+			   ctf_file_t *ctf, ctf_id_t parent_ctf_id,
+			   die_override_t *overrides, int top_level_type,
+			   int backwards, enum skip_type *skip, int *replace,
+			   const char *id);
+
+/*
+ * Return the next DIE, if that DIE needs to be emitted before this one.
+ */
+static Dwarf_Die *die_emit_next_backwards(Dwarf_Die *next, Dwarf_Die *die,
+					  die_override_t *overrides);
+
+/*
+ * Look up a type through its reference: return its ctf_id_t, or
+ * recursively construct it if need be.
+ *
+ * Must be called on a DIE with a type attribute.
+ */
+static ctf_id_t lookup_ctf_type(const char *module_name, const char *file_name,
+				Dwarf_Die *die, ctf_file_t *ctf,
+				const char *locerrstr);
+
+/*
+ * Assemble a given DIE and its children into CTF in some fashion, returning the
+ * ID of the top-level piece of generated CTF (only relevant for aggregates).
+ *
+ * The parent_ctf_id is the ID of the CTF entity that was or is being generated
+ * from the enclosing DWARF DIE, or 0 if population succeeded but did not yield
+ * a type ID (e.g. for variable assembly), or -1 on error.  The parent_die is
+ * the parent of the current DWARF DIE, and is always populated (even if just
+ * with the CU's DIE).  The parent_ctf_id is always in the same CTF file as the
+ * ctf_id, just as the parent DWARF DIE is always in the same DWARF CU: this is
+ * lexical scope, not dynamic, so referenced types themselves located at the top
+ * level have the CU as their parent.
+ *
+ * Returning an error value (see below) indicates that no CTF was generated from
+ * this DWARF DIE.
+ *
+ * Setting skip to SKIP_ABORT indicates that the translation of this entity
+ * failed, and the entire top-level type of which it is a part should be
+ * skipped.  Setting it to SKIP_SKIP indicates that this entity does not need to
+ * be translated (perhaps because it already exists), so recursion into
+ * sub-entities can be skipped, but translation of the containing type should
+ * continue.  Setting it to SKIP_CONTINUE indicates no error.
+ *
+ * Setting 'replace' to 1 in a child DIE indicates that this type should
+ * entirely *replace* its parent's type (generally because it has wrapped it up
+ * in something).  This replacemenu takes immediate effect for later children of
+ * the same DIE.
+ *
+ * die_to_ctf() calls these functions repeatedly for every child of the
+ * requested DIE: the CTF ID eventually returned is whatever ID is returned by
+ * the last such function, and parent_ctf_id is repeatedly replaced with the ID
+ * returned by the last assembly function.  Thus, assembly functions that
+ * augment an already-present ctf_id should return parent_ctf_id: assembly
+ * functions that wrap it in a new ctf_id referring to the parent_ctf_id should
+ * return the new ID.  (Assembly functions should never entirely disregard the
+ * parent_ctf_id.)
+ */
+typedef ctf_id_t (*ctf_assembly_fun)(const char *module_name,
+				     const char *file_name,
+				     Dwarf_Die *die,
+				     Dwarf_Die *parent_die,
+				     ctf_file_t *ctf,
+				     ctf_id_t parent_ctf_id,
+				     const char *locerrstr,
+				     die_override_t *overrides,
+				     int top_level_type,
+				     enum skip_type *skip,
+				     int *replace);
+
+#define ASSEMBLY_FUN(name)					     \
+	static ctf_id_t assemble_ctf_##name(const char *module_name,  \
+					    const char *file_name,    \
+					    Dwarf_Die *die,	      \
+					    Dwarf_Die *parent_die,    \
+					    ctf_file_t *ctf,	      \
+					    ctf_id_t parent_ctf_id,   \
+					    const char *locerrstr,    \
+					    die_override_t *overrides, \
+					    int top_level_type,	      \
+					    enum skip_type *skip,     \
+					    int *replace)
+
+/*
+ * Defined assembly functions.
+ */
+ASSEMBLY_FUN(base);
+ASSEMBLY_FUN(array);
+ASSEMBLY_FUN(array_dimension);
+ASSEMBLY_FUN(cvr_qual);
+ASSEMBLY_FUN(enumeration);
+ASSEMBLY_FUN(enumerator);
+ASSEMBLY_FUN(pointer);
+ASSEMBLY_FUN(struct_union);
+ASSEMBLY_FUN(su_member);
+ASSEMBLY_FUN(typedef);
+ASSEMBLY_FUN(variable);
+
+/*
+ * An assembly filter is an optional function called with the DIE and parent DIE
+ * of a top-level type alone, before calling down into the process_file()
+ * processing function: it can be used to rapidly determine that this DIE is not
+ * worth processing.  (It should return 0 in this case, and nonzero otherwise.)
+ */
+typedef int (*ctf_assembly_filter_fun)(Dwarf_Die *die,
+				       Dwarf_Die *parent_die);
+
+/*
+ * A CTF assembly filter function which excludes all types not at the global
+ * scope (i.e. whose immediate parent is not a CU DIE) and which does not have a
+ * structure or union as its ultimate dependent type.  (All structures and
+ * unions and everything dependent on them must be recorded, even inside
+ * functions, because GCC may emit references to the opaque variants of those
+ * types from file scope.)
+ */
+static int filter_ctf_file_scope(Dwarf_Die *die,
+				 Dwarf_Die *parent_die);
+
+/*
+ * A CTF assembly filter function which excludes all names not at the global
+ * scope, all static symbols, and all names whose names are unlikely to be
+ * interesting.  (DTrace userspace contains a similar list, but the two lists
+ * need not be in sync.)
+ */
+static int filter_ctf_uninteresting(Dwarf_Die *die,
+				    Dwarf_Die *parent_die);
+
+/*
+ * Error return values from CTF assembly functions.  These differ only in that
+ * die_to_ctf() reports the ctf_errmsg() if CTF_NO_ERROR_REPORTED is returned,
+ * but says nothing in the CTF_ERROR_REPORTED case.
+ */
+#define CTF_NO_ERROR_REPORTED CTF_ERR
+#define CTF_ERROR_REPORTED (-2L)
+
+/*
+ * The total number of type errors encountered.
+ */
+static long num_errors;
+
+/*
+ * A mapping from DW_TAG_* to functions which assemble this DW_TAG_* and
+ * possibly its children into the passed CTF.  This table is not used
+ * directly, but rather assembled into a lookup table.
+ */
+static struct assembly_tab_t
+{
+	int tag;
+	ctf_assembly_filter_fun filter;
+	ctf_assembly_fun fun;
+} assembly_tab_init[] =
+{{ DW_TAG_base_type, filter_ctf_file_scope, assemble_ctf_base },
+ { DW_TAG_array_type, filter_ctf_file_scope, assemble_ctf_array },
+ { DW_TAG_subrange_type, NULL, assemble_ctf_array_dimension },
+ { DW_TAG_const_type, filter_ctf_file_scope, assemble_ctf_cvr_qual },
+ { DW_TAG_restrict_type, filter_ctf_file_scope, assemble_ctf_cvr_qual },
+ { DW_TAG_enumeration_type, NULL, assemble_ctf_enumeration },
+ { DW_TAG_enumerator, NULL, assemble_ctf_enumerator },
+ { DW_TAG_pointer_type, filter_ctf_file_scope, assemble_ctf_pointer },
+ { DW_TAG_structure_type, NULL, assemble_ctf_struct_union },
+ { DW_TAG_union_type, NULL, assemble_ctf_struct_union },
+ { DW_TAG_member, NULL, assemble_ctf_su_member },
+ { DW_TAG_typedef, NULL, assemble_ctf_typedef },
+ { DW_TAG_variable, filter_ctf_uninteresting, assemble_ctf_variable },
+ { DW_TAG_volatile_type, filter_ctf_file_scope, assemble_ctf_cvr_qual },
+ { 0, NULL }};
+
+/*
+ * The CTF assembly and filter lookup tables, in constructed form.
+ */
+static ctf_assembly_fun *assembly_tab;
+static ctf_assembly_filter_fun *assembly_filter_tab;
+static size_t assembly_len;
+
+/*
+ * Populate the assembly_tab and assembly_filter_tab from the assembly_tab_init.
+ */
+static void init_assembly_tab(void);
+
+/*
+ * A mapping from sizeof() to CTF type encoding.
+ */
+struct type_encoding_tab {
+	size_t size;
+	int ctf_encoding;
+};
+
+/*
+ * Given a type encoding table, and a size, return the CTF encoding for that
+ * type, or 0 if none.
+ */
+static int find_ctf_encoding(struct type_encoding_tab *type_tab, size_t size);
+
+/*
+ * Count the number of members of a DWARF aggregate.
+ */
+static long count_dwarf_members(Dwarf_Die *die);
+
+/*
+ * Given a DIE that may contain a type attribute, look up the target of that
+ * attribute and return it, or NULL if none.
+ */
+static Dwarf_Die *private_dwarf_type(Dwarf_Die *die, Dwarf_Die *target_die);
+
+/*
+ * Check for existence of an attribute in a DIE, chasing through
+ * DW_AT_specification if need be.
+ */
+static inline int private_dwarf_hasattr(Dwarf_Die *die,
+					unsigned int search_name);
+
+/*
+ * Return a DIE attribute, chasing through DW_AT_specification if need be.
+ */
+static inline Dwarf_Attribute *private_dwarf_attr(Dwarf_Die *die,
+						  unsigned int search_name,
+						  Dwarf_Attribute *result);
+
+/*
+ * Given a DIE that contains a udata attribute, look up that attribute and
+ * return its value (optionally overridden or modified by the die_overrides).
+ */
+static inline Dwarf_Word private_dwarf_udata(Dwarf_Die *die, int attribute,
+					     die_override_t *overrides);
+
+/*
+ * Find an override in an override list.
+ */
+static die_override_t *private_find_override(Dwarf_Die *die,
+					     int attribute,
+					     die_override_t *overrides);
+
+/*
+ * Determine the dimensions of an array subrange, or 0 if variable.
+ */
+static Dwarf_Word private_subrange_dimensions(Dwarf_Die *die);
+
+/*
+ * A string appender working on dynamic strings.
+ */
+static char *str_append(char *s, const char *append)
+	__attribute__((__warn_unused_result__));
+
+/*
+ * A vararg string appender.
+ */
+static char *str_appendn(char *s, ...)
+	__attribute__((__warn_unused_result__, sentinel));
+
+/*
+ * An error-checking strdup().
+ */
+static char *xstrdup(const char *s) __attribute__((__nonnull__,
+						   __warn_unused_result__,
+						   __malloc__));
+
+/*
+ * Filter a GList, calling a predicate on it and removing all elements for which
+ * the predicate returns true, calling the free_func on them if set.
+ */
+typedef int (*filter_pred_fun) (void *element, void *data);
+static GList *list_filter(GList *list, filter_pred_fun fun, GDestroyNotify free_func,
+			  void *data);
+
+/*
+ * Figure out the (pathless, suffixless) module name for a given module file (.o
+ * or .ko), and return it in a new dynamically allocated string.
+ *
+ * Takes the object_to_module mapping into account.
+ */
+static char *fn_to_module(const char *file_name);
+
+/*
+ * Determine, and cache, absolute filenames.
+ */
+static const char *abs_file_name(const char *file_name);
+
+/*
+ * Determine absolute filenames relative to some other directory: do not cache
+ * them.  It is the caller's responsibility to free them.
+ */
+static char *rel_abs_file_name(const char *file_name, const char *relative_to);
+
+/*
+ * Free a per_module's contents.
+ */
+static void private_per_module_free(void *per_module);
+
+/*
+ * Free a detect_duplicates_id_file's contents.
+ */
+static void free_duplicates_id_file(void *id_file);
+
+/* Initialization.  */
+
+int main(int argc, char *argv[])
+{
+	char *output;
+
+	if (getuid() == 0 || geteuid() == 0) {
+		fprintf(stderr, "dwarf2ctf: root run: doing nothing.\n");
+		fprintf(stderr, "CTF type information will not be produced.\n");
+		fprintf(stderr, "Please run as a non-root user.\n");
+		/*
+		 * Refuse to produce any output.
+		 */
+		exit(0);
+	}
+
+	trace = getenv("DWARF2CTF_TRACE");
+
+	if ((argc != 4 && argc != 7) ||
+	    (argc == 4 && strcmp(argv[2], "-e") != 0)) {
+		fprintf(stderr, "Syntax: dwarf2ctf output-file srcdir "
+			"objects.builtin modules.builtin member.blacklist\n");
+		fprintf(stderr, "                  filelist\n");
+		fprintf(stderr, "    or dwarf2ctf output-dir -e filelist\n"
+			"for external module use\n");
+		exit(1);
+	}
+
+	output = argv[1];
+
+	elf_version(EV_CURRENT);
+
+	if (elf_errno()) {
+		fprintf(stderr, "Version synchronization fault: %s\n",
+			elf_errmsg(elf_errno()));
+		exit(1);
+	}
+
+	init_assembly_tab();
+	object_to_module = g_hash_table_new_full(g_str_hash, g_str_equal,
+						 free, free);
+
+	/*
+	 * When not building an external module, we run over all the arguments
+	 * at once, deduplicating them.  In external-module mode, we act as if
+	 * independently invoked with every argument.
+	 */
+	if (strcmp(argv[2], "-e") != 0) {
+		const char *srcdir;
+		char *builtin_objects_file;
+		char *builtin_module_file;
+		char *member_blacklist_file;
+
+                srcdir = argv[2];
+		builtin_objects_file = argv[3];
+		builtin_module_file = argv[4];
+		member_blacklist_file = argv[5];
+		deduplicating = 1;
+
+		init_builtin(builtin_objects_file, builtin_module_file);
+		init_member_blacklist(member_blacklist_file, srcdir);
+		init_object_names(argv[6]);
+
+		run(output, 0);
+	} else {
+		char *single_object_name;
+		char **all_object_names;
+		size_t all_object_names_cnt;
+		size_t i;
+
+		deduplicating = 0;
+		init_object_names(argv[3]);
+
+		/*
+		 * Repeatedly populate object_names with one object name, and
+		 * call run() with that.
+		 */
+		all_object_names = object_names;
+		all_object_names_cnt = object_names_cnt;
+		object_names = &single_object_name;
+		object_names_cnt = 1;
+
+		for (i = 0; i < all_object_names_cnt; i++) {
+			single_object_name = all_object_names[i];
+
+			run(output, 1);
+		}
+	}
+
+	g_hash_table_destroy(object_to_module);
+
+	if (num_errors > 0)
+		fprintf(stderr, "%li CTF construction errors.\n", num_errors);
+
+	return 0;
+}
+
+/*
+ * Run dwarf2ctf over a single object file or set thereof.
+ *
+ * output is the directory into which the CTF goes, if 'standalone', or the
+ * CTF archive file name otherwise.
+ */
+static void run(char *output, int standalone)
+{
+	size_t i;
+
+	/*
+	 * Create all the hashes, assemble the translation unit->module list for
+	 * builtin modules, and create the shared CTF file if deduplicating.
+	 */
+
+	id_to_type = g_hash_table_new_full(g_str_hash, g_str_equal,
+					   free, free);
+	id_to_module = g_hash_table_new_full(g_str_hash, g_str_equal,
+					     free, free);
+	per_module = g_hash_table_new_full(g_str_hash, g_str_equal, free,
+					   private_per_module_free);
+	variable_blacklist = g_hash_table_new_full(g_str_hash, g_str_equal,
+						   free, free);
+
+	dw_ctf_trace("Initializing...\n");
+
+	if (deduplicating)
+		init_ctf_table("shared_ctf");
+
+	scan_duplicates();
+
+	/*
+	 * Now construct CTF out of the types.
+	 */
+	dw_ctf_trace("CTF construction.\n");
+	for (i = 0; i < object_names_cnt; i++)
+		process_file(object_names[i], construct_ctf, NULL, NULL, NULL);
+
+	/*
+	 * Finally, emit the types into their .ctf files, and generate the
+	 * necessary linker scripts.
+	 */
+	dw_ctf_trace("Writeout.\n");
+	write_types(output, standalone);
+
+	g_hash_table_destroy(id_to_type);
+	g_hash_table_destroy(id_to_module);
+	g_hash_table_destroy(per_module);
+}
+
+
+/*
+ * Populate the object_names list from the module filelist.
+ */
+static void init_object_names(const char *object_names_file)
+{
+	FILE *f;
+	char *line = NULL;
+	size_t line_size = 0;
+
+	if ((f = fopen(object_names_file, "r")) == NULL) {
+		fprintf(stderr, "Cannot open object names file %s: "
+			"%s\n", object_names_file, strerror(errno));
+		exit(1);
+	}
+
+	/*
+	 * This needs no massaging other than linefeed removal, just reading and
+	 * stashing.
+	 */
+
+	while (getline(&line, &line_size, f) >= 0) {
+		size_t len = strlen(line);
+
+		if (len == 0)
+			continue;
+
+		if (line[len-1] == '\n')
+			line[len-1] = '\0';
+
+		object_names = realloc(object_names,
+				       ++object_names_cnt *
+				       sizeof (char *));
+
+		if (object_names == NULL) {
+			fprintf(stderr, "Out of memory reading %s",
+				object_names_file);
+			exit(1);
+		}
+
+		object_names[object_names_cnt-1] = xstrdup(line);
+	}
+	free(line);
+
+	if (ferror(f)) {
+		fprintf(stderr, "Error reading from %s: %s\n",
+			object_names_file, strerror(errno));
+		exit(1);
+	}
+
+	fclose(f);
+}
+
+/*
+ * Populate object_to_module from the objects.builtin and modules.builtin file.
+ */
+static void init_builtin(const char *builtin_objects_file,
+			 const char *builtin_module_file)
+{
+	FILE *f;
+	struct modules_thick_iter *i;
+	char *line = NULL;
+	size_t line_size = 0;
+	char *module_name = NULL;
+	char **module_paths;
+
+	/*
+	 * Iterate over all modules in modules_thick.builtin and add each to
+	 * object_to_module.
+	 */
+	i = modules_thick_iter_new(builtin_module_file);
+	if (i == NULL) {
+		fprintf(stderr, "Cannot iterate over builtin module file.\n");
+		exit(1);
+	}
+
+	while ((module_paths = modules_thick_iter_next(i, &module_name)) != NULL) {
+		size_t j;
+
+		for (j = 0; module_paths[j] != NULL; j++) {
+			dw_ctf_trace("noting built-in module mapping %s -> %s\n",
+				     module_name, module_paths[j]);
+			g_hash_table_replace(object_to_module,
+					     module_paths[j],
+					     xstrdup(module_name));
+		}
+		free(module_paths);
+	}
+	free(module_name);
+	modules_thick_iter_free(i);
+
+	if ((f = fopen(builtin_objects_file, "r")) == NULL) {
+		fprintf(stderr, "Cannot open builtin objects file %s: "
+			"%s\n", builtin_objects_file, strerror(errno));
+		exit(1);
+	}
+
+	/*
+	 * Those entries in builtin.objects that are not already known are
+	 * unconditionally-built-in object files.
+	 */
+	while (getline(&line, &line_size, f) >= 0) {
+		size_t len = strlen(line);
+
+		if (len == 0)
+			continue;
+
+		if (line[len-1] == '\n')
+			line[len-1] = '\0';
+
+		if (!g_hash_table_lookup(object_to_module, line))
+			g_hash_table_replace(object_to_module, xstrdup(line),
+					     xstrdup("vmlinux"));
+	}
+
+	if (ferror(f)) {
+		fprintf(stderr, "Error reading from %s: %s\n",
+			builtin_objects_file, strerror(errno));
+		exit(1);
+	}
+
+	free(line);
+	fclose(f);
+}
+
+/*
+ * Translate the assembly lookup table into the assembly_tab and
+ * assembly_filter_tab arrays.
+ */
+static void init_assembly_tab(void)
+{
+	struct assembly_tab_t *walk;
+
+	for (walk = assembly_tab_init; walk->fun != NULL; walk++) {
+		if (assembly_len < walk->tag)
+			assembly_len = walk->tag;
+	}
+
+	if ((assembly_tab = calloc(sizeof (ctf_assembly_fun *),
+				   assembly_len + 1)) == NULL) {
+		fprintf(stderr, "Out of memory allocating assembly table\n");
+		exit(1);
+	}
+
+	if ((assembly_filter_tab = calloc(sizeof (ctf_assembly_filter_fun *),
+				   assembly_len + 1)) == NULL) {
+		fprintf(stderr, "Out of memory allocating assembly filter "
+			"table\n");
+		exit(1);
+	}
+
+	for (walk = assembly_tab_init; walk->fun != NULL; walk++) {
+		assembly_tab[walk->tag] = walk->fun;
+		assembly_filter_tab[walk->tag] = walk->filter;
+	}
+}
+
+/*
+ * Populate the member blacklist from the member_blacklist file.
+ */
+static void init_member_blacklist(const char *member_blacklist_file,
+				  const char *srcdir)
+{
+	FILE *f;
+	char *line = NULL;
+	size_t line_num = 0;
+	size_t line_size = 0;
+
+	/*
+	 * Not having a member blacklist is not an error.
+	 */
+	if ((f = fopen(member_blacklist_file, "r")) == NULL)
+		return;
+
+	member_blacklist = g_hash_table_new(g_str_hash, g_str_equal);
+
+	while (getline(&line, &line_size, f) >= 0) {
+		size_t len = strlen(line);
+		char *last_colon;
+		const char *last_dot;
+		char *absolutized;
+
+		line_num++;
+
+		if (len == 0)
+			continue;
+
+		if (line[len-1] == '\n')
+			line[len-1] = '\0';
+
+		last_colon = strrchr(line, ':');
+		last_dot = strrchr(last_colon + 1, '.');
+		if (!last_colon || !last_dot) {
+			fprintf(stderr, "Syntax error on line %li of %s.\n"
+			    "Syntax: filename:structure.member.\n",
+			    line_num, member_blacklist_file);
+			continue;
+		}
+
+		*last_colon = '\0';
+		last_colon++;
+		absolutized = rel_abs_file_name(line, srcdir);
+		absolutized = str_appendn(absolutized, ":", last_colon, NULL);
+
+		g_hash_table_insert(member_blacklist, absolutized, NULL);
+	}
+	free(line);
+
+	if (ferror(f)) {
+		fprintf(stderr, "Error reading from %s: %s\n",
+			member_blacklist_file, strerror(errno));
+		exit(1);
+	}
+
+	fclose(f);
+}
+
+/*
+ * Return 1 if a given DWARF DIE, which must be a DW_TAG_member, appears in the
+ * member blacklist.
+ */
+static int member_blacklisted(Dwarf_Die *die, Dwarf_Die *parent_die)
+{
+	const char *fname = dwarf_decl_file(die);
+	char *id;
+	int blacklisted = 0;
+
+	/*
+	 * If there is no member blacklist, do nothing.
+	 */
+	if (!member_blacklist)
+		return 0;
+
+	/*
+	 * Unnamed structure and union members cannot be blacklisted, for now.
+	 */
+	if ((dwarf_diename(parent_die) == NULL) ||
+	    (dwarf_diename(die) == NULL))
+		return 0;
+
+	/*
+	 * If the compiler is now emitting members without decl_files, we
+	 * want to know.
+	 */
+	if (fname == NULL) {
+		static int warned = 0;
+
+		if (!warned)
+			fprintf(stderr, "Warning: member_blacklisted() called with "
+			    "NULL decl_file, which should never happen.\n");
+
+		warned = 1;
+		return 0;
+	}
+
+	fname = abs_file_name(fname);
+
+	if (dwarf_tag(die) != DW_TAG_member ||
+	    (dwarf_tag(parent_die) != DW_TAG_structure_type &&
+		dwarf_tag(parent_die) != DW_TAG_union_type)) {
+		fprintf(stderr, "Warning: member_blacklisted() called on "
+		    "%s:%s.%s at offset %li, which is not a structure member.",
+		    fname, dwarf_diename(parent_die), dwarf_diename(die),
+		    dwarf_dieoffset(die));
+		return 0;
+	}
+
+	id = xstrdup(fname);
+	id = str_appendn(id, ":", dwarf_diename(parent_die), ".",
+	    dwarf_diename(die), NULL);
+
+	if (g_hash_table_lookup_extended(member_blacklist, id, NULL, NULL))
+		blacklisted = 1;
+
+	free(id);
+	return blacklisted;
+}
+
+/*
+ * Initialize a CTF type table, and possibly fill it with those special types
+ * that appear in CTF but not in DWARF (such as 'void').  (This filling happens
+ * only for the type table named "shared_ctf", unless deduplication is turned
+ * off.)
+ *
+ * If this is a local type table, and deduplication is active, make the global
+ * type table its parent.
+ */
+static void init_ctf_table(const char *module_name)
+{
+	ctf_file_t *ctf_file;
+	per_module_t *new_per_mod;
+	int ctf_err;
+
+	if ((ctf_file = ctf_create(&ctf_err)) == NULL) {
+		fprintf(stderr, "Cannot create CTF file: %s\n",
+			strerror(ctf_err));
+		exit(1);
+	}
+	new_per_mod = malloc(sizeof(struct per_module));
+	if (new_per_mod == NULL) {
+		fprintf(stderr, "Out of memory allocating per-module CTF "
+			"info\n");
+		exit(1);
+	}
+
+	new_per_mod->ctf_file = ctf_file;
+	new_per_mod->member_counts = g_hash_table_new_full(g_str_hash,
+							   g_str_equal,
+							   free, free);
+	g_hash_table_replace(per_module, xstrdup(module_name), new_per_mod);
+
+	dw_ctf_trace("Initializing module: %s\n", module_name);
+	if ((strcmp(module_name, "shared_ctf") == 0) ||
+	    !deduplicating) {
+		ctf_encoding_t void_encoding = { CTF_INT_SIGNED, 0, 0 };
+		ctf_encoding_t int_encoding = { CTF_INT_SIGNED, 0,
+						sizeof (int) * 8 };
+		ctf_id_t int_type;
+		ctf_id_t func_type;
+		ctf_funcinfo_t func_info;
+
+		/*
+		 * Global types module, or deduplication is disabled.  Add a
+		 * type for 'void *' to point to, and a type for the return
+		 * value of pointers to functions: then add the (single,
+		 * universal) pointer-to-function value.
+		 */
+		ctf_void_type = ctf_add_integer(ctf_file, CTF_ADD_ROOT,
+						"void", &void_encoding);
+		int_type = ctf_add_integer(ctf_file, CTF_ADD_ROOT, "int",
+					   &int_encoding);
+		mark_shared_by_name(ctf_file, ctf_void_type, "void");
+		mark_shared_by_name(ctf_file, int_type, "int");
+
+		func_info.ctc_return = int_type;
+		func_info.ctc_argc = 0;
+		func_info.ctc_flags = 0;
+		func_type = ctf_add_function(ctf_file, CTF_ADD_ROOT,
+					     &func_info, NULL);
+		ctf_funcptr_type = ctf_add_pointer(ctf_file, CTF_ADD_ROOT,
+						   func_type);
+
+		if (ctf_update(ctf_file) < 0) {
+			fprintf(stderr, "Cannot initialize shared CTF "
+				"file: %s\n", ctf_errmsg(ctf_errno(ctf_file)));
+			exit(1);
+		}
+	} else {
+		/*
+		 * Local types module with deduplication enabled: point the
+		 * parent at the global CTF file, which must exist by this
+		 * point.
+		 */
+		if (ctf_import(ctf_file, lookup_ctf_file("shared_ctf")) < 0) {
+			fprintf(stderr, "Cannot set parent of CTF file for "
+				"module %s: %s\n", module_name,
+				ctf_errmsg(ctf_errno(ctf_file)));
+			exit(1);
+		}
+		ctf_parent_name_set(ctf_file, "shared_ctf");
+	}
+
+	dw_ctf_trace("Created CTF file for module %s: %p\n",
+		     module_name, ctf_file);
+
+	return;
+}
+
+/* DWARF walkers.  */
+
+/*
+ * Type ID computation.
+ *
+ * A type ID is a constant, recursively-constructed, dynamically-allocated
+ * string describing a given DWARF DIE in such a way that any DWARF file
+ * containing the same type will have the same type ID.  (It even works for
+ * variables!  Variables of the same name and referring to the same type have
+ * the same ID...)
+ *
+ * Optionally, call a callback with the computed ID once we know it (this is a
+ * recursive process, so the callback can be called multiple times as the ID is
+ * built up).
+ *
+ * An ID of NULL indicates that this DIE has no ID and need not be considered.
+ *
+ * It is probably an error for two DWARF DIEs representing top-level types to
+ * return the same ID, but for certain other DIEs (notably those representing the
+ * members of structures or unions), it is expected that they return the same
+ * ID as their type DIE.
+ *
+ * This function is the hottest hot spot in dwarf2ctf, so is somewhat
+ * aggressively optimized.
+ */
+static char *type_id(Dwarf_Die *die,
+		     die_override_t *overrides,
+		     void (*fun)(Dwarf_Die *die,
+				 const char *id,
+				 void *data),
+		     void *data)
+{
+	char *id = NULL;
+	int no_type_id = 0;
+	int decorated = 1;
+	Dwarf_Die type_die;
+
+	/*
+	 * The ID of a null pointer is NULL.
+	 */
+	if (die == NULL)
+		return NULL;
+
+	/*
+	 * The ID of a function pointer is '//fp//', as a special case,
+	 * with no location, ever.
+	 */
+	if (dwarf_tag(die) == DW_TAG_subroutine_type) {
+		id = xstrdup("//fp//");
+		if (fun)
+			fun(die, id, data);
+		return id;
+	}
+
+	/*
+	 * If we have a type DIE, generate it first, passing any overrides down.
+	 *
+	 * Otherwise, note the location of this DIE, providing scoping
+	 * information for all types based upon this one.  Location elements are
+	 * separated by //, an element impossible in a Linux path.  The
+	 * blacklist type prefix (if set) follows this (which is a name which,
+	 * while not impossible in a Linux path, is very unlikely.)
+	 *
+	 * Array dimensions get none of this: they must be contained within
+	 * another DIE, so will always have a location attached via that DIE,
+	 * and get their type chased further down (so as to arrange that they
+	 * appear inside an [].)
+	 */
+	if (dwarf_tag(die) != DW_TAG_subrange_type) {
+		if (dwarf_tag(die) != DW_TAG_base_type)
+			id = type_id(private_dwarf_type(die, &type_die),
+				     overrides, fun, data);
+
+		/*
+		 * Location information.  We use cached realpath() results, and
+		 * call str_appendn() only once, minimizing the number of
+		 * strlen()s.
+		 */
+		if (id == NULL) {
+			const char *decl_file_name = dwarf_decl_file(die);
+			int decl_line_num;
+			const char *fname = "";
+			char line_num[21] = "";	 /* bigger than 2^64's digit count */
+
+			no_type_id = 1;
+			if (decl_file_name != NULL) {
+				fname = abs_file_name(decl_file_name);
+			}
+
+			if (dwarf_decl_line(die, &decl_line_num) >= 0) {
+				snprintf(line_num, sizeof (line_num), "%i",
+					 decl_line_num);
+			}
+			if (!blacklist_type_prefix)
+				id = str_appendn(id, fname, "//", line_num, "//", NULL);
+			else
+				id = str_appendn(id, blacklist_type_prefix, "//", fname,
+						 "//", line_num, "//", NULL);
+		}
+	}
+
+	/*
+	 * We implement this via a switch statement, rather than a jump table
+	 * like the assembly_tab, simply because most cases are so small that
+	 * splitting them into separate functions would do more harm than good
+	 * to readability.
+	 *
+	 * WARNING: The spaces in the strings in this switch statement are not
+	 * just for appearance: types with spaces in their names are impossible
+	 * in C.  If you move those spaces around for appearance's sake, please
+	 * adjust mark_shared_by_name and detect_duplicates_alias_fixup(), which
+	 * construct the IDs of basic types, structures, and unions by hand.
+	 */
+	switch (dwarf_tag(die)) {
+	case DW_TAG_base_type: {
+		Dwarf_Word bit_size = -1;
+		Dwarf_Word type_size = -1;
+		Dwarf_Word bit_offset = -1;
+
+		/*
+		 * CTF encodes the size and bitwise-offset of bit-fields in the
+		 * base type, so it must be stored once for each size, even if
+		 * it only appears once for all sizes in the DWARF.
+		 */
+		if (private_dwarf_hasattr(die, DW_AT_bit_size) ||
+		    private_find_override(die, DW_AT_bit_size,
+					  overrides))
+			bit_size = private_dwarf_udata(die, DW_AT_bit_size,
+						       overrides);
+		if (private_dwarf_hasattr(die, DW_AT_bit_offset) ||
+		    private_find_override(die, DW_AT_bit_offset,
+					  overrides))
+			bit_offset = private_dwarf_udata(die, DW_AT_bit_offset,
+							 overrides);
+
+		/*
+		 * Bitfields that occupy their entire containing type are not
+		 * bitfields, but just redundant DWARF.  GCC emits these now and
+		 * again, but the dups would trip CTF consistency checks, so
+		 * must be skipped.
+		 */
+		if (bit_size > -1) {
+			/*
+			 * This "may be omitted" in DWARF, but GCC doesn't:
+			 * bitfields always get both.  (See
+			 * gcc/dwarf2out.c:gen_field_die().)
+			 */
+			type_size = private_dwarf_udata(die, DW_AT_bit_size,
+							overrides);
+		}
+		if (bit_size != type_size) {
+			char bitsize[22];	/* > 2^64's digit count */
+			char bitoffset[22];	/* > 2^64's digit count */
+
+			snprintf(bitsize, sizeof (bitsize), "%li", bit_size);
+			id = str_appendn(id, dwarf_diename(die), ":", bitsize,
+					 NULL);
+			if (bit_offset != -1) {
+				snprintf(bitoffset, sizeof (bitoffset), "%li",
+					bit_offset);
+				id = str_appendn(id, ":", bitoffset, NULL);
+			}
+			id = str_append(id, " ");
+		} else {
+			/*
+			 * Ordinary (non-bit-field) base type.
+			 */
+			id = str_appendn(id, dwarf_diename(die), " ", NULL);
+		}
+		break;
+	}
+	case DW_TAG_enumeration_type:
+		id = str_appendn(id, "enum ", dwarf_diename(die), " ", NULL);
+		break;
+	case DW_TAG_structure_type:
+	case DW_TAG_union_type: {
+		/*
+		 * Incorporate the sizeof() the structure, if statically known
+		 * (the offset of the last member in the DWARF) so that most
+		 * structures which are redefined on the fly by preprocessor
+		 * defines are disambiguated despite being defined in the same
+		 * place.
+		 *
+		 * Only do this if this is a non-opaque structure/union
+		 * definition: opaque definitions cannot have a size, but if
+		 * they do by some mischance get one, notating it will mess up
+		 * the several other places that manually construct opaque
+		 * structure identifiers (and cannot incorporate a size, since
+		 * they don't know it).
+		 */
+		const char *sou;
+
+		if (strncmp(id, "////", 4) != 0 &&
+		    private_dwarf_hasattr(die, DW_AT_byte_size)) {
+			Dwarf_Attribute size_attr;
+			long long size;
+			char byte_size[24];
+
+			private_dwarf_attr(die, DW_AT_byte_size, &size_attr);
+
+			switch (dwarf_whatform(&size_attr)) {
+			case DW_FORM_data1:
+			case DW_FORM_data2:
+			case DW_FORM_data4:
+			case DW_FORM_data8:
+			case DW_FORM_udata:
+			case DW_FORM_sdata:
+
+				if (dwarf_whatform(&size_attr) ==
+				    DW_FORM_sdata) {
+					Dwarf_Sword dw_size;
+
+					dwarf_formsdata(&size_attr, &dw_size);
+					size = dw_size;
+				} else {
+					Dwarf_Word dw_size;
+
+					dwarf_formudata(&size_attr, &dw_size);
+					size = dw_size;
+				}
+
+				sprintf(byte_size, "%lli", size);
+				id = str_appendn(id, byte_size, "//", NULL);
+			}
+		}
+
+		if (dwarf_tag(die) == DW_TAG_union_type)
+			sou = "union ";
+		else
+			sou = "struct ";
+
+		id = str_appendn(id, sou, dwarf_diename(die), " ", NULL);
+		break;
+	}
+	case DW_TAG_variable:
+		id = str_appendn(id, "var ", dwarf_diename(die), " ", NULL);
+		break;
+	case DW_TAG_typedef:
+		id = str_appendn(id, "typedef ", dwarf_diename(die), " ", NULL);
+		break;
+	case DW_TAG_const_type:
+		id = str_append(id, "const ");
+		break;
+	case DW_TAG_restrict_type:
+		id = str_append(id, "restrict ");
+		break;
+	case DW_TAG_volatile_type:
+		id = str_append(id, "volatile ");
+		break;
+	case DW_TAG_pointer_type:
+		if (no_type_id)
+			id = str_append(id, "void ");
+		id = str_append(id, "* ");
+		break;
+
+	case DW_TAG_array_type: {
+		/*
+		 * No explicit notation: all done per-dimension: so recurse to
+		 * those.
+		 */
+
+		int sib_ret;
+		int dimens = 0;
+		Dwarf_Die dim_die;
+
+		switch (dwarf_child(die, &dim_die)) {
+		case -1:
+			fprintf(stderr, "Corrupt DWARF: Cannot get array "
+				"dimensions: %s\n", dwarf_errmsg(dwarf_errno()));
+			exit(1);
+		case 1: /* No dimensions.  */
+			id = str_append(id, "[] ");
+			break;
+		default:
+			dimens = 1;
+		}
+
+		if (!dimens)
+			break;
+
+		do {
+			char *sub_id = type_id(&dim_die, overrides, fun, data);
+			id = str_append(id, sub_id);
+			free(sub_id);
+		} while ((sib_ret = dwarf_siblingof(&dim_die, &dim_die)) == 0);
+
+		if (sib_ret == -1) {
+			fprintf(stderr, "Corrupt DWARF: Cannot get array "
+				"dimensions: %s\n", dwarf_errmsg(dwarf_errno()));
+			exit(1);
+		}
+		break;
+	}
+	case DW_TAG_subrange_type: {
+		Dwarf_Word nelems = private_subrange_dimensions(die);
+
+		id = str_append(id, "[");
+
+		if (nelems > 0)
+		{
+			char elems[22];	    /* bigger than 2^64's digit count */
+			char *sub_id = type_id(private_dwarf_type(die, &type_die),
+					       overrides, fun, data);
+
+			snprintf(elems, sizeof (elems), " %li", nelems);
+			id = str_appendn(id, sub_id, elems, NULL);
+			free(sub_id);
+		}
+		id = str_append(id, "] ");
+		break;
+	}
+	default:
+		/*
+		 * Some tags (e.g. structure members) get the same ID as their
+		 * associated type.  We don't need to call the hook function
+		 * again for such tags.
+		 */
+		decorated = 0;
+	}
+
+	if (fun && decorated)
+		fun(die, id, data);
+
+	return id;
+}
+
+/*
+ * Process a file, calling the dwarf_process function for every top-level type
+ * found therein.  Optionally call tu_init() at the start of each translation
+ * unit, and tu_done() at the end.
+ */
+static void process_file(const char *file_name,
+			 void (*dwarf_process)(const char *module_name,
+					       const char *file_name,
+					       Dwarf_Die *die,
+					       Dwarf_Die *parent_die,
+					       void *data),
+			 void (*tu_init)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void (*tu_done)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void *data)
+{
+	const char *err;
+	char *fn_module_name = fn_to_module(file_name);
+	const char *module_name = fn_module_name;
+
+	Dwfl *dwfl = simple_dwfl_new(file_name, NULL);
+	GHashTable *seen_before = g_hash_table_new_full(g_str_hash, g_str_equal,
+							free, free);
+	Dwarf_Die *tu_die = NULL;
+	Dwarf_Addr junk;
+
+	if (seen_before == NULL) {
+		fprintf(stderr, "Out of memory creating seen_before hash\n");
+		exit(1);
+	}
+
+	while ((tu_die = dwfl_nextcu(dwfl, tu_die, &junk)) != NULL) {
+		const char *tu_name;
+
+		if (dwarf_tag(tu_die) != DW_TAG_compile_unit) {
+			err = "Malformed DWARF: non-compile_unit at top level";
+			goto fail;
+		}
+
+		tu_name = dwarf_diename(tu_die);
+
+		dw_ctf_trace("Processing %s\n", tu_name);
+
+		/*
+		 * If we have seen this TU before, skip it.  We assume that
+		 * types in multiple identical TUs are always entirely
+		 * identical.  This lets us skip cases where the same object
+		 * file is linked in multiple places without scanning every type
+		 * in it.  (Note: this may be inaccurate if a TU is built
+		 * repeatedly with different #defines in force.  I hope this
+		 * cannot happen, but if it does, a workaround a-la libtool is
+		 * simple: rename or symlink the TU for such repeated builds.)
+		 *
+		 * Otherwise, note the name of the module to which this TU maps,
+		 * if it is not already known: otherwise, extract that name.
+		 *
+		 * This is purely an optimization: it breaks somewhat for
+		 * multifile modules but this has no effect but a slight
+		 * slowdown.
+		 */
+		if (g_hash_table_lookup_extended(seen_before, tu_name,
+						 NULL, NULL))
+			continue;
+
+		g_hash_table_replace(seen_before, xstrdup(tu_name), NULL);
+
+		/*
+		 * We are only interested in top-level definitions within each
+		 * TU.
+		 */
+		Dwarf_Die die;
+
+		switch (dwarf_child(tu_die, &die)) {
+		case -1:
+			err = "fetch first child of TU";
+			goto fail;
+		case 1: /* No DIEs at all in this TU */
+			continue;
+		default: /* Child DIEs exist.  */
+			break;
+		}
+
+		if (tu_init != NULL)
+			tu_init(module_name, file_name, tu_die, data);
+
+		process_tu_func(module_name, file_name, tu_die, &die,
+				dwarf_process, data);
+
+		if (tu_done != NULL)
+			tu_done(module_name, file_name, tu_die, data);
+	}
+
+	free(fn_module_name);
+	simple_dwfl_free(dwfl);
+	g_hash_table_destroy(seen_before);
+
+	return;
+
+ fail:
+	fprintf(stderr, "Cannot %s for %s: %s\n", err, module_name,
+		dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * process_file() helper, walking over subroutines and their contained blocks
+ * recursively and picking up types therein.
+ */
+static void process_tu_func(const char *module_name,
+			    const char *file_name,
+			    Dwarf_Die *parent_die,
+			    Dwarf_Die *die,
+			    void (*dwarf_process)(const char *module_name,
+						  const char *file_name,
+						  Dwarf_Die *die,
+						  Dwarf_Die *parent_die,
+						  void *data),
+			    void *data)
+{
+	const char *err;
+	int sib_ret;
+
+	/*
+	 * We are only interested in definitions for which we can (eventually)
+	 * emit CTF: call the processing function for all such.  Recurse into
+	 * subprograms to catch type declarations there as well, since there may
+	 * be definitions of aggregates referred to outside this function only
+	 * opaquely.
+	 */
+	do {
+		if ((dwarf_tag(die) <= assembly_len) &&
+		    (assembly_filter_tab[dwarf_tag(die)] == NULL ||
+		     assembly_filter_tab[dwarf_tag(die)](die, parent_die)) &&
+		    (assembly_tab[dwarf_tag(die)] != NULL))
+			dwarf_process(module_name, file_name, die,
+				      parent_die, data);
+
+		if ((dwarf_tag(die) == DW_TAG_subprogram) ||
+		    (dwarf_tag(die) == DW_TAG_lexical_block)) {
+			Dwarf_Die subroutine_die;
+
+			switch (dwarf_child(die, &subroutine_die)) {
+			case -1:
+				err = "fetch first child of subroutine";
+				goto fail;
+			case 1: /* No DIEs at all in this subroutine */
+				continue;
+			default: /* Child DIEs exist.  */
+				break;
+			}
+			process_tu_func(module_name, file_name, die,
+					&subroutine_die, dwarf_process, data);
+		}
+	} while ((sib_ret = dwarf_siblingof(die, die)) == 0);
+
+	if (sib_ret == -1) {
+		err = "fetch sibling";
+		goto fail;
+	}
+
+	return;
+ fail:
+	fprintf(stderr, "Cannot %s for %s: %s\n", err, module_name,
+		dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/* Duplicate detection. */
+
+/*
+ * Scan and identify duplicates across the entire set of object files.
+ */
+static void scan_duplicates(void)
+{
+	size_t i;
+
+	/*
+	 * First, determine which types are referenced by more than one
+	 * translation unit, and construct the mapping from translation unit to
+	 * non-builtin module name.
+	 *
+	 * The first pass detects duplicated types in need of sharing, without
+	 * considering opaque/transparent structure/union aliasing.  It requests
+	 * an alias detection pass if any structures, or typedefs to them, are
+	 * newly marked as shared.
+	 *
+	 * We must do this even when deduplication is disabled, because we need
+	 * the TU->module-name mapping, even if in this case it is trivial.
+	 */
+
+	struct detect_duplicates_state state = {0};
+
+	dw_ctf_trace("Duplicate detection: primary pass.\n");
+
+	/*
+	 * This is merely flushed between TUs, not recreated: we create it here.
+	 */
+	state.vars_seen = g_hash_table_new_full(g_str_hash,
+						g_str_equal,
+						free, NULL);
+
+	for (i = 0; i < object_names_cnt; i++)
+		process_file(object_names[i], detect_duplicates,
+			     detect_duplicates_tu_init,
+			     detect_duplicates_tu_done, &state);
+
+	if ((!state.repeat_detection) || !deduplicating)
+		goto out;
+
+	do {
+		/*
+		 * The second pass recognizes that opaque structures must be
+		 * shared if the transparent equivalents are, and vice versa,
+		 * and re-traces all transparent types that need sharing.
+		 *
+		 * It requests another alias detection pass if any non-opaque
+		 * structures are newly marked as shared.
+		 */
+		dw_ctf_trace("Duplicate detection: alias fixup pass.\n");
+
+		state.repeat_detection = 0;
+		state.named_structs = list_filter(state.named_structs,
+						  detect_duplicates_alias_fixup,
+						  free_duplicates_id_file,
+						  &state);
+	} while (state.repeat_detection);
+ out:
+	g_hash_table_destroy(state.vars_seen);
+	detect_duplicates_dwarf_free(&state);
+	dw_ctf_trace("Duplicate detection: complete.\n");
+	dw_ctf_trace("%llu distinct type IDs known.\n",
+		     (long long unsigned) g_hash_table_size(id_to_module));
+	dw_ctf_trace("%llu variables blacklisted for static/nonstatic "
+		     "conflicts.\n",
+		     (long long unsigned) g_hash_table_size(variable_blacklist));
+	g_list_free_full(state.named_structs, free_duplicates_id_file);
+}
+
+/*
+ * Set up state for detect_duplicates().  A tu_init() callback.
+ */
+static void detect_duplicates_tu_init(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *tu_die,
+				      void *data)
+{
+	struct detect_duplicates_state *state = data;
+	per_module_t *per_mod;
+
+	/*
+	 * Make sure that even if this module has no types in it we still end up
+	 * generating a CTF file.  (Userspace depends on this, since a CTF file
+	 * with no types in means the module is known and typeless, while no CTF
+	 * file at all means the module is not known.)
+	 */
+
+	per_mod = g_hash_table_lookup(per_module, module_name);
+	if (per_mod == NULL) {
+		init_ctf_table(module_name);
+		dw_ctf_trace("%s: initialized CTF file.\n", module_name);
+	}
+
+	state->structs_seen = g_hash_table_new_full(g_str_hash, g_str_equal,
+						    free, NULL);
+	g_hash_table_remove_all(state->vars_seen);
+	state->module_name = module_name;
+}
+
+/*
+ * Free state for detect_duplicates().  A tu_done() callback.
+ */
+static void detect_duplicates_tu_done(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *tu_die,
+				      void *data)
+{
+	struct detect_duplicates_state *state = data;
+
+	/*
+	 * We have to annul module_name because it is freed between object files
+	 * by process_file().  Since we use that to track whether vars_seen
+	 * needs reconstructing, that means we have to destroy that as well.
+	 */
+	g_hash_table_destroy(state->structs_seen);
+	state->structs_seen = NULL;
+	state->module_name = NULL;
+}
+
+/*
+ * Free DWARF state for detect_duplicates().
+ */
+static void detect_duplicates_dwarf_free(struct detect_duplicates_state *state)
+{
+	if (state->dwfl == NULL)
+		return;
+	simple_dwfl_free(state->dwfl);
+	state->dwfl = NULL;
+	state->dwarf = NULL;
+	free(state->dwfl_file_name);
+	state->dwfl_file_name = NULL;
+	if (state->structs_seen)
+		g_hash_table_destroy(state->structs_seen);
+	state->structs_seen = NULL;
+}
+
+/*
+ * Duplicate detection.
+ *
+ * Scan for duplicate types.  A duplicate type is defined as any type which
+ * appears in more than one module, or, more precisely, any type for which a
+ * type with the same ID already exists in another module.
+ *
+ * This pass also constructs the id_to_module table, so is essential even when
+ * deduplication is disabled (though then it need be run only once.)
+ */
+
+static void detect_duplicates(const char *module_name,
+			      const char *file_name,
+			      Dwarf_Die *die,
+			      Dwarf_Die *parent_die,
+			      void *data)
+{
+	struct detect_duplicates_state *state = data;
+	int is_sou = 0;
+	char *id = type_id(die, NULL, is_named_struct_union_enum, &is_sou);
+
+	state->file_name = file_name;
+	/*
+	 * If a DWARF-4 type signature is found, abort.  While we can support
+	 * DWARF-4 eventually, support in elfutils is insufficiently robust for
+	 * now (elfutils 0.152).
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_type)) {
+		Dwarf_Attribute type_attr;
+
+		if ((private_dwarf_attr(die, DW_AT_type, &type_attr) != NULL) &&
+		    (dwarf_whatform(&type_attr) == DW_FORM_ref_sig8)) {
+			fprintf(stderr, "sorry, not yet implemented: %s "
+				"contains DWARF-4 debugging information.\n",
+				module_name);
+			exit(1);
+		}
+	}
+
+	/*
+	 * Non-anonymous, non-opaque structure types in non-dedup-blacklisted
+	 * modules get their names and locations recorded for subsequent passes;
+	 * all type_id()-descendant types are similarly noted.
+	 */
+	if (is_sou && strncmp(id, "////", strlen("////")) != 0)
+		free(type_id(die, NULL, detect_duplicates_will_rescan, state));
+
+	/*
+	 * Handle static variable blacklisting.  (We still shuffle blacklisted
+	 * variables into the right place in id_to_module because we check for
+	 * blacklisting at the lowest level, by which point we have already
+	 * depended on id_to_module being correctly populated.)
+	 *
+	 * Avoid calling this for recursive dependent-type scans: variables
+	 * cannot be dependent types.
+	 */
+	if (parent_die != NULL && dwarf_tag(die) == DW_TAG_variable)
+		detect_duplicates_blacklist_var_dups(die, state);
+
+	/*
+	 * If we know of a single module incorporating this type, and it is not
+	 * the same as the module we are currently in, then this type is
+	 * duplicated across modules and belongs in the global type table.
+	 * (This means that duplicated types are repeatedly so marked: this
+	 * is unavoidable, because pass 3 requires re-marking structures that
+	 * have already been marked, to pick up unmarked intermediate types.)
+	 *
+	 * We never consider types in modules on the deduplication blacklist
+	 * to introduce duplicates.
+	 */
+	switch (type_needs_sharing(module_name, id)) {
+	case NS_NEEDS_SHARING:
+		mark_shared(die, NULL, data);
+		mark_seen_contained(die, "shared_ctf");
+		/* Fall through */
+	case NS_NO_MARKING:
+		/*
+		 * A duplicated type, but in the same module, or deduplication
+		 * is disabled, so id_to_module is already correct.  (When
+		 * deduplication is disabled, we will be running with only one
+		 * module at a time, and id_to_module will be a trivial
+		 * mapping.)
+		 */
+		free(id);
+		return;
+	case NS_NOT_SHARED:
+		break;
+	}
+
+	/*
+	 * Record that we have seen this type, and all its dependent types, in
+	 * this module (or in the shared module if need be).
+	 */
+
+	dw_ctf_trace("Marking %s as seen in %s\n", id, module_name);
+	g_hash_table_replace(id_to_module, id, xstrdup(module_name));
+	mark_seen_contained(die, module_name);
+	free(type_id(die, NULL, detect_duplicates_typeid, data));
+}
+
+/*
+ * Note in the detect_duplicates_id_file list that we will rescan a DIE in
+ * a later duplicate detection pass
+ *
+ * A type_id() callback.
+ */
+static void detect_duplicates_will_rescan(Dwarf_Die *die, const char *id,
+					  void *data)
+{
+	struct detect_duplicates_state *state = data;
+	struct detect_duplicates_id_file *id_file;
+
+	/*
+	 * We don't care about array index types, which will never be structures
+	 * in C.
+	 */
+	if (id[0] == '[')
+		return;
+
+	id_file = calloc(1, sizeof (struct detect_duplicates_id_file));
+	if (id_file == NULL) {
+		fprintf(stderr, "Out of memory allocating id_file\n");
+		exit (1);
+	}
+	id_file->file_name = xstrdup(state->file_name);
+	id_file->id = xstrdup(id);
+	id_file->dieoff = dwarf_dieoffset(die);
+	state->named_structs = g_list_prepend(state->named_structs, id_file);
+}
+
+/*
+ * Note the variable referenced by this DIE in vars_seen: blacklist it if an
+ * entry for this variable already exists in vars_seen and this instance is
+ * static, or if a static entry already exists in vars_seen, whether this
+ * instance is static or not.
+ */
+static void detect_duplicates_blacklist_var_dups(Dwarf_Die *die,
+						 struct detect_duplicates_state *state)
+{
+	void *static_var;
+	int blacklist = 0;
+
+	if (g_hash_table_lookup_extended(state->vars_seen,
+					 dwarf_diename(die),
+					 NULL, &static_var)) {
+		if (!private_dwarf_hasattr(die, DW_AT_external) &&
+		    !private_dwarf_hasattr(die, DW_AT_declaration))
+			blacklist = 1;
+		if (static_var != NULL)
+			blacklist = 1;
+	}
+	else
+	  /*
+	   * We need a non-NULL address here, but that is all we need.
+	   * The address of a random variable will do.
+	   */
+		g_hash_table_insert(state->vars_seen,
+				    xstrdup(dwarf_diename(die)),
+				    (!private_dwarf_hasattr(die, DW_AT_external) &&
+				     !private_dwarf_hasattr(die, DW_AT_declaration)) ?
+				    &static_var : NULL);
+
+	if (blacklist) {
+		char *var = NULL;
+		var = str_appendn(var, state->module_name, "`",
+				  dwarf_diename(die), NULL);
+		g_hash_table_replace(variable_blacklist, var, NULL);
+	}
+}
+
+/*
+ * Free a detect_duplicates_id_file's contents.
+ */
+static void free_duplicates_id_file(void *data)
+{
+	struct detect_duplicates_id_file *id_file = data;
+	free(id_file->file_name);
+	free(id_file->id);
+	free(id_file);
+}
+
+/*
+ * Determine if a type is duplicated and needs sharing.
+ */
+static enum needs_sharing type_needs_sharing(const char *module_name,
+					     const char *id)
+{
+	const char *existing_type_module;
+	existing_type_module = g_hash_table_lookup(id_to_module, id);
+
+	/*
+	 * Types not already known about do not need sharing.
+	 *
+	 * Types already in the current modules and any types in external-module
+	 * mode do not even need marking.
+	 */
+	if (existing_type_module == NULL)
+		return NS_NOT_SHARED;
+
+	if ((strcmp(existing_type_module, module_name) == 0) ||
+	    (strcmp(existing_type_module, "shared_ctf") == 0) ||
+	    !deduplicating)
+		return NS_NO_MARKING;
+
+	return NS_NEEDS_SHARING;
+}
+
+/*
+ * Detect duplicates and mark seen types for a given type, via a type_id()
+ * callback: used to detect dependent types (particularly those at child-DIE
+ * level) as duplicates.
+ */
+static void detect_duplicates_typeid(Dwarf_Die *die, const char *id,
+				     void *data)
+{
+	struct detect_duplicates_state *state = data;
+
+	detect_duplicates(state->module_name, state->file_name, die, NULL,
+			  data);
+}
+
+/*
+ * Mark any types contained within a particular type DIE as seen.  This is
+ * needed since even nameless types contained within other aggregates can be
+ * used as the type of members in any of their enclosing aggregates (though they
+ * cannot possibly be found in a module different from that of their containing
+ * aggregate, any more than a structure member can).
+ */
+static void mark_seen_contained(Dwarf_Die *die, const char *module_name)
+{
+	const char *err;
+	Dwarf_Die child;
+
+	if ((dwarf_tag(die) != DW_TAG_structure_type) &&
+	    (dwarf_tag(die) != DW_TAG_union_type))
+		return;
+
+	switch (dwarf_child(die, &child)) {
+	case -1:
+		err = "fetch first child of aggregate";
+		goto fail;
+	case 1: /* No DIEs at all in this aggregate */
+		return;
+	default: /* Child DIEs exist.  */
+		break;
+	}
+
+	/*
+	 * We iterate over all immediate children and recursively call ourselves
+	 * for all those of type DW_TAG_structure_type and DW_TAG_union_type.
+	 *
+	 * Further, everything with an entry in assembly_tab other than
+	 * non-bitfield members needs marking, since these may be declared at
+	 * structure scope rather than being confined to global scope.
+	 * Non-bitfield members are skipped because they cannot be used as the
+	 * type of another field.  These types cannot be duplicates if their
+	 * containing type is not a duplicate, and typedefs cannot occur at this
+	 * level so they cannot be aliased; thus we can mark them directly
+	 * without going back into the top of detect_duplicates().
+	 *
+	 * (Bit-field members are not skipped: they use different CTF from their
+	 * non-bitfield equivalents, even though they refer to the same
+	 * top-level DIE.)
+	 */
+	int sib_ret;
+
+	do
+		switch (dwarf_tag(&child)) {
+		case DW_TAG_member: {
+			/*
+			 * bit_size and bit_offset go together: we can assume
+			 * that if a member has the one, it has the other.
+			 */
+			if (dwarf_tag(&child) == DW_TAG_member &&
+			    !private_dwarf_hasattr(&child, DW_AT_bit_size))
+				break;
+
+			die_override_t override[] =
+				{{ DW_TAG_base_type,
+				   DW_AT_bit_size,
+				   DIE_OVERRIDE_REPLACE,
+				   private_dwarf_udata(&child, DW_AT_bit_size,
+						       NULL) },
+				 { DW_TAG_base_type,
+				   DW_AT_bit_offset,
+				   DIE_OVERRIDE_REPLACE,
+				   private_dwarf_udata(&child, DW_AT_bit_offset,
+						       NULL) },
+				 {0}};
+
+			char *id = type_id(&child, override, NULL, NULL);
+
+			/*
+			 * We also have to do shared checking in here, since
+			 * this type does not exist at the DWARF top level.
+			 */
+			switch (type_needs_sharing(module_name, id)) {
+			case NS_NEEDS_SHARING:
+				g_hash_table_replace(id_to_module, id,
+						     xstrdup("shared_ctf"));
+				dw_ctf_trace("Marking bitfield member %s as "
+					     "shared\n", id);
+
+				break;
+			case NS_NO_MARKING:
+				free(id);
+				break;
+			case NS_NOT_SHARED:
+				g_hash_table_replace(id_to_module, id,
+						     xstrdup(module_name));
+				dw_ctf_trace("Marking bitfield member %s as seen in %s\n",
+					     id, module_name);
+				break;
+			}
+			break;
+		}
+		case DW_TAG_structure_type:
+		case DW_TAG_union_type:
+			mark_seen_contained(&child, module_name);
+			/* fall through */
+		default:
+			if (dwarf_tag(&child) <= assembly_len &&
+			    assembly_tab[dwarf_tag(&child)] != NULL) {
+
+				char *id = type_id(&child, NULL, NULL, NULL);
+
+				dw_ctf_trace("Marking member %s as seen in %s\n", id,
+					     module_name);
+				g_hash_table_replace(id_to_module, id,
+						     xstrdup(module_name));
+			}
+		}
+	while ((sib_ret = dwarf_siblingof(&child, &child)) == 0);
+
+	if (sib_ret == -1) {
+		err = "iterate over members";
+		goto fail;
+	}
+
+	return;
+
+ fail:
+	fprintf(stderr, "Cannot %s while marking aggregates as seen: %s\n",
+		err, dwfl_errmsg(dwfl_errno()));
+	exit(1);
+}
+
+/*
+ * Mark a type as duplicated and located in the shared CTF table.  Recursive,
+ * via the type_id() callback mechanism.
+ *
+ * A type_id() callback (though also called directly).
+ */
+static void mark_shared(Dwarf_Die *die, const char *id, void *data)
+{
+	struct detect_duplicates_state *state = data;
+	const char *existing_module;
+
+	/*
+	 * Non-recursive call.  Trigger type_id for its recursive callback,
+	 * throwing the result away.
+	 */
+	if (id == NULL) {
+		free(type_id(die, NULL, mark_shared, state));
+		return;
+	}
+
+	existing_module = g_hash_table_lookup(id_to_module, id);
+
+	if ((existing_module == NULL) ||
+	    (strcmp(existing_module, "shared_ctf") != 0)) {
+
+		dw_ctf_trace("Marking %s as duplicate\n", id);
+		g_hash_table_replace(id_to_module, xstrdup(id),
+				     xstrdup("shared_ctf"));
+
+		/*
+		 * Newly-marked structures or unions must trigger a new
+		 * duplicate detection pass (even if they are opaque).
+		 */
+
+		if (((dwarf_tag(die) == DW_TAG_structure_type) ||
+		     (dwarf_tag(die) == DW_TAG_union_type)) &&
+		    (!state->repeat_detection)) {
+			dw_ctf_trace("Requesting another duplicate detection "
+				     "pass.\n");
+			state->repeat_detection = 1;
+		}
+	}
+
+	/*
+	 * If this is a structure or union, mark its members as duplicates too.
+	 *
+	 * Do this even if we've seen this structure before, as this instance of
+	 * the structure may have more members than the last we saw.  However,
+	 * if we have seen this structure before *in this translation unit*,
+	 * skip it, to avoid infinite recursion in mutually referential
+	 * structures.
+	 */
+	if ((dwarf_tag(die) == DW_TAG_structure_type) ||
+	    (dwarf_tag(die) == DW_TAG_union_type)) {
+		Dwarf_Die child;
+
+		if (g_hash_table_lookup_extended(state->structs_seen, id,
+						 NULL, NULL))
+			return;
+		g_hash_table_replace(state->structs_seen, xstrdup(id), NULL);
+
+		switch (dwarf_child(die, &child)) {
+		case -1:
+			goto fail;
+		case 1: /* No DIEs at all in this aggregate */
+			return;
+		}
+
+		/*
+		 * We are only interested in non-blacklisted children of type
+		 * DW_TAG_member.  As above, bitfields get an override to
+		 * denote the bitfieldness of their parent type.
+		 */
+		int sib_ret;
+
+		do
+			if ((dwarf_tag(&child) == DW_TAG_member) &&
+			    !member_blacklisted(&child, die)) {
+				if (private_dwarf_hasattr(&child, DW_AT_bit_size)) {
+					die_override_t override[] =
+						{{ DW_TAG_base_type,
+						   DW_AT_bit_size,
+						   DIE_OVERRIDE_REPLACE,
+						   private_dwarf_udata(&child,
+								       DW_AT_bit_size,
+								       NULL) },
+						 { DW_TAG_base_type,
+						   DW_AT_bit_offset,
+						   DIE_OVERRIDE_REPLACE,
+						   private_dwarf_udata(&child,
+								       DW_AT_bit_offset,
+								       NULL) },
+						 {0}};
+
+					free(type_id(&child, override,
+						     mark_shared, state));
+				} else
+					free(type_id(&child, NULL,
+						     mark_shared, state));
+			}
+		while ((sib_ret = dwarf_siblingof(&child, &child)) == 0);
+
+		if (sib_ret == -1)
+			goto fail;
+	}
+
+	return;
+
+ fail:
+	fprintf(stderr, "Cannot mark aggregate %s members as duplicated: %s\n",
+		dwarf_diename(die), dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * Determine if a type is a named struct, union, or enum.
+ *
+ * A type_id() callback.
+ */
+static void is_named_struct_union_enum(Dwarf_Die *die, const char *unused,
+				       void *data)
+{
+	int *is_sou = data;
+
+	if (((dwarf_tag(die) == DW_TAG_structure_type) ||
+	     (dwarf_tag(die) == DW_TAG_union_type) ||
+	     (dwarf_tag(die) == DW_TAG_enumeration_type)) &&
+	    (private_dwarf_hasattr(die, DW_AT_name)))
+		*is_sou = 1;
+}
+
+/*
+ * Duplicate detection alias fixup pass.  Once the first pass is complete, we
+ * may have marked an opaque 'struct foo' for sharing but not caught the
+ * non-opaque instance, because no users of the non-opaque instance appeared in
+ * the DWARF after the opaque copy was detected as a duplicate.
+ * This pass detects such cases, and marks their members as duplicates too.
+ *
+ * (The inverse case of a non-opaque structure/union/enum detected as a
+ * duplicate after the last usage of its opaque alias will be caught by this
+ * trap too.)
+ *
+ * Warning: this routine directly computes type_id()s without access to the
+ * corresponding type DIE, and as such is dependent on the format of type_id()s.
+ * (This is why it must run over non-opaque structures: given a non-opaque
+ * structure, its opaque alias is easy to compute, but the converse is not
+ * true.)
+ *
+ * As a list_filter() filter function, returns nonzero if this structure will
+ * not need to be checked again (because both its opaque and transparent
+ * variants are shared).
+ */
+static int detect_duplicates_alias_fixup(void *id_file_data, void *data)
+{
+	struct detect_duplicates_id_file *id_file = id_file_data;
+	struct detect_duplicates_state *state = data;
+
+	int transparent_shared = 0;
+	int opaque_shared = 0;
+	int made_shared = 0;
+
+	char *opaque_id;
+	const char *line_num;
+	const char *type_size;
+	const char *type_name;
+
+	/*
+	 * Compute the opaque variant corresponding to this transparent type,
+	 * and check to see if either is marked shared, then find the DIE and
+	 * mark both as shared if either is.  (Unfortunately this means a double
+	 * recursion in such cases, but this is unavoidable.)
+	 */
+
+	line_num = strstr(id_file->id, "//");
+	if (!line_num) {
+		fprintf(stderr, "Internal error: type ID %s is corrupt.\n",
+			id_file->id);
+		exit(1);
+	}
+
+	type_size = strstr(line_num + 2, "//");
+	if (!type_size) {
+		fprintf(stderr, "Internal error: type ID %s is corrupt.\n",
+			id_file->id);
+		exit(1);
+	}
+
+	type_name = strstr(type_size + 2, "//");
+	if (!type_name) {
+		/*
+		 * That's OK: the type size is optional, so what we thought was
+		 * the type size is actually the type name.
+		 */
+		type_name = type_size;
+	}
+	type_name += 2;
+
+	opaque_id = xstrdup("////");
+	opaque_id = str_append(opaque_id, type_name);
+
+	const char *transparent_module = g_hash_table_lookup(id_to_module,
+							     id_file->id);
+	const char *opaque_module = g_hash_table_lookup(id_to_module,
+							opaque_id);
+
+	transparent_shared = ((transparent_module != NULL) &&
+			      (strcmp(transparent_module, "shared_ctf") == 0));
+
+	opaque_shared = ((opaque_module != NULL) &&
+			 (strcmp(opaque_module, "shared_ctf") == 0));
+
+	/*
+	 * Transparent type needs sharing.
+	 */
+	if (opaque_shared && !transparent_shared) {
+		Dwarf_Die die;
+		Dwfl_Module *mod;
+		Dwarf_Addr dummy;
+
+		/*
+		 * Since we are not using process_file(), we must handle
+		 * translation unit switches by hand, including resetting
+		 * structs_seen.  We also need to open the DWARF file, since
+		 * type_id() needs access to the DIE of this type and all its
+		 * dependent types as well.
+		 */
+
+		if (state->dwfl != NULL &&
+		    strcmp(state->dwfl_file_name,
+			   id_file->file_name) != 0)
+			detect_duplicates_dwarf_free(state);
+
+		if (state->dwfl_file_name == NULL) {
+			state->dwfl = simple_dwfl_new(id_file->file_name, &mod);
+			state->dwarf = dwfl_module_getdwarf(mod, &dummy);
+			state->dwfl_file_name = xstrdup(id_file->file_name);
+			if (state->structs_seen)
+				g_hash_table_destroy(state->structs_seen);
+			state->structs_seen = g_hash_table_new_full(g_str_hash,
+								    g_str_equal,
+								    free, NULL);
+		}
+		if (!dwarf_offdie(state->dwarf, id_file->dieoff,
+				  &die)) {
+			fprintf(stderr, "Cannot look up offset %li in "
+				"%s for type with ID %s\n",
+				id_file->dieoff, id_file->file_name,
+				id_file->id);
+			exit(1);
+		}
+		mark_shared(&die, NULL, state);
+		made_shared = 1;
+	}
+
+	/*
+	 * We don't have the opaque type's DIE, so we can't use mark_shared():
+	 * this is also good since this triggers another duplicate detection
+	 * pass, and we don't want to trigger another pass merely because of a
+	 * nonshared opaque type (since they don't have members that may have
+	 * structure or union type themselves and thus force more unshared
+	 * types to become shared).
+	 *
+	 * Instead, do it by hand: this is simple, as member recursion is
+	 * guaranteed not to be required for an opaque type.
+	 */
+	if (transparent_shared && !opaque_shared) {
+		dw_ctf_trace("Marking %s as duplicate\n", opaque_id);
+		g_hash_table_replace(id_to_module, xstrdup(opaque_id),
+				     xstrdup("shared_ctf"));
+		made_shared = 1;
+	}
+
+	free(opaque_id);
+
+	return made_shared || (opaque_shared && transparent_shared);
+}
+
+/*
+ * Mark a basic type shared by name and intern it in all relevant hashes.  (Used
+ * for marking basic types we don't have a DIE for.)
+ */
+static void mark_shared_by_name(ctf_file_t *ctf, ctf_id_t ctf_id,
+				const char *name)
+{
+	ctf_full_id_t static_ctf_id = { ctf, ctf_id };
+	ctf_full_id_t *full_ctf_id;
+	char *id = NULL;
+
+	full_ctf_id = malloc(sizeof (struct ctf_full_id));
+	if (full_ctf_id == NULL) {
+		fprintf(stderr, "%s: out of memory\n", __func__);
+		exit(1);
+	}
+	*full_ctf_id = static_ctf_id;
+
+	id = str_appendn(id, "////", name, " ", NULL);
+#ifdef DEBUG
+	strcpy(full_ctf_id->module_name, "shared_ctf");
+	strcpy(full_ctf_id->file_name, "<built-in type>");
+#endif
+	g_hash_table_replace(id_to_module, id, xstrdup("shared_ctf"));
+	g_hash_table_replace(id_to_type, xstrdup(id), full_ctf_id);
+}
+
+/*
+ * Type assembly.
+ *
+ * Given a DWARF DIE corresponding to a top-level type, call the appropriate
+ * construction function, passing it the appropriate ctf_file_t, constructing it
+ * if necessary, and stashing them in the appropriate hashes.  Return the
+ * ctf_file_t and ctf_id_t of this type.
+ *
+ * Indirectly recursively called for types depending on other types, and for
+ * the types of variables (which for the sake of argument we call 'types' here
+ * too, since we treat them exactly like types, and dealing with types is our
+ * most important function).  In such calls, the module_name may be 'shared_ctf'
+ * if this type is in the shared CTF repository.
+ *
+ * Select properties of the DIE can be overridden via the overrides array, if
+ * needed.
+ */
+static ctf_full_id_t *construct_ctf_id(const char *module_name,
+				       const char *file_name,
+				       Dwarf_Die *die,
+				       Dwarf_Die *parent_die,
+				       die_override_t *overrides)
+{
+	char *id = type_id(die, overrides, NULL, NULL);
+	char *ctf_module;
+	ctf_file_t *ctf;
+	ctf_snapshot_id_t snapshot;
+
+	dw_ctf_trace("    %p: %s: looking up %s: %s\n", &id,
+		     module_name ? module_name : "(no module)",
+		     dwarf_diename(die), id);
+	/*
+	 * Make sure this type does not already exist.  (Recursive chasing for
+	 * referenced types can lead to construct_ctf() being called on them
+	 * more than once.)
+	 */
+	ctf_full_id_t *ctf_id;
+	if ((ctf_id = g_hash_table_lookup(id_to_type, id)) != NULL) {
+		dw_ctf_trace("    %p: %p:%i found in module %s, file %s\n", &id,
+			     ctf_id->ctf_file, (int) ctf_id->ctf_id,
+			     ctf_id->module_name, ctf_id->file_name);
+		free(id);
+		return ctf_id;
+	}
+
+	/*
+	 * Create the CTF file for this type, if it does not exist.  Verify that
+	 * the duplicate-detection pass scanned this type, and that this is
+	 * either the current module or the shared CTF module.
+	 */
+
+	ctf_module = g_hash_table_lookup(id_to_module, id);
+
+	if (ctf_module == NULL) {
+		fprintf(stderr, "Internal error: within file %s, module %s, "
+			"type at DIE offset %lx with ID %s was not already "
+			"noted by detect_duplicates().\n", file_name,
+			module_name, (unsigned long) dwarf_dieoffset(die), id);
+		fprintf(stderr, "detect_duplicates() is probably buggy.\n");
+		exit(1);
+	}
+
+	if ((strcmp(ctf_module, module_name) != 0) &&
+	    (strcmp(ctf_module, "shared_ctf") != 0)) {
+		fprintf(stderr, "Internal error: within file %s, module %s, "
+			"type at DIE offset %lx with ID %s is in a different "
+			"non-shared module, %s.\n", file_name, module_name,
+			(unsigned long) dwarf_dieoffset(die), id, ctf_module);
+		fprintf(stderr, "detect_duplicates() is probably buggy.\n");
+		exit(1);
+	}
+
+	ctf = lookup_ctf_file(ctf_module);
+
+	/*
+	 * Construct the CTF, then insert the top-level CTF entity into the
+	 * id->type hash so that references from other types can find it, and
+	 * update the CTF container.  If conversion failed, roll back all
+	 * changes made since the last successful call to this function.
+	 *
+	 * NOTE: references within DWARF to non-top-level types will currently
+	 * fail, but I'm not sure if these can exist.  (The type ID
+	 * representation implicitly assumes that they cannot.)
+	 */
+
+	snapshot = ctf_snapshot(ctf);
+
+	enum skip_type skip = SKIP_CONTINUE;
+	dw_ctf_trace("%p: into die_to_ctf() for %s\n", &id, id);
+	ctf_id_t this_ctf_id = die_to_ctf(ctf_module, file_name, die,
+					  parent_die, ctf, -1, overrides,
+					  1, 0, &skip, NULL, id);
+	dw_ctf_trace("%p: out of die_to_ctf()\n", &id);
+
+	ctf_id = malloc(sizeof (struct ctf_full_id));
+	if (ctf_id == NULL) {
+		fprintf(stderr, "Out of memory\n");
+		exit(1);
+	}
+
+	if (skip != SKIP_ABORT) {
+		ctf_id->ctf_file = ctf;
+		ctf_id->ctf_id = this_ctf_id;
+#ifdef DEBUG
+		strcpy(ctf_id->module_name, ctf_module);
+		strcpy(ctf_id->file_name, file_name);
+#endif
+		g_hash_table_replace(id_to_type, id, ctf_id);
+
+		dw_ctf_trace("    %lx: %s: new type added, CTF ID %p:%i\n",
+			     (unsigned long) dwarf_dieoffset(die), id,
+			     ctf_id->ctf_file, (int) ctf_id->ctf_id);
+	} else {
+		/*
+		 * Failure.  Remove the type from the id_to_type mapping, if it
+		 * is there, and discard any added types from the CTF.
+		 *
+		 * If we have had to ctf_update() due to a new type getting
+		 * used, the rollback will fail: discard instead. It might leave
+		 * some spurious types hanging around but it will clean up as
+		 * much as we can at this point.
+		 */
+
+		if (ctf_rollback(ctf, snapshot) < 0)
+			if (ctf_errno(ctf) == ECTF_OVERROLLBACK)
+				ctf_discard(ctf);
+
+		free(ctf_id);
+		ctf_id = NULL;
+
+		g_hash_table_remove(id_to_type, id);
+		free(id);
+
+		dw_ctf_trace("    %p: (failure)\n", &id);
+	}
+
+	return ctf_id;
+}
+
+/*
+ * Given a DWARF DIE corresponding to a top-level type, or to an aggregate
+ * member, and the ctf_file_t where it is to be placed, call the appropriate
+ * construction function to place it and (for aggregates) its siblings there,
+ * recursing to handle contained aggregates.
+ *
+ * The parameters to this function are:
+ *
+ * module_name: The kernel module.
+ * file_name: The object file.
+ * die: The DWARF DIE.
+ * parent_die: Its parent, i.e. if a structure member, this is a structure: if
+ * top-level, this is a CU DIE.
+ * ctf: The CTF file this object should go into (possibly shared_ctf).
+ * parent_ctf_id: The CTF ID of the parent DIE, or -1 if none.
+ * die_override_t: Overrides for DWARF attributes (a NULL-terminated array,
+ * or NULL).
+ * top_level_type: 1 if this is a top-level type that can have a name and be
+ * referred to by other types.
+ * backwards: if 1, this is an internal call to process a series of bitfields
+ *            with descending bit_offset and identical data_member_location.
+ * skip: The error-handling / skipping enum.
+ * replace: if 1, this type should replace its parent type entirely.
+ * id: the ID of this type.
+ *
+ * Note: id is only defined when top_level_type is 1.  (We never use it
+ * in other situations, and computing it is quite expensive.)
+ */
+static ctf_id_t die_to_ctf(const char *module_name, const char *file_name,
+			   Dwarf_Die *die, Dwarf_Die *parent_die,
+			   ctf_file_t *ctf, ctf_id_t parent_ctf_id,
+			   die_override_t *overrides, int top_level_type,
+			   int backwards, enum skip_type *skip, int *replace,
+			   const char *id)
+{
+	int sib_ret = 0;
+	ctf_id_t this_ctf_id;
+	int dummy;
+
+	do {
+		const char *id_name;
+		const char *decl_file_name = dwarf_decl_file(die);
+		int decl_line_num;
+		int emitted_backwards = 0;
+		char locerrstr[1024];
+		Dwarf_Die next_die;
+
+		/*
+		 * If the next DWARF DIE is at the same location as this one but
+		 * with a lower bit_offset, we need to process the set of DIEs
+		 * at this location in *reverse*, because DWARF has the DIEs in
+		 * declaration order, while CTF wants them in in-memory order:
+		 * so recurse to handle the next until we get to an element with
+		 * a sibling at a different data_member_location (safe because
+		 * there can't be that many of them per data_member_location),
+		 * then (at the end of die_to_ctf()) exit the recursion and skip
+		 * over the lot.
+		 *
+		 * We can ignore 'replace' and the return value of die_to_ctf
+		 * because bitfields must be structure or union members and
+		 * cannot be array dimensions.
+		 */
+		if (die_emit_next_backwards(&next_die, die, overrides) != NULL) {
+			ctf_id_t dummy;
+
+			dw_ctf_trace("Emitting %s:%s:%lx backwards\n",
+				     module_name, file_name,
+				     dwarf_dieoffset(&next_die));
+
+			dummy = die_to_ctf(module_name, file_name, &next_die,
+					   parent_die, ctf, parent_ctf_id,
+					   overrides, top_level_type, 1, skip,
+					   replace, NULL);
+			if (*skip == SKIP_ABORT)
+				return dummy;
+			emitted_backwards = 1;
+		}
+
+		/*
+		 * Compute a name for our current location, for error messages.
+		 * (The type representation could be used, but is likely to be
+		 * hard for users to comprehend, and should we move to a hashed
+		 * representation would be entirely useless for this purpose.)
+		 */
+		if ((decl_file_name == NULL) ||
+		    (dwarf_decl_line(die, &decl_line_num) < 0)) {
+			decl_file_name = "global";
+			decl_line_num = 0;
+		}
+
+		id_name = dwarf_diename(die);
+		if (id_name == NULL)
+			id_name = "(unnamed type)";
+
+		snprintf(locerrstr, sizeof (locerrstr), "%s:%i:%s",
+			 decl_file_name, decl_line_num, id_name);
+
+		dw_ctf_trace("Working over %s:%s:%s:%lx:%x with CTF file %p\n",
+			     module_name, file_name,
+			     dwarf_diename(die)==NULL?"NULL":dwarf_diename(die),
+			     (unsigned long) dwarf_dieoffset(die),
+			     dwarf_tag(die), ctf);
+
+		/*
+		 * Only process a given node, or its children, if we know how to
+		 * do so.
+		 */
+		if ((dwarf_tag(die) >= assembly_len) ||
+		    (assembly_tab[dwarf_tag(die)] == NULL)) {
+			fprintf(stderr, "%s:%i: warning: skipping identifier "
+				"%s with unknown DWARF tag %lx.\n",
+				decl_file_name, decl_line_num, id_name,
+				(unsigned long) dwarf_tag(die));
+			return -1;
+		}
+
+		*skip = SKIP_CONTINUE;
+
+		this_ctf_id = assembly_tab[dwarf_tag(die)](module_name,
+							   file_name,
+							   die, parent_die,
+							   ctf, parent_ctf_id,
+							   locerrstr,
+							   overrides,
+							   top_level_type,
+							   skip,
+							   replace ? replace :
+							   &dummy);
+		dw_ctf_trace("%s: out of assembly function for tag %lx with "
+			     "type ID %li\n", locerrstr,
+			     (unsigned long) dwarf_tag(die), this_ctf_id);
+
+		if (this_ctf_id < 0) {
+			if ((this_ctf_id == CTF_NO_ERROR_REPORTED) &&
+			    (ctf_errno(ctf) != 0))
+				fprintf(stderr, "%s: CTF error in assembly of "
+					"item with tag %i: %s\n", locerrstr,
+					dwarf_tag(die),
+					ctf_errmsg(ctf_errno(ctf)));
+
+			num_errors++;
+#ifdef DEBUG
+			exit(1);
+#endif
+			*skip = SKIP_ABORT;
+		}
+
+		/*
+		 * Add newly-added non-skipped top-level structure or union CTF
+		 * IDs to the type table at once.  This allows circular type
+		 * references via pointers in structure/union member DIEs to be
+		 * looked up correctly.
+		 */
+		if (top_level_type && (*skip == SKIP_CONTINUE) &&
+		    ((dwarf_tag(die) == DW_TAG_structure_type) ||
+		     (dwarf_tag(die) == DW_TAG_union_type))) {
+			ctf_full_id_t full_ctf_id = { ctf, this_ctf_id };
+			ctf_full_id_t *ctf_id;
+
+#ifdef DEBUG
+			strcpy(full_ctf_id.module_name, module_name);
+			strcpy(full_ctf_id.file_name, file_name);
+#endif
+
+			if ((ctf_id = malloc(sizeof (ctf_full_id_t))) == NULL) {
+				fprintf(stderr, "Out of memory allocating "
+					"type ID\n");
+				exit(1);
+			}
+
+			dw_ctf_trace("    die_to_ctf(): immediate addition of "
+				     "%s, CTF ID %p:%li in module %s, file %s\n",
+				     id, full_ctf_id.ctf_file, full_ctf_id.ctf_id,
+				     module_name, file_name);
+			*ctf_id = full_ctf_id;
+
+			g_hash_table_replace(id_to_type, xstrdup(id), ctf_id);
+		}
+
+		/*
+		 * Recurse to handle contained DIEs.
+		 */
+
+		if ((dwarf_haschildren(die)) && (*skip == SKIP_CONTINUE)) {
+			Dwarf_Die child_die;
+			ctf_id_t new_id;
+			int replace = 0;
+
+			if (dwarf_child(die, &child_die) < 0) {
+				fprintf(stderr, "%s: Cannot recurse to "
+					"DWARF DIE children: %s\n", locerrstr,
+					dwarf_errmsg(dwarf_errno()));
+				exit(1);
+			}
+
+			new_id = die_to_ctf(module_name, file_name, &child_die,
+					    die, ctf, this_ctf_id, overrides, 0,
+					    0, skip, &replace, NULL);
+
+			if (replace)
+				this_ctf_id = new_id;
+		}
+
+		/*
+		 * If we are walking backwards over a bunch of bitfields, this
+		 * is a recursive walk, not an iterative one: return.
+		 */
+		if (backwards)
+			return this_ctf_id;
+
+		/*
+		 * We are not walking backwards, but this is the final stage of
+		 * a bunch of backwards emissions: walk forwards until we hit
+		 * the last one again.
+		 */
+		if (emitted_backwards)
+			while (die_emit_next_backwards(&next_die, die,
+						       overrides) != NULL)
+				*die = next_die;
+
+		/*
+		 * Walk siblings of non-top-level types only: the sibling walk
+		 * of top-level types is done by process_file(), so that
+		 * construct_ctf_id() gets a chance to put each such type in the
+		 * right CTF file.
+		 */
+	} while (*skip != SKIP_ABORT && !top_level_type &&
+		 (sib_ret = dwarf_siblingof(die, die)) == 0);
+
+	if (sib_ret == -1) {
+		fprintf(stderr, "In module %s, failure walking the sibling "
+			"list: %s\n", module_name, dwarf_errmsg(dwarf_errno()));
+		exit(1);
+	}
+
+	dw_ctf_trace("New type ID: %p:%li\n", ctf, this_ctf_id);
+	return this_ctf_id;
+}
+
+/*
+ * Calls construct_ctf_id() and throws the ID away.  Used as a process_file()
+ * callback.
+ */
+static void construct_ctf(const char *module_name, const char *file_name,
+			  Dwarf_Die *die, Dwarf_Die *parent_die,
+			  void *unused __unused__)
+{
+	construct_ctf_id(module_name, file_name, die, parent_die, NULL);
+}
+
+/*
+ * Return the next DIE, if that DIE needs to be emitted before this one.
+ */
+static Dwarf_Die *die_emit_next_backwards(Dwarf_Die *next, Dwarf_Die *die,
+					  die_override_t *overrides)
+{
+	if (dwarf_tag(die) == DW_TAG_member &&
+	    dwarf_siblingof(die, next) == 0 &&
+	    dwarf_tag(next) == DW_TAG_member &&
+	    private_dwarf_hasattr(die, DW_AT_data_member_location) &&
+	    private_dwarf_hasattr(next, DW_AT_data_member_location) &&
+	    private_dwarf_udata(die, DW_AT_data_member_location, overrides) ==
+	    private_dwarf_udata(next, DW_AT_data_member_location, overrides) &&
+	    private_dwarf_hasattr(die, DW_AT_bit_offset) &&
+	    private_dwarf_hasattr(next, DW_AT_bit_offset) &&
+	    private_dwarf_udata(die, DW_AT_bit_offset, overrides) >
+	    private_dwarf_udata(next, DW_AT_bit_offset, overrides))
+		return next;
+	return NULL;
+}
+
+/*
+ * Look up a type through its reference: return its ctf_id, or recursively
+ * construct it if need be.
+ */
+static ctf_id_t lookup_ctf_type(const char *module_name, const char *file_name,
+				Dwarf_Die *die, ctf_file_t *ctf,
+				const char *locerrstr)
+{
+	Dwarf_Die tmp;
+	Dwarf_Die *type_die = private_dwarf_type(die, &tmp);
+	Dwarf_Die cu_die;
+	ctf_full_id_t *type_ref;
+
+	/*
+	 * Pointers to functions and void are special cases: there is only one
+	 * of each of these in CTF, so we can use global singletons.
+	 */
+
+	if (type_die == NULL)
+		return ctf_void_type;
+
+	if (dwarf_tag(type_die) == DW_TAG_subroutine_type)
+		return ctf_funcptr_type;
+
+	/*
+	 * Look up or construct CTF for this type.
+	 */
+
+	dwarf_diecu(type_die, &cu_die, NULL, NULL);
+
+	dw_ctf_trace("    %s: Looking up dependent type at offset %lx "
+		     "for type %s at module %s, file %s\n", locerrstr,
+		     (unsigned long) dwarf_dieoffset(type_die),
+		     dwarf_diename(die) ? dwarf_diename(die) : "NULL",
+		     module_name, file_name);
+
+	type_ref = construct_ctf_id(module_name, file_name,
+				    type_die, &cu_die, NULL);
+
+	/*
+	 * Pass any error back up.
+	 */
+	if (type_ref == NULL) {
+		fprintf(stderr, "%s: type lookup failed.\n", locerrstr);
+		return -1;
+	}
+
+	if ((type_ref->ctf_file != ctf) &&
+	    type_ref->ctf_file != lookup_ctf_file("shared_ctf")) {
+#ifdef DEBUG
+		fprintf(stderr, "%s: Internal error: lookup of %s found in "
+			"different file: %s/%s versus %s/%s.\n", locerrstr,
+			dwarf_diename(die) ? dwarf_diename(die) : "(unnamed)",
+			type_ref->module_name, type_ref->file_name, module_name,
+			file_name);
+#else
+		fprintf(stderr, "%s: Internal error: lookup of %s found in different "
+			"file.\n", locerrstr,
+			dwarf_diename(die) ? dwarf_diename(die) : "(unnamed)");
+#endif
+		fprintf(stderr, "detect_duplicates() is probably buggy.\n");
+		exit(1);
+	}
+
+	return type_ref->ctf_id;
+}
+
+/* Assembly functions.  */
+
+#define CTF_DW_ENFORCE(attribute) do 						\
+		if (!private_dwarf_hasattr(die, (DW_AT_##attribute))) {		\
+			fprintf(stderr, "%s: %s: %lx: skipping type, %s attribute not "	\
+				"present.\n", locerrstr, __func__,		\
+				(unsigned long) dwarf_dieoffset(die), #attribute); \
+			*skip = SKIP_ABORT;					\
+			return CTF_ERROR_REPORTED;				\
+		}								\
+	while (0)
+
+#define CTF_DW_ENFORCE_NOT(attribute) do					\
+		if (private_dwarf_hasattr(die, (DW_AT_##attribute))) {		\
+			fprintf(stderr, "%s: %s: %lx: skipping type, %s attribute not "	\
+				"supported.\n", locerrstr, __func__,		\
+				(unsigned long) dwarf_dieoffset(die), #attribute); \
+			*skip = SKIP_ABORT;					\
+			return CTF_ERROR_REPORTED;				\
+		}								\
+	while (0)
+
+/*
+ * A CTF assembly filter function which excludes all types not at the global
+ * scope (i.e. whose immediate parent is not a CU DIE) and which does not have a
+ * structure or union as its ultimate dependent type.  (All structures and
+ * unions and everything dependent on them must be recorded, even inside
+ * functions, because GCC may emit references to the opaque variants of those
+ * types from file scope.)
+ */
+static int filter_ctf_file_scope(Dwarf_Die *die, Dwarf_Die *parent_die)
+{
+	/*
+	 * Find the ultimate parent of this DIE.
+	 */
+
+	Dwarf_Die dependent_die;
+	Dwarf_Die *dependent_diep = private_dwarf_type(die, &dependent_die);
+
+	if (dependent_diep != NULL) {
+		Dwarf_Die *possible_depp = dependent_diep;
+		do {
+			Dwarf_Die possible_dep;
+			possible_depp = private_dwarf_type(possible_depp,
+							   &possible_dep);
+
+			if (possible_depp != NULL)
+				dependent_die = possible_dep;
+		} while (possible_depp != NULL);
+	}
+
+	if (dependent_diep)
+		return (dwarf_tag(dependent_diep) == DW_TAG_structure_type ||
+			dwarf_tag(dependent_diep) == DW_TAG_union_type ||
+			dwarf_tag(dependent_diep) == DW_TAG_enumeration_type ||
+			dwarf_tag(parent_die) == DW_TAG_compile_unit);
+	else
+		return (dwarf_tag(parent_die) == DW_TAG_compile_unit);
+}
+
+/*
+ * A CTF assembly filter function which excludes all names not at the global
+ * scope, and all names whose names are unlikely to be interesting.  (DTrace
+ * userspace contains a similar list, but the two lists need not be in sync.)
+ */
+static int filter_ctf_uninteresting(Dwarf_Die *die,
+				    Dwarf_Die *parent_die)
+{
+	const char *sym_name = dwarf_diename(die);
+
+	/*
+	 * 'Variables' with no name are not interesting.
+	 */
+	if (sym_name == NULL)
+		return 0;
+
+#define strstarts(var, x) (strncmp(var, x, strlen (x)) == 0)
+	return ((dwarf_tag(parent_die) == DW_TAG_compile_unit) &&
+		!((strcmp(sym_name, "__per_cpu_start") == 0) ||
+		  (strcmp(sym_name, "__per_cpu_end") == 0) ||
+		  (strcmp(sym_name, "_sdt_probes") == 0) ||
+		  (strstarts(sym_name, "__crc_")) ||
+		  (strstarts(sym_name, "__ksymtab_")) ||
+		  (strstarts(sym_name, "__kcrctab_")) ||
+		  (strstarts(sym_name, "__kstrtab_")) ||
+		  (strstarts(sym_name, "__param_")) ||
+		  (strstarts(sym_name, "__syscall_meta__")) ||
+		  (strstarts(sym_name, "__p_syscall_meta__")) ||
+		  (strstarts(sym_name, "__event_")) ||
+		  (strstarts(sym_name, "event_")) ||
+		  (strstarts(sym_name, "ftrace_event_")) ||
+		  (strstarts(sym_name, "types__")) ||
+		  (strstarts(sym_name, "args__")) ||
+		  (strstarts(sym_name, "__tracepoint_")) ||
+		  (strstarts(sym_name, "__tpstrtab_")) ||
+		  (strstarts(sym_name, "__tpstrtab__")) ||
+		  (strstarts(sym_name, "__initcall_")) ||
+		  (strstarts(sym_name, "__setup_")) ||
+		  (strstarts(sym_name, "__pci_fixup_")) ||
+		  (strstr(sym_name, ".") != NULL)));
+#undef strstarts
+}
+
+/*
+ * Assemble base types.
+ */
+static ctf_id_t assemble_ctf_base(const char *module_name,
+				  const char *file_name, Dwarf_Die *die,
+				  Dwarf_Die *parent_die, ctf_file_t *ctf,
+				  ctf_id_t parent_ctf_id, const char *locerrstr,
+				  die_override_t *overrides,
+				  int top_level_type, enum skip_type *skip,
+				  int *replace)
+{
+	typedef ctf_id_t (*ctf_add_fun)(ctf_file_t *, uint_t,
+					const char *, const ctf_encoding_t *);
+
+	const char *name = dwarf_diename(die);
+	Dwarf_Word encoding, size;
+	ctf_add_fun ctf_add_func;
+	ctf_encoding_t ctf_encoding;
+	size_t encoding_search;
+	die_override_t *bit_size_override, *bit_offset_override;
+
+	struct dwarf_encoding_tab {
+		Dwarf_Word encoding;
+		ctf_add_fun func;
+		uint_t encoding_fixed;
+		struct type_encoding_tab *size_lookup;
+	};
+
+	struct type_encoding_tab float_encoding[] =
+		{{sizeof (float), CTF_FP_SINGLE },
+		 {sizeof (double), CTF_FP_DOUBLE },
+		 {sizeof (long double), CTF_FP_LDOUBLE },
+		 {0, 0}};
+
+	struct type_encoding_tab float_cplx_encoding[] =
+		{{sizeof (float), CTF_FP_CPLX },
+		 {sizeof (double), CTF_FP_DCPLX },
+		 {sizeof (long double), CTF_FP_LDCPLX },
+		 {0, 0}};
+
+	struct type_encoding_tab float_imagry_encoding[] =
+		{{sizeof (float), CTF_FP_IMAGRY },
+		 {sizeof (double), CTF_FP_DIMAGRY },
+		 {sizeof (long double), CTF_FP_LDIMAGRY },
+		 {0, 0}};
+
+	struct dwarf_encoding_tab all_encodings[] =
+		{{DW_ATE_boolean, ctf_add_integer, CTF_INT_BOOL, NULL},
+		 {DW_ATE_signed, ctf_add_integer, CTF_INT_SIGNED, NULL},
+		 {DW_ATE_signed_char, ctf_add_integer,
+		  CTF_INT_SIGNED | CTF_INT_CHAR, NULL},
+		 {DW_ATE_unsigned, ctf_add_integer, 0, NULL},
+		 {DW_ATE_unsigned_char, ctf_add_integer, CTF_INT_CHAR, NULL},
+		 {DW_ATE_float, ctf_add_float, 0, float_encoding},
+		 {DW_ATE_complex_float, ctf_add_float, 0, float_cplx_encoding},
+		 {DW_ATE_imaginary_float, ctf_add_float, 0,
+		  float_imagry_encoding},
+		 {0, 0, 0, 0}};
+
+	CTF_DW_ENFORCE(name);
+	CTF_DW_ENFORCE(encoding);
+	CTF_DW_ENFORCE(byte_size);
+	CTF_DW_ENFORCE_NOT(endianity);
+
+	encoding = private_dwarf_udata(die, DW_AT_encoding, overrides);
+	size = private_dwarf_udata(die, DW_AT_byte_size, overrides);
+
+	for (encoding_search = 0; all_encodings[encoding_search].func != 0;
+	     encoding_search++) {
+		if (all_encodings[encoding_search].encoding == encoding) {
+			ctf_add_func = all_encodings[encoding_search].func;
+			if (all_encodings[encoding_search].size_lookup != NULL)
+				ctf_encoding.cte_format =
+					find_ctf_encoding(all_encodings[encoding_search].size_lookup,
+							  size);
+			else
+				ctf_encoding.cte_format =
+					all_encodings[encoding_search].encoding_fixed;
+			break;
+		}
+	}
+
+	if (all_encodings[encoding_search].func == 0) {
+		fprintf(stderr, "%s: skipping type, base type %li "
+			"not yet implemented.\n", locerrstr, (long) encoding);
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	/*
+	 * Handle bitfields.  Only look at overrides, since bitfields can only
+	 * be members of structures in C, thus derived from the referencing DIE.
+	 * Bitfields are never top-level types in C, even though they are in
+	 * DWARF.
+	 */
+	bit_size_override = private_find_override(die, DW_AT_bit_size,
+						  overrides);
+	bit_offset_override = private_find_override(die, DW_AT_bit_offset,
+						    overrides);
+	if (bit_size_override) {
+		ctf_encoding.cte_bits = bit_size_override->value;
+		top_level_type = 0;
+	} else
+		ctf_encoding.cte_bits = size * 8;
+
+	if (bit_offset_override) {
+#if __BYTE_ORDER == __BIG_ENDIAN
+		ctf_encoding.cte_offset = bit_offset_override->value;
+#else
+		/*
+		 * The figure here counts from the left to the leftmost edge of
+		 * the bitfield: we want to count from the right to the
+		 * rightmost edge.
+		 */
+		ctf_encoding.cte_offset = (size * 8) -
+			bit_offset_override->value - ctf_encoding.cte_bits;
+		dw_ctf_trace("Endianizing cte_offset from %x to %x\n", bit_offset_override->value,
+			     ctf_encoding.cte_offset);
+#endif
+	} else
+		ctf_encoding.cte_offset = 0;
+
+
+	return ctf_add_func(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			    name, &ctf_encoding);
+}
+
+/*
+ * Assemble pointer types.
+ */
+static ctf_id_t assemble_ctf_pointer(const char *module_name,
+				     const char *file_name,
+				     Dwarf_Die *die, Dwarf_Die *parent_die,
+				     ctf_file_t *ctf, ctf_id_t parent_ctf_id,
+				     const char *locerrstr,
+				     die_override_t *overrides,
+				     int top_level_type,
+				     enum skip_type *skip, int *replace)
+{
+	ctf_id_t type_ref;
+
+	if ((type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+					locerrstr)) < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	/*
+	 * Pointers to functions are all the same type in CTF: don't bother
+	 * adding it over again.
+	 */
+	if (type_ref == ctf_funcptr_type)
+		return type_ref;
+
+	return ctf_add_pointer(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			       type_ref);
+}
+
+/*
+ * Assemble array types.  This function looks up the array type, but does not do
+ * any array construction: that is left to assemble_ctf_array_dimension().
+ */
+static ctf_id_t assemble_ctf_array(const char *module_name,
+				   const char *file_name, Dwarf_Die *die,
+				   Dwarf_Die *parent_die, ctf_file_t *ctf,
+				   ctf_id_t parent_ctf_id,
+				   const char *locerrstr,
+				   die_override_t *overrides,
+				   int top_level_type,
+				   enum skip_type *skip, int *replace)
+{
+	ctf_id_t type_ref;
+
+	CTF_DW_ENFORCE_NOT(name);
+	CTF_DW_ENFORCE_NOT(ordering);
+	CTF_DW_ENFORCE_NOT(bit_stride);
+	CTF_DW_ENFORCE_NOT(byte_stride);
+
+	if ((type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+					locerrstr)) < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+	return type_ref;
+}
+
+/*
+ * Assemble an array dimension, wrapping an array round the parent_ctf_id and
+ * replacing it.
+ */
+static ctf_id_t assemble_ctf_array_dimension(const char *module_name,
+					     const char *file_name,
+					     Dwarf_Die *die,
+					     Dwarf_Die *parent_die,
+					     ctf_file_t *ctf,
+					     ctf_id_t parent_ctf_id,
+					     const char *locerrstr,
+					     die_override_t *overrides,
+					     int top_level_type,
+					     enum skip_type *skip,
+					     int *replace)
+{
+	ctf_arinfo_t arinfo;
+
+	CTF_DW_ENFORCE_NOT(bit_size);
+	CTF_DW_ENFORCE_NOT(byte_size);
+	CTF_DW_ENFORCE_NOT(bit_stride);
+	CTF_DW_ENFORCE_NOT(byte_stride);
+	CTF_DW_ENFORCE_NOT(lower_bound);
+	CTF_DW_ENFORCE_NOT(threads_scaled);
+
+	arinfo.ctr_contents = parent_ctf_id;
+
+	if ((arinfo.ctr_index = lookup_ctf_type(module_name, file_name, die,
+						ctf, locerrstr)) < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	arinfo.ctr_nelems = private_subrange_dimensions(die);
+
+	/*
+	 * For each array dimension, construct an appropriate array of the
+	 * type-so-far, overriding the parent type.
+	 */
+
+	*replace = 1;
+	return ctf_add_array(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			     &arinfo);
+}
+
+/*
+ * Assemble an enumeration.
+ */
+static ctf_id_t assemble_ctf_enumeration(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *die,
+					 Dwarf_Die *parent_die,
+					 ctf_file_t *ctf,
+					 ctf_id_t parent_ctf_id,
+					 const char *locerrstr,
+					 die_override_t *overrides,
+					 int top_level_type,
+					 enum skip_type *skip,
+					 int *replace)
+{
+	const char *name = dwarf_diename(die);
+
+	return ctf_add_enum(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			    name);
+}
+
+/*
+ * Assemble an enumeration value.
+ */
+static ctf_id_t assemble_ctf_enumerator(const char *module_name,
+					const char *file_name,
+					Dwarf_Die *die,
+					Dwarf_Die *parent_die,
+					ctf_file_t *ctf,
+					ctf_id_t parent_ctf_id,
+					const char *locerrstr,
+					die_override_t *overrides,
+					int top_level_type,
+					enum skip_type *skip,
+					int *replace)
+{
+	const char *name = dwarf_diename(die);
+	Dwarf_Word value;
+	int err;
+
+	CTF_DW_ENFORCE(name);
+	CTF_DW_ENFORCE(const_value);
+	CTF_DW_ENFORCE_NOT(bit_stride);
+	CTF_DW_ENFORCE_NOT(byte_stride);
+
+	value = private_dwarf_udata(die, DW_AT_const_value, overrides);
+	err = ctf_add_enumerator(ctf, parent_ctf_id, name, value);
+
+	if (err != 0)
+		return err;
+
+	return parent_ctf_id;
+}
+
+/*
+ * Assemble a typedef.
+ */
+static ctf_id_t assemble_ctf_typedef(const char *module_name,
+				     const char *file_name,
+				     Dwarf_Die *die,
+				     Dwarf_Die *parent_die,
+				     ctf_file_t *ctf,
+				     ctf_id_t parent_ctf_id,
+				     const char *locerrstr,
+				     die_override_t *overrides,
+				     int top_level_type,
+				     enum skip_type *skip,
+				     int *replace)
+{
+	const char *name = dwarf_diename(die);
+	ctf_id_t type_ref;
+
+	CTF_DW_ENFORCE(name);
+
+	if ((type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+					locerrstr)) < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	return ctf_add_typedef(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			       name, type_ref);
+}
+
+/*
+ * Assemble a const/volatile/restrict qualifier.
+ */
+static ctf_id_t assemble_ctf_cvr_qual(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *die,
+				      Dwarf_Die *parent_die,
+				      ctf_file_t *ctf,
+				      ctf_id_t parent_ctf_id,
+				      const char *locerrstr,
+				      die_override_t *overrides,
+				      int top_level_type,
+				      enum skip_type *skip,
+				      int *replace)
+{
+	ctf_id_t (*ctf_cvr_fun)(ctf_file_t *, uint_t, ctf_id_t);
+	ctf_id_t type_ref;
+
+	switch (dwarf_tag(die)) {
+	case DW_TAG_const_type: ctf_cvr_fun = ctf_add_const; break;
+	case DW_TAG_volatile_type: ctf_cvr_fun = ctf_add_volatile; break;
+	case DW_TAG_restrict_type: ctf_cvr_fun = ctf_add_restrict; break;
+	default:
+		fprintf(stderr, "%s: internal error: assemble_ctf_cvr_qual() "
+			"called with non-const/volatile/restrict: %i\n",
+			locerrstr, dwarf_tag(die));
+		exit(1);
+	}
+
+	if ((type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+					locerrstr)) < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	return ctf_cvr_fun(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			   type_ref);
+}
+
+/*
+ * Assemble a structure or union type.  This assembles only the type itself, not
+ * its constituent members: that is done by assemble_ctf_su_member().
+ *
+ * We assume that if a structure or union type is discovered with more members
+ * than an earlier-discovered type, that it is compatible with that earlier type
+ * and a superset of it.
+ *
+ * FIXME: in debug mode we should not assume this.
+ */
+static ctf_id_t assemble_ctf_struct_union(const char *module_name,
+					  const char *file_name,
+					  Dwarf_Die *die,
+					  Dwarf_Die *parent_die,
+					  ctf_file_t *ctf,
+					  ctf_id_t parent_ctf_id,
+					  const char *locerrstr,
+					  die_override_t *overrides,
+					  int top_level_type,
+					  enum skip_type *skip,
+					  int *replace)
+{
+	ctf_id_t (*ctf_add_sou)(ctf_file_t *, uint_t, const char *);
+
+	const char *name = dwarf_diename(die);
+	int is_union = (dwarf_tag(die) == DW_TAG_union_type);
+	ctf_memb_count_t *member_count = NULL;
+	ctf_id_t id;
+
+	/*
+	 * FIXME: these both need handling for DWARF4 support.
+	 */
+	CTF_DW_ENFORCE_NOT(specification);
+	CTF_DW_ENFORCE_NOT(signature);
+
+	/*
+	 * Possibly we should ignore this entire structure, if we already know
+	 * of one with the same name and at least as many members.  If we
+	 * already know of one and it is shorter, we want to use its ID rather
+	 * than creating a new one.
+	 *
+	 * Note; by this point, the deduplicator has long run: thus we know for
+	 * sure what module a potentially-shared type will end up in, and
+	 * there's no need to double-check the shared CTF repository for types.
+	 * We also know that the module must exist in the per_module hash.
+	 */
+
+	if (name != NULL) {
+		char *structized_name = NULL;
+		per_module_t *ctf_pm;
+
+		structized_name = str_appendn(structized_name,
+					      is_union ? "u " : "s ",
+					      name, NULL);
+
+		ctf_pm = g_hash_table_lookup(per_module, module_name);
+		member_count = g_hash_table_lookup(ctf_pm->member_counts,
+						   structized_name);
+
+		if (member_count) {
+			free(structized_name);
+			dw_ctf_trace("%s: already exists (with ID %li) with "
+				     "%zi members versus current %li members\n",
+				     locerrstr, member_count->ctf_id,
+				     member_count->count,
+				     count_dwarf_members(die));
+
+			if (member_count->count < count_dwarf_members(die))
+				return member_count->ctf_id;
+
+			*skip = SKIP_SKIP;
+			return member_count->ctf_id;
+		}
+
+		/*
+		 * Not in existence yet.  Create it.
+		 */
+		member_count = malloc(sizeof(struct ctf_memb_count));
+		if (member_count == NULL) {
+			fprintf(stderr, "Out of memory allocating "
+				"structure/union member count\n");
+			exit(1);
+		}
+		member_count->count = 0;
+		g_hash_table_insert(ctf_pm->member_counts,
+				    structized_name, member_count);
+	}
+
+	dw_ctf_trace("%s: adding structure %s\n", locerrstr, name);
+	if (is_union)
+		ctf_add_sou = ctf_add_union;
+	else
+		ctf_add_sou = ctf_add_struct;
+
+	id = ctf_add_sou(ctf, top_level_type ? CTF_ADD_ROOT : CTF_ADD_NONROOT,
+			 name);
+
+	if (member_count != NULL)
+		member_count->ctf_id = id;
+
+	return id;
+}
+
+/*
+ * Assemble a structure or union member.
+ *
+ * We only assemble a member of a given name if a member by that name does not
+ * already exist, and if the member is not blacklisted.
+ */
+static ctf_id_t assemble_ctf_su_member(const char *module_name,
+				       const char *file_name,
+				       Dwarf_Die *die,
+				       Dwarf_Die *parent_die,
+				       ctf_file_t *ctf,
+				       ctf_id_t parent_ctf_id,
+				       const char *locerrstr,
+				       die_override_t *overrides,
+				       int top_level_type,
+				       enum skip_type *skip,
+				       int *replace)
+{
+	ulong_t offset = 0;
+	ulong_t bit_offset = 0;
+	ctf_full_id_t *new_type;
+	Dwarf_Attribute type_attr;
+	Dwarf_Die type_die;
+	Dwarf_Die cu_die;
+	die_override_t *o;
+	ctf_memb_count_t *member_count;
+	const char *struct_name = dwarf_diename(parent_die);
+
+	CTF_DW_ENFORCE(type);
+
+	/*
+	 * Increment the member count of named structures.  This is the number
+	 * of members in the DWARF, not in the CTF: blacklisted members are
+	 * counted too.
+	 */
+	if (struct_name != NULL) {
+		int is_union = (dwarf_tag(parent_die) == DW_TAG_union_type);
+		char *structized_name = NULL;
+		per_module_t *ctf_pm;
+
+		structized_name = str_appendn(structized_name,
+					      is_union ? "u " : "s ",
+					      struct_name, NULL);
+
+		ctf_pm = g_hash_table_lookup(per_module, module_name);
+		member_count = g_hash_table_lookup(ctf_pm->member_counts,
+						   structized_name);
+		member_count->count++;
+		free(structized_name);
+	}
+
+	/*
+	 * If this member is blacklisted, just skip it.
+	 */
+	if (member_blacklisted(die, parent_die)) {
+		dw_ctf_trace("%s: blacklisted, skipping.\n", locerrstr);
+		return parent_ctf_id;
+	}
+
+	/*
+	 * Find the associated type so we can either add a member with that type
+	 * (if it is named) or add its members directly (for unnamed types,
+	 * which must be unnamed structs/unions).
+	 */
+	private_dwarf_attr(die, DW_AT_type, &type_attr);
+	if (dwarf_formref_die(&type_attr, &type_die) == NULL) {
+		fprintf(stderr, "%s: nonexistent type reference. "
+			"Corrupted DWARF, cannot continue.\n", locerrstr);
+		exit(1);
+	}
+	dwarf_diecu(&type_die, &cu_die, NULL, NULL);
+
+	/*
+	 * Figure out the offset of this type, in bits.  (This is split in two
+	 * for bitfields, where the bitfield itself gets represented elsewhere,
+	 * in the CTF type of the member itself.)
+	 *
+	 * DW_AT_data_bit_offset is the simple case.  DW_AT_data_member_location
+	 * is trickier, and, alas, the DWARF2 variation is the complex one.
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_data_bit_offset))
+		offset = private_dwarf_udata(die, DW_AT_data_bit_offset, NULL);
+	else if (private_dwarf_hasattr(die, DW_AT_data_member_location)) {
+		Dwarf_Attribute location_attr;
+
+		private_dwarf_attr(die, DW_AT_data_member_location,
+				   &location_attr);
+
+		switch (dwarf_whatform(&location_attr)) {
+		case DW_FORM_data1:
+		case DW_FORM_data2:
+		case DW_FORM_data4:
+		case DW_FORM_data8:
+		case DW_FORM_udata:
+		case DW_FORM_sdata:
+		{
+			/*
+			 * Byte offset, with bit_offset of containing
+			 * structure/union added, if present.
+			 *
+			 * (No overrides supported here, yet, due to lack of
+			 * sdata overrides and the desire for consistency.
+			 * We can add them if we start passing down
+			 * DW_AT_data_member_location overrides.)
+			 */
+			if (dwarf_whatform(&location_attr) == DW_FORM_sdata) {
+				Dwarf_Sword location;
+
+				dwarf_formsdata(&location_attr, &location);
+				offset = location * 8;
+			} else {
+				Dwarf_Word location;
+
+				dwarf_formudata(&location_attr, &location);
+				offset = location * 8;
+			}
+			break;
+		}
+		case DW_FORM_block1:
+		case DW_FORM_block2:
+		case DW_FORM_block4:
+		{
+			Dwarf_Op *location;
+			size_t nlocs;
+
+			/*
+			 * DWARF 2 block-based data_member_location.  This can
+			 * be quite complicated in some situations (notably C++
+			 * virtual bases), but for normal structure members it
+			 * is simple.  FIXME for userspace tracing of C++.
+			 *
+			 * This is thoroughly specific to the forms of DWARF2
+			 * emitted by GCC.  We don't need to feel guilty about
+			 * this because elfutils does just the same thing.
+			 */
+
+			if (dwarf_getlocation(&location_attr, &location,
+					      &nlocs) < 0) {
+				fprintf(stderr, "%s: offset not a valid "
+					"location expression: %s\n", locerrstr,
+					dwarf_errmsg(dwarf_errno()));
+				*skip = SKIP_ABORT;
+				return CTF_ERROR_REPORTED;
+			}
+
+			if ((nlocs != 1) ||
+			    ((location[0].atom != DW_OP_plus_uconst) &&
+			     (location[0].atom != DW_OP_constu))) {
+				fprintf(stderr, "%s: complex location lists "
+					"not supported: either C++ or non-GCC "
+					"output: skipped\n", locerrstr);
+				*skip = SKIP_ABORT;
+				return CTF_ERROR_REPORTED;
+			}
+
+			offset = location[0].number * 8;
+			break;
+		}
+		case DW_FORM_exprloc:
+		{
+			/*
+			 * We need a full DWARF expression list interpreter to
+			 * handle this.
+			 */
+			fprintf(stderr, "DWARF 4 expression location lists "
+				"not supported.\n");
+			exit(1);
+		}
+		default:
+		{
+			fprintf(stderr, "%s: expression location lists in "
+				"form %u not supported.\n", locerrstr,
+				dwarf_whatform(&location_attr));
+			exit(1);
+		}
+		}
+
+		/*
+		 * Handle the bit offset.
+		 */
+		if (private_dwarf_hasattr(die, DW_AT_bit_offset)) {
+			Dwarf_Attribute bit_attr;
+			Dwarf_Word bit;
+
+			private_dwarf_attr(die, DW_AT_bit_offset,
+					   &bit_attr);
+			dwarf_formudata(&bit_attr, &bit);
+			bit_offset = bit;
+		}
+
+	}
+
+	/*
+	 * Handle the offset value override.  It does not matter which method
+	 * has been used to get the value.  At this point offset is always
+	 * the bit distance of the member from the structure/union start.
+	 *
+	 * The DW_AT_data_bit_offset override is always used to pass the offset
+	 * around, so that we don't need to add special override handling for
+	 * various forms of the DW_AT_data_member_location as a special case.
+	 * This is safe as it is not possible to have both attributes attached
+	 * to the same DIE per the DWARF4 standard, and if we have one attached
+	 * as an override to a DIE that has the other, we will only ever need to
+	 * use one (since no DIE can be both an unnamed struct/union and a
+	 * bitfield at the same time).
+	 */
+	if ((o = private_find_override(die, DW_AT_data_bit_offset,
+				       overrides)) != NULL) {
+		if (o->op == DIE_OVERRIDE_REPLACE)
+			offset = o->value;
+		else
+			offset += o->value;
+	}
+
+	/*
+	 * If this is an unnamed struct/union, call directly back to
+	 * die_to_ctf() to add this struct's members to the current structure,
+	 * merging it seamlessly with its parent (excepting only the member
+	 * offsets).  Use DW_AT_data_bit_offset because it does not require
+	 * the complexity of DW_AT_data_member_location to be faked.
+	 */
+	if (!private_dwarf_hasattr(die, DW_AT_name)) {
+		Dwarf_Die child_die;
+		int dummy = 0;
+
+		if ((dwarf_tag(&type_die) != DW_TAG_structure_type) &&
+		    (dwarf_tag(&type_die) != DW_TAG_union_type)) {
+			fprintf(stderr, "%s:%lx: not supported: anonymous "
+			    "structure member not a structure or union.\n",
+			    locerrstr, (unsigned long) dwarf_dieoffset(die));
+			*skip = SKIP_ABORT;
+			return CTF_ERROR_REPORTED;
+		}
+
+		/*
+		 * Anonymous structure or union with no members. Silently skip.
+		 */
+		if (dwarf_child(&type_die, &child_die) < 0)
+			return parent_ctf_id;
+
+		/*
+		 * Add override that will adjust offset of the anonymous
+		 * struct/union members during inlining.  The bit_offset is
+		 * ignored here as it is not expected that a nested
+		 * structure/union will start on a non-byte-aligned boundary.
+		 */
+		die_override_t o[] = {{ dwarf_tag(&child_die),
+					DW_AT_data_bit_offset,
+					DIE_OVERRIDE_ADD,
+					offset }, {0} };
+
+		die_to_ctf(module_name, file_name, &child_die, parent_die, ctf,
+			   parent_ctf_id, o, 0, 0, skip, &dummy, NULL);
+
+		return parent_ctf_id;
+	}
+
+	/*
+	 * Get the CTF ID of this member's type, by recursive lookup.
+	 *
+	 * If this is a bitfield, we want to note that said type's size and
+	 * bit-offset should be adjusted.
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_bit_size)) {
+		die_override_t o[] =
+			{{ dwarf_tag(&type_die),
+			   DW_AT_bit_size,
+			   DIE_OVERRIDE_REPLACE,
+			   private_dwarf_udata(die, DW_AT_bit_size,
+					       NULL) },
+			 { dwarf_tag(&type_die),
+			   DW_AT_bit_offset,
+			   DIE_OVERRIDE_REPLACE,
+			   bit_offset },
+			 {0} };
+
+		new_type = construct_ctf_id(module_name, file_name, &type_die,
+					    &cu_die, o);
+	} else {
+		if (bit_offset != 0) {
+			fprintf(stderr, "%s:%s: error in member %s: No "
+				"DW_AT_bit_size, but nonzero bit offset of "
+				"%lx in overall offset of %lx\n", locerrstr,
+				dwarf_diename(&cu_die), dwarf_diename(die),
+				bit_offset, offset);
+			return CTF_ERROR_REPORTED;
+		}
+		new_type = construct_ctf_id(module_name, file_name, &type_die,
+					    &cu_die, NULL);
+	}
+
+	if (new_type == NULL) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	if ((new_type->ctf_file != ctf) &&
+	    (new_type->ctf_file != lookup_ctf_file("shared_ctf"))) {
+		fprintf(stderr, "%s:%s: internal error: referenced type lookup "
+			"for member %s yields a different CTF file: %p versus "
+			"%p\n", locerrstr, dwarf_diename(&cu_die),
+			dwarf_diename(die), ctf, new_type->ctf_file);
+		fprintf(stderr, "detect_duplicates() is probably buggy.\n");
+		exit(1);
+	}
+
+	if (ctf_add_member_offset(ctf, parent_ctf_id, dwarf_diename(die),
+				  new_type->ctf_id, offset) < 0) {
+		/*
+		 * If we have seen this member before, as part of another
+		 * definition somewhere else, that's fine.  We cannot recurse
+		 * from this point, so we can just return the parent CTF ID, the
+		 * ID of the containing structure.
+		 */
+		if (ctf_errno(ctf) == ECTF_DUPLICATE)
+			return parent_ctf_id;
+
+		/*
+		 * CTF doesn't know of of either this member's type or the
+		 * enclosing structure.  Try a ctf_update() in case this is
+		 * recently added.
+		 */
+
+		if (ctf_errno(ctf) == ECTF_BADID ||
+		    ctf_errno(ctf) == ECTF_NOTSOU) {
+
+			ctf_file_t *shared_ctf;
+
+			/*
+			 * Try an update of the current CTF file first, to bring
+			 * the type ID table up to date: if that doesn't work,
+			 * try an update of the shared table.  (If none is
+			 * needed, this is cheap.)
+			 */
+
+			if (ctf_update(new_type->ctf_file) < 0) {
+				fprintf(stderr, "Cannot update CTF file: %s\n",
+					ctf_errmsg(ctf_errno(ctf)));
+				exit(1);
+			}
+
+			if (ctf_add_member_offset(ctf, parent_ctf_id,
+						  dwarf_diename(die),
+						  new_type->ctf_id,
+						  offset) == 0)
+				return parent_ctf_id;
+
+			shared_ctf = lookup_ctf_file("shared_ctf");
+			if (ctf_update(shared_ctf) < 0) {
+				fprintf(stderr, "Cannot update shared CTF: %s\n",
+					ctf_errmsg(ctf_errno(shared_ctf)));
+				exit(1);
+			}
+
+			if (ctf_add_member_offset(ctf, parent_ctf_id,
+						  dwarf_diename(die),
+						  new_type->ctf_id,
+						  offset) == 0)
+				return parent_ctf_id;
+#ifdef DEBUG
+			fprintf(stderr, "%s: Internal error: %s %s:%s:%p:%i "
+				"on member addition to ctf_file %p.\n",
+				locerrstr, ctf_errmsg(ctf_errno(ctf)),
+				new_type->module_name,
+				new_type->file_name, new_type->ctf_file,
+				(int) new_type->ctf_id, ctf);
+#else
+			fprintf(stderr, "%s: Internal error: %s %p:%i on "
+				"member addition to ctf_file %p.\n",
+				locerrstr, ctf_errmsg(ctf_errno(ctf)),
+				new_type->ctf_file, (int) new_type->ctf_id,
+				ctf);
+#endif
+			return CTF_ERROR_REPORTED;
+		}
+
+		/*
+		 * Another error: not fine.
+		 */
+		return CTF_NO_ERROR_REPORTED;
+	}
+
+	return parent_ctf_id;
+}
+
+/*
+ * Assemble a variable.
+ */
+static ctf_id_t assemble_ctf_variable(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *die,
+				      Dwarf_Die *parent_die,
+				      ctf_file_t *ctf,
+				      ctf_id_t parent_ctf_id,
+				      const char *locerrstr,
+				      die_override_t *overrides,
+				      int top_level_type,
+				      enum skip_type *skip,
+				      int *replace)
+{
+	const char *name = dwarf_diename(die);
+	char *blacklist_name = NULL;
+	ctf_id_t type_ref;
+	int err;
+
+	CTF_DW_ENFORCE(name);
+
+	/*
+	 * If blacklisted, just skip it.
+	 */
+	blacklist_name = str_appendn(blacklist_name, module_name, "`",
+				     dwarf_diename(die), NULL);
+	if (g_hash_table_lookup_extended(variable_blacklist, blacklist_name,
+					 NULL, NULL)) {
+		dw_ctf_trace("%s: variable %s is blacklisted for static/non-"
+			     "static ambiguity.\n", file_name, blacklist_name);
+		free(blacklist_name);
+		return 0;
+	}
+	free(blacklist_name);
+
+	if ((type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+					locerrstr)) < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	/*
+	 * This isn't a type: full DWARF child recursion and type-id addition is
+	 * not called for.
+	 */
+	*skip = SKIP_SKIP;
+
+	err = ctf_add_variable(ctf, name, type_ref);
+
+	if (err == 0)
+		dw_ctf_trace("%p: Added variable %s, type %i\n", ctf, name,
+			     (int)type_ref);
+
+	/*
+	 * Variable references to opaque versus non-opaque structures could only
+	 * get deduplicated with yet another deduplication pass.  This seems
+	 * pointlessly expensive when nothing can refer to them: just skip
+	 * duplicates instead.
+	 */
+	if ((err < 0) && (ctf_errno(ctf) == ECTF_DUPLICATE))
+		return 0;
+
+	return err;
+
+}
+
+/* Writeout.  */
+
+static void write_types(char *output, int standalone)
+{
+	GHashTableIter module_iter;
+	char *module;
+	per_module_t *per_mod;
+	ctf_file_t **ctfs;
+	const char **names;
+	size_t i = 0;
+	size_t ctf_count = g_hash_table_size(per_module);
+
+	/*
+	 * Work over all the modules and write their compressed CTF data out.
+	 * Standalone modules get placed in files in the output directory named
+	 * with names ending in .mod.ctf.new, and the makefile moves .ctf.new
+	 * over the top of .ctf iff it has changed; built-in modules and the
+	 * core kernel and shared type repository are placed into a CTF archive.
+	 */
+	if (standalone) {
+		if ((mkdir(output, 0777) < 0) && errno != EEXIST) {
+			fprintf(stderr, "Cannot create .ctf directory: %s\n",
+				strerror(errno));
+			exit(1);
+		}
+	} else {
+		ctfs = calloc(ctf_count, sizeof (ctf_file_t *));
+		names = calloc(ctf_count, sizeof (char *));
+		if (!ctfs || !names) {
+			fprintf (stderr, "Out of memory in CTF writeout\n");
+		}
+	}
+
+	/*
+	 * Write the files out (in standalone mode), or construct the arrays of
+	 * module names and files to put in the archive (otherwise).
+	 */
+	g_hash_table_iter_init(&module_iter, per_module);
+	while (g_hash_table_iter_next(&module_iter, (void **) &module,
+				      (void **)&per_mod)) {
+		int fd;
+
+		dw_ctf_trace("Writing out %s\n", module);
+
+		if (ctf_update(per_mod->ctf_file) < 0) {
+			fprintf(stderr, "Cannot serialize CTF file %s: %s\n",
+				module, ctf_errmsg(ctf_errno(per_mod->ctf_file)));
+			exit(1);
+		}
+
+		if (!standalone) {
+			names[i] = module;
+			ctfs[i] = per_mod->ctf_file;
+			i++;
+		} else {
+			char *path = NULL;
+			path = str_appendn(path, output, "/", module,
+					   ".mod.ctf.new", NULL);
+
+			if ((fd = open(path, O_WRONLY | O_CREAT | O_TRUNC |
+				       O_CLOEXEC, 0666)) < 0) {
+				fprintf(stderr, "Cannot open CTF file %s for "
+					"writing: %s\n", path,
+					strerror(errno));
+				exit(1);
+			}
+			if (ctf_compress_write(per_mod->ctf_file, fd) < 0) {
+				fprintf(stderr, "Cannot write to CTF file %s: "
+					"%s\n", path,
+					ctf_errmsg(ctf_errno(per_mod->ctf_file)));
+				exit(1);
+			}
+			if (close(fd) != 0) {
+				fprintf(stderr, "Cannot close CTF file %s: %s\n",
+					path, strerror(errno));
+				exit(1);
+			}
+			free(path);
+		}
+	}
+
+	if (!standalone) {
+		int err;
+		if ((err = ctf_arc_write(output, ctfs, ctf_count,
+					 names, 4096) != 0)) {
+			fprintf(stderr, "Cannot write to CTF archive %s: %s\n",
+				output, err < ECTF_BASE ? strerror(err) :
+				ctf_errmsg(err));
+			exit(1);
+		}
+		free(names);
+		free(ctfs);
+	}
+}
+
+/* Utilities.  */
+
+/*
+ * Given a DIE that may contain a type attribute, look up the target of that
+ * attribute and return it, or NULL if none.
+ */
+static Dwarf_Die *private_dwarf_type(Dwarf_Die *die, Dwarf_Die *target_die)
+{
+	Dwarf_Attribute type_ref_attr;
+
+	if (private_dwarf_attr(die, DW_AT_type, &type_ref_attr) != NULL) {
+		if (dwarf_formref_die(&type_ref_attr, target_die) == NULL) {
+			fprintf(stderr, "Corrupt DWARF at offset %lx: ref with "
+				"no target.\n",
+				(unsigned long) dwarf_dieoffset(die));
+			exit(1);
+		}
+		return target_die;
+	}
+
+	return NULL;
+}
+
+/*
+ * Check for existence of an attribute in a DIE, chasing through
+ * DW_AT_specification if need be.
+ */
+static inline int private_dwarf_hasattr(Dwarf_Die *die,
+					unsigned int search_name)
+{
+	int hasattr = 0;
+	Dwarf_Attribute spec_ref_attr;
+	Dwarf_Die spec_die;
+
+	/*
+	 * DW_AT_declaration is not forwarded, because non-declarations can
+	 * reference declarations via DW_AT_specification, without implying that
+	 * the referencing DIE is a declaration.
+	 */
+	hasattr = dwarf_hasattr(die, search_name);
+	if (hasattr || (search_name == DW_AT_declaration))
+		return hasattr;
+
+	if (dwarf_attr(die, DW_AT_specification, &spec_ref_attr) != NULL) {
+		if (dwarf_formref_die(&spec_ref_attr, &spec_die) == NULL) {
+			fprintf(stderr, "Corrupt DWARF at offset %lx: ref with "
+				"no target.\n",
+				(unsigned long) dwarf_dieoffset(die));
+			exit(1);
+		}
+		return dwarf_hasattr(&spec_die, search_name);
+	}
+	return hasattr;
+}
+
+/*
+ * Return a DIE attribute, chasing through DW_AT_specification if need be.
+ */
+static inline Dwarf_Attribute *private_dwarf_attr(Dwarf_Die *die,
+						  unsigned int search_name,
+						  Dwarf_Attribute *result)
+{
+	Dwarf_Attribute spec_ref_attr;
+	Dwarf_Die spec_die;
+	Dwarf_Attribute *ret;
+
+	ret = dwarf_attr(die, search_name, result);
+	if (ret != NULL || (search_name == DW_AT_declaration))
+		return ret;
+
+	if (dwarf_attr(die, DW_AT_specification, &spec_ref_attr) != NULL) {
+		if (dwarf_formref_die(&spec_ref_attr, &spec_die) == NULL) {
+			fprintf(stderr, "Corrupt DWARF at offset %lx: ref with "
+				"no target.\n",
+				(unsigned long) dwarf_dieoffset(die));
+			exit(1);
+		}
+		return dwarf_attr(&spec_die, search_name, result);
+	}
+
+	return NULL;
+}
+
+/*
+ * Given a DIE that contains a udata attribute, look up that attribute and
+ * return its value (optionally overridden or modified by the die_overrides).
+ */
+static inline Dwarf_Word private_dwarf_udata(Dwarf_Die *die, int attribute,
+					     die_override_t *overrides)
+{
+	Dwarf_Attribute attr;
+	Dwarf_Word value;
+	die_override_t *override;
+
+	override = private_find_override(die, attribute, overrides);
+
+	if (override && override->op == DIE_OVERRIDE_REPLACE)
+		return override->value;
+
+	private_dwarf_attr(die, attribute, &attr);
+	dwarf_formudata(&attr, &value);
+
+	if (override)
+		value += override->value;
+
+	return value;
+}
+
+/*
+ * Find an override in an override list.
+ */
+static die_override_t *private_find_override(Dwarf_Die *die,
+					     int attribute,
+					     die_override_t *overrides)
+{
+	size_t i;
+
+	if (overrides == NULL)
+	    return NULL;
+
+	for (i = 0; overrides[i].tag != 0; i++)
+		if ((overrides[i].tag == dwarf_tag(die)) &&
+		    (overrides[i].attribute == attribute))
+			return &overrides[i];
+
+	return NULL;
+}
+
+/*
+ * Determine the dimensions of an array subrange, or 0 if variable.
+ */
+static Dwarf_Word private_subrange_dimensions(Dwarf_Die *die)
+{
+	int flexible_array = 0;
+	Dwarf_Attribute nelem_attr;
+	Dwarf_Word nelems;
+
+	if (((private_dwarf_attr(die, DW_AT_upper_bound, &nelem_attr) == NULL) &&
+	     (private_dwarf_attr(die, DW_AT_count, &nelem_attr) == NULL)) ||
+	    (!private_dwarf_hasattr(die, DW_AT_type)))
+		flexible_array = 1;
+
+	if (!flexible_array)
+		switch (dwarf_whatform(&nelem_attr)) {
+		case DW_FORM_data1:
+		case DW_FORM_data2:
+		case DW_FORM_data4:
+		case DW_FORM_data8:
+		case DW_FORM_udata:
+			break;
+		default:
+			flexible_array = 1;
+		}
+
+	if (flexible_array)
+		return 0;
+
+	dwarf_formudata(&nelem_attr, &nelems);
+
+	/*
+	 * Upper bounds indicate that we have one more element than that, since
+	 * C starts counting at zero.
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_upper_bound))
+		nelems++;
+
+	return nelems;
+}
+
+/*
+ * An error checking strdup().
+ */
+static char *xstrdup(const char *s)
+{
+	char *s2 = strdup(s);
+
+	if (s2 == NULL) {
+		fprintf(stderr, "Out of memory\n");
+		exit(1);
+	}
+
+	return s2;
+}
+
+/*
+ * A string appender working on dynamic strings.
+ */
+static char *str_append(char *s, const char *append)
+{
+	size_t s_len = 0;
+
+	if (append == NULL)
+		return s;
+
+	if (s != NULL)
+		s_len = strlen(s);
+
+	size_t append_len = strlen(append);
+
+	s = realloc(s, s_len + append_len + 1);
+
+	if (s == NULL) {
+		fprintf(stderr, "Out of memory appending a string of length "
+			"%li to a string of length %li\n", strlen(append),
+			s_len);
+		exit(1);
+	}
+
+	memcpy(s + s_len, append, append_len);
+	s[s_len+append_len]='\0';
+
+	return s;
+}
+
+/*
+ * A vararg string appender.
+ */
+static char *str_appendn(char *s, ...)
+{
+	va_list ap;
+	const char *append;
+	size_t len, s_len = 0;
+
+	va_start(ap, s);
+	if (s)
+		s_len = strlen(s);
+	len = s_len;
+
+	append = va_arg(ap, const char *);
+	while (append != NULL) {
+		len += strlen(append);
+		append = va_arg(ap, char *);
+	}
+	va_end(ap);
+
+	s = realloc(s, len + 1);
+	if (s == NULL) {
+		fprintf(stderr, "Out of memory appending a string of length "
+			"%li to a string of length %li\n", strlen(append),
+			s_len);
+		exit(1);
+	}
+
+	va_start(ap, s);
+	append = va_arg(ap, const char *);
+	while (append != NULL) {
+		size_t append_len = strlen(append);
+
+		memcpy(s + s_len, append, append_len);
+		s_len += append_len;
+
+		append = va_arg(ap, char *);
+	}
+	s[len] = '\0';
+	va_end(ap);
+
+	return s;
+}
+
+/*
+ * Filter a GList, calling a predicate on it and removing all elements for which
+ * the predicate returns true, calling the free_func on them if set.
+ */
+static GList *list_filter(GList *list, filter_pred_fun fun,
+			  GDestroyNotify free_func, void *data)
+{
+	GList *cur = list;
+	while (cur) {
+		GList *next = cur->next;
+		if (fun(cur->data, data)) {
+			if (free_func)
+				free_func(cur->data);
+			list = g_list_delete_link(list, cur);
+		}
+		cur = next;
+	}
+
+	return list;
+}
+
+/*
+ * Figure out the (pathless, suffixless) module name for a given module file (.o
+ * or .ko), and return it in a new dynamically allocated string.
+ *
+ * Takes the object_to_module mapping into account.
+ */
+static char *fn_to_module(const char *file_name)
+{
+	char *module_name;
+	char *chop, *dash;
+
+	module_name = g_hash_table_lookup(object_to_module, file_name);
+	if (module_name != NULL)
+		return xstrdup(module_name);
+
+	if ((chop = strrchr(file_name, '/')) != NULL)
+		module_name = xstrdup(++chop);
+	else
+		module_name = xstrdup(file_name);
+
+	if ((chop = strrchr(module_name, '.')) != NULL)
+		*chop = '\0';
+
+	dash = module_name;
+	while (dash != NULL) {
+		dash = strchr(dash, '-');
+		if (dash != NULL)
+			*dash = '_';
+	}
+
+	return module_name;
+}
+
+/*
+ * Determine, and cache, absolute filenames.  This is called in very hot
+ * paths, notably type_id(), and must be kept fast.
+ */
+static const char *abs_file_name(const char *file_name)
+{
+	static GHashTable *abs_file_names;
+	const char *abs_name;
+
+	if (abs_file_names == NULL)
+		abs_file_names = g_hash_table_new_full(g_str_hash, g_str_equal,
+		    free, free);
+
+	abs_name = g_hash_table_lookup(abs_file_names, file_name);
+
+	if (abs_name == NULL) {
+		char abspath[PATH_MAX] = "";
+
+		if (realpath(file_name, abspath) == NULL)
+			strcpy(abspath, file_name);
+		g_hash_table_replace(abs_file_names,
+		    xstrdup(file_name), xstrdup(abspath));
+
+		abs_name = g_hash_table_lookup(abs_file_names, file_name);
+	}
+
+	return abs_name;
+}
+
+/*
+ * Determine absolute filenames relative to some other directory.  This does not
+ * need to be fast.  The returned name is dynamically allocated, and must be
+ * freed by the caller.
+ */
+static char *rel_abs_file_name(const char *file_name, const char *relative_to)
+{
+	int dir = -1;
+	static int warned = 0;
+	char *abspath;
+	/*
+	 * If we can't get this name relatively, we might as well *try* to do it
+	 * absolutely: but print a warning.
+	 */
+	if ((dir = open(".", O_RDONLY | O_DIRECTORY)) < 0) {
+		if (!warned) {
+			fprintf(stderr, "Cannot open current directory: %s\n",
+				strerror(errno));
+			warned = 1;
+		}
+	} else {
+		if (chdir(relative_to) < 0)
+			if (!warned) {
+				fprintf(stderr, "Cannot change "
+					"directory to %s: %s\n",
+					relative_to, strerror(errno));
+				warned = 1;
+			}
+	}
+
+	abspath = realpath(file_name, NULL);
+	if (abspath == NULL)
+		abspath = xstrdup(file_name);
+
+	if ((dir > -1) && (fchdir(dir) < 0)) {
+		fprintf(stderr, "Cannot return to original directory "
+			"after relative realpath(): %s\n",
+			strerror(errno));
+		exit(1);
+	}
+
+	close(dir);
+
+	return abspath;
+}
+
+/*
+ * Given a type encoding table, and a size, return the CTF encoding for that
+ * type, or 0 if none.
+ */
+static int find_ctf_encoding(struct type_encoding_tab *type_tab, size_t size)
+{
+	size_t i;
+
+	for (i = 0; type_tab[i].size != 0; i++) {
+		if (type_tab[i].size == size)
+			return type_tab[i].ctf_encoding;
+	}
+	return 0;
+}
+
+/*
+ * Count the number of members of a DWARF aggregate.
+ */
+static long count_dwarf_members(Dwarf_Die *d)
+{
+	const char *err;
+	Dwarf_Die die;
+
+	switch (dwarf_child(d, &die)) {
+	case -1:
+		err = "fetch first child of aggregate";
+		goto fail;
+	case 1: /* No DIEs at all in this aggregate */
+		return 0;
+	default: /* Child DIEs exist.  */
+		break;
+	}
+
+	/*
+	 * We are only interested in children of type DW_TAG_member.
+	 */
+	int sib_ret;
+	long count = 0;
+
+	do
+		if (dwarf_tag(&die) == DW_TAG_member)
+			count++;
+	while ((sib_ret = dwarf_siblingof(&die, &die)) == 0);
+
+	if (sib_ret == -1) {
+		err = "count members";
+		goto fail;
+	}
+
+	return count;
+
+ fail:
+	fprintf(stderr, "Cannot %s: %s\n", err, dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * Free a per_module's contents.
+ */
+static void private_per_module_free(void *per_module)
+{
+	per_module_t *per_mod = per_module;
+
+	ctf_close(per_mod->ctf_file);
+	g_hash_table_destroy(per_mod->member_counts);
+	free(per_module);
+}
+
+/*
+ * Get a ctf_file out of the per_module hash for a given module.
+ */
+static ctf_file_t *lookup_ctf_file(const char *module_name)
+{
+	per_module_t *per_mod;
+
+	per_mod = g_hash_table_lookup(per_module, module_name);
+	if (per_mod == NULL)
+		return NULL;
+	return per_mod->ctf_file;
+}
diff --git a/scripts/dwarf2ctf/eu_simple.c b/scripts/dwarf2ctf/eu_simple.c
new file mode 100644
index 000000000000..66d821e462b7
--- /dev/null
+++ b/scripts/dwarf2ctf/eu_simple.c
@@ -0,0 +1 @@
+#include "../eu_simple.c"
diff --git a/scripts/dwarf2ctf/member.blacklist b/scripts/dwarf2ctf/member.blacklist
new file mode 100644
index 000000000000..85122def7b5f
--- /dev/null
+++ b/scripts/dwarf2ctf/member.blacklist
@@ -0,0 +1 @@
+include/linux/netfilter/ipset/ip_set_ahash.h:ip_set_hash.next
diff --git a/scripts/eu_simple.c b/scripts/eu_simple.c
new file mode 100644
index 000000000000..f0416ef9115c
--- /dev/null
+++ b/scripts/eu_simple.c
@@ -0,0 +1,379 @@
+/*
+ * Convenience wrappers for functions in elfutils.
+ *
+ * (C) 2014, 2017 Oracle, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <elfutils/libdwfl.h>
+#include <elfutils/version.h>
+
+#include <eu_simple.h>
+
+#ifndef __GNUC__
+#define __attribute__((foo))
+#endif
+
+#define __unused__ __attribute__((__unused__))
+
+/*
+ * A version of dwfl_report_elf() that compensates for parameter changes in
+ * newer elfutils.
+ */
+static Dwfl_Module *private_dwfl_report_elf(Dwfl *dwfl, const char *name,
+					    const char *file_name, int fd,
+					    GElf_Addr base)
+{
+#if _ELFUTILS_PREREQ(0,156)
+	return dwfl_report_elf(dwfl, name, file_name, fd, base, 0);
+#else
+	return dwfl_report_elf(dwfl, name, file_name, fd, base);
+#endif
+}
+
+/*
+ * Stub libdwfl callback, use only the ELF handle passed in.
+ */
+static int no_debuginfo(Dwfl_Module *mod __unused__,
+			void **userdata __unused__,
+			const char *modname __unused__,
+			Dwarf_Addr base __unused__,
+			const char *file_name __unused__,
+			const char *debuglink_file __unused__,
+			GElf_Word debuglink_crc __unused__,
+			char **debuginfo_file_name __unused__)
+{
+	return -1;
+}
+
+/*
+ * Wrap up dwfl_new() complexities.
+ */
+Dwfl *simple_dwfl_new(const char *file_name, Dwfl_Module **module)
+{
+	const char *err;
+	static Dwfl_Callbacks cb = { .find_debuginfo = no_debuginfo,
+				     .section_address = dwfl_offline_section_address };
+	Dwfl *dwfl = dwfl_begin(&cb);
+	Dwfl_Module *mod;
+
+	if (dwfl == NULL) {
+		err = "initialize libdwfl";
+		goto fail;
+	}
+
+	mod = private_dwfl_report_elf(dwfl, "", file_name, -1, 0);
+	if (mod == NULL) {
+		err = "open object file with libdwfl";
+		goto fail;
+	}
+	if (module)
+		*module = mod;
+
+	if (dwfl_report_end(dwfl, NULL, NULL) != 0) {
+		err = "finish opening object file with libdwfl";
+		goto fail;
+	}
+
+	return dwfl;
+ fail:
+	fprintf(stderr, "Cannot %s for %s: %s\n", err, file_name,
+		dwfl_errmsg(dwfl_errno()));
+	exit(1);
+}
+
+/*
+ * A variant of simple_dwfl_new() that iterates over multiple object files.
+ * (Used for thin archives.)
+ *
+ * Takes ownership of the paths, until free.
+ */
+struct simple_dwfl_multi *
+simple_dwfl_new_multi(char **paths)
+{
+	struct simple_dwfl_multi *multi;
+
+	multi = malloc(sizeof (struct simple_dwfl_multi));
+	if (multi == NULL)
+		return NULL;
+
+	multi->paths = paths;
+	multi->i = -1;
+	multi->dwfl = NULL;
+	multi->last_die = NULL;
+
+	return multi;
+}
+
+/*
+ * A variant of dwfl_nextcu() that crosses file boundaries as needed,
+ * using the state in the simple_dwfl_multi.
+ */
+Dwarf_Die *
+simple_dwfl_nextcu(struct simple_dwfl_multi *multi)
+{
+	Dwarf_Addr junk;
+
+	/*
+	 * Switch object files as needed (and always, the first time).
+	 */
+
+	if (multi->i >= 0)
+		multi->last_die = dwfl_nextcu(multi->dwfl, multi->last_die, &junk);
+
+	while (multi->last_die == NULL) {
+		simple_dwfl_free(multi->dwfl);
+		if (multi->paths[++multi->i] == NULL) {
+			multi->i = -1;
+			multi->dwfl = NULL;
+			multi->last_die = NULL;
+			return NULL;
+		}
+
+		multi->dwfl = simple_dwfl_new(multi->paths[multi->i], NULL);
+		multi->last_die = dwfl_nextcu(multi->dwfl, multi->last_die,
+					      &junk);
+	}
+	return multi->last_die;
+}
+
+/*
+ * Free a simple_dwfl_new_multi: return its contained paths so the caller can
+ * free them again.  (They are not changed, so the caller can just hang on to
+ * them if preferred.)
+ */
+char **
+simple_dwfl_free_multi(struct simple_dwfl_multi *multi)
+{
+	char **paths = multi->paths;
+	simple_dwfl_free(multi->dwfl);
+	free(multi);
+	return paths;
+}
+
+/*
+ * The converse of simple_dwfl_new().
+ */
+void simple_dwfl_free(Dwfl *dwfl)
+{
+	if (dwfl != NULL) {
+		dwfl_report_end(dwfl, NULL, NULL);
+		dwfl_end(dwfl);
+	}
+}
+
+
+/*
+ * Read a modules_thick.builtin file and translate it into a stream of
+ * arguments suitable for simple_dwfl_new_multi().
+ */
+
+/*
+ * Construct a modules_thick.builtin iterator.
+ */
+struct modules_thick_iter *
+modules_thick_iter_new(const char *modules_thick_file)
+{
+	struct modules_thick_iter *i;
+
+	i = calloc(1, sizeof (struct modules_thick_iter));
+	if (i == NULL)
+		return NULL;
+
+	i->f = fopen(modules_thick_file, "r");
+
+	if (i->f == NULL) {
+		fprintf(stderr, "Cannot open builtin module file %s: "
+			"%s\n", modules_thick_file, strerror(errno));
+		return NULL;
+	}
+
+	return i;
+}
+
+/*
+ * Iterate, returning a new null-terminated array of object
+ * file names, and a new dynamically-allocated module name.
+ * (The module name passed in is freed.)
+ */
+
+char **  __attribute__((__nonnull__))
+modules_thick_iter_next(struct modules_thick_iter *i,
+    char **module_name)
+{
+	char **last_module_paths = NULL;
+
+	/*
+	 * Reinvocation of exhausted iterator. Return NULL, once.
+	 */
+	if (i->module_npaths < 0) {
+		i->module_npaths = 0;
+		return NULL;
+	}
+
+	/*
+	 * Read in all module entries, computing the suffixless, pathless name
+	 * of the module and building the next arrayful of object file names for
+	 * return.
+	 *
+	 * Modules can consist of multiple files: in this case, the line
+	 * contains a colon, and the portion before it is the path to the module
+	 * (as before): the portion after the colon is a file that should be
+	 * considered part of this module.  All files that are part of a given
+	 * module are consecutive in the file, with the same module path.
+	 * All module names have - translated to _, to match what is done to
+	 * the names of the same things when built as modules.
+	 *
+	 * Note that we do not know the value of the current arrayful until we
+	 * have read the *next* line, or (if it was the last) until we have hit
+	 * the end of the file.  This makes the logic in the loop somewhat
+	 * contorted (the desire to not repeat this contortion in multiple
+	 * places is why this function exists at all).
+	 */
+
+	while (getline(&i->line, &i->line_size, i->f) >= 0) {
+		char *last_slash;
+		char *last_dot;
+		char *trailing_linefeed;
+		char *object_name = i->line;
+		char *dash;
+
+		if (i->line[0] == '\0')
+			continue;
+
+		/*
+		 * Slice the line in two at the multifile separator, if any.
+		 */
+		if (strchr(i->line, ':') != NULL) {
+			object_name = strchr(i->line, ':');
+			*object_name = '\0';
+			object_name++;
+		}
+
+		/*
+		 * Figure out the module name.
+		 */
+		last_slash = strrchr(i->line, '/');
+		last_slash = (!last_slash) ? i->line :
+		    last_slash + 1;
+		free(*module_name);
+		*module_name = strdup(last_slash);
+		dash = *module_name;
+
+		while (dash != NULL) {
+			dash = strchr(dash, '-');
+			if (dash != NULL)
+				*dash = '_';
+		}
+
+		last_dot = strrchr(*module_name, '.');
+		if (last_dot != NULL)
+			*last_dot = '\0';
+
+		trailing_linefeed = strchr(object_name, '\n');
+		if (trailing_linefeed != NULL)
+			*trailing_linefeed = '\0';
+
+		/*
+		 * Module name changed?  Remember that we have to return a bunch
+		 * of module names, and stash them, and the last module name
+		 * away: we will be returning them this time.
+		 *
+		 * Check for multifileness in multiple ways, to prevent
+		 * buggy duplicate single-file module names from causing null
+		 * pointer dereferences.
+		 */
+		if (i->module_paths != NULL &&
+		    (i->last_module_name == NULL ||
+		     strcmp(i->last_module_name, *module_name) != 0)) {
+			char *swap;
+
+			swap = i->last_module_name;
+			i->last_module_name = *module_name;
+			*module_name = swap;
+			last_module_paths = i->module_paths;
+			i->module_paths = NULL;
+			i->module_npaths = 0;
+			/*
+			 * module_name now holds the name from the last pass:
+			 * the name that we will return.
+			 */
+		} else if (i->last_module_name == NULL) {
+			/*
+			 * First pass? Note the last module name.
+			 *
+			 * Dup it because we are sure to do a second loop, and
+			 * we do not want to free the last module name by
+			 * accident (since only in this case does it alias
+			 * *module_name).
+			 */
+			i->last_module_name = strdup(*module_name);
+		}
+
+		/*
+		 * Add the entry just read to module_paths.
+		 */
+
+		i->module_npaths++;
+		i->module_paths = realloc(i->module_paths,
+					  (i->module_npaths + 1) *
+					  sizeof (char *));
+		if (!i->module_paths) {
+			fprintf(stderr, "out of memory\n");
+			exit(1);
+		}
+		i->module_paths[i->module_npaths - 1] = strdup(object_name);
+		i->module_paths[i->module_npaths] = NULL;
+
+		/*
+		 * If we have a complete set of paths waiting to go, send them
+		 * out.
+		 */
+		if (last_module_paths)
+			return last_module_paths;
+	}
+	if (ferror(i->f)) {
+		fprintf(stderr, "Error reading from modules_thick file: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+	rewind(i->f);
+
+	/*
+	 * There will be one lingering module to send back, if any modules were
+	 * read at all. (If not, this will just return NULL.)
+	 */
+	free(*module_name);
+	*module_name = i->last_module_name;
+	last_module_paths = i->module_paths;
+	i->module_paths = NULL;
+	i->module_npaths = -1;
+	return last_module_paths;
+}
+
+/*
+ * Free an iterator. Can be called while iteration is underway, so even
+ * state that is freed at the end of iteration must be freed here too.
+ */
+void
+modules_thick_iter_free(struct modules_thick_iter *i)
+{
+	size_t j;
+	if (i == NULL)
+		return;
+	fclose(i->f);
+	free(i->line);
+	for (j = 0; j < i->module_npaths; j++)
+		free(i->module_paths[j]);
+	free(i->module_paths);
+	free(i);
+}
diff --git a/scripts/eu_simple.h b/scripts/eu_simple.h
new file mode 100644
index 000000000000..de674ff397ab
--- /dev/null
+++ b/scripts/eu_simple.h
@@ -0,0 +1,94 @@
+/*
+ * Simplifying wrappers for functions in elfutils, and functions to
+ * feed them data.
+ *
+ * (C) 2014, 2017 Oracle, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _LINUX_EU_SIMPLE_H
+#define _LINUX_EU_SIMPLE_H
+
+#include <stdio.h>
+#include <stddef.h>
+#include <elfutils/libdwfl.h>
+
+/*
+ * Iteration state for simple_dwfl_new_multi().
+ */
+struct simple_dwfl_multi
+{
+	char **paths;
+	ssize_t i;
+	Dwfl *dwfl;
+	Dwarf_Die *last_die;
+};
+
+/*
+ * Wrap up dwfl_new() complexities.
+ */
+Dwfl *simple_dwfl_new(const char *file_name, Dwfl_Module **module);
+
+/*
+ * A variant of simple_dwfl_new() that iterates over multiple object files.
+ * (Used for thin archives.)
+ *
+ * Takes ownership of the paths, until free.
+ */
+struct simple_dwfl_multi *simple_dwfl_new_multi(char **paths);
+
+/*
+ * A variant of dwfl_nextcu() that crosses file boundaries as needed,
+ * using the state in the simple_dwfl_multi.
+ */
+Dwarf_Die *simple_dwfl_nextcu(struct simple_dwfl_multi *multi);
+
+/*
+ * Free a simple_dwfl_new_multi: return its contained paths so the caller
+ * free them again.  (They are not changed, so the caller can just hang on to
+ * them if preferred.)
+ */
+char **simple_dwfl_free_multi(struct simple_dwfl_multi *multi);
+
+/*
+ * The converse of simple_dwfl_new().
+ */
+void simple_dwfl_free(Dwfl *dwfl);
+
+/*
+ * modules_thick.builtin iteration state.
+ */
+struct modules_thick_iter {
+	FILE *f;
+	char *line;
+	size_t line_size;
+
+	char *last_module_name;
+	ssize_t module_npaths;
+	char **module_paths;
+};
+
+/*
+ * Construct a modules_thick.builtin iterator.
+ */
+struct modules_thick_iter *
+modules_thick_iter_new(const char *modules_thick_file);
+
+/*
+ * Iterate, returning a new null-terminated array of object
+ * file names, and a new dynamically-allocated module name.
+ * (The module name passed in is freed.)
+ */
+
+char ** __attribute__((__nonnull__))
+modules_thick_iter_next(struct modules_thick_iter *i,
+    char **module_name);
+
+void
+modules_thick_iter_free(struct modules_thick_iter *i);
+
+#endif
diff --git a/scripts/kallsyms.c b/scripts/kallsyms.c
index 9ee9bf7fd1a2..b0b1b177658a 100644
--- a/scripts/kallsyms.c
+++ b/scripts/kallsyms.c
@@ -5,7 +5,10 @@
  * This software may be used and distributed according to the terms
  * of the GNU General Public License, incorporated herein by reference.
  *
- * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols] > symbols.S
+ * Usage: nm -n vmlinux | scripts/kallsyms [--all-symbols]
+ *                                         [--symbol-prefix=<prefix char>]
+ *                                         [--builtin=modules_thick.builtin]
+ *                                         > symbols.S
  *
  *      Table compression uses all the unused char codes on the symbols and
  *  maps these to the most used substrings (tokens). For instance, it might
@@ -18,11 +21,26 @@
  *
  */
 
+#define _GNU_SOURCE 1
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <limits.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "../include/generated/autoconf.h"
+
+#ifdef CONFIG_KALLMODSYMS
+#include <libelf.h>
+#include <dwarf.h>
+#include <elfutils/libdwfl.h>
+#include <elfutils/libdw.h>
+#include <glib.h>
+
+#include <eu_simple.h>
+#endif
 
 #ifndef ARRAY_SIZE
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))
@@ -36,6 +54,7 @@ struct sym_entry {
 	unsigned int start_pos;
 	unsigned char *sym;
 	unsigned int percpu_absolute;
+	unsigned int module;
 };
 
 struct addr_range {
@@ -71,12 +90,34 @@ int token_profit[0x10000];
 unsigned char best_table[256][2];
 unsigned char best_table_len[256];
 
+#ifdef CONFIG_KALLMODSYMS
+/*
+ * The list of builtin module names.
+ */
+static char **builtin_modules;
+static unsigned int builtin_module_size, builtin_module_len;
+
+/*
+ * A mapping from symbol name to the index of the module it is part of in the
+ * builtin_modules list.  Symbols within the same module share pointers to the
+ * same index allocation (thus this is nearly impossible to free safely, but
+ * quite space-efficient).
+ */
+static GHashTable *symbol_to_module;
+#endif
+
+/*
+ * For each builtin module, its offset from the start of the builtin_module
+ * list, assuming consecutive placement.
+ */
+static unsigned int *builtin_module_offsets;
 
 static void usage(void)
 {
 	fprintf(stderr, "Usage: kallsyms [--all-symbols] "
 			"[--symbol-prefix=<prefix char>] "
-			"[--base-relative] < in.map > out.S\n");
+			"[--base-relative] [--builtin=modules_thick.builtin] "
+			"< in.map > out.S\n");
 	exit(1);
 }
 
@@ -115,6 +156,7 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 {
 	char str[500];
 	char *sym, stype;
+	unsigned int *module;
 	int rc;
 
 	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
@@ -161,6 +203,18 @@ static int read_symbol(FILE *in, struct sym_entry *s)
 	else if (stype == 'N' || stype == 'n')
 		return -1;
 
+#ifdef CONFIG_KALLMODSYMS
+	/* look up the builtin module this is part of (if any). */
+	module = g_hash_table_lookup(symbol_to_module, sym);
+#else
+        module = 0;
+#endif
+
+	if (module)
+		s->module = builtin_module_offsets[*module];
+	else
+		s->module = 0;
+
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
 	s->len = strlen(str) + 1;
@@ -213,6 +267,8 @@ static int symbol_valid(struct sym_entry *s)
 		"kallsyms_markers",
 		"kallsyms_token_table",
 		"kallsyms_token_index",
+		"kallsyms_symbol_modules",
+		"kallsyms_modules",
 
 	/* Exclude linker generated symbols which vary between passes */
 		"_SDA_BASE_",		/* ppc */
@@ -471,8 +527,22 @@ static void write_src(void)
 	for (i = 0; i < 256; i++)
 		printf("\t.short\t%d\n", best_idx[i]);
 	printf("\n");
-}
 
+#ifdef CONFIG_KALLMODSYMS
+	output_label("kallsyms_modules");
+	for (i = 0; i < builtin_module_len; i++)
+		printf("\t.asciz\t\"%s\"\n", builtin_modules[i]);
+	printf("\n");
+
+	for (i = 0; i < builtin_module_len; i++)
+		free(builtin_modules[i]);
+
+	output_label("kallsyms_symbol_modules");
+	for (i = 0; i < table_cnt; i++)
+		printf("\t.int\t%d\n", table[i].module);
+	printf("\n");
+#endif
+}
 
 /* table lookup compression functions */
 
@@ -758,12 +828,248 @@ static void record_relative_base(void)
 			relative_base = table[i].addr;
 }
 
+#ifdef CONFIG_KALLMODSYMS
+/* Built-in module list computation. */
+
+/*
+ * Populate the symbol_to_module mapping for one built-in module, while
+ * tracking whether it is known to exist in other modules.
+ */
+static void read_module_symbols(unsigned int module_name_off,
+				struct simple_dwfl_multi *dwfl,
+				GHashTable *module_symbol_seen)
+{
+	Dwarf_Die *tu = NULL;
+	unsigned int *module_idx = NULL;
+	GHashTable *this_module_symbol_seen;
+	GHashTableIter copying_iter;
+	void *copying_name;
+	void *copying_dummy_value;
+
+	this_module_symbol_seen = g_hash_table_new_full(g_str_hash, g_str_equal,
+							free, NULL);
+
+	while ((tu = simple_dwfl_nextcu(dwfl)) != NULL) {
+		Dwarf_Die toplevel;
+		int sib_ret;
+
+		if (dwarf_tag(tu) != DW_TAG_compile_unit) {
+			fprintf(stderr, "Malformed DWARF: non-compile_unit at "
+				"top level in %s.\n", dwfl->paths[dwfl->i]);
+			exit(1);
+		}
+
+		switch (dwarf_child(tu, &toplevel)) {
+		case -1: fprintf(stderr, "Warning: looking for toplevel "
+				 "child of %s in %s: %s\n", dwarf_diename(tu),
+				 dwfl->paths[dwfl->i],
+				 dwarf_errmsg(dwarf_errno()));
+			continue;
+		case 1: /* No DIEs at all in this TU */
+			continue;
+		default: /* Child DIE's exist. */
+			break;
+		}
+
+		do {
+			if (((dwarf_tag(&toplevel) == DW_TAG_subprogram) ||
+                             (dwarf_tag(&toplevel) == DW_TAG_variable)) &&
+                            !dwarf_hasattr(&toplevel, DW_AT_declaration)) {
+				if (module_idx == NULL) {
+					module_idx = malloc(sizeof(unsigned int));
+					if (module_idx == NULL) {
+						fprintf(stderr, "out of memory\n");
+						exit(1);
+					}
+
+					*module_idx = module_name_off;
+				}
+				/*
+				 * If we have never seen this symbol before
+				 * outside of this module, we note that we have
+				 * now seen it in this module, and track it in
+				 * the symbol_to_module mapping.  Otherwise,
+				 * this symbol appears in multiple modules and
+				 * is not a per-module symbol: *remove* it from
+				 * that mapping, if it is present there.
+				 */
+
+				if (!g_hash_table_lookup_extended(module_symbol_seen,
+								  dwarf_diename(&toplevel),
+								  NULL, NULL)) {
+
+					if (!g_hash_table_lookup_extended (symbol_to_module,
+									   dwarf_diename(&toplevel),
+									   NULL, NULL))
+						g_hash_table_insert(symbol_to_module,
+								    strdup(dwarf_diename(&toplevel)),
+								    module_idx);
+
+					if (!g_hash_table_lookup_extended (this_module_symbol_seen,
+									   dwarf_diename(&toplevel),
+									   NULL, NULL))
+						g_hash_table_insert(this_module_symbol_seen,
+								    strdup(dwarf_diename(&toplevel)),
+								    NULL);
+				} else {
+					g_hash_table_remove(symbol_to_module,
+							    dwarf_diename(&toplevel));
+				}
+			}
+		} while ((sib_ret = dwarf_siblingof(&toplevel, &toplevel)) == 0);
+
+		if (sib_ret == -1) {
+			fprintf(stderr, "Warning: Cannot advance to next sibling "
+				"of %s in %s: %s\n", dwarf_diename(&toplevel),
+				dwfl->paths[dwfl->i],
+				dwarf_errmsg(dwarf_errno()));
+		}
+	}
+
+	/*
+	 * Work over all the symbols seen in this module and note that in future
+	 * they are to be considered symbols that were seen in some other
+	 * module.
+	 */
+	g_hash_table_iter_init(&copying_iter, this_module_symbol_seen);
+	while (g_hash_table_iter_next(&copying_iter, &copying_name,
+				      &copying_dummy_value))
+		g_hash_table_insert(module_symbol_seen,
+				    strdup((char *) copying_name), NULL);
+
+	g_hash_table_destroy(this_module_symbol_seen);
+}
+
+/*
+ * Expand the builtin modules list.
+ */
+static void expand_builtin_modules(void)
+{
+	builtin_module_size += 50;
+
+	builtin_modules = realloc(builtin_modules,
+				  sizeof(*builtin_modules) *
+				  builtin_module_size);
+	builtin_module_offsets = realloc(builtin_module_offsets,
+					 sizeof(*builtin_module_offsets) *
+					 builtin_module_size);
+
+	if (!builtin_modules || !builtin_module_offsets) {
+		fprintf(stderr, "out of memory\n");
+		exit(1);
+	}
+}
+
+/*
+ * Add a single built-in module (possibly composed of many files) to the modules
+ * list.  Take the offset of the current module and return it (purely for
+ * simplicity's sake in the caller).
+ */
+static size_t add_builtin_module(const char *module_name,
+				 char **module_paths, size_t offset,
+				 GHashTable *module_symbol_seen)
+{
+	struct simple_dwfl_multi *multi;
+
+	multi = simple_dwfl_new_multi(module_paths);
+	if (multi == NULL) {
+		fprintf(stderr, "Out of memory iterating over %s\n",
+			module_name);
+		exit(1);
+	}
+
+	read_module_symbols(builtin_module_len, multi, module_symbol_seen);
+	simple_dwfl_free_multi(multi);
+
+	if (builtin_module_size >= builtin_module_len)
+		expand_builtin_modules();
+	builtin_modules[builtin_module_len] = strdup(module_name);
+	builtin_module_offsets[builtin_module_len] = offset;
+	offset += strlen(module_name) + 1;
+	builtin_module_len++;
+
+	return offset;
+}
+
+/*
+ * Populate the symbol_to_module mapping for all built-in modules,
+ * and the list of built-in modules itself.
+ */
+static void read_modules(const char *modules_builtin)
+{
+	struct modules_thick_iter *i;
+	size_t offset = 0;
+
+	/*
+	 * A hash containing a mapping from a symbol name if that symbol has
+	 * been seen in any modules so far.  This is used to filter out symbols
+	 * found in more than one built-in module, on the grounds that they are
+	 * probably symbols from the out-of-line representation of inline
+	 * functions in kernel header files shared between modules.
+	 */
+	GHashTable *module_symbol_seen;
+	char *module_name = NULL;
+	char **module_paths;
+	size_t j;
+
+	symbol_to_module = g_hash_table_new_full(g_str_hash, g_str_equal,
+						 free, NULL);
+	module_symbol_seen = g_hash_table_new_full(g_str_hash, g_str_equal,
+						   free, NULL);
+
+	if (symbol_to_module == NULL || module_symbol_seen == NULL) {
+		fprintf(stderr, "Out of memory");
+		exit(1);
+	}
+
+	/*
+	 * builtin_modules[0] is a null entry signifying a symbol that cannot be
+	 * modular.
+	 */
+	builtin_module_size = 50;
+	builtin_modules = malloc(sizeof(*builtin_modules) *
+				 builtin_module_size);
+	builtin_module_offsets = malloc(sizeof(*builtin_module_offsets) *
+				 builtin_module_size);
+	builtin_modules[0] = strdup("");
+	builtin_module_len = 1;
+	offset++;
+
+	/*
+	 * Iterate over all modules in modules_thick.builtin and add each.
+	 */
+	i = modules_thick_iter_new(modules_builtin);
+	if (i == NULL) {
+		fprintf(stderr, "Cannot iterate over builtin modules.\n");
+		exit(1);
+	}
+
+	while ((module_paths = modules_thick_iter_next(i, &module_name)) != NULL) {
+		offset = add_builtin_module(module_name, module_paths,
+					    offset, module_symbol_seen);
+		for (j = 0; module_paths[j] != NULL; j++)
+			free(module_paths[j]);
+		free(module_paths);
+		module_paths = NULL;
+	}
+
+	free(module_name);
+	modules_thick_iter_free(i);
+
+	g_hash_table_destroy(module_symbol_seen);
+}
+#else
+static void read_modules(const char *unused) {}
+#endif /* CONFIG_KALLMODSYMS */
+
 int main(int argc, char **argv)
 {
-	if (argc >= 2) {
+	const char *modules_builtin = "modules_thick.builtin";
+
+	if (argc >= 1) {
 		int i;
 		for (i = 1; i < argc; i++) {
-			if(strcmp(argv[i], "--all-symbols") == 0)
+			if (strcmp(argv[i], "--all-symbols") == 0)
 				all_symbols = 1;
 			else if (strcmp(argv[i], "--absolute-percpu") == 0)
 				absolute_percpu = 1;
@@ -775,12 +1081,15 @@ int main(int argc, char **argv)
 				symbol_prefix_char = *p;
 			} else if (strcmp(argv[i], "--base-relative") == 0)
 				base_relative = 1;
+			else if (strncmp(argv[i], "--builtin=", 10) == 0)
+				modules_builtin = &argv[i][10];
 			else
 				usage();
 		}
 	} else if (argc != 1)
 		usage();
 
+	read_modules(modules_builtin);
 	read_map(stdin);
 	if (absolute_percpu)
 		make_percpus_absolute();
diff --git a/scripts/kmodsdt.c b/scripts/kmodsdt.c
new file mode 100644
index 000000000000..dbd05cab0134
--- /dev/null
+++ b/scripts/kmodsdt.c
@@ -0,0 +1,401 @@
+/*
+ * Copyright 2016 Oracle, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#include "../include/generated/autoconf.h"
+
+#define	ELF_TARGET_ALL
+#include <elf.h>
+#include <gelf.h>
+
+#include <sys/types.h>
+
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <assert.h>
+
+typedef struct symtbl {
+	struct symtbl *next;
+	void *strtab;
+	void *symtab;
+} symtbl_t;
+
+static int
+dt_elf_symtab_lookup(Elf_Data *data_sym, int nsym, uintptr_t addr, uint32_t shn,
+    GElf_Sym *sym)
+{
+	int i, ret = -1;
+	GElf_Sym s;
+
+	for (i = 0; i < nsym && gelf_getsym(data_sym, i, sym) != NULL; i++) {
+		if (GELF_ST_TYPE(sym->st_info) == STT_FUNC &&
+		    shn == sym->st_shndx &&
+		    sym->st_value <= addr &&
+		    addr < sym->st_value + sym->st_size) {
+			if (GELF_ST_BIND(sym->st_info) == STB_GLOBAL)
+				return i;
+
+			ret = i;
+			s = *sym;
+		}
+	}
+
+	if (ret >= 0)
+		*sym = s;
+	return (ret);
+}
+
+static int
+process_obj(const char *obj)
+{
+	static const char dt_ppref[] = "__dtrace_probe_";
+	static const char dt_spref[] = "__dta_";
+	int fd, i, sidx, mod = 0;
+	Elf *elf = NULL;
+	GElf_Ehdr ehdr;
+	Elf_Scn *scn_rel, *scn_sym, *scn_str;
+	Elf_Data *data_rel, *data_sym, *data_str;
+	GElf_Shdr shdr_rel, shdr_sym, shdr_str;
+	GElf_Sym rsym, fsym, dsym;
+	GElf_Rela rela;
+	char *p, *r, *f, *a;
+	uint32_t eclass, emachine1, emachine2;
+	size_t symsize, nsym, nstr, isym, istr, osym, len;
+	symtbl_t *pair, *bufs = NULL;
+	char **alttab;
+	const char *elferrstr = "no error";
+
+	if ((fd = open(obj, O_RDWR)) == -1) {
+		fprintf(stderr, "failed to open %s: %s\n", obj,
+			strerror(errno));
+		return 1;
+	}
+
+	if (elf_version(EV_CURRENT) == EV_NONE) {
+		fprintf(stderr, "ELF library version too old\n");
+		return 1;
+	}
+
+	if ((elf = elf_begin(fd, ELF_C_RDWR, NULL)) == NULL) {
+		fprintf(stderr, "failed to process %s: %s\n", obj,
+			elf_errmsg(elf_errno()));
+		return 1;
+	}
+
+	switch (elf_kind(elf)) {
+	case ELF_K_ELF:
+		break;
+	case ELF_K_AR:
+		fprintf(stderr, "archives are not permitted; %s\n", obj);
+		return 1;
+	default:
+		fprintf(stderr, "invalid file type: %s\n", obj);
+		return 1;
+	}
+
+	if (gelf_getehdr(elf, &ehdr) == NULL) {
+		fprintf(stderr, "corrupt file: %s\n", obj);
+		return 1;
+	}
+
+#ifdef CONFIG_64BIT
+	eclass = ELFCLASS64;
+# if defined(__sparc)
+	emachine1 = emachine2 = EM_SPARCV9;
+# elif defined(__i386) || defined(__amd64)
+	emachine1 = emachine2 = EM_X86_64;
+# elif defined(__aarch64__)
+	emachine1 = emachine2 = EM_AARCH64;
+# endif
+	symsize = sizeof(Elf64_Sym);
+#else
+	eclass = ELFCLASS32;
+# if defined(__sparc)
+	emachine1 = EM_SPARC;
+	emachine2 = EM_SPARC32PLUS;
+# elif defined(__i386) || defined(__amd64)
+	emachine1 = emachine2 = EM_386;
+# elif defined(__arm__)
+	emachine1 = emachine2 = EM_ARM;
+# endif
+	symsize = sizeof(Elf32_Sym);
+#endif
+
+	if (ehdr.e_ident[EI_CLASS] != eclass) {
+		fprintf(stderr, "incorrect ELF class for %s: %d "
+			"(expected %d)\n", obj, ehdr.e_ident[EI_CLASS],
+			eclass);
+		return 1;
+	}
+	if (ehdr.e_machine != emachine1 && ehdr.e_machine != emachine2) {
+		fprintf(stderr, "incorrect ELF machine type for %s: %d "
+			"(expected %d or %d)\n",
+			obj, ehdr.e_machine, emachine1, emachine2);
+		return 1;
+	}
+
+	scn_rel = NULL;
+	while ((scn_rel = elf_nextscn(elf, scn_rel)) != NULL) {
+		if (gelf_getshdr(scn_rel, &shdr_rel) == NULL) {
+			elferrstr = "failed to get section header";
+			goto elf_err;
+		}
+
+		/*
+		 * Skip any non-relocation sections.
+		 */
+		if (shdr_rel.sh_type != SHT_RELA && shdr_rel.sh_type != SHT_REL)
+			continue;
+
+		if ((data_rel = elf_getdata(scn_rel, NULL)) == NULL) {
+			elferrstr = "failed to get relocation data";
+			goto elf_err;
+		}
+
+		/*
+		 * Grab the section, section header and section data for the
+		 * symbol table that this relocation section references.
+		 */
+		if ((scn_sym = elf_getscn(elf, shdr_rel.sh_link)) == NULL ||
+		    gelf_getshdr(scn_sym, &shdr_sym) == NULL ||
+		    (data_sym = elf_getdata(scn_sym, NULL)) == NULL) {
+			elferrstr = "failed to get symbol table";
+			goto elf_err;
+		}
+
+		/*
+		 * Ditto for that symbol table's string table.
+		 */
+		if ((scn_str = elf_getscn(elf, shdr_sym.sh_link)) == NULL ||
+		    gelf_getshdr(scn_str, &shdr_str) == NULL ||
+		    (data_str = elf_getdata(scn_str, NULL)) == NULL) {
+			elferrstr = "failed to get string table";
+			goto elf_err;
+		}
+
+		/*
+		 * We're looking for relocations to symbols matching this form:
+		 *
+		 *   __dtrace_probe_<probe>
+		 *
+		 * If the function containing the probe is locally scoped
+		 * (static), we create an alias.  The alias, a new symbol,
+		 * will be global (so that it can be referenced from sdtinfo
+		 * entries) and hidden (so that it is converted to a local
+		 * symbol at link time). Such aliases have this form:
+		 *
+		 *   __dta_<function>_<symindex>
+		 *
+		 * The <symindex> is appended to ensure that aliases are unique
+		 * because they are referenced in global scope.  Two local
+		 * functions with identical names need to be distrinct at the
+		 * level of the aliases.
+		 *
+		 * We take a first pass through all the relocations to
+		 * populate our string table and count the number of extra
+		 * symbols we'll require.  Note that the <function> is
+		 * sanitized to ensure that it is a valid C identifier, i.e.
+		 * any periods in the name are converted to underscores.
+		 */
+		isym = osym = data_sym->d_size / symsize;
+		istr = data_str->d_size;
+
+		/*
+		 * Allocate the alias table to be the exact same size as the
+		 * symtab.  If an alias is required for a specific symbol, its
+		 * corresponding entry in this alias table will contain the
+		 * alias name.  Otherwise, the entry will be NULL.
+		 */
+		alttab = (char **)calloc(isym, sizeof(char *));
+
+		nsym = 0;
+		nstr = 0;
+
+		for (i = 0; i < shdr_rel.sh_size / shdr_rel.sh_entsize; i++) {
+			if (shdr_rel.sh_type == SHT_RELA) {
+				if (gelf_getrela(data_rel, i, &rela) == NULL)
+					continue;
+			} else {
+				GElf_Rel rel;
+				if (gelf_getrel(data_rel, i, &rel) == NULL)
+					continue;
+				rela.r_offset = rel.r_offset;
+				rela.r_info = rel.r_info;
+				rela.r_addend = 0;
+			}
+
+			if (gelf_getsym(data_sym, GELF_R_SYM(rela.r_info),
+					&rsym) == NULL) {
+				elferrstr = "relocation symbol not found";
+				goto elf_err;
+			}
+
+			assert(rsym.st_name < data_str->d_size);
+
+			r = (char *)data_str->d_buf + rsym.st_name;
+			if (strncmp(r, dt_ppref, sizeof(dt_ppref) - 1) != 0)
+				continue;
+
+			sidx = dt_elf_symtab_lookup(data_sym, isym,
+						    rela.r_offset,
+						    shdr_rel.sh_info, &fsym);
+			if (sidx < 0) {
+				fprintf(stderr, "relocation %x not in "
+					"function\n", i);
+				goto err;
+			}
+
+			assert(fsym.st_name < data_str->d_size);
+			assert(GELF_ST_TYPE(fsym.st_info) == STT_FUNC);
+
+			if (GELF_ST_BIND(fsym.st_info) != STB_LOCAL)
+				continue;
+
+			f = (char *)data_str->d_buf + fsym.st_name;
+
+			if (alttab[sidx] != NULL)
+				continue;
+
+			len = snprintf(NULL, 0, "%s%s_%d", dt_spref, f, sidx)
+			      + 1;
+			a = malloc(len);
+			assert(a != NULL);
+			nstr += snprintf(a, len, "%s%s_%d", dt_spref, f, sidx)
+				 + 1;
+			for (p = a; *p != '\0'; p++) {
+				if (*p == '.')
+					*p = '_';
+			}
+			alttab[sidx] = a;
+			nsym++;
+		}
+
+		if (!nsym) {
+			free(alttab);
+			continue;
+		}
+
+		if ((pair = malloc(sizeof(symtbl_t))) == NULL) {
+			fprintf(stderr, "failed to alloc new symtbl\n");
+			goto err;
+		}
+		if ((pair->strtab = malloc(data_str->d_size + nstr)) == NULL) {
+			fprintf(stderr, "failed to alloc new symtbl->strtab\n");
+			free(pair);
+			goto err;
+		}
+		if ((pair->symtab =
+		     malloc(data_sym->d_size + nsym * symsize)) == NULL) {
+			fprintf(stderr, "failed to alloc new symtbl->symtab\n");
+			free(pair->strtab);
+			free(pair);
+			goto err;
+		}
+
+		pair->next = bufs;
+		bufs = pair;
+
+		memcpy(pair->strtab, data_str->d_buf, data_str->d_size);
+		data_str->d_buf = pair->strtab;
+		data_str->d_size += nstr;
+		elf_flagdata(data_str, ELF_C_SET, ELF_F_DIRTY);
+		shdr_str.sh_size += nstr;
+		gelf_update_shdr(scn_str, &shdr_str);
+
+		memcpy(pair->symtab, data_sym->d_buf, data_sym->d_size);
+		data_sym->d_buf = pair->symtab;
+		data_sym->d_size += nsym * symsize;
+		elf_flagdata(data_sym, ELF_C_SET, ELF_F_DIRTY);
+		shdr_sym.sh_size += nsym * symsize;
+		gelf_update_shdr(scn_sym, &shdr_sym);
+
+		nsym += isym;
+
+		/*
+		 * Now that the tables have been allocated, add the aliases as
+		 * described above.  Since we already know the symtab index of
+		 * the symbol that the alias refers to, we can simply run down
+		 * the alttab and add alias for any non-NULL entries.
+		 */
+		for (i = 1; i < osym; i++) {
+			if (alttab[i] == NULL)
+				continue;
+
+			if (gelf_getsym(data_sym, i, &fsym) == NULL) {
+				fprintf(stderr, "failed to get symbol %d: %s\n",
+					i, elf_errmsg(elf_errno()));
+				goto err;
+			}
+
+			assert(GELF_ST_TYPE(fsym.st_info) == STT_FUNC);
+			assert(GELF_ST_BIND(fsym.st_info) == STB_LOCAL);
+			/*
+			 * Add the alias as a new symbol to the symtab.
+			 */
+			dsym = fsym;
+			dsym.st_name = istr;
+			dsym.st_info = GELF_ST_INFO(STB_GLOBAL, STT_FUNC);
+			dsym.st_other = ELF64_ST_VISIBILITY(STV_HIDDEN);
+
+			len = strlen(alttab[i]) + 1;
+			assert(istr + len <= data_str->d_size);
+			a = (char *)data_str->d_buf + istr;
+			memcpy(a, alttab[i], len);
+
+			gelf_update_sym(data_sym, isym, &dsym);
+			istr += len;
+			isym++;
+
+			assert(isym <= nsym);
+
+			mod = 1;
+
+			free(alttab[i]);
+		}
+
+		free(alttab);
+	}
+
+	if (mod && elf_update(elf, ELF_C_WRITE) == -1) {
+		elferrstr = "Failed to update ELF object";
+		goto elf_err;
+	}
+
+	elf_end(elf);
+	close(fd);
+
+	while ((pair = bufs) != NULL) {
+		bufs = pair->next;
+		free(pair->strtab);
+		free(pair->symtab);
+		free(pair);
+	}
+
+	return 0;
+
+elf_err:
+	fprintf(stderr, "%s: %s\n", elferrstr, elf_errmsg(elf_errno()));
+err:
+	fprintf(stderr, "an error was encountered while processing %s\n", obj);
+	return 1;
+}
+
+int
+main(int argc, char *argv[])
+{
+	int i;
+
+	for (i = 1; i < argc; i++) {
+		if (process_obj(argv[i]))
+			exit(1);
+	}
+
+	exit(0);
+}
diff --git a/scripts/link-vmlinux.sh b/scripts/link-vmlinux.sh
index e6818b8e7141..82c489dbf23b 100755
--- a/scripts/link-vmlinux.sh
+++ b/scripts/link-vmlinux.sh
@@ -64,6 +64,34 @@ archive_builtin()
 	fi
 }
 
+# Generate the SDT probe point stubs object file
+# ${1} output file
+sdtstub()
+{
+	info SDTSTB ${1}
+	${srctree}/scripts/dtrace_sdt.sh sdtstub .tmp_sdtstub.S \
+		${KBUILD_VMLINUX_INIT} ${KBUILD_VMLINUX_MAIN}
+
+	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
+		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
+
+	${CC} ${aflags} -c -o ${1} .tmp_sdtstub.S
+}
+
+# Generate the SDT probe info for kernel image ${1}
+# ${2} output file
+sdtinfo()
+{
+	info SDTINF ${2}
+
+	${srctree}/scripts/dtrace_sdt.sh sdtinfo .tmp_sdtinfo.S ${1}
+
+	local aflags="${KBUILD_AFLAGS} ${KBUILD_AFLAGS_KERNEL}               \
+		      ${NOSTDINC_FLAGS} ${LINUXINCLUDE} ${KBUILD_CPPFLAGS}"
+
+	${CC} ${aflags} -c -o ${2} .tmp_sdtinfo.S
+}
+
 # Link of vmlinux.o used for section mismatch analysis
 # ${1} output file
 modpost_link()
@@ -90,6 +118,7 @@ modpost_link()
 # Link of vmlinux
 # ${1} - optional extra .o files
 # ${2} - output file
+# ${3} - optional extra ld flag(s)
 vmlinux_link()
 {
 	local lds="${objtree}/${KBUILD_LDS}"
@@ -113,7 +142,7 @@ vmlinux_link()
 				${1}"
 		fi
 
-		${LD} ${LDFLAGS} ${LDFLAGS_vmlinux} -o ${2}		\
+		${LD} ${LDFLAGS} ${LDFLAGS_vmlinux} ${3} -o ${2}	\
 			-T ${lds} ${objects}
 	else
 		if [ -n "${CONFIG_THIN_ARCHIVES}" ]; then
@@ -133,7 +162,7 @@ vmlinux_link()
 				${1}"
 		fi
 
-		${CC} ${CFLAGS_vmlinux} -o ${2}				\
+		${CC} ${CFLAGS_vmlinux} ${3} -o ${2}			\
 			-Wl,-T,${lds}					\
 			${objects}					\
 			-lutil -lrt -lpthread
@@ -191,6 +220,8 @@ cleanup()
 	rm -f .old_version
 	rm -f .tmp_System.map
 	rm -f .tmp_kallsyms*
+	rm -f .tmp_sdtstub.*
+	rm -f .tmp_sdtinfo.*
 	rm -f .tmp_version
 	rm -f .tmp_vmlinux*
 	rm -f built-in.o
@@ -252,6 +283,14 @@ ${MAKE} -f "${srctree}/scripts/Makefile.build" obj=init GCC_PLUGINS_CFLAGS="${GC
 
 archive_builtin
 
+sdtstubo=""
+sdtinfoo=""
+if [ -n "${CONFIG_DTRACE}" ]; then
+	sdtstubo=.tmp_sdtstub.o
+	sdtinfoo=.tmp_sdtinfo.o
+	sdtstub ${sdtstubo}
+fi
+
 #link vmlinux.o
 info LD vmlinux.o
 modpost_link vmlinux.o
@@ -289,12 +328,25 @@ if [ -n "${CONFIG_KALLSYMS}" ]; then
 	kallsymso=.tmp_kallsyms2.o
 	kallsyms_vmlinux=.tmp_vmlinux2
 
+	if [ -n "${CONFIG_DTRACE}" ]; then
+		sdtinfo vmlinux.o ${sdtinfoo}
+	fi
+
 	# step 1
-	vmlinux_link "" .tmp_vmlinux1
+	vmlinux_link "${sdtstubo} ${sdtinfoo}" .tmp_vmlinux1
 	kallsyms .tmp_vmlinux1 .tmp_kallsyms1.o
 
+	if [ -n "${CONFIG_DTRACE}" ]; then
+		if [ -n "${CONFIG_ARM64}" ]; then
+			vmlinux_link "${sdtstubo} ${sdtinfoo}" .tmp_vmlinux1
+		else
+			vmlinux_link "${sdtstubo} ${sdtinfoo}" .tmp_vmlinux1 "-r"
+		fi
+		sdtinfo .tmp_vmlinux1 ${sdtinfoo}
+	fi
+
 	# step 2
-	vmlinux_link .tmp_kallsyms1.o .tmp_vmlinux2
+	vmlinux_link "${sdtstubo} .tmp_kallsyms1.o ${sdtinfoo}" .tmp_vmlinux2
 	kallsyms .tmp_vmlinux2 .tmp_kallsyms2.o
 
 	# step 3
@@ -305,14 +357,14 @@ if [ -n "${CONFIG_KALLSYMS}" ]; then
 		kallsymso=.tmp_kallsyms3.o
 		kallsyms_vmlinux=.tmp_vmlinux3
 
-		vmlinux_link .tmp_kallsyms2.o .tmp_vmlinux3
+		vmlinux_link "${sdtstubo} .tmp_kallsyms2.o ${sdtinfoo}" .tmp_vmlinux3
 
 		kallsyms .tmp_vmlinux3 .tmp_kallsyms3.o
 	fi
 fi
 
 info LD vmlinux
-vmlinux_link "${kallsymso}" vmlinux
+vmlinux_link "${sdtstubo} ${kallsymso} ${sdtinfoo}" vmlinux
 
 if [ -n "${CONFIG_BUILDTIME_EXTABLE_SORT}" ]; then
 	info SORTEX vmlinux
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 54deaa1066cf..66bed20b5f45 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2139,10 +2139,21 @@ static int check_modname_len(struct module *mod)
  **/
 static void add_header(struct buffer *b, struct module *mod)
 {
+	const char *modname;
+
+	if ((modname = strrchr(mod->name, '/')) != NULL)
+		modname++;
+	else
+		modname = mod->name;
+
 	buf_printf(b, "#include <linux/module.h>\n");
 	buf_printf(b, "#include <linux/vermagic.h>\n");
 	buf_printf(b, "#include <linux/compiler.h>\n");
 	buf_printf(b, "\n");
+	buf_printf(b, "#ifdef CONFIG_DTRACE\n");
+	buf_printf(b, "# include \"%s.sdtinfo.c\"\n", modname);
+	buf_printf(b, "#endif\n");
+	buf_printf(b, "\n");
 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
 	buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
 	buf_printf(b, "\n");
@@ -2156,6 +2167,10 @@ static void add_header(struct buffer *b, struct module *mod)
 			      "\t.exit = cleanup_module,\n"
 			      "#endif\n");
 	buf_printf(b, "\t.arch = MODULE_ARCH_INIT,\n");
+	buf_printf(b, "#ifdef CONFIG_DTRACE\n");
+	buf_printf(b, "\t.sdt_probes = _sdt_probes,\n");
+	buf_printf(b, "\t.sdt_probec = _sdt_probec,\n");
+	buf_printf(b, "#endif\n");
 	buf_printf(b, "};\n");
 }
 
@@ -2192,7 +2207,9 @@ static int add_versions(struct buffer *b, struct module *mod)
 	for (s = mod->unres; s; s = s->next) {
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
-			if (have_vmlinux && !s->weak) {
+			if (have_vmlinux && !s->weak &&
+			    !strstarts(s->name, "__dtrace_probe_") &&
+			    !strstarts(s->name, "__dtrace_isenabled_")) {
 				if (warn_unresolved) {
 					warn("\"%s\" [%s.ko] undefined!\n",
 					     s->name, mod->name);
diff --git a/scripts/move-if-change b/scripts/move-if-change
new file mode 100755
index 000000000000..f6546c84d1dd
--- /dev/null
+++ b/scripts/move-if-change
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+if test -r "$2" && cmp -s "$1" "$2"; then
+  rm -f "$1"
+else
+  mv -f "$1" "$2"
+fi
diff --git a/scripts/package/mkspec b/scripts/package/mkspec
index f47f17aae135..4deff9062400 100755
--- a/scripts/package/mkspec
+++ b/scripts/package/mkspec
@@ -21,6 +21,13 @@ if [ "`grep CONFIG_DRM=y .config | cut -f2 -d\=`" = "y" ]; then
 	PROVIDES=kernel-drm
 fi
 
+#
+if [ "`grep CONFIG_CTF=y .config | cut -f2 -d\=`" = "y" ]; then
+	CTF=true
+else
+	CTF=
+fi
+
 PROVIDES="$PROVIDES kernel-$KERNELRELEASE"
 __KERNELRELEASE=`echo $KERNELRELEASE | sed -e "s/-/_/g"`
 
@@ -38,6 +45,12 @@ echo "Source: kernel-$__KERNELRELEASE.tar.gz"
 fi
 
 echo "BuildRoot: %{_tmppath}/%{name}-%{PACKAGE_VERSION}-root"
+
+if [[ -n $CTF ]]; then
+echo "BuildRequires: libdtrace-ctf >= 0.5.0"
+echo "BuildRequires: libdtrace-ctf-devel >= 0.5.0"
+fi
+
 echo "Provides: $PROVIDES"
 echo "%define __spec_install_post /usr/lib/rpm/brp-compress || :"
 echo "%define debug_package %{nil}"
@@ -64,6 +77,11 @@ echo "AutoReqProv: no"
 echo "%description -n kernel-devel"
 echo "This package provides kernel headers and makefiles sufficient to build modules"
 echo "against the $__KERNELRELEASE kernel package."
+
+if [[ -n $CTF ]]; then
+echo "Requires: libdtrace-ctf >= 0.5.0"
+fi
+
 echo ""
 
 if ! $PREBUILT; then
@@ -75,7 +93,7 @@ fi
 echo "%build"
 
 if ! $PREBUILT; then
-echo "make clean && make %{?_smp_mflags} KBUILD_BUILD_VERSION=%{release}"
+echo "make clean && make %{?_smp_mflags} KBUILD_BUILD_VERSION=%{release}${CTF:+ && make %{?_smp_mflags\} ctf}"
 echo ""
 fi
 
@@ -154,6 +172,7 @@ echo ""
 echo "%files headers"
 echo '%defattr (-, root, root)'
 echo "/usr/include"
+echo "%exclude /usr/include/linux/dtrace"
 echo ""
 if ! $PREBUILT; then
 echo "%files devel"
diff --git a/tools/testing/selftests/waitfd/Makefile b/tools/testing/selftests/waitfd/Makefile
new file mode 100644
index 000000000000..f85c80b54f05
--- /dev/null
+++ b/tools/testing/selftests/waitfd/Makefile
@@ -0,0 +1,28 @@
+uname_M := $(shell uname -m 2>/dev/null || echo not)
+ARCH ?= $(shell echo $(uname_M) | sed -e s/i.86/i386/)
+ifeq ($(ARCH),i386)
+        ARCH := X86
+	CFLAGS := -DCONFIG_X86_32 -D__i386__
+endif
+ifeq ($(ARCH),x86_64)
+	ARCH := X86
+	CFLAGS := -DCONFIG_X86_64 -D__x86_64__
+endif
+
+CFLAGS += -I../../../../arch/x86/include/generated/
+CFLAGS += -I../../../../include/
+CFLAGS += -I../../../../usr/include/
+CFLAGS += -I../../../../arch/x86/include/
+
+all:
+ifeq ($(ARCH),X86)
+	gcc $(CFLAGS) waitfd.c -o waitfd
+else
+	echo "Not an x86 target, can't build waitfd selftest"
+endif
+
+run_tests: all
+	@./waitfd || echo "waitfd: [FAIL]"
+
+clean:
+	rm -fr ./waitfd
diff --git a/tools/testing/selftests/waitfd/waitfd.c b/tools/testing/selftests/waitfd/waitfd.c
new file mode 100644
index 000000000000..09c6967222ac
--- /dev/null
+++ b/tools/testing/selftests/waitfd/waitfd.c
@@ -0,0 +1,110 @@
+/* waitfd testcase. */
+
+#define _GNU_SOURCE 1
+#include <linux/unistd.h>
+#include <sys/syscall.h>
+#include <sys/ptrace.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#include <poll.h>
+
+int waitfd(int which, pid_t upid, int options, int flags)
+{
+        return syscall(__NR_waitfd, which, upid, options, flags);
+}
+
+void sleeper(void)
+{
+	sleep(10);
+	exit(0);
+}
+
+int main (void)
+{
+        pid_t die_pid, ptrace_pid;
+        int die_fd, ptrace_fd;
+        int status;
+	struct pollfd pfd[2];
+        int procs_left = 2;
+
+	memset(pfd, 0, sizeof(pfd));
+
+        /*
+         * Fork off two children, one of which waits for a ptrace().
+         * Both just sleep after that.  Make sure we can use __WNOTHREAD,
+         * __WALL, and WUNTRACED without getting an -EINVAL.
+         */
+
+        die_pid = fork();
+
+        if (die_pid == 0)
+                sleeper();
+
+        ptrace_pid = fork();
+        if (ptrace_pid == 0) {
+                ptrace(PTRACE_TRACEME, 0, 0, 0);
+                sleeper();
+        }
+
+        die_fd = waitfd(P_PID, die_pid, 0, 0);
+        ptrace_fd = waitfd(P_PID, ptrace_pid, __WNOTHREAD | __WALL | WUNTRACED, 0);
+
+        if (die_fd < 0 || ptrace_fd < 0) {
+                perror("Cannot waitfd()");
+                exit(1);
+        }
+
+        pfd[0].fd = die_fd;
+        pfd[0].events = POLLIN;
+        pfd[1].fd = ptrace_fd;
+        pfd[1].events = POLLIN;
+
+        /*
+         * Hit the ptrace PID with a signal
+         */
+        kill(ptrace_pid, SIGABRT);
+
+        while (procs_left > 0) {
+                ssize_t bytes;
+
+                if (poll(pfd, 2, -1) < 0)
+                        perror ("poll() failed");
+
+                if (pfd[0].revents != 0) {
+                        if ((bytes = read(die_fd, &status, sizeof (int))) < sizeof (int)) {
+                                fprintf(stderr, "Only read %zi bytes\n", bytes);
+                                exit(1);
+                        }
+
+                        printf("die_fd returned %i via waitfd read: revents are %x\n", status, pfd[0].revents);
+                        pfd[0].fd *= -1;
+                        procs_left--;
+                }
+
+                if (pfd[1].revents != 0) {
+                        pid_t check_pid;
+                        status = 0;
+                        check_pid = waitpid(ptrace_pid, &status, __WNOTHREAD | __WALL | WUNTRACED | WNOHANG);
+                        if (check_pid < 0) {
+                                fprintf(stderr, "waitpid() failed: %s\n", strerror(errno));
+                                exit(1);
+                        }
+                        if (check_pid != ptrace_pid) {
+                                fprintf(stderr, "waitfd() said PID %i was ready, but waitpid() says it isn't: %i\n",
+                                    ptrace_pid, check_pid);
+                                exit(1);
+                        }
+                        printf("ptrace_fd returned status %i via waitpid; revents are %x\n", status, pfd[1].revents);
+                        pfd[1].fd *= -1;
+                        procs_left--;
+                }
+        }
+
+        return 0;
+}
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index f2ac53ab8243..b4c237a1480a 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -234,7 +234,7 @@ irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
 
 static void
 irqfd_ptable_queue_proc(struct file *file, wait_queue_head_t *wqh,
-			poll_table *pt)
+			poll_table *pt, unsigned long unused)
 {
 	struct kvm_kernel_irqfd *irqfd =
 		container_of(pt, struct kvm_kernel_irqfd, pt);
